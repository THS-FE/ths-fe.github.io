<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>跨域解决 - 思路大前端团队</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#f7f7f7"><meta name="application-name" content="思路大前端"><meta name="msapplication-TileImage" content="/img/favicon.ico"><meta name="msapplication-TileColor" content="#f7f7f7"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="思路大前端"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description="本文简单介绍了会发生跨域的情况并给出了相应的解决办法"><meta property="og:type" content="blog"><meta property="og:title" content="跨域解决"><meta property="og:url" content="https://ths-fe.github.io/2020/08/27/%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3/"><meta property="og:site_name" content="思路大前端团队"><meta property="og:description" content="本文简单介绍了会发生跨域的情况并给出了相应的解决办法"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://ths-fe.github.io/2020/08/27/%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3/title.jpg"><meta property="article:published_time" content="2020-08-27T09:59:00.000Z"><meta property="article:modified_time" content="2023-08-05T13:20:43.671Z"><meta property="article:author" content="苏永蓬"><meta property="article:tag" content="CORS"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/2020/08/27/%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3/title.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://ths-fe.github.io/2020/08/27/%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3/"},"headline":"思路大前端团队","image":["https://ths-fe.github.io/2020/08/27/%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3/title.jpg"],"datePublished":"2020-08-27T09:59:00.000Z","dateModified":"2023-08-05T13:20:43.671Z","author":{"@type":"Person","name":"苏永蓬"},"description":"本文简单介绍了会发生跨域的情况并给出了相应的解决办法"}</script><link rel="canonical" href="https://ths-fe.github.io/2020/08/27/%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3/"><link rel="icon" href="/img/favicon.ico"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.13.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/monokai.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?fd8cc3421abec7b8f4e6bc337e25c7d1";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=UA-72716512-3" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'UA-72716512-3');</script><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><script data-ad-client="ca-pub-6826040978803389" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script><meta name="generator" content="Hexo 5.2.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/ths.png" alt="思路大前端团队" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">博客</a><a class="navbar-item" href="/fe">大前端技术体系</a><a class="navbar-item" href="/gis">GIS技术体系</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/about">关于我们</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/2020/08/27/%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3/title.jpg" alt="跨域解决"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-08-27T09:59:00.000Z" title="2020-08-27T09:59:00.000Z">2020-08-27</time>发表</span><span class="level-item"><time dateTime="2023-08-05T13:20:43.671Z" title="2023-08-05T13:20:43.671Z">2023-08-05</time>更新</span><span class="level-item"> 苏永蓬 </span><span class="level-item"><a class="link-muted" href="/categories/%E5%AE%89%E5%85%A8/">安全</a><span> / </span><a class="link-muted" href="/categories/%E5%AE%89%E5%85%A8/%E8%B7%A8%E5%9F%9F/">跨域</a></span><span class="level-item">1 小时读完 (大约7741个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">跨域解决</h1><div class="content"><h1 id="什么导致了跨域"><a href="#什么导致了跨域" class="headerlink" title="什么导致了跨域"></a>什么导致了跨域</h1><h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><p>首先，网络是没有绝对安全可言的，但是，我们又需要使用浏览器来访问网络，所以浏览器能存在的安全基础就是有相对较高的安全性，提升了别人做坏事的成本。</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy">Same-origin policy(同源策略,以下简写为 CORS)</a>就是浏览器安全的一个重要部分。</p>
<p>同源策略是一个重要的安全策略，它用于限制一个<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Glossary/%E6%BA%90">源(Origin)</a>的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。</p>
<p>同源策略的目的有两个：</p>
<ul>
<li><strong>对系统用户：保证用户信息的安全，防止恶意的网站窃取数据</strong>。</li>
<li><strong>对开发人员：约束网站使用的资源尽可能是同源可控或者信任的资源，减少问题的可能性，从而来增强网站的安全性</strong>。</li>
</ul>
<p>真实案例（仅限演示例子使用）：<br>在登录腾讯文档后，打开一个文档，在控制台调用下面的代码，将会给一个好友分配该文档的编辑权限。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">  type: <span class="string">&quot;post&quot;</span>,</span><br><span class="line">  url: <span class="string">&quot;https://docs.qq.com/cgi-bin/redirect/300000000/ep/api/setpadinfo?localPadId=BYtWkVVnlVCW&amp;type=1&amp;ver=2&amp;route_ip=&amp;room_route_ip=&amp;get_vip_info=1&quot;</span>,</span><br><span class="line">  data: <span class="string">&quot;corp_id=&amp;data=%7B%22policy%22%3A1%2C%22addmemlist%22%3A%5B%7B%22uintype%22%3A0%2C%22uin%22%3A2803621806%2C%22work_id%22%3A%22%22%2C%22info%22%3A2%2C%22new%22%3A1%7D%5D%2C%22submemlist%22%3A%5B%5D%7D&amp;message=%7B%22seq%22%3A%2272bcde05-6052-44f2-be8c-b6454a3e6716%22%2C%22action%22%3A1%7D&amp;xsrf=ac8bd23b7c50fa4b&amp;dataType=0&quot;</span>,</span><br><span class="line">  success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">  &#125;,</span><br><span class="line">  error: <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;&#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>退出账号后，调用相同代码，不能给相同好友分配该文档的编辑权限。并报下面的错误。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cgicode: <span class="number">11000</span>;</span><br><span class="line">msg: <span class="string">&quot;no correct p_uin or p_skey or uid or uid_key in cookie [errcode:11000:0]&quot;</span>;</span><br><span class="line">retcode: <span class="number">11000</span>;</span><br></pre></td></tr></table></figure>

<p>由报错可以看出，出现问题是因为 cookie 中缺少相关信息，导致服务端认证失败。</p>
<p>在其他网站的控制台调用相同代码会报如下错误：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access to XMLHttpRequest at <span class="string">&#x27;https://docs.qq.com/cgi-bin/redirect/300000000/ep/api/setpadinfo?localPadId=BYtWkVVnlVCW&amp;type=1&amp;ver=2&amp;route_ip=&amp;room_route_ip=&amp;get_vip_info=1&#x27;</span> <span class="keyword">from</span> origin <span class="string">&#x27;https://fanyi.baidu.com&#x27;</span> has been blocked by CORS policy: 、No <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span> header is present on the requested resource.</span><br></pre></td></tr></table></figure>

<p>现在根据上面的情况试想在没有同源策略的情况下：<br>在你登陆腾讯文档后，再打开一个其他源的网站，调用上面的代码，也是会成功给好友分配编辑权限的。进而联想到在一个第三方网站掌握腾讯文档的接口信息规则后，就可以<strong>假冒</strong>你对你的账号进行任意操作，这是十分可怕的。</p>
<p>那么怎么判断是同一个源呢，它的定义是什么呢？</p>
<p>同源的定义：<br>如果两个 URL 的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Glossary/Protocol">协议</a>、<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Glossary/host">主机</a> 和  <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Glossary/port">端口</a> (如果有指定的话) 都相同的话，则这两个 URL 是同源。这个方案也被称为“协议/主机/端口元组”。</p>
<p>注：</p>
<ol>
<li><strong>只有浏览器才会有跨域问题，因为只有浏览器才有同源策略</strong>。</li>
<li>恶意文档：可能导致推栈缓冲区溢出，从而在电脑中执行一些代码的文件，一般指病毒或者木马的运行程序。</li>
</ol>
<h2 id="跨域示例"><a href="#跨域示例" class="headerlink" title="跨域示例"></a>跨域示例</h2><p>下表给出了与 URL：<a target="_blank" rel="noopener" href="http://store.company.com/dir/page.html">http://store.company.com/dir/page.html</a>  的源进行对比的示例:</p>
<table>
<thead>
<tr>
<th align="left">URL</th>
<th align="left">结果</th>
<th align="left">原因</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a target="_blank" rel="noopener" href="http://store.company.com/dir2/other.html">http://store.company.com/dir2/other.html</a></td>
<td align="left">同源</td>
<td align="left">只有路径不同</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="http://store.company.com/dir/inner/another.html">http://store.company.com/dir/inner/another.html</a></td>
<td align="left">同源</td>
<td align="left">只有路径不同</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://store.company.com/secure.html">https://store.company.com/secure.html</a></td>
<td align="left">失败</td>
<td align="left">协议不同</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="http://store.company.com:81/dir/etc.html">http://store.company.com:81/dir/etc.html</a></td>
<td align="left">失败</td>
<td align="left">端口不同 ( http:  默认端口是 80;https: 默认端口是 443)</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="http://news.company.com/dir/other.html">http://news.company.com/dir/other.html</a></td>
<td align="left">失败</td>
<td align="left">主机不同</td>
</tr>
</tbody></table>
<p>注：<strong>域名和 IP 指向一样，但是还是会引起跨域的。</strong><br>例如：<a target="_blank" rel="noopener" href="http://www.ths.com.cn/">http://www.ths.com.cn/</a>和<a target="_blank" rel="noopener" href="http://223.223.179.206/">http://223.223.179.206/</a>都指向同一个地方</p>
<h2 id="限制范围"><a href="#限制范围" class="headerlink" title="限制范围"></a>限制范围</h2><p>随着互联网的发展，”同源策略”越来越严格。目前，如果非同源，共有三种行为受到限制。</p>
<ul>
<li>Cookie、LocalStorage、SessionStorage 和 <a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2018/07/indexeddb.html">IndexDB</a> 无法读取。</li>
<li>脚本 API 访问。</li>
<li>AJAX 请求不能发送。</li>
</ul>
<h1 id="常见跨域错误"><a href="#常见跨域错误" class="headerlink" title="常见跨域错误"></a>常见跨域错误</h1><h2 id="缺少可跨域响应头"><a href="#缺少可跨域响应头" class="headerlink" title="缺少可跨域响应头"></a>缺少可跨域<strong>响应头</strong></h2><img src="/2020/08/27/%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3/err-CORS1.png" class="">
<p>关键字： <strong>No ‘Access-Control-Allow-Origin’ header</strong> （Access-Control-Allow-Origin 翻译：允许访问的源）<br>注：客户端发送的叫请求，服务器端返回的叫响应<br>生动例子：客户端向服务器借钱是请求，服务器不给钱是对客户端的响应</p>
<h2 id="允许跨域的值重复"><a href="#允许跨域的值重复" class="headerlink" title="允许跨域的值重复"></a>允许跨域的值重复</h2><img src="/2020/08/27/%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3/err-CORS2.png" class="">
<p>关键字： <strong>The ‘Access-Control-Allow-Origin’ header contains multiple values ‘*, *‘, but only one is allowed</strong>。 （”允许访问的源“响应头包含重复的两个*号，但是只有一个是允许的）<br>原因： <strong>多次代理的时候配置的允许跨域的值有重复的</strong>。</p>
<h2 id="不允许访问其他域的对象或者数据存储（cookie-等）"><a href="#不允许访问其他域的对象或者数据存储（cookie-等）" class="headerlink" title="不允许访问其他域的对象或者数据存储（cookie 等）"></a>不允许访问其他域的对象或者数据存储（cookie 等）</h2><img src="/2020/08/27/%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3/err-CORS3.png" class="">
<p>关键字：<strong>block a frame with origin form accessing a cross-origin frame</strong> （访问了一个跨域的源）</p>
<h1 id="解决跨域"><a href="#解决跨域" class="headerlink" title="解决跨域"></a>解决跨域</h1><h2 id="跨域网络访问（Cross-origin-network-access）"><a href="#跨域网络访问（Cross-origin-network-access）" class="headerlink" title="跨域网络访问（Cross-origin network access）"></a>跨域网络访问（Cross-origin network access）</h2><p>因为跨域产生的原因是两个资源不在同一个域，所以有四种解决的办法：</p>
<ul>
<li>把两个资源放到同一个域中</li>
<li>服务器允许资源跨域共享(<a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2016/04/cors.html">CORS</a>)</li>
<li>浏览器插件</li>
<li>利用一些不受同源策略影响的标签实现（<code>script</code>）</li>
</ul>
<h3 id="把两个资源放到同一个域中"><a href="#把两个资源放到同一个域中" class="headerlink" title="把两个资源放到同一个域中"></a>把两个资源放到同一个域中</h3><ul>
<li><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/7793488?fr=aladdin">反向代理</a>：通过 <strong>nginx</strong> 把多个资源代理到一块<ul>
<li>参考 <strong><a target="_blank" rel="noopener" href="https://docs.qq.com/doc/DSlh5YVJEbUhiV1dI">nginx 说明文档</a></strong><br>注： 在能操作文件的情况下，不建议<strong>多次代理</strong>，因为这样会导致<strong>网络传输变慢</strong>，影响系统的流畅性。</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86">正向代理</a>：通过同域的接口返回其他域的资源</li>
</ul>
<p>注：</p>
<ul>
<li>反向代理：访问自定义的接口来返回其他接口的资源，通过自定义接口已经<strong>不能分出真实资源来自哪里</strong>。</li>
<li>正向代理：由代理服务器去请求资源并返回给你，<strong>访问还是原来的真实网址</strong>。</li>
<li>不管是正向代理还是反向代理，都是由服务器端去进行访问的，所以<strong>要保证在服务器端能访问到真实地址</strong>。</li>
</ul>
<h3 id="服务器允许资源跨域共享"><a href="#服务器允许资源跨域共享" class="headerlink" title="服务器允许资源跨域共享"></a>服务器允许资源跨域共享</h3><ul>
<li>Tomcat</li>
</ul>
<p>在 Tomcat 根目录 –&gt; conf –&gt; web.xml 的 <code>web-app</code> 节点下加入如下代码。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CorsFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.apache.catalina.filters.CorsFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>cors.allowed.origins<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>*<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 当指定部分可跨域时，使用下面代码配置指定域 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;param-value&gt;http://127.0.0.1:10229&lt;/param-value&gt; --&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CorsFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注: <strong>Tomcat 配置修改后必须重启 Tomcat 才会生效</strong>。</p>
<ul>
<li>Nginx<br>在 Nginx 的根目录 –&gt; conf –&gt; nginx.conf 文件适当写入下述代码。<ul>
<li>全局可跨域</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 server 节点下添加以下语句</span></span><br><span class="line">add_header Access-Control-Allow-Origin *;</span><br><span class="line">add_header <span class="string">&#x27;Access-Control-Allow-Credentials&#x27;</span> <span class="string">&#x27;true&#x27;</span>;</span><br><span class="line">add_header Access-Control-Allow-Methods <span class="string">&#x27;GET,POST&#x27;</span>;</span><br><span class="line">add_header Access-Control-Allow-Headers <span class="string">&#x27;Content-Type,*&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>指定接口可跨域</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在指定的 location 节点下添加，示例如下：</span></span><br><span class="line">location /tomcat/ &#123;</span><br><span class="line"> proxy_pass   http://localhost:<span class="number">8090</span>/;</span><br><span class="line"> add_header Access-Control-Allow-Origin *;</span><br><span class="line"> add_header <span class="string">&#x27;Access-Control-Allow-Credentials&#x27;</span> <span class="string">&#x27;true&#x27;</span>;</span><br><span class="line"> add_header Access-Control-Allow-Methods <span class="string">&#x27;GET,POST&#x27;</span>;</span><br><span class="line"> add_header Access-Control-Allow-Headers <span class="string">&#x27;Content-Type,*&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>注：</code></pre>
<ul>
<li>Nginx 配置修改后必须<strong>重启</strong>才会生效。</li>
<li>同时添加全局可跨域和指定接口可跨域时，访问指定接口会产生可跨域响应头重复的问题，可使用指定接口代理，因此<strong>不推荐使用全局可跨域</strong>。</li>
<li>注意<code>localtion</code>的匹配规则</li>
<li>当配置指定域可跨域时，可把<code>*</code>换为<strong>具体的域名或者 IP</strong>，多个之间用<strong>逗号</strong>隔开。</li>
<li>多次代理设置具体相同的域也是会报<strong>允许跨域的值重复</strong>错误</li>
<li>多次代理设置域时，<code>http:127.0.0.1:10229/ === http:127.0.0.1:10229</code></li>
</ul>
<p>补：<strong>location 和 proxy_pass 易混淆点</strong></p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000013267839">location</a> (后面两点为 URL 访问的相关知识补充)</p>
<ul>
<li><p><code>location</code> 后面带不带<code>/</code> 都是一样的</p>
</li>
<li><p>如果 URL 的格式为<code>http://my.suyp.com/</code>或者<code>http://127.0.0.1:10229/</code>，**尾部有没有<code>/</code>都不会造成<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%87%8D%E5%AE%9A%E5%90%91/9064196?fr=aladdin">重定向</a>**。<br>因为这种情况下，浏览器请求时会在后面默认加上<code>/</code>。可以这样理解，没有请求是访问的<code>http://my.suyp.com</code>,都是访问的<code>http://my.suyp.com/</code>,所以没有重定向。</p>
</li>
<li><p>如果 URL 的格式为<code>http:127.0.1:10229/node/</code>。尾部如果<strong>缺少<code>/</code>将导致重定向</strong>。<br>因为根据约定，URL 尾部的<code>/</code>表示目录，没有<code>/</code>表示文件。所以访问<code>/node/</code>时，服务器会自动去该目录下找对应的默认文件或者返回该目录的文件列表。如果访问<code>/node</code>的话，服务器会先去找<code>node</code>文件，找不到的话会将<code>node</code>当成目录重定向到<code>/node/</code>，去该目录下找默认文件或者返回该目录的文件列表。</p>
</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u010433704/article/details/99945557">proxy_pass</a><br>假设下面四种情况分别用 <a target="_blank" rel="noopener" href="http://192.168.1.1/proxy/test.html">http://192.168.1.1/proxy/test.html</a> 进行访问。</p>
<p>-</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location /proxy/ &#123;</span><br><span class="line">  proxy_pass http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">10229</span>/;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 代理到URL：http://127.0.0.1:10229/test.html</span></span><br></pre></td></tr></table></figure>

<p>-</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location /proxy/ &#123;</span><br><span class="line">  proxy_pass http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">10229</span>; <span class="comment"># （相对于第一种，最后少一个 / ）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 代理到URL：http://127.0.0.1:10229/test.html</span></span><br></pre></td></tr></table></figure>

<p>-</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location /proxy/ &#123;</span><br><span class="line">  proxy_pass http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">10229</span>/aaa/;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 代理到URL：http://127.0.0.1:10229/aaa/test.html</span></span><br></pre></td></tr></table></figure>

<p>-</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location /proxy/ &#123;</span><br><span class="line">  proxy_pass http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">10229</span>/aaa; <span class="comment"># （相对于第三种，最后少一个 / ）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 代理到URL：http://127.0.0.1:10229/aaatest.html</span></span><br></pre></td></tr></table></figure>

<p>理解：<br> 如果最后有<code>/</code>，就是把 URL 以<code>location</code>路由切割，把<strong>后面的部分</strong>放到代理地址的后面，如果没有，就是把<strong>路由加上后面的部分</strong>放到代理地址的后面。（注意: <code>http://127.0.0.1</code>===<code>http://127.0.0.1/</code>）。</p>
</li>
</ul>
<p><strong>推荐配置代理的写法：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">location /proxy/ &#123;</span><br><span class="line">  proxy_pass http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>/;</span><br><span class="line">&#125;</span><br><span class="line">location /proxy/ &#123;</span><br><span class="line">  proxy_pass http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>/aaa/;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># location 的路由最后也加上/</span></span><br><span class="line"><span class="comment"># proxy_pass 的最后也加上/</span></span><br><span class="line"><span class="comment"># 好处：访问的地址和真实地址在/proxy/之后是完全一样的，便于理解记忆</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Node<ul>
<li>全局可跨域</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">app.all(<span class="string">&quot;*&quot;</span>, <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 设置允许跨域的域名，*代表允许任意域名跨域</span></span><br><span class="line">  res.header(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">  <span class="comment">// 允许的header类型</span></span><br><span class="line">  res.header(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="string">&quot;content-type&quot;</span>);</span><br><span class="line">  <span class="comment">// 跨域允许的请求方式</span></span><br><span class="line">  res.header(<span class="string">&quot;Access-Control-Allow-Methods&quot;</span>, <span class="string">&quot;DELETE,PUT,POST,GET,OPTIONS&quot;</span>);</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>指定接口可跨域</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">&quot;/node&quot;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 设置允许跨域的域名，*代表允许任意域名跨域</span></span><br><span class="line">  res.header(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">  <span class="comment">// 允许的header类型</span></span><br><span class="line">  res.header(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="string">&quot;content-type&quot;</span>);</span><br><span class="line">  <span class="comment">// 跨域允许的请求方式</span></span><br><span class="line">  res.header(<span class="string">&quot;Access-Control-Allow-Methods&quot;</span>, <span class="string">&quot;DELETE,PUT,POST,GET,OPTIONS&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>注：因为 Node 的路由是由上到下匹配的，有符合的默认就不继续向下匹配了 + 指定全局可跨域时，一定要先写<code>app.all</code> + 在<code>app.all</code> 中，一定要加<code>next()</code>, 来让路由继续向下匹配</p>
<h3 id="浏览器插件"><a href="#浏览器插件" class="headerlink" title="浏览器插件"></a>浏览器插件</h3><p>在 chrome 网上商店中搜索 <strong>Allow CORS: Access-Control-Allow-Origin</strong> 插件安装，在需要的时候运行即可。</p>
<h3 id="利用一些不受同源策略影响的标签"><a href="#利用一些不受同源策略影响的标签" class="headerlink" title="利用一些不受同源策略影响的标签"></a>利用一些不受同源策略影响的标签</h3><h4 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/hansexploration/article/details/80314948">JSONP</a></h4><p>JSONP 是服务器与客户端跨源通信的一种方法。最大特点就是简单适用，老式浏览器全部支持，服务器不用做任何改造。</p>
<p>理论基础：<strong>Web 页面上调用 js 文件时是不受否跨域的影响</strong>（不仅如此，凡是拥有”src”这个属性的标签都拥有跨域的能力，比如<code>&lt;script&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;iframe&gt;</code>）。</p>
<p>因为 JSONP 是利用<code>script</code>标签的特性来实现跨域的，所以不支持<code>post</code>请求。</p>
<p>基本思想：在远程服务器上设法把数据装进 <code>js</code> 格式的文件里，供客户端调用和进一步处理。</p>
<p>首先，网页动态插入<code>&lt;script&gt;</code>元素，由它向跨源网址发出请求。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addScriptTag</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">  script.setAttribute(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;text/javascript&quot;</span>);</span><br><span class="line">  script.src = src;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这里使用一个文本来模拟jsonp服务端返回的最终数据格式</span></span><br><span class="line">  <span class="comment">// 文本内容：jsonpExe(&#123;&quot;data&quot;:&quot;我是jsonp的数据&quot;&#125;);</span></span><br><span class="line">  addScriptTag(<span class="string">&quot;http://localhost:1000/jsonp.txt?callback=jsonpExe&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonpExe</span>(<span class="params">param</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// jsonp方式传回来的数据本身就是json对象</span></span><br><span class="line">  alert(<span class="built_in">JSON</span>.stringify(param));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码通过动态添加<code>&lt;script&gt;</code>元素，向服务器<code>localhost:1000</code>发出请求。注意，该请求的查询字符串有一个<code>callback</code>参数，用来指定<strong>回调函数的名字</strong>，这对于 JSONP 是必需的。</p>
<p>服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jsonpExe(&#123; <span class="attr">data</span>: <span class="string">&quot;我是jsonp的数据&quot;</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>由于<code>&lt;script&gt;</code>元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了<code>foo</code>函数，该函数就会立即调用。作为参数的 JSON 数据被视为 JavaScript 对象，而不是字符串，因此避免了使用<code>JSON.parse</code>的步骤。</p>
<p>或者使用 AJAX 调用，示例如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getJSONPData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  $.ajax(&#123;</span><br><span class="line">    type: <span class="string">&quot;get&quot;</span>,</span><br><span class="line">    url: <span class="string">&quot;http://localhost:1000/jsonp.txt&quot;</span>,</span><br><span class="line">    dataType: <span class="string">&quot;jsonp&quot;</span>, <span class="comment">// 一定要使用 jsonp 类型</span></span><br><span class="line">    success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;,</span><br><span class="line">    error: <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;&#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonpExe</span>(<span class="params">param</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// jsonp方式传回来的数据本身就是json对象</span></span><br><span class="line">  alert(<span class="built_in">JSON</span>.stringify(param));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="表单提交数据不受同源策略的影响"><a href="#表单提交数据不受同源策略的影响" class="headerlink" title="表单提交数据不受同源策略的影响"></a><strong>表单提交数据不受同源策略的影响</strong></h4><ul>
<li>表单提交:</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 成功 --&gt;</span><br><span class="line">&lt;form action=<span class="string">&quot;http://localhost:10229/setUserInfo&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">  &lt;p&gt;</span><br><span class="line">    &lt;label&gt;用户名：&lt;/label&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;user&quot;</span> /&gt;</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">  &lt;p&gt;</span><br><span class="line">    &lt;label&gt;密&amp;nbsp;&amp;nbsp;&amp;nbsp;码：&lt;/label&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;password&quot;</span> name=<span class="string">&quot;password&quot;</span> /&gt;</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">  &lt;p&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> name=<span class="string">&quot;&quot;</span> value=<span class="string">&quot;提交1&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;reset&quot;</span> name=<span class="string">&quot;&quot;</span> value=<span class="string">&quot;重置1&quot;</span>&gt;</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>ajax 请求：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// err 跨域</span></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">  type: <span class="string">&quot;post&quot;</span>,</span><br><span class="line">  url: <span class="string">&quot;http://localhost:10229/setUserInfo&quot;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    user: <span class="string">&quot;suyp&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">    $(<span class="string">&quot;.txt-erea&quot;</span>).text(data);</span><br><span class="line">  &#125;,</span><br><span class="line">  error: <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;&#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>发散一下思维：<br>虽然<code>form</code>标签只能发送数据，但是没有跨域问题，所以在只需要发送消息的时候也可以使用<code>form</code>来进行单方面通信。</p>
<h3 id="Canvas-中的跨域问题"><a href="#Canvas-中的跨域问题" class="headerlink" title="Canvas 中的跨域问题"></a>Canvas 中的跨域问题</h3><p>受影响的方法如下：</p>
<ul>
<li>getImageData()：<br>返回一个<code>ImageData</code>对象，用来描述 canvas 区域隐含的像素数据</li>
<li>toBlob()：<br>创造<code>Blob</code>对象，用以展示 canvas 上的图片；这个图片文件可以被缓存或保存到本地，由用户代理端自行决定。如不特别指明，图片的类型默认为 <code>image/png</code>，分辨率为<code>96dpi</code>。</li>
<li>toDataURL() ：<br>返回一个包含图片展示的 data URI 。可以使用 type 参数其类型，默认为 <code>PNG</code> 格式。图片的分辨率为<code>96dpi</code>。</li>
</ul>
<p>下面以<code>toDataURL()</code>为例。</p>
<p>在使用<code>Canvas</code>绘制不同域的图片然后转为<code>Base64</code>时，会有跨域问题。但是，<strong>不影响 Canvas 绘制展示图片</strong>。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;myCanvas&quot;</span> <span class="attr">width</span>=<span class="string">&quot;1920&quot;</span> <span class="attr">height</span>=<span class="string">&quot;1080&quot;</span> <span class="attr">style</span>=<span class="string">&quot;border: 2px solid grey&quot;</span>&gt;</span>当前浏览器不支持canvas<span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myCanvas&quot;</span>)</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> context = canvas.getContext(<span class="string">&quot;2d&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> img = <span class="keyword">new</span> Image()</span></span><br><span class="line"><span class="javascript">  <span class="comment">// img.src = &#x27;./img/思路logo紫.png&#x27;; // 同源图片</span></span></span><br><span class="line"><span class="javascript">  img.src = <span class="string">&#x27;http://localhost:8090/CORS/思路logo蓝.png&#x27;</span>; <span class="comment">// 不同源图片</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">//图片加载完后，将其显示在canvas中</span></span></span><br><span class="line"><span class="javascript">  img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    context.drawImage(<span class="built_in">this</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1920</span>, <span class="number">1080</span>) <span class="comment">// 改变图片大小到1080*980</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// toDataURL是向canvas转为Base64的一个方法</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(canvas.toDataURL(<span class="string">&#x27;image/png&#x27;</span>));</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>报错：</p>
<img src="/2020/08/27/%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3/err-CORS4.png" class="">
<img src="/2020/08/27/%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3/err-CORS5.png" class="">

<p><strong>解决方式</strong>：</p>
<ol>
<li>设置图片的<code>crossOrigin = &#39;anonymous&#39;</code>,来让<code>toDataURL</code>方法不因跨域报错</li>
<li>设置图片可跨域<br><strong>二者缺一不可</strong>。</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;myCanvas&quot;</span> <span class="attr">width</span>=<span class="string">&quot;1920&quot;</span> <span class="attr">height</span>=<span class="string">&quot;1080&quot;</span> <span class="attr">style</span>=<span class="string">&quot;border: 2px solid grey&quot;</span>&gt;</span>当前浏览器不支持canvas<span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myCanvas&quot;</span>)</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> context = canvas.getContext(<span class="string">&quot;2d&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> img = <span class="keyword">new</span> Image()</span></span><br><span class="line"><span class="javascript">img.src = <span class="string">&#x27;http://localhost:8090/CORS/思路logo蓝.png&#x27;</span>; <span class="comment">// 不同源图片</span></span></span><br><span class="line"><span class="javascript">img.crossOrigin = <span class="string">&#x27;anonymous&#x27;</span>;</span></span><br><span class="line"><span class="javascript"><span class="comment">//图片加载完后，将其显示在canvas中</span></span></span><br><span class="line"><span class="javascript">img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  context.drawImage(<span class="built_in">this</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1920</span>, <span class="number">1080</span>) <span class="comment">// 改变图片大小到1080*980</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// toDataURL是向canvas转为Base64的一个方法</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(canvas.toDataURL(<span class="string">&#x27;image/png&#x27;</span>));</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="不允许-IFrame-被嵌入"><a href="#不允许-IFrame-被嵌入" class="headerlink" title="不允许 IFrame 被嵌入"></a>不允许 IFrame 被嵌入</h3><p>在响应头中有这么一个配置项 <strong>X-Frame-Options</strong>来标识一个页面是否可以被其他页面嵌入。<br>可选值：</p>
<ul>
<li>deny：表示该页面不允许在 frame 中展示，即便是在相同域名的页面中嵌套也不允许。</li>
<li>sameorigin：表示该页面可以在相同域名页面的 frame 中展示。</li>
<li>allow-from uri：表示该页面可以在指定来源的 frame 中展示。（uri 为指定源的地址）</li>
</ul>
<p>配置：</p>
<ul>
<li><p>Tomcat<br>在 Tomcat 根目录 –&gt; conf –&gt; web.xml 的 web-app 节点下加入如下代码。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">&lt;!-- 配置页面是否能被其他页面展示 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>httpHeaderSecurity<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.apache.catalina.filters.HttpHeaderSecurityFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>antiClickJackingOption<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 配置的具体值 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>sameorigin<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">async-supported</span>&gt;</span>true<span class="tag">&lt;/<span class="name">async-supported</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>httpHeaderSecurity<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dispatcher</span>&gt;</span>REQUEST<span class="tag">&lt;/<span class="name">dispatcher</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dispatcher</span>&gt;</span>FORWARD<span class="tag">&lt;/<span class="name">dispatcher</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">&lt;!-- 配置页面是否能被其他页面展示 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>httpHeaderSecurity<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.apache.catalina.filters.HttpHeaderSecurityFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>antiClickJackingOption<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 配置的具体值 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>allow-from<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 当指定部分域可展示时，使用下面代码配置指定域 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>antiClickJackingUri<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>http://127.0.0.1:10229<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">async-supported</span>&gt;</span>true<span class="tag">&lt;/<span class="name">async-supported</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>httpHeaderSecurity<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dispatcher</span>&gt;</span>REQUEST<span class="tag">&lt;/<span class="name">dispatcher</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dispatcher</span>&gt;</span>FORWARD<span class="tag">&lt;/<span class="name">dispatcher</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注：目前测试指定域可嵌入无效，错误如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">testIframe.html:1 Invalid &#39;X-Frame-Options&#39; header encountered when loading &#39;http:&#x2F;&#x2F;localhost:8090&#x2F;CORS&#x2F;testIframe.html&#39;: &#39;ALLOW-FROM http:&#x2F;&#x2F;127.0.0.1:10229&#39; is not a recognized directive. The header will be ignored.</span><br></pre></td></tr></table></figure>
</li>
<li><p>Nginx<br>配置 nginx 发送 X-Frame-Options 响应头，把下面这行添加到 ‘http’, ‘server’ 或者 ‘location’ 的配置中:<br> <code>add_header X-Frame-Options sameorigin always;</code><br><code>add_header X-Frame-Options deny always;</code><br><code>add_header X-Frame-Options allow-from &#39;http://127.0.0.1,http://127.0.0.2&#39; always;</code><br><strong>小结：</strong><br><strong>跨域网络访问推荐做法：</strong></p>
</li>
<li><p><strong>在能随意操作文件的情况优先把资源分类放到一起，这样既不会有跨域请求问题，也方便管理。</strong></p>
</li>
<li><p><strong>不行的话，使用 Nginx 代理。</strong></p>
</li>
</ul>
<h2 id="跨域数据存储访问（Cross-origin-data-storage-access）"><a href="#跨域数据存储访问（Cross-origin-data-storage-access）" class="headerlink" title="跨域数据存储访问（Cross-origin data storage access）"></a>跨域数据存储访问（Cross-origin data storage access）</h2><h3 id="使用域名"><a href="#使用域名" class="headerlink" title="使用域名"></a>使用域名</h3><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy">document.domain</a> 属性中存入的是主机信息，并且可以设置为当前域或者<strong>当前域的父域</strong>。如果将其设置为其当前域的父域，则这个较短的父域将<strong>用于后续源检查</strong>。<br>另外，任何对 document.domain 的赋值操作，包括 document.domain = document.domain 都会导致端口号被<strong>重写为 null</strong>。因此 company.com:8080 不能仅通过设置 document.domain = “company.com” 来与 company.com 通信。<strong>必须在他们双方中都进行赋值，以确保端口号都为 null 。</strong></p>
<p>由于以上的情况，我们可以在多个只有二级域名不同的网页进行以下操作。</p>
<p>注：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%9F%9F%E5%90%8D/86062?fr=aladdin">域名</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/29998374">域名分类</a></li>
</ul>
<h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>Cookie 是服务器写入浏览器的一小段信息，只有同源的网页才能共享。但是，两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置 <code>document.domain</code>共享 <code>Cookie</code>。</p>
<p>举例来说，A 网页是**<a target="_blank" rel="noopener" href="http://w1.example.com/a.html">http://w1.example.com/a.html</a><strong>，B 网页是</strong><a target="_blank" rel="noopener" href="http://w2.example.com/b.html">http://w2.example.com/b.html</a>**，那么只要设置相同的 document.domain，两个网页就可以共享 Cookie。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.domain = <span class="string">&quot;example.com&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>现在，A 网页通过脚本设置一个 Cookie。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">&quot;test1=hello&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>B 网页就可以读到这个 Cookie。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> allCookie = <span class="built_in">document</span>.cookie;</span><br></pre></td></tr></table></figure>

<p>另外，服务器也可以在设置 Cookie 的时候，指定 Cookie 的所属域名为一级域名，这样二级域名和三级域名不用做任何设置，都可以读取这个 Cookie。</p>
<h4 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h4><p>如果两个窗口一级域名相同，只是二级域名不同，那么设置上一节介绍的 <code>document.domain</code>属性，就可以规避同源策略，拿到 DOM。</p>
<p>父页面：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.domain = <span class="string">&quot;suyp.com&quot;</span>;</span><br><span class="line">  <span class="built_in">document</span>.cookie = <span class="string">&quot;username=suyp&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>子页面：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.domain = <span class="string">&quot;suyp.com&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里请求时，会带上父页面的cookie: document.cookie = &#x27;username=suyp&#x27;;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  $.ajax(&#123;</span><br><span class="line">    type: <span class="string">&quot;get&quot;</span>,</span><br><span class="line">    url: <span class="string">&quot;http://localhost:10229/node&quot;</span>,</span><br><span class="line">    <span class="comment">//  默认情况下，标准的跨域请求是不会发送cookie的</span></span><br><span class="line">    xhrFields: &#123;</span><br><span class="line">      withCredentials: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(data);</span><br><span class="line">      <span class="comment">// $(&#x27;.txt-erea&#x27;).text(data);</span></span><br><span class="line">    &#125;,</span><br><span class="line">    error: <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;&#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Node 服务端：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在开启服务的代码基础上新加如下代码</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> cookieParser = <span class="built_in">require</span>(<span class="string">&quot;cookie-parser&quot;</span>);</span><br><span class="line"></span><br><span class="line">app.use(cookieParser());</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&quot;/node&quot;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 使用cookie时不能设置域为 *</span></span><br><span class="line">  res.header(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, req.headers.origin);</span><br><span class="line">  <span class="comment">// 允许的header类型</span></span><br><span class="line">  res.header(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="string">&quot;content-type&quot;</span>);</span><br><span class="line">  <span class="comment">// 跨域允许的请求方式</span></span><br><span class="line">  res.header(<span class="string">&quot;Access-Control-Allow-Methods&quot;</span>, <span class="string">&quot;DELETE,PUT,POST,GET,OPTIONS&quot;</span>);</span><br><span class="line">  <span class="comment">// 要设置允许客户端携带验证信息</span></span><br><span class="line">  res.header(<span class="string">&quot;Access-Control-Allow-Credentials&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;cookie信息&quot;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(req.cookies);</span><br><span class="line">  res.end(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 开启监听</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">app.listen(port, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>注：</p>
<ul>
<li>同源 ajax 请求是可以自动携带 cookie 的</li>
<li>而非同源需要客户端和服务端都做处理：<ul>
<li>客户端需要对 xhr 对象设置 withCredentials:true</li>
<li>服务端需要设置响应头 access-control-allow-credentials:true<ul>
<li>同时必须指明 access-control-allow-origin 为服务方的 origin， 不能为*</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>新增属性：<br>Chrome 51 开始，浏览器的 Cookie 新增加了一个<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie/SameSite#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7">SameSite</a>属性，用来防止 CSRF 攻击和用户追踪。<br>可选值：</p>
<ul>
<li>Strict<br><code>Strict</code>最为严格，完全禁止第三方 Cookie，跨站点时，任何情况下都不会发送 Cookie。换言之，只有当前网页的 URL 与请求目标一致，才会带上 Cookie。</li>
<li>Lax<br><code>Lax</code>规则稍稍放宽，大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外。</li>
<li>None<br><code>None</code>相当于忽略该属性。不过，前提是必须同时设置 Secure 属性（Cookie 只能通过 HTTPS 协议发送），否则无效。</li>
</ul>
<p>相关东西，后面补充。</p>
<p>小结：<br><strong>跨域数据存储访问推荐做法：</strong></p>
<ul>
<li>把文件放在一起或者使用 Nginx 代理到一起 （推荐）</li>
<li>如果使用的域名可以考虑设置<code>document.domain</code>属性</li>
<li>完全不同源，可以考虑通过跨域通信的方式传递相关参数</li>
</ul>
<h2 id="跨域脚本-API-访问（Cross-origin-script-API-access）"><a href="#跨域脚本-API-访问（Cross-origin-script-API-access）" class="headerlink" title="跨域脚本 API 访问（Cross-origin script API access）"></a>跨域脚本 API 访问（Cross-origin script API access）</h2><p>如果两个网页不同源，就无法拿到对方的 DOM。典型的例子是<code>iframe</code>窗口和<code>window.open</code>方法打开的窗口，它们与父窗口无法通信。</p>
<p>比如，父窗口运行下面的命令，如果 iframe 窗口不是同源，就会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;myIFrame&quot;</span>).contentWindow.document;</span><br><span class="line"><span class="comment">// Uncaught DOMException: Blocked a frame with origin &quot;http://127.0.0.1:5500&quot; from accessing a cross-origin frame.</span></span><br></pre></td></tr></table></figure>

<p>上面命令中，父窗口想获取子窗口的 DOM，因为跨源导致报错。</p>
<p>反之亦然，子窗口获取主窗口的 DOM 也会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.parent.document.body;</span><br><span class="line"><span class="comment">// Uncaught DOMException: Blocked a frame with origin &quot;http://localhost:1000&quot; from accessing a cross-origin frame.</span></span><br></pre></td></tr></table></figure>

<p>对于完全不同源的网站，目前有四种方法，可以解决跨域窗口的通信问题。</p>
<ul>
<li>片段标识符（<code>fragment identifier</code>）</li>
<li>window.name</li>
<li>跨文档通信 API（<code>Cross-document messaging</code>）</li>
<li>WebSocket</li>
</ul>
<h3 id="片段标识符"><a href="#片段标识符" class="headerlink" title="片段标识符"></a>片段标识符</h3><p>片段标识符（fragment identifier）指的是，URL 的#号后面的部分，比如<code>http://example.com/x.html#fragment</code>的<code>#fragment</code>。<strong>如果只是改变片段标识符，页面不会重新刷新</strong>。也可以叫做<code>锚点</code>, 用作页面定位.</p>
<p>父窗口可以把信息，写入子窗口的片段标识符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> srcStr =</span><br><span class="line">  <span class="built_in">document</span>.getElementsByClassName(<span class="string">&quot;iframe&quot;</span>)[<span class="number">0</span>].src.split(<span class="string">&quot;#&quot;</span>)[<span class="number">0</span>] +</span><br><span class="line">  <span class="string">&quot;#&quot;</span> +</span><br><span class="line">  <span class="built_in">encodeURI</span>(value);</span><br><span class="line">$(<span class="string">&quot;.iframe&quot;</span>).attr(<span class="string">&quot;src&quot;</span>, srcStr);</span><br></pre></td></tr></table></figure>

<p>子窗口通过监听 hashchange 事件得到通知。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onhashchange = checkMessage;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkMessage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> message = <span class="built_in">window</span>.location.hash;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，子窗口也可以改变父窗口的片段标识符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parent.location.href = target + <span class="string">&quot;#&quot;</span> + hash;</span><br></pre></td></tr></table></figure>

<p>注意：<strong>如果修改后的 hash 值和原来的一样，不会进片段标识符改变的监听</strong></p>
<h3 id="window-name"><a href="#window-name" class="headerlink" title="window.name"></a>window.name</h3><p>浏览器窗口有<code>window.name</code>属性。这个属性的最大特点是，无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页可以读取它。</p>
<p>父窗口先打开一个子窗口，载入一个不同源的网页，该网页将信息写入 window.name 属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.name = <span class="string">&#x27;&#123;&quot;name&quot;: &quot;lisi&quot;&#125;&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>接着，子窗口跳回一个与主窗口同域的网址。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把子页面的window.location 设置为域和父页面同源的</span></span><br><span class="line"><span class="built_in">window</span>.location = <span class="string">&quot;http://127.0.0.1:5500/windowName/testWN.html&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>然后，主窗口就可以读取子窗口的 window.name 了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myFrame&quot;</span>).contentWindow.name;</span><br></pre></td></tr></table></figure>

<p>这种方法的优点是，<code>window.name</code>容量很大，可以放置非常长的字符串；<br>代码实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> state = <span class="number">0</span>;</span><br><span class="line">(iframe = <span class="built_in">document</span>.createElement(<span class="string">&quot;iframe&quot;</span>)),</span><br><span class="line">  (loadfn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> data = iframe.contentWindow.name; <span class="comment">// 读取数据</span></span><br><span class="line">      alert(data); <span class="comment">// 你好，我是子页面的window.name， 携带了一些数据</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state === <span class="number">0</span>) &#123;</span><br><span class="line">      state = <span class="number">1</span>;</span><br><span class="line">      iframe.contentWindow.location =</span><br><span class="line">        <span class="string">&quot;http://127.0.0.1:10229/page/windowName/null.html&quot;</span>; <span class="comment">// 设置的代理文件</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">iframe.src = <span class="string">&quot;http://localhost:1000/windowname-nginx.html&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (iframe.attachEvent) &#123;</span><br><span class="line">  iframe.attachEvent(<span class="string">&quot;onload&quot;</span>, loadfn);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  iframe.onload = loadfn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(iframe);</span><br></pre></td></tr></table></figure>

<h3 id="window-postMessage"><a href="#window-postMessage" class="headerlink" title="window.postMessage"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage"><strong>window.postMessage</strong></a></h3><p>上面两种方法都属于破解，HTML5 为了解决这个问题，引入了一个全新的 API：跨文档通信 API（<code>Cross-document messaging</code>）。</p>
<p>这个 API 为 window 对象新增了一个方法 <code>window.postMessage</code>，允许跨窗口通信，不论这两个窗口是否同源，只要你能获取到目标对象的 window 对象。</p>
<p>举例来说，父窗口<code>http://aaa.com</code>向子窗口<code>http://bbb.com</code>发消息，调用<code>postMessage</code>方法就可以了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> popup = <span class="built_in">window</span>.open(<span class="string">&quot;http://aaa.com&quot;</span>, <span class="string">&quot;title&quot;</span>);</span><br><span class="line">popup.postMessage(<span class="string">&quot;Hello World!&quot;</span>, <span class="string">&quot;http://aaa.com&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><code>postMessage</code>方法的第一个参数是具体的信息内容，第二个参数是接收消息的窗口的源（<code>origin</code>），即”协议 + 域名 + 端口”。也可以设为<code>*</code>，表示不限制域名，向所有窗口发送.</p>
<p>子窗口向父窗口发送消息的写法类似。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.opener.postMessage(<span class="string">&quot;Nice to see you&quot;</span>, <span class="string">&quot;http://bbb.com&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>注：<code>window.opener</code> 属性是一个可读可写的属性，可返回对<strong>创建该窗口的 Window 对象的引用</strong>。</p>
<p>父窗口和子窗口都可以通过<code>message</code>事件，监听对方的消息。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(</span><br><span class="line">  <span class="string">&quot;message&quot;</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.data);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>下面的例子是，子窗口通过<code>event.source</code>属性引用父窗口，然后发送消息。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;message&quot;</span>, receiveMessage);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">receiveMessage</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.source.postMessage(<span class="string">&quot;Nice to see you!&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>event.origin</code>属性可以过滤不是发给本窗口的消息。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;message&quot;</span>, receiveMessage);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">receiveMessage</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (event.origin !== <span class="string">&quot;http://bbb.com&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (event.data === <span class="string">&quot;Hello World&quot;</span>) &#123;</span><br><span class="line">    event.source.postMessage(<span class="string">&quot;Hello&quot;</span>, event.origin);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event.data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>message 事件的事件对象 event，提供以下三个属性。</p>
<ul>
<li><strong>event.source：发送消息的窗口</strong></li>
<li><strong>event.origin: 消息发向的网址</strong></li>
<li><strong>event.data: 消息内容</strong></li>
</ul>
<p>下面的例子是，子窗口通过<code>event.source</code>属性引用父窗口，然后发送消息。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;message&quot;</span>, receiveMessage);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">receiveMessage</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.source.postMessage(<span class="string">&quot;Nice to see you!&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>event.origin</code>属性可以过滤不是发给本窗口的消息。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;message&quot;</span>, receiveMessage);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">receiveMessage</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (event.origin !== <span class="string">&quot;http://bbb.com&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (event.data === <span class="string">&quot;Hello World&quot;</span>) &#123;</span><br><span class="line">    event.source.postMessage(<span class="string">&quot;Hello&quot;</span>, event.origin);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event.data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通过 window.postMessage，读写其他窗口的 LocalStorage 或者 SessionStorage 也成为了可能。</strong></p>
<p>下面是一个例子，主窗口写入<code>iframe</code>子窗口的<code>localStorage</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e.origin !== <span class="string">&quot;http://bbb.com&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> payload = <span class="built_in">JSON</span>.parse(e.data);</span><br><span class="line">  <span class="built_in">localStorage</span>.setItem(payload.key, <span class="built_in">JSON</span>.stringify(payload.data));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，子窗口将父窗口发来的消息，写入自己的<code>LocalStorage</code>。</p>
<p>父窗口发送消息的代码如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> win = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;iframe&quot;</span>)[<span class="number">0</span>].contentWindow;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">&quot;Jack&quot;</span> &#125;;</span><br><span class="line">win.postMessage(</span><br><span class="line">  <span class="built_in">JSON</span>.stringify(&#123; <span class="attr">key</span>: <span class="string">&quot;storage&quot;</span>, <span class="attr">data</span>: obj &#125;),</span><br><span class="line">  <span class="string">&quot;http://bbb.com&quot;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>加强版的子窗口接收消息的代码如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e.origin !== <span class="string">&quot;http://bbb.com&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">var</span> payload = <span class="built_in">JSON</span>.parse(e.data);</span><br><span class="line">  <span class="keyword">switch</span> (payload.method) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;set&quot;</span>:</span><br><span class="line">      <span class="built_in">localStorage</span>.setItem(payload.key, <span class="built_in">JSON</span>.stringify(payload.data));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;get&quot;</span>:</span><br><span class="line">      <span class="keyword">var</span> parent = <span class="built_in">window</span>.parent;</span><br><span class="line">      <span class="keyword">var</span> data = <span class="built_in">localStorage</span>.getItem(payload.key);</span><br><span class="line">      parent.postMessage(data, <span class="string">&quot;http://aaa.com&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;remove&quot;</span>:</span><br><span class="line">      <span class="built_in">localStorage</span>.removeItem(payload.key);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>加强版的父窗口发送消息代码如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> win = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;iframe&quot;</span>)[<span class="number">0</span>].contentWindow;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">&quot;Jack&quot;</span> &#125;;</span><br><span class="line"><span class="comment">// 存入对象</span></span><br><span class="line">win.postMessage(</span><br><span class="line">  <span class="built_in">JSON</span>.stringify(&#123; <span class="attr">key</span>: <span class="string">&quot;storage&quot;</span>, <span class="attr">method</span>: <span class="string">&quot;set&quot;</span>, <span class="attr">data</span>: obj &#125;),</span><br><span class="line">  <span class="string">&quot;http://bbb.com&quot;</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">// 读取对象</span></span><br><span class="line">win.postMessage(<span class="built_in">JSON</span>.stringify(&#123; <span class="attr">key</span>: <span class="string">&quot;storage&quot;</span>, <span class="attr">method</span>: <span class="string">&quot;get&quot;</span> &#125;), <span class="string">&quot;*&quot;</span>);</span><br><span class="line"><span class="built_in">window</span>.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e.origin != <span class="string">&quot;http://aaa.com&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// &quot;Jack&quot;</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(e.data).name);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>SessionStorage 同理。</strong></p>
<h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2017/05/websocket.html">WebSocket</a></h3><p>WebSocket 是一种通信协议，使用<code>ws://（非加密）</code>和<code>wss://（加密）</code>作为协议前缀。该协议不实行同源策略，只要服务器支持，就可以通过它进行跨源通信。</p>
<p>下面是一个例子，浏览器发出的 WebSocket 请求的头信息（摘自维基百科）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;chat HTTP&#x2F;1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw&#x3D;&#x3D;</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Origin: http:&#x2F;&#x2F;example.com</span><br></pre></td></tr></table></figure>

<p>上面代码中，有一个字段是<code>Origin</code>，表示该请求的请求源（<code>origin</code>），即发自哪个域名。</p>
<p>正是因为有了<code>Origin</code>这个字段，所以 WebSocket 才没有实行同源策略。因为服务器可以根据这个字段，判断是否许可本次通信。如果该域名在白名单内，服务器就会做出如下回应。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk&#x3D;</span><br><span class="line">Sec-WebSocket-Protocol: chat</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<ul>
<li>Node 服务端:</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> WebSocket = <span class="built_in">require</span>(<span class="string">&quot;ws&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// websocket服务的端口</span></span><br><span class="line"><span class="keyword">const</span> wsport = <span class="number">3006</span>;</span><br><span class="line"><span class="keyword">var</span> wss = <span class="keyword">new</span> WebSocket.Server(&#123;</span><br><span class="line">  port: wsport,</span><br><span class="line">  path: <span class="string">&quot;/ws&quot;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> webSocketServer = wss.on(<span class="string">&quot;connection&quot;</span>, <span class="function"><span class="keyword">function</span> <span class="title">connection</span>(<span class="params">ws</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;ws连接&quot;</span>);</span><br><span class="line">  ws.isAlive = <span class="literal">true</span>;</span><br><span class="line">  ws.on(<span class="string">&quot;pong&quot;</span>, heartbeat);</span><br><span class="line">  ws.on(<span class="string">&quot;message&quot;</span>, <span class="function"><span class="keyword">function</span> <span class="title">incoming</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">    message = <span class="built_in">JSON</span>.parse(message);</span><br><span class="line">    sendAllMessage(webSocketServer, message);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 广播消息</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendAllMessage</span>(<span class="params">server, message</span>) </span>&#123;</span><br><span class="line">  server.clients.forEach(<span class="function">(<span class="params">ws</span>) =&gt;</span> &#123;</span><br><span class="line">    ws.send(<span class="built_in">JSON</span>.stringify(message));</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定时每30s发送ping监测连接是否中断</span></span><br><span class="line"><span class="keyword">const</span> interval = <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> <span class="title">ping</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  wss.clients.forEach(<span class="function"><span class="keyword">function</span> <span class="title">each</span>(<span class="params">ws</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ws.isAlive === <span class="literal">false</span>) <span class="keyword">return</span> ws.terminate();</span><br><span class="line">    ws.isAlive = <span class="literal">false</span>;</span><br><span class="line">    ws.ping();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="number">30000</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>页面 1：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">&quot;ws://localhost:3006/ws&quot;</span>, <span class="string">&quot;suyp&quot;</span>);</span><br><span class="line">ws.onopen = <span class="function"><span class="keyword">function</span> (<span class="params">param</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;WebSocket连接成功！&quot;</span>);</span><br><span class="line">  ws.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">param</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;这是WebSocket接收的消息 --- &quot;</span> + param.data);</span><br><span class="line">    <span class="comment">// 接收消息这里推荐写try catch 来捕捉错误，因为消息有可能不是JSON格式</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> message = <span class="built_in">JSON</span>.parse(param.data);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (message) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (message.key) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;closeInfoWindow&quot;</span>:</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">&quot;弹窗已关闭&quot;</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  ws.onclose = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;ws关闭了&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>页面 2</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向父页面发送消息,来关闭弹窗</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">closeInfowWindow2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ws) &#123;</span><br><span class="line">    ws.send(</span><br><span class="line">      <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">        key: <span class="string">&quot;closeInfoWindow&quot;</span>,</span><br><span class="line">        msg: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>小结</strong><br><strong>跨域脚本 API 访问推荐做法：</strong></p>
<ul>
<li>Nginx 代理到一起 （最好）</li>
<li>使用 postMessaget 通信 （挺好）</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/hansexploration/article/details/80314948">什么是 JSONP — HansExploration</a></li>
<li><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/jsonp/493658?fr=aladdin">JSONP — 百度百科</a></li>
<li><a target="_blank" rel="noopener" href="https://www.techug.com/post/same-origin-policy.html">浏览器同源策略及其规避方法 — 阮一峰</a></li>
<li><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2017/05/websocket.html">WebSocket 教程 — 阮一峰</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options">X-Frame-Options — MDN</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie/SameSite#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7">SameSite — MDN</a></li>
</ul>
</div><div class="article-licensing box"><div class="licensing-title"><p>跨域解决</p><p><a href="https://ths-fe.github.io/2020/08/27/%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3/">https://ths-fe.github.io/2020/08/27/%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>苏永蓬</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2020-08-27</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2023-08-05</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="" rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/CORS/">CORS</a></div><div class="sharethis-inline-share-buttons"></div><script src="https://platform-api.sharethis.com/js/sharethis.js#property=5ea1492221690600121bcf3a&amp;product=inline-share-buttons&amp;cms=sop" defer></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/alipayqr.jpg" alt="支付宝"></span></a><a class="button donate" href="https://www.buymeacoffee.com/zapzqc?new=1" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>送我杯咖啡</span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/wechatqr.jpg" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/08/28/HTML%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">HTML编码规范</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/08/24/JavaScript%E6%96%B0%E7%89%B9%E6%80%A7/"><span class="level-item">JavaScript新特性</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="content" id="valine-thread"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script><script>new Valine({
            el: '#valine-thread' ,
            appId: "4o5OfjCIGaSyqIwg7jop80Ge-gzGzoHsz",
            appKey: "Rj9jcPLhW8WgWd6bDmXGmKaA",
            placeholder: "欢迎评论交流",
            avatar: "mm",
            
            meta: ["nick","mail","link"],
            pageSize: 10,
            lang: "zh-CN",
            
            highlight: true,
            
            
            
            
            
            requiredFields: [],
        });</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#什么导致了跨域"><span class="level-left"><span class="level-item">什么导致了跨域</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#跨域"><span class="level-left"><span class="level-item">跨域</span></span></a></li><li><a class="level is-mobile" href="#跨域示例"><span class="level-left"><span class="level-item">跨域示例</span></span></a></li><li><a class="level is-mobile" href="#限制范围"><span class="level-left"><span class="level-item">限制范围</span></span></a></li></ul></li><li><a class="level is-mobile" href="#常见跨域错误"><span class="level-left"><span class="level-item">常见跨域错误</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#缺少可跨域响应头"><span class="level-left"><span class="level-item">缺少可跨域响应头</span></span></a></li><li><a class="level is-mobile" href="#允许跨域的值重复"><span class="level-left"><span class="level-item">允许跨域的值重复</span></span></a></li><li><a class="level is-mobile" href="#不允许访问其他域的对象或者数据存储（cookie-等）"><span class="level-left"><span class="level-item">不允许访问其他域的对象或者数据存储（cookie 等）</span></span></a></li></ul></li><li><a class="level is-mobile" href="#解决跨域"><span class="level-left"><span class="level-item">解决跨域</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#跨域网络访问（Cross-origin-network-access）"><span class="level-left"><span class="level-item">跨域网络访问（Cross-origin network access）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#把两个资源放到同一个域中"><span class="level-left"><span class="level-item">把两个资源放到同一个域中</span></span></a></li><li><a class="level is-mobile" href="#服务器允许资源跨域共享"><span class="level-left"><span class="level-item">服务器允许资源跨域共享</span></span></a></li><li><a class="level is-mobile" href="#浏览器插件"><span class="level-left"><span class="level-item">浏览器插件</span></span></a></li><li><a class="level is-mobile" href="#利用一些不受同源策略影响的标签"><span class="level-left"><span class="level-item">利用一些不受同源策略影响的标签</span></span></a></li><li><a class="level is-mobile" href="#Canvas-中的跨域问题"><span class="level-left"><span class="level-item">Canvas 中的跨域问题</span></span></a></li><li><a class="level is-mobile" href="#不允许-IFrame-被嵌入"><span class="level-left"><span class="level-item">不允许 IFrame 被嵌入</span></span></a></li></ul></li><li><a class="level is-mobile" href="#跨域数据存储访问（Cross-origin-data-storage-access）"><span class="level-left"><span class="level-item">跨域数据存储访问（Cross-origin data storage access）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#使用域名"><span class="level-left"><span class="level-item">使用域名</span></span></a></li></ul></li><li><a class="level is-mobile" href="#跨域脚本-API-访问（Cross-origin-script-API-access）"><span class="level-left"><span class="level-item">跨域脚本 API 访问（Cross-origin script API access）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#片段标识符"><span class="level-left"><span class="level-item">片段标识符</span></span></a></li><li><a class="level is-mobile" href="#window-name"><span class="level-left"><span class="level-item">window.name</span></span></a></li><li><a class="level is-mobile" href="#window-postMessage"><span class="level-left"><span class="level-item">window.postMessage</span></span></a></li><li><a class="level is-mobile" href="#WebSocket"><span class="level-left"><span class="level-item">WebSocket</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#参考资料"><span class="level-left"><span class="level-item">参考资料</span></span></a></li></ul></div></div><style>.menu-list > li > a.is-active + .menu-list { display: block; }.menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="adsense"><div class="card-content"><div class="menu"><h3 class="menu-label"> </h3><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-6826040978803389" data-ad-slot="1033672070" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/ths.png" alt="思路大前端团队" height="28"></a><p class="is-size-7"><span>&copy; 2023 苏永蓬</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>