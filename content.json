{"pages":[{"title":"关于我们","text":"思路大前端团队于2018年成立，分布北京、成都、深圳、西安四地，是由UI设计师、前端开发工程师、GIS开发工程师共同组成的集设计、开发于一体的综合性团队。我们致力于产品的用户体验设计，利用各种可视化技术手段进行信息展现，为各业务线提供可视化解决方案，增强产品的核心竞争力。 愿景成为一个学习型且有影响力的团队，成为业内一流的可视化解决方案提供者 使命利用技术提升产品的核心竞争力 文化开心、乐观、自驱、互助、专业、创新 职责 参与产品设计讨论，结合用户体验为公司新产品与新功能提供创意及设计方案，跟踪设计效果，把控产品最终界面的实现效果 结合项目的整体计划和安排，协助其他开发人员解决项目开发过程中的技术难题 参与前端工程构建系统的研发，包括开发规范、自动化工具、框架研发、可视化搭建、数据埋点、持续集成、应用监控、安全保障、性能优化等 实现界面和交互的开发需求，确保不同平台、设备上具有优秀的用户体验 负责数据可视化前沿技术的研究，可视化平台整体架构设计和研发 加入我们对用户来说，界面就是一切。想做一个掌控一切的人吗？加入我们吧！ 可加微信：zapzqc 或发送简历至：zapzqc@qq.com","link":"/about/index.html"},{"title":"大前端技术体系","text":"核心 网页行为：JavaScript ✅ 编码规范 thanks to airbnb 😂 ⬜ JavaScript 简介 ⬜ 变量提升(Variable Hoisting)、事件冒泡(Event Bubbling)、严格模式(Strict) ⬜ this ⬜ 闭包(Closure) ⬜ 原型(Prototype)与原型链(Prototype Chain) ⬜ JSON(JavaScript Object Notation) ⬜ 作用域(Scope)与作用域链(Scope Chain) ⬜ AJAX(Asynchronous Javascript And XML) ⬜ 跨域(Cross Domain) ⬜ 模块化(Module) ⬜ 事件循环(Event Loop) ⬜ 正则表达式(Regular expressions) ⬜ Web API(CustomEvent、WebSockets、Web Workers.etc) ES5-ES6+ ✅ JavaScript 新特性 吴俊 图形 ⬜ Canvas ⬜ WebGL ⬜ SVG Web Component ⬜ Shadow DOM TypeScript ✅ 编码规范 刘莹鑫 ⬜ 类型(Type) ⬜ 接口、类、命名空间、模块 ⬜ 装饰器 ⬜ 声明文件 网页样式：CSS ✅ CSS 编码规范 刘燕 ⬜ CSS 实战 ⬜ BEM ⬜ 响应式和媒体查询 ⬜ Sass 编码规范 刘燕 网页结构：HTML ✅ HTML 编码规范 刘燕 ⬜ HTML 简介 ⬜ HTML5 特性 概念 基本 ✅ 前端开发必须掌握的基本概念 段美霞 ⬜ 值 🆚 引用类型，栈 🆚 堆 ⬜ 形参 🆚 实参，转译 🆚 编译 ⬜ BOM 🆚 DOM ⬜ 对称加密 🆚 非对称加密 ⬜ 逻辑像素 🆚 物理像素 rem 🆚 em pt 🆚 dp ⬜ 标准化组织 进阶 ⬜ 字符编码(Character Encodings) ⬜ SOAP 和 RESTful 能做比较吗？ ⬜ 开源协议 ⬜ 命令式 🆚 声明式 开发周边 ⬜ 命令行 ⬜ JSDoc ⬜ Markdown ⬜ GitHub ⬜ 蓝湖 ⬜ Fiddler ⬜ Chrome DevTools ⬜ PostWoman ✅ RAP2 入门 刘莹鑫 ✅Storybook的基本使用指南 老吕 协议相关 ⬜ OSI 模型 ⬜ DNS ✅ HTTP 协议演变 马文超 ✅ HTTP 请求方法的异同 天下布武 ⬜ HTTPS ⬜ 端口 ⬜ URI 🆚 UDP 浏览器 ⬜ 浏览器历史 ⬜ 主流浏览器对比 ⬜ 浏览器工作原理 JS 框架 Vue.js ✅ Vue.js2 最佳实践 天下布武 ✅ Vue 组件开发及 NPM 发布（TS 版） 天下布武 ⬜ SSR Angular ⬜ Angular 组件开发及 NPM 发布 ReactUI 框架 ⬜ Element ⬜ Ionic 库 ⬜ ECharts ⬜ D3 ⬜ three.js ⬜ RxJS 跨平台 ✅ PWA–下一代的 web 应用模型 曹芯萍 ⬜ Cordova ⬜ Electron ⬜ Flutter？ ⬜ Service Worker 服务器&amp;操作系统&amp;中间件 ⬜ nginx 使用 ⬜ Tomcat ⬜ IIS 添加 HTTPS ⬜ Redis ⬜ RabbitMQ ⬜ CentOS Node.js ⬜ NPM ✅ Nest.js 张金秀 ⬜ mongoose ⬜ socket.io 数据库 ⬜ MongoDB ⬜ PostgreSQL 编辑器&amp;IDE ⬜ VS Code ⬜ WebStrom ⬜ Xcode ⬜ Android Studio 持续集成&amp;交付&amp;部署 ⬜ SVN ⬜ Git ⬜ 常用构建、静态分析工具及配置 ⬜ Jenkins ⬜ Docker 监控 ⬜ Sentry ⬜ New Relic 数据结构&amp;算法 ⬜ 时间复杂度、空间复杂度 设计思想&amp;模式 性能 安全 ⬜ JWT 管理 ⬜ 招聘 ⬜ 团队管理 ⬜ 项目管理 ⬜ PPT ⬜ Word ⬜ 设计说明书 其它 ⬜ WebRTC ⬜ WebAssembly ⬜ Tensorflow.js ⬜ GraphQL ⬜ Serverless 大前端技术体系一张图","link":"/fe/index.html"},{"title":"gis","text":"概念 ⬜ 地理坐标系 ⬜ 插值 ⬜ WebGL ⬜ 空间坐标系 ⬜ 正交投影 🆚 透视投影 ⬜ 上帝说有光，于是便有了光 ⬜ 纹理 ⬜ 旋转、跳跃，我闭着眼 ⬜ 粒子系统 ⬜ 着色器 桌面软件ArcMapQGIS服务器ArcGIS ServerGeoServer数据库PostGIS工具库ArcpyGDAL2D Map库ArcGIS API for JavaScriptTurf3D Map库three.jsCesium","link":"/gis/index.html"}],"posts":[{"title":"博客使用指南","text":"我们现在使用的博客框架是 Hexo，感兴趣的同学可以去了解下。 1 下载源码从GitHub的仓库中下载博客工具源码到自己机器上 1git clone https://github.com/THS-FE/blog.git 2 安装依赖进入项目所在文件夹，执行 12# npm install -g hexo-clinpm install 3 新建帖子1npx hexo new post '博客的名称' 需要用到图片等资源都放进新生成的文件夹中，图片尽量是JPG格式。使用以下语句来引入图片 1{% asset_img 你的图片名称.jpg %} 4 删除帖子直接在 source_posts 文件夹下删除对应的md文件和文件夹，再运行命令 12npx hexo cleannpx hexo g 5 运行博客1npx hexo s 执行成功后，在浏览器中输入 http://localhost:4000/ 6 发布博客前提是你有这个仓库的修改权限。修改提交说明 运行命令 12npx hexo gnpx hexo deploy 第一次会要求输入你Github的用户名和密码。 如果部署以后发现 https://ths-fe.github.io/ 博客没有更新，需要手动删除项目中的.deploy_git 文件夹，重新运行命令 12npx hexo cleannpx hexo g -d 7 文章规范7.1 多级标题要加上数字编号标题最多分 6 级，即对应 h1 ~ h6。 如： 3.2 我的世界 7.2 段落之间要有空行图片与图片，图片与段落、段落与段落前后都要留有空行。 7.3 中英文（数字）前后要留出空格当数字、英文在句子开头，前面不需留空格；当数字、英文在句子末尾，后面亦不需留空格。 错误： 有些英文拼写要正确，比如说iPhone不要写成iphone。虽然2020年已经奔3了，但还要继续学习。 正确： 有些英文拼写要正确，比如说 iPhone 不要写成 iphone。虽然 2020 年已经奔 3 了，但还要不断学习。 7.4 标识重点使用加粗，但首尾的标点符号不要加粗被加粗的语句、短语前后，如果有标点符号，不要对它加粗，句子中间的标点符号可正常加粗。 错误：要学会如何使用加粗啊，兄弟。 正确：要学会如何使用加粗啊，兄弟。 7.5 正确拼写英文单词英文的拼写，如 GraphQL 而不是 graphql，Node.js 而不是 nodejs，iPhone 而不是 iphone，Apple 而不是 apple，Java 而不是 java，Aliyun 而不是 aliyun，UED 而不是 ued，RDS MySQL 而不是 rds mysql，OSS 而不是 oss 等等，使用前，先网上查下正确使用。 8 注意事项 文章写完后别忘记先提交github，然后再发布 上传的图片大小尽量不大于 50 KB，文章标题图片大小要为 760*325（小于的不用太调整），统一命名为 cover.jpg，其它无限制。在线压缩网址：https://www.yasuotu.com/ 在 VS Code中安装插件：markdownlint，用以检查 md 文件中，要保证上传的 md 中没有错误 在大前端技术体系的对应模块中添加该文章的链接","link":"/2020/04/24/%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"title":"HTTP请求方法的异同","text":"HTTP（HyperText Transfer Protocol，超文本传输协议）中定义的请求方法共八种（GET、HEAD、POST、PUT、DELETE、CONNECT、OPTIONS、TRACE，参看RFC7231）。工作中我们最常接触到的是其中的GET、POST、PUT和DELETE。网上有很多针对这四种方法的说明和比较，但内容都不尽如人意。为了能让大家更清晰地了解这些方法，在实际工作中灵活运用，我将从定义和实现两个方面详细地阐述一下它们的异同。 首先，看一些基本概念。超文本传输协议是网络七层结构中应用层的协议。我们看到“超文本”一般会联想到另一个词：HTML(HyperText Mark-up Language，超文本标记语言)。那什么是“超文本”？“超文本”是1965年美国人Ted Nelson创造的，简单的说就是包含有其他文本链接的文本 (Hypertext is text which contains links to other texts)，通过这些链接可以访问指向的文本。HTML就是用来创建超文本(如Web页面)的。最初设计HTTP的目的是为了能够在客户端和服务器端之间传输超文本文档 (HTML)**。不过随着时代的发展，“超文本”已经从最初的纯文本扩展成为包括文本、图像、音频、视频等在内的多媒体。现今，把HTTP称为超媒体传输协议可能更为合适些**。 针对HTTP，有文档明确定义的版本有0.9（1991）、1.0（1996）、1.1（1997）和2（2015）。目前使用最广泛的是1.1，该规范由IETF（Internet Engineering Task Force，互联网工程任务组）中的HTTP Working Group（HTTP工作组）于2014年更新，定义的内容在RFC7230–RFC7235六个文档中。 接下来，开始正式的对比： 1 定义上RFC文档定义了三种方法属性：安全、幂等、可缓存。 安全 如果请求方法的语义是只读的(如GET、HEAD、OPTIONS、TRACE )，那么该方法就是安全的。也就是说客户端不会请求和期望改变服务器上目标资源的任何状态。 幂等 如果使用该方法对服务器发送多次相同请求和一次请求的效果是一样的，那么该方法就被认为是幂等的。PUT, DELETE及上面提到的安全方法都是幂等的。 可缓存 对于请求方法的响应被允许存储以备将来重用，那么该方法就可以定义为“可缓存”。一般来说，不依赖于当前响应的安全方法被定义为可缓存的。规范将GET，HEAD和POST定义为可缓存，尽管绝大多数缓存实现只支持GET和HEAD。 属性 GET POST PUT DELETE 安全 是 否 否 否 幂等 是 否 是 是 可缓存 是 是 否 否 语义 检索信息（查） 创建或附加资源（增、改） 创建或替换资源（增、改） 删除资源（删） ⚠️ 以上的“是”，指的是定义中有明确要求的。“否”指的是没有明确要求，可做可不做的。 稍微解释下： 安全：使用GET方法，不能修改服务器上的数据，而其它方法是可以的。 幂等：同样是添加资源，使用PUT只能添加一条数据，无论执行多少次。而使用POST可以是执行一次就添加一条新数据。 补充： 所有通用的服务器必须支持GET和HEAD方法，其他方法是可选的。这和大部分的实现还算是比较吻合，因为一般的服务器是做网站用途的，在地址栏中访问对应的URL地址、图片引入、JS文件引入、CSS文件引入等都是发送的GET请求。 无论是GET还是POST都没有限制请求参数的长度和位置（URL后还是消息体message body里）。 2 实现上 GET能被缓存，POST很少能被缓存 。 GET 和 POST 请求参数的位置不同，GET 请求的参数放在 URL 中（以?分割URL和传输数据，参数之间以&amp;相连，如：login?name=zqc&amp;password=zqc。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64编码，得出如：%E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII），而 POST 请求的参数放在消息体中。 由于以上2的缘故，再加上有些服务器会记录和打印GET请求的地址，因此，POST比GET相对安全一些。但是使用抓包工具的话，只要不加密，参数都能被轻而易举地获取。 华为手机浏览器不支持PUT方法，因此有些公司会规定添加和修改都使用POST。 GET和POST请求参数的大小主要是由浏览器和Web服务器决定。以下是利用node.js做服务端进行的一系列测试（感谢 橘子君）： 浏览器 请求类型 GET(Bytes) POST(Bytes) IE11 地址栏 2047 -- ajax 81593 102400 IE11 地址栏 2047 -- ajax Edge 地址栏 2083 -- ajax 81488 102400 Chrome 地址栏只粘贴 81550 -- 粘贴加输入 如果超32791，则为：32791+一次性新输入个数 -- ajax 有可能是服务器端限制 81459 102400 python ajax 81825 102400 也就是说除了在地址栏中输入URL发送GET请求有明显的限制，而直接通过代码发送请求，Get(80K左右)和Post(100K)发送的数据大小相差不多。 3 误区 一般认为HTTP请求方法与CRUD(Create, Read, Update, Delete)操作的对应关系如下：而实际上，除了GET和DELETE可以这样对应，POST和PUT都可以作为增加或修改操作。 CRUD HTTP 增加 POST 查询 GET 更新 PUT 删除 DELETE GET请求能够被保存在浏览器的浏览历史里面 不准确！只有是在浏览器地址栏内输入的URL地址才可以在浏览器历史中查看。 GET参数是带在URL后面，传统IE中URL的最大可用长度为2048字符，其他浏览器对URL长度限制实现上有所不同，POST请求无长度限制 不准确！上方已经写出了结论：除了在地址栏中输入URL发送GET请求有明显的限制，而直接通过代码发送请求，Get(80K左右)和Post(100K)发送的数据大小相差不多。 最后，再看下HTTP状态码，简单易懂：","link":"/2020/04/26/HTTP%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%E7%9A%84%E5%BC%82%E5%90%8C/"},{"title":"TypeScript编码规范","text":"1 命名及约定1.1 类使用PascalCase进行命名。 Bad 1class foo { } Good 1class Foo { } 1.2 类成员（变量、方法）使用camelCase进行命名。 Bad 1234class Foo { Bar: number; Baz(): number { }} Good 1234class Foo { bar: number; baz(): number { }} 1.3 接口使用PascalCase进行命名，不要在接口名前加“I”。 接口成员使用camelCase进行命名。 Bad 1234interface IFoo { Bar: number; Baz(): number;} Good 1234interface Foo { bar: number; baz(): number;} 1.4 命名空间使用PascalCase进行命名。 Bad 12namespace foo {} Good 12namespace Foo {} 1.5 枚举 使用PascalCase进行命名。 Bad 12enum color {} Good 12enum Color {} 枚举成员使用PascalCase进行命名。 Bad 123enum Color { red} Good 123enum Color { Red} 1.6 文件名 使用破折号分隔描述性单词，比如：hero-list.ts。 使用点将描述性名称与类型分开，比如：user-info.page.ts。 尽量使用常规的几种类型名，包括.page,.service,.component,.pipe,.module,.directive,.controller和.middleware。当然也可以自己创建其他类型，但不宜太多。 类名与文件名匹配，并遵循类命名规范。 类名 文件名 export class AppComponent { } app.component.ts export class HeroListComponent { } hero-list.component.ts export class UserProfileService { } user-profile.service.ts 2 类型 需显式地为变量、数组和方法编写类型（类型推论能够推断出类型的不需要声明类型）。 Bad 1234567891011121314class Bar { bar(input) { let isZero; const foo: number = 5; if(input===5){ isZero=false; } const resultObject = { fo: foo, isZeroRes: isZero }; return resultObject; }} Good 12345678910111213141516171819class Bar { bar(input: number): BarResult { let isZero: boolean; const foo = 5; if (input === 0) { isZero = true; } const resultObject = { fo: foo, isZeroRes: isZero }; return resultObject; }}interface BarResult { fo: number; isZeroRes: boolean;} 不要使用Number、String、Boolean、Object为变量、数组和方法设置类型。 Bad 123baz(foo: String): String {} Good 123baz(foo: string): string {} 3 声明变量 如果变量在其生命周期可能发生改变，尽量使用let。 如果一个值在程序生命周期内不会改变，尽量使用const。 Bad 1234567var bar = 'bar';var count;if (true) { console.log(bar); count += 1} Good 123456const bar = 'bar';let count: number;if (true) { console.log(bar); count += 1;} 4 对象 使用{}进行对象创建。 Bad 1const item = new Object（）; Good 1const item = {}; 在对象字面量里使用属性简写。 Bad 1234const lukeSkywalker = 'Luke Skywalker';const obj = { lukeSkywalker: lukeSkywalker,}; Good 1234const lukeSkywalker = 'Luke Skywalker';const obj = { lukeSkywalker,}; 仅使用引号用于属于无效标识符的属性。 Bad 12345const bad = { 'foo': 3, 'bar': 4, 'data-blah': 5, }; Good 12345const good = { foo: 3, bar: 4, 'data-blah': 5, }; 5 字符串 使用单引号声明字符串。 Bad 1const bar = &quot;bar&quot;; Good 1const bar = 'bar'； 6 解构 访问和使用对象的多个属性时，使用对象解构。 Bad 12const foo = user.firstName;const bar = user.lastName; Good 1const { foo, bar } = user; 访问数组中的多个数据时，使用解构。 Bad 123const arr = [1, 2, 3, 4];const first = arr[0];const second = arr[1]; Good 12const arr = [1, 2, 3, 4];const [first, second] = arr; 7 空格 在定义类型前面加上空格。 赋值等号两边加上空格。 方法、类大括号前空格。 对象冒号后空格。 Bad 12345678910class Foo{ openDetail(item:string):void{ let foo:string; foo=''; const foa={ name:'foo' }; console.log(item); }} Good 12345678910class Foo { openDetail(item: string): void { let foo: string; foo = ''; const foa = { name: 'foo' }; console.log(item); }} 8 缩进使用两个空格缩进。 9 分号语句结尾添加分号。 Bad 1const foo = 'foo' Good 1const foo = 'foo'; 10 数组 使用[]定义数组。 Bad 1let foos:Array&lt;Foo&gt;; Good 1let foos:Foo[]; 使用push添加数据 Bad 12const foos = [];foos[foos.length] = 'abracadabra'; Good 12const foos = [];foos.push('abracadabra');","link":"/2020/05/24/TypeScript%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"},{"title":"JavaScript模块化","text":"模块化的理解1、什么是模块化 将一个复杂的程序，依据一定的规则(规范)封装成一个或多个块(文件), 并进行组合在一起。 块的内部数据与实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信。 2、模块化的进化过程无模块时代 在ajax还未提出之前，js还只是用来在网页上进行表单校验、提交，对DOM渲染操作。 123456789101112131415161718var str,num;//......function submit(){ str = document.getElementById(&quot;xx&quot;).value; if(str){ //...... } else{ //...... } num = 1; for(var i=0; i&lt;10; i++){ num++ //...... } //...... form.submit()} 1234&lt;script type=&quot;text/javascript&quot; src=&quot;a.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;b.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;c.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;main.js&quot;&gt;&lt;/script&gt; 缺点： 全局变量污染 函数命名冲突 文件依赖顺序 模块雏形时代 2006年，ajax的概念被提出，前端拥有了主动向服务端发送请求并操作返回数据的能力，传统的网页向“富客户端”发展，出现了简单的功能对象封装。 namespace模式 12345678//模块jsvar myModule = { first_name: 'www.', second_name: 'baidu.com', getFullName: function() { return this.first_name + this.second_name; }} 1234//调用jsconsole.log(myModule.getFullName());myModule.first_name = 'img.';console.log(myModule.getFullName()); 优点: 减少了全局变量，解决命名冲突缺点: 数据不安全(外部可以直接修改模块内部的数据)，模块名称会暴露在全局，存在命名冲突，依赖顺序问题 自执行匿名函数（闭包）模式 1234567891011//模块js(function (window) { let _moduleName = 'module'; function setModuleName(name) { _moduleName = name; } function getModuleName() { return _moduleName; } window.moduleA = { setModuleName, getModuleName }})(window) 1234//调用jsmoduleA.setModuleName('html-module');console.log(moduleA.getModuleName());console.log(moduleA._moduleName);//模块不暴露，无法访问模块内属性方法 优点：变量、方法全局隐藏，模块私有化缺点：模块名称会暴露在全局，存在命名冲突，依赖顺序问题 3、面临的问题从以上的尝试中，可以归纳出js模块化需要解决那些问题： 如何安全的包装一个模块的代码？（不污染模块外的任何代码） 如何唯一标识一个模块？ 如何优雅的把模块的API暴漏出去？（不能增加全局变量） 如何方便的使用所依赖的模块？ 模块化的规范1、CommonJS2009年Nodejs发布，采用 CommonJS 模块规范。 特点： 每个文件都是一个模块实例，代码运行在模块作用域，不会污染全局作用域。 文件内通过require对象引入指定模块，通过exports对象来向往暴漏API，文件内定义的变量、函数，都是私有的，对其他文件不可见。 每个模块加载一次之后就会被缓存。 所有文件加载均是同步完成，加载的顺序，按照其在代码中出现的顺序。 模块输出的是一个值的拷贝，模块内部的变化不会影响该值。 123456789//模块jslet _moduleName = 'module';function setModuleName(name) { _moduleName = name;}function getModuleName() { return _moduleName ;}module.exports = { setModuleName, getModuleName } 1234//调用jsimport { getModuleName, setModuleName } from './es6.module';setModuleName(&quot;es6 Module&quot;);console.log(getModuleName()); 缺点：模块同步加载，资源消耗和等待时间，适用于服务器编程 2、AMD/RequireJSCommonjs局限性很明显： 基于Node原生api在服务端可以实现模块同步加载，但是仅仅局限于服务端，客户端如果同步加载依赖的话时间消耗非常大，所以需要一个在客户端上基于Commonjs但是对于加载模块做改进的方案，于是AMD规范诞生了。 AMD是”Asynchronous Module Definition”的缩写，意思就是”异步模块定义”。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到所有依赖加载完成之后（依赖前置），这个回调函数才会运行。 RequireJS是一个工具库，主要用于客户端的模块管理。它的模块管理遵守AMD规范，RequireJS的基本思想是，通过define方法将代码定义为模块，通过require方法实现代码的模块加载。 12345678// module1.js 定义没有依赖的模块define(function () { let _moduleName = 'module'; function getName() { return _moduleName; } return { getName } // 暴露模块}) 123456789101112// module2.js 定义有依赖的模块define(['module1'], function (module1) { let _firstName = 'AMD' function getFullName() { return _firstName + ' ' + module1.getName(); } function setFirstName(name) { _firstName = name; } // 暴露模块 return { _firstName, getFullName, setFirstName }}) 12345678910111213141516//mian.jsrequire.config({ paths: { module1: './modules/module1', module2: './modules/module2', // 第三方库模块 jquery: './libs/jquery.min' }})require(['module2','jquery'], function(module2,jquery) { console.log(module2.getFullName()); module2.setFirstName('AMD-AMD'); console.log(module2.getFullName()); console.log(module2._firstName); jquery('#moduleId').html(&quot;&lt;i&gt;My name is jquery-module&lt;/i&gt;&quot;);}) 12//html中引入工具库，并定义js主文件&lt;script data-main=&quot;./main&quot; src=&quot;./libs/require.js&quot;&gt;&lt;/script&gt; 特点：浏览器直接运行无需编译，异步加载，依赖关系清晰 3、CMD/SeaJSCMD规范专门用于浏览器端，同样是受到Commonjs的启发，国内（阿里）诞生了一个CMD（Common Module Definition）规范。该规范借鉴了Commonjs的规范与AMD规范，在两者基础上做了改进。 与AMD相比非常类似，CMD规范（2011）具有以下特点： define定义模块，require加载模块，exports暴露变量。 不同于AMD的依赖前置，CMD推崇依赖就近（需要的时候再加载） 推崇api功能单一，一个模块干一件事。 SeaJs是CMD规范的实现，跟RequireJs类似，CMD是SeaJs推广过程中诞生的规范。CMD借鉴了很多AMD和Commonjs优点。 123456//module.1define(function (require, exports, module) { module.exports = { msg: 'I am module1' }}) 12345678//module.2define(function (require, exports, module) { var module2 = require('./module1') function show() { console.log('同步引入依赖模块1 ' + module2.msg) } exports.showModule = show}) 123456//main.jsdefine(function (require) { var m2 = require('./modules/module2') m2.showModule();}) 12345//html中引入工具库，并定义js主文件&lt;script type=&quot;text/javascript&quot; src=&quot;./libs/sea.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; seajs.use('./main')&lt;/script&gt; AMD、CMD区别 AMD 推崇依赖前置 CMD 推崇依赖就近 12345678//AMDdefine(['./a', './b'], function(a, b) { // 依赖必须一开始就写好 a.doSomething() ... // 此处略去 100 行 b.doSomething() ...}) 12345678910//CMDdefine(function(require, exports, module) { var a = require('./a') a.doSomething() ... // 此处略去 100 行 var b = require('./b') // 依赖可以就近书写 b.doSomething() ...} 4、ES62015年，ES6规范中，终于将模块化纳入JavaScript标准，从此js模块化被ECMA官方扶正，也是后来js的标准。ES6中的模块化在CommonJS的基础上有所不同，关键字有import，export，default，as，from。 123456789//模块jslet _moduleName = 'module';function setModuleName(name) { _moduleName = name;}function getModuleName() { return _moduleName;}export { setModuleName, getModuleName } 1234//调用jsimport { getModuleName,setModuleName } from './es6.module';setModuleName(&quot;es6 Module&quot;);console.log(getModuleName()); CommonJS和ES6区别 CommonJS 模块输出的是一个值的拷贝，即原来模块中的值改变不会影响已经加载的该值。ES6 模块输出的是值的只读引用，模块内值改变，引用也改变。 CommonJS 模块是运行时加载，加载的是整个模块，即将所有的接口全部加载进来。ES6 模块是编译时输出接口，可以单独加载其中的某个接口。 总结 CommonJS规范主要用于服务端编程，加载模块是同步的，不适合在浏览器环境，存在阻塞加载，浏览器资源是异步加载的，因此有了AMD、CMD解决方案。 AMD规范在浏览器环境中异步加载模块，而且可以并行加载多个模块。 CMD规范与AMD规范很相似，都用于浏览器编程，依赖就近，代码更简单。 ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。","link":"/2020/05/29/JavaScript%E6%A8%A1%E5%9D%97%E5%8C%96/"},{"title":"Rap2入门","text":"1 写在最前面1.1 是什么是阿里妈妈前端团队出品，是一个接口可视化管理平台。 使用了Mock.js作为Mock引擎，用于前后端分离的开发模式中，根据约定接口自动生成模拟数据。 1.2 能解决什么问题 前端独立开发，不受后端接口开发进度的影响。 无需前后端联调，避免频繁沟通，减少双方时间成本。 支持生成随机的文本、数字、布尔值、日期、邮箱、链接、图片、颜色等模拟数据，可实现真实接口请求效果。 1.3 最终目的提升协作效率，少加班，少熬夜。 2 快速上手2.1 登录打开Rap2官方服务站点rap2.taobao.org之后进行登录，新用户需要注册。 说明：rap2为开源项目，也可以通过下载官方源码，自行编译本地部署。rap2源码传送门注意：公司内部用户请使用内部服务，数据进行了定期备份，更安全，更可靠。内部地址：http://xxx.xx.xxx.108:8887/ths-rap2，地址全路径请咨询组内人员。 2.2 新建仓库一般一个项目建立一个仓库，仓库中存放这个项目的所有接口。按照以下步骤进行操作: 操作说明： 新建仓库：发起仓库新建操作。 仓库名称（必填）：建议与项目名称保持一致。 简介（非必填）：对仓库名称进行补充描述。 成员（非必填）：被添加的成员可以获得这个仓库内接口的操作权限，一般为这个项目的前后端开发人员。 团队（非必填）：被添加的团队，团队内成员可以获得这个仓库内接口的操作权限。 协同仓库ID（非必填）：在当前仓库中无法匹配到接口时，将会从协同仓库中寻找，便于大的项目按不同仓库拆分管理。 2.3 新建模块一般仓库下可以按照功能划分出来多个模块，每个模块放对应的接口，方便接口查找。按照以下步骤进行操作: 操作说明： 新建模块：发起模块新建操作。 模块名称（必填）：这里的模块名称，可以按照功能划分。 模块简介（非必填）：对模块名称进行补充描述。 2.4 新建接口按照以下步骤进行操作: 操作说明： 新建接口：发起接口新建操作。 名称（必填）：接口文本描述。 地址（必填）：接口的访问地址。 类型：请求类型。 请求码：http状态码。 简介：对名称的补充描述。 2.5 设置请求参数&amp;响应结果2.5.1 请求参数示例数据JSON： 1234567891011121314{ &quot;token&quot;: &quot;&quot;, &quot;login_name&quot;: &quot;&quot;, &quot;code_region&quot;: &quot;&quot;, &quot;trade_code&quot;: &quot;&quot;, &quot;sync_nation&quot;: &quot;&quot;, &quot;code_land&quot;: &quot;&quot;, &quot;scflag&quot;: &quot;&quot;, &quot;longitude_d&quot;: &quot;&quot;, &quot;latitude_d&quot;: &quot;&quot;, &quot;pageSize&quot;: &quot;&quot;, &quot;pageMum&quot;: &quot;&quot;, &quot;&quot;: &quot;&quot;} 按照以上操作进入接口编辑状态。 进入编辑状态后操作说明： 这个区域可以设置请求头，参数传输方式。这两个都需要提前跟后端沟通好。 导入：该操作可以根据提前跟后端沟通定义好的JSON格式对象进行参数的快速导入注意：也可以通过单行方式导入，具体参照下图 2.5.2 响应参数示例数据JSON： 1234567891011121314151617181920{ &quot;data&quot;: [ { &quot;LANDNAME&quot;: &quot;@cword(1, 3)污染地块&quot;, &quot;CODE_LAND&quot;: &quot;&quot;, &quot;CODE_STAGE_NAME&quot;: &quot;初步调查&quot;, &quot;NEW_SUPERVISETIME&quot;: &quot;@now(yyyy-MM-dd)&quot;, &quot;SUPERVISENUM&quot;: &quot;1&quot;, &quot;DISTANCE&quot;: &quot;@natural(10, 1000)&quot;, &quot;LONGITUDE&quot;: &quot;@float(109,120)&quot;, &quot;LATITUDE&quot;: &quot;@float(20,30)&quot;, &quot;TRADENAME&quot;: &quot;采矿业&quot;, &quot;REGIONNAME&quot;: &quot;白云区&quot;, &quot;SYNC_NATION&quot;: &quot;&quot;, &quot;FAVOURITE_ID&quot;: &quot;&quot;, &quot;CODE_STAGE&quot;: &quot;SURVEP&quot;, &quot;SEEMINFO_ID&quot;: &quot;6f2b8060- 34a1-446f-8f80-a771df3e1a20&quot; } ]} 注意：所有设置完成后，记得点击右上角的保存，不然接口设置不生效。 操作说明： 导入：该操作可以根据提前跟后端沟通定义好的JSON格式对象进行参数的快速导入注意：也可以通过单行方式导入。 2.6 接口访问地址 注意：由于演示地址为post 请求，必须在程序中或Postman等工具发起请求，这里只是为了获取到地址。 地址说明： 基础地址：对应生成环境中的项目服务地址。 接口地址：接口相对地址，定义时建议和实际接口保持一致，这样只需修改基础地址即可切换生产环境。 到此为止，一个可以在程序中访问的模拟接口已经完成了。 3 补充看到这里，大家肯定有疑问，模拟随机数据怎么模拟的呢？上边一些截图中带@符号的是什么啊？我模拟数据是个列表，现在才生成一条啊。 下面为大家讲解下，两个比较重要的东西：生成规则和初始值。 生成规则和初始值这两个是配合着使用的，也可以单独设置一个。在文章刚开始，讲到rap2使用了Mock.js作为Mock引擎,所以这两个的设置是遵循Mock.js 语法规范的。 比如快速上手部分例子，我们要让列表生成10条数据，如何设置呢？我们只需要把生成规则列设置成10就行了。 我是如何知道这个设置10可以生成10条数呢？查看Mockjs官方文档示例。传送门 再比如我们还想设置地块列表中地块名称为xxx污染地块，每一条都不一样，那就需要像上边截图中那样设置初始值了。@cword(1, 3)污染地块。[传送门](&lt;http://mockjs.com/examples.html#Random.cword( pool?, min?, max? )&gt;) Mockjs示例文档与Rap2设置对应关系说明（有其他模拟数据需求，都可以查看Mockjs给出的示例）:","link":"/2020/06/01/Rap2%E5%85%A5%E9%97%A8/"},{"title":"PWA--下一代的web应用模型","text":"概述 不知道从什么时候开始，当我们在浏览网页时，页面会出现一个弹窗，询问我们是否要将此网页保存到本地，如果我们选择了确定，在设备的主屏上就会出现一个新的app，而它就是我们刚才浏览的网页。这种app我们并没有从应用商店去下载，但是我们可以像使用app一样去使用它，也可以像卸载其他app一样去将它卸载，那么这究竟是个什么东西呢，它就是这篇文章的主角——PWA。 什么是PWAPWA是Progressive Web App的简写，中文名称为渐进式web应用。它是Google 在2016年提出的概念，2017年落地的web技术，一种在移动端利用提供的标准化框架，在网页应用中实现和原生应用相近的用户体验的渐进式网页应用。PWA不单指一种技术，你也可以将其理解为一种思想和概念，目的就是对标原生app，将Web网站通过一系列的Web技术去优化它，提升其安全性，性能，流畅性，用户体验等各方面指标，最后达到用户就像在用app一样的感觉。 PWA为什么会出现说到app，我们就不得不提起native app即原生app，现在非常主流的移动端应用。原生app使用起来会很流畅，性能好，安全性也可以很高，这是它很显著的优势。但是缺点呢，也很明显，比如： 开发成本很昂贵 软件上线，版本更新都需要发布到不同的商店，并通过审核 这对开发人员来说是比较麻烦的事情。而对于用户来说，有些APP可能使用频率特别少，但还是不得不去商店中下载庞大的安装包，或者可能一段时间不使用以后，随着版本的更新，也不得不去重新更新并安装。 PWA则完美地避免了这些问题。 如何判断一个web应用是PWA要判断一个web应用是否是PWA，可以从以下几个方面去考虑： 可发现的—— 内容可以通过搜索引擎发现。 可安装—— 可以出现在设备的主屏幕。 可链接—— 你可以简单地通过一个URL来分享它。 独立于网络——它可以在离线状态或者是在网速很差的情况下运行。 渐进式—— 它在老版本的浏览器仍旧可以使用，在新版本的浏览器上可以使用全部功能。 可重用—— 无论何时有新的内容它都可以发送通知。 响应性—— 它在任何具有屏幕和浏览器的设备上可以正常使用——包括手机，平板电脑，笔记本，电视，冰箱，等。 安全—— 在你和应用之间的连接是安全的，可以阻止第三方访问你的敏感数据。 当然，在安装方式上PWA应用与原生app有很大的不同，但是在实际使用上，与原生应用的差距非常小，对于用户来说，几乎是无感的。 核心功能Service-WorkersService Workers是浏览器和网络之间的虚拟代理，运行在一个与页面的 JavaScript 主线程独立的线程上，并且没有对 DOM 结构的任何访问权限，并且可以在不同的上下文之间发送和接收信息。 您可分配给 Service Worker 一些任务，并使用基于 Promise 的方法在任务完成时收到结果。他们不仅仅提供离线功能，还提供包括处理通知，在单独的线程上执行繁重的计算等。Service workers 非常强大，因为他们可以控制网络请求，修改网络请求，返回缓存的自定义响应，或合成响应。因为它们非常强大，所以 Service Workers 只能在安全的上下文中执行（即 HTTPS ）。 注册service worker12345678if ('serviceWorker' in navigator) { // 浏览器支持SW // Service Worker 的注册路径决定了其 scope 默认作用页面的范围。如果存放在网站的根路径下，则将会收到该网站的所有 fetch 事件。如果希望改变它的作用域，可在第二个参数设置 scope 范围 navigator.serviceWorker.register('serviceWorker.js').then(function (registration) { console.log('ServiceWorker注册成功: ', registration.scope); }).catch(function (err) { console.log('ServiceWorker注册失败: ', err); }); } 注册完成后，serviceWorker.js 文件会自动下载，然后安装，最后激活。 service worker中的常用事件 install 123456789101112131415161718var cacheName = 'hello-pwa';// install 事件，它发生在浏览器安装并注册 Service Worker 时 self.addEventListener('install', event =&gt; { // event.waitUtil 用于在安装成功之前执行一些预装逻辑,但是建议只做一些轻量级和非常重要资源的缓存，减少安装失败的概率,安装成功后 ServiceWorker 状态会从 installing 变为 installed event.waitUntil( caches.open(cacheName) .then(cache =&gt; cache.addAll( [ '/', // 这个一定要包含整个目录，不然无法离线浏览 './images/cat2.jpg', './index.html', './style.css' ] // 如果所有的文件都成功缓存了，便会安装完成。如果任何文件下载失败了，那么安装过程也会随之失败。 )).then(() =&gt; self.skipWaiting()) );}); service worker会等到 waitUntil 里面的代码执行完毕之后才开始安装，它返回一个promise。caches 是一个特殊的 CacheStorage 对象，它能在Service Worker指定的范围内提供数据存储的能力。 fetch 每次当我们的应用发起一个http请求时，我们还有一个fetch 事件可以使用。这个事件对我们来说非常有用，它允许我们拦截请求并对请求作出自定义的响应。 1234567891011121314// 为 fetch 事件添加一个事件监听器,service worker将从缓存中请求所需的数据，从而提供离线应用功能self.addEventListener('fetch', function (e) { event.respondWith( // 使用 caches.match() 函数来检查传入的请求 URL 是否匹配当前缓存中存在的任何内容，如果存在的话，返回缓存的资源；如果资源并不存在于缓存当中，通过网络来获取资源，并将资源存储到缓存中。 caches.match(e.request).then(function (r) { return r || fetch(e.request).then(function (response) { return caches.open(cacheName).then(function (cache) { cache.put(e.request, response.clone()); return response; }); }); }) );}); Manifest为了成为可安装网站，需要下列事情就位： 一份网页清单，填好正确的字段 网站的域必须是安全（HTTPS）的 一个本设备上代表应用的图标 一个注册好的service worker，可以让应用离线工作（这仅对于安卓设备上的Chrome浏览器是必需的） 清单文件清单文件通常位于网页应用的根目录，包含一些有用的信息，比如应用的标题，在一个移动OS上显示的代表该应用的不同大小的图标（例如，主屏图标）的路径，和用于加载或启动画面的背景颜色。这些信息是浏览器在安装web应用时和在主屏上显示应用需要的，这些信息是以JSON的形式列出来的。 12345678910111213141516171819202122232425262728{ &quot;name&quot;: &quot;Minimal PWA&quot;, //网站应用的全名 &quot;short_name&quot;: &quot;PWA Demo&quot;, // 显示在主屏上的短名 &quot;description&quot;: &quot;The app that helps you understand PWA&quot;, //一两句话解释你的应用的用途 &quot;display&quot;: &quot;standalone&quot;, // 应用的显示方式：可以是全屏，独立，最小ui或者浏览器 &quot;start_url&quot;: &quot;/&quot;, //应用启动的index文档 &quot;theme_color&quot;: &quot;#313131&quot;, // ui的主题色，这是操作系统使用的 &quot;background_color&quot;: &quot;#313131&quot;, // 背景色，用于安装程序时和启动应用时 &quot;icons&quot;: [ { &quot;src&quot;: &quot;icon/lowres.webp&quot;, &quot;sizes&quot;: &quot;48x48&quot;, &quot;type&quot;: &quot;image/webp&quot; }, { &quot;src&quot;: &quot;icon/lowres&quot;, &quot;sizes&quot;: &quot;48x48&quot; }, { &quot;src&quot;: &quot;icon/hd_hi.ico&quot;, &quot;sizes&quot;: &quot;72x72 96x96 128x128 256x256&quot; }, { &quot;src&quot;: &quot;icon/hd_hi.svg&quot;, &quot;sizes&quot;: &quot;72x72&quot; } ] //一串图标信息——源URL,大小和类型，确保包含一些图标，这样有一个最适合用户设备的图标可以被选中} 一份网页清单最少需要name和一个图标 (带有 src, size 和 type)。description, short_name, 和start_url最好要提供。 扩展以下，过去有一些常用的扩展名用于清单：manifest.webapp 在Firefox OS应用清单中很流行，许多人使用manifest.json作为网页清单因为内容是JSON格式的。但是，.webmanifest 扩展名是在W3C清单规范中显示指定的，建议使用清单文件使用.webmanifest作为后缀 。 添加到主屏“添加到主屏”是移动浏览器实现的一个特性，它利用网页清单中的信息来在设备主屏上显示应用图标和文字。当用户使用一个支持的移动浏览器访问一个PWA时，会显示一个弹框表示可以安装这个应用，用户确认之后应用就被安装到主屏了，用户可以立刻启动并使用应用。在一些浏览器中，可以通过清单信息产生一个启动画面，当PWA启动时显示，图标、主题和背景色用于创建这个启动画面。 在ios上和android手机上打开vue的官网，可以将其添加到设备主屏： ios android Push&amp;NotificationPush&amp;Notification即推送和通知，通过推送API和通知API来实现。 推送可以实现从服务端推送新的内容而不需要客户端发起请求，它是由应用的service worker来实现的。通知功能则可以通过service worker来向用户展示一些新的信息，或者至少提醒用户应用已经更新了某些功能。 这些工作是在浏览器外部实现的，跟service worker一样，所以即使应用被隐藏到后台甚至应用已经被关闭了，我们仍然能够推送更新或者推送通知给用户。 推送API和通知API可以独立工作，也可以结合到一起使用。 通知API——请求授权当用户确定接收通知，我们的应用就可以获得推送通知的功能。用户的授权的结果有三种，default，granted 或者denied，当用户没有做出选择的时候，授权结果会返回defalut，另外两种结果分别是用户选择了授权或者拒绝授权。一旦用户选择授权，这个授权结果对通知API和推送API两者都有效。 1234567891011var button = document.getElementById(&quot;notifications&quot;);console.log(button);button.addEventListener('click', function (e) { Notification.requestPermission().then(function (result) { if (result === 'granted') { // randomNotification(); console.log('授权'); } });}); 推送推送比通知要复杂一些，我们需要从服务端订阅一个服务，之后服务端会推送数据到客户端应用。应用的Service Worker将会接收到从服务端推送的数据，这些数据可以用来做通知推送，或者实现其他的需求，这个技术还处在非常初级的阶段。为了接收到推送的消息，你需要有一个service worker，在service worker 内部，存在一个消息推送服务订阅机制。 1registration.pushManager.getSubscription() .then( /* ... */ ); 一旦用户订阅服务，他们就能接收到服务器推送的通知。为了能够接收到推送的消息，我们需要在Service Worker文件里面监听push事件。 1self.addEventListener('push', function(e) { /* ... */ }); 这个技术还处在非常初级的阶段，从服务端的角度来看，出于安全的目的，这整个过程必须使用非对称加密技术进行加密。而VAPID可以为你的应用提供一层额外的安全保护。 发展趋势既然谈到PWA的发展趋势，就不得不说说它的优势和劣势了。 优势 无需安装，无需下载，只要你输入网址访问一次，然后将其添加到设备桌面就可以持续使用。 发布不需要提交到app商店审核，更新迭代版本不需要审核 现有的web网页都能通过改进成为PWA， 能很快的转型，上线，实现业务、获取流量 不需要开发Android和IOS两套不同的版本 劣势 浏览器对技术支持还不够全面， 不是每一款游览器都能100%的支持所有PWA 需要通过第三方库才能调用底层硬件（如摄像头） PWA现在还没那么火，国内一些手机生产上在Android系统上做了手脚，似乎屏蔽了PWA PWA作为一个2016年才落地的新技术，经过四年的发展，基于 Chromium 的浏览器 Chrome 和 Opera 已经完全支持 PWA 了，随着 iOS 11.3 的发布，iOS正式开始支持PWA，Windows Edge 也支持PWA了。越来越多的游览器大厂，相继的对PWA做出了支持和优化，想必PWA的时代即将到来。 关于PWA，你怎么看呢？","link":"/2020/08/06/PWA-%E4%B8%8B%E4%B8%80%E4%BB%A3%E7%9A%84web%E5%BA%94%E7%94%A8%E6%A8%A1%E5%9E%8B/"},{"title":"Vue组件开发及NPM发布（TS版）","text":"1 创建项目123npm install -g @vue/cli // 安装Vue命令行工具，最新为vue create vue-components-ts // 项目名称自取,使用TS来开发项目 2 修改项目结构 将 src 文件夹改为 examples 作为组件的示例展示 删除 src 中的 assets，components 文件夹 将 public 中的 index.html 移入 examples 文件夹后，删除 public 文件夹 在项目根目录下，新增: components 文件夹：用于存放组件源码及导出文件 types 文件夹：用于添加 TypeScript 的类型定义文件 vue.config.js：用于修改默认的构建配置 .npmignore 文件：设置要忽略发布的文件 最终项目主要结构如下： 123456789101112131415161718192021├── components│ ├── category-name // 分类名（可选，如ECharts）│ │ ├── component-name // 单个组件│ │ │ ├── index.ts // 对外提供对组件的引用│ │ │ └── component-name.vue│ └── index.ts // 所有组件的导出文件├── examples│ ├── router│ │ ├── index.ts // 各个组件示例的路由│ ├── views│ │ ├── category-name // 分类名（可选，如ECharts）│ │ │ │── component-name // 单个组件│ │ │ │ └── component-name.vue // 封装组件的示例│ ├── App.vue│ ├── index.html│ └── main.ts // 导入所有的组件├── types // 类型定义文件夹│ └── index.d.ts // 所有组件类型的导出文件├── package.json├── README.md└── vue.config.js 3 修改构建配置3.1 添加vue.config.js12345678910111213141516171819module.exports = { // 修改 src 目录 为 examples 目录 pages: { index: { // page 的入口 entry: 'examples/main.ts', // 模板来源 template: 'examples/index.html', // 在 dist/index.html 的输出 filename: 'index.html', }, }, // 扩展 webpack 配置 chainWebpack: (config) =&gt; { // 没有任何具名导出并直接暴露默认导出 config.output .libraryExport('default'); },}; 3.2 修改package.json123456789101112131415name: 包名，该名不能和NPM中已有的名称冲突；version: 版本号，不能和当前包的历史版本号相同；description: 简介；keyword：关键字，以空格分割，方便别人搜索到本模块author：作者；private：是否私有，需要修改为 false 才能发布到 npm；license：开源协议main: 入口文件，应指向编译后的包文件； 123456789101112131415{ &quot;name&quot;: &quot;ths-vue&quot;, &quot;version&quot;: &quot;0.2.5&quot;, &quot;private&quot;: false, &quot;description&quot;: &quot;基于Vue的业务组件库&quot;, &quot;main&quot;: &quot;./dist/ths-vue.umd.min.js&quot;, &quot;author&quot;: &quot;ths-fe &lt;zapzqc@qq.com&gt;&quot;, &quot;license&quot;: &quot;MIT&quot;, &quot;keyword&quot;: [ &quot;ths&quot;, &quot;vue&quot;, &quot;components&quot; ], &quot;typings&quot;: &quot;types/index.d.ts&quot;,} 在scripts中添加： 123456&quot;scripts&quot;: { &quot;serve&quot;: &quot;vue-cli-service serve&quot;, &quot;build&quot;: &quot;vue-cli-service build&quot;, &quot;lint&quot;: &quot;vue-cli-service lint&quot;, &quot;lib&quot;: &quot;vue-cli-service build --target lib --name ths-vue ./components/index.ts&quot;}, –-target : 构建目标，默认为应用模式这里修改为 lib 启用库模式 –name : 输出文件名称 –-dest : 输出目录，默认 dist，这里没有设置 3.3 修改.npmignore1234567891011121314151617# 忽略目录examples/examples/node_modules/# 忽略指定文件*.map.browserslistrc.editorconfig.eslintrc.jsbabel.config.jspackage-lock.jsontsconfig.jsonyarn.lockvue.config.js# 编辑器缓存文件.idea.vscode 4 构建并发布*4.1 构建生成组件库： 1npm run lib 实现对 examples 中应用的访问： 1npm run serve 4.2 发布首先需要在 npm 官网上注册一个账号，通过: 1npm adduser 命令创建一个账户，或者在 npm 官网注册。 注册完成后在本地命令行中登录： 1npm login 输入用户名、密码、邮箱： 执行发布命令，发布到 npm： 1npm publish 如果以前改过 npm 的镜像地址，比如使用了淘宝镜像，就先改回来： 1npm config set registry http://registry.npmjs.org 5 新增组件* 在components文件夹下创建新组件命名的文件夹，其中包含新组件的单文件组件.vue和一个导出文件index.ts。 1234567import 新的组件名 from './新的单文件组件名.vue';新的组件名.install = (Vue) =&gt; { Vue.component(新的组件名.name, 新的组件名);};export default 新的组件名; 在components文件夹下的所有组件的入口文件index.js中添加 12345678// 在下方导入新增组件import 新的组件名 from './新的单文件组件名';// 存储组件列表const components = { // 在下方添加新增组件 新的组件名,}; 在types文件夹下创建新组件的d.ts文件 123import { TUIComponent } from './component';export declare class 新的组件名 extends TUIComponent { } 测试组件 在examples的main.js中导入组件，并use。 待补充 在App.vue的模板中使用： 待补充 运行： 1npm run serve 6 使用组件库*ths-vue 是基于思路前端设计理念的 Vue UI 组件库，主要用于研发企业级前端产品。 特性 提炼自企业前端产品的交互语言和视觉风格。 开箱即用的高质量 Vue 组件。 支持环境 现代浏览器和 IE9及以上（需要 polyfills） 支持服务端渲染 Electron IE/Edge Firefox Chrome Safari Opera ) Electron IE9, IE10, IE11, Edge last 2 versions last 2 versions last 2 versions last 2 versions last 2 versions 兼容性 ths-vue 支持所有的现代浏览器和 IE9+。 对于 IE系列浏览器，需要提供 es5-shim 和 es6-shim 等Polyfills 的支持。 如果你使用了babel，强烈推荐使用 babel-polyfill 和 babel-plugin-transform-runtime 来替代以上两个shim。不要同时使用 babel 和 shim 两种兼容方法。 安装使用 npm 或 yarn 安装推荐使用 npm 或 yarn的方式进行开发，不仅可在开发环境轻松调试，也可放心地在生产环境打包部署使用，享受整个生态圈和工具链带来的诸多好处。 123npm install ths-vue --saveyarn add ths-vue 如果网络环境不佳，推荐使用 cnpm。 完整引入在 main.js 引入并注册： 12345import Tvue from 'ths-vue';import 'ths-vue/dist/ths-vue.css';Vue.use(Tvue); 在组件中使用： 1234567891011&lt;template&gt; &lt;HelloWorld&gt;&lt;/HelloWorld&gt;&lt;/template&gt;&lt;script&gt; export default { data () { return { } } }&lt;/script&gt; 按需引入使用 babel-plugin-import，在命令行中运行： 1npm i babel-plugin-import --save-dev 修改babel.config.js： 12345678910111213presets: [ '@vue/cli-plugin-babel/preset', ],plugins: [ ['import', { libraryName: 'ths-vue', libraryDirectory: 'components', }, 'ths-vue', ], ], 在main.ts中： 123import { HelloWorld } from 'ths-vue';Vue.use(HelloWorld); 7 注意事项组件必须声明 name 属性，这个 name 就是组件的 HTML 标签。","link":"/2020/08/20/Vue%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91%E5%8F%8ANPM%E5%8F%91%E5%B8%83%EF%BC%88TS%E7%89%88%EF%BC%89/"},{"title":"CSS编码规范","text":"1、文件命名 采用 HTML 命名规则。 2、选择器 尽量少用通用选择器 *。 禁止使用 ID 选择器编写样式。 尽可能避免使用属性选择器（例如，[class^=”…”]）。属性选择器相较其他选择器对浏览器的性能消耗是巨大的。 属性选择器必须使用双引号。 3、属性的顺序 顺序：定位 &gt; 盒模型 &gt; 文字 &gt; 其他内部属性 &gt; 其他 CSS3 属性。 1234567891011121314定位属性z-index，position，float，top，right，bottom，left盒模型属性width，height，padding，margin，border文字属性font-\\*，line-height，text-align，text-decoration....其他内部属性overflow，opacity，cursor....其他 css3 属性animation，transition，transform.... 4、代码编写规范 统一使用两个空格进行代码缩进，使得各编辑器表现一致（各编辑器有相关配置）。 每个属性声明末尾都要加分号。 左括号与类名之间一个空格，冒号与属性值之间一个空格。 逗号分隔的取值，逗号之后一个空格。 每个选择器单独占一行。 颜色值 rgb() rgba() hsl() hsla() rect() 中不需有空格，且取值不要带有不必要的 0。 属性值十六进制数值能用简写的尽量用简写。 不要为 0 指明单位。 可简写的属性设置多值时，尽量使用简写语法。 可简写的属性设置单值时，尽量不使用简写语法。 尽量不要在 CSS 中使用!important。 url()中的路径不添加引号。 避免使用标签选择器编写样式。 123456789.fs,.fc { display: block; width: 50px; box-shadow: 1px 1px 1px #333, 2px 2px 2px #ccc; color: rgba(255,255,255,.5); background: #fff; margin: 0;} 5、浏览器私有前缀的写法 CSS3 浏览器私有前缀在前，标准前缀在后。 1234567.fs { -webkit-border-radius: 10px; -moz-border-radius: 10px; -o-border-radius: 10px; -ms-border-radius: 10px; border-radius: 10px;} 6、注释 注释内容第一个字符和最后一个字符都是一个空格字符，单独占一行。 12/* Comment Text */.fs{} 不同人编写的 css 应该加上对应的注释，注明页面说明、作者、日期等信息。 1234567891011/** * @description 说明 * @author 作者 * 修改者（多个人） * @date 2015-10-10 最后的修改时间 */ 7、重置标签的默认样式 因为不同浏览器对有些标签的默认值是不同的，如果不对 css 初始化往往会出现浏览器之间的页面显示差异，为了让各个浏览器的 CSS 样式有一个统一的基准，使 HTML 元素样式在跨浏览器时有一致性的效果，所以需要重置 css 的默认样式。（以下代码，在使用 fbi 创建项目时会自动生成） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* 清除默认样式 */* { -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box;}html,body { padding: 0; margin: 0; font-family: 'Microsoft yahei';}ul,ol,li,span,p,h1,h2,h3,h4,h5,h6,a,dl,dt,dd,input { padding: 0; margin: 0; list-style: none; text-decoration: none; font-weight: normal; font-style: normal; font-family: 'Microsoft yahei'; font-size: 14px;}a { cursor: pointer;}img { vertical-align: middle; border: 0;}","link":"/2020/08/28/CSS%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"},{"title":"HTML编码规范","text":"1、文件命名 文件名不得包含空格和特殊字符。 文件名统一使用小写字母(为了醒目，某些说明文件的文件名，可以使用大写字母，比如 README、LICENSE )。 文件名包含多个单词时，单词之间以中划线 ( - ) 分隔。 入口文件使用 index 命名（比如 index.html、index.asp、index.jsp）。 命名的原则是语义化，方便理解，见名知意。 外部插件建议放在 modules 目录里，组件建议放在 components 目录里，不要全都放到 js 文件夹中。 使用统一的自动化工具构建页面结构。 123npm install -g tfbifbi init 项目名称 2、DOCTYPE 声明 为了确保在每个浏览器中拥有一致的展现效果，HTML 文件必须加上 DOCTYPE 声明，并统一使用 HTML5 的文档声明。 1&lt;!DOCTYPE html&gt; 3、页面语言 LANG 强烈建议为 html 根元素指定 lang 属性，从而为文档设置正确的语言。这将有助于语音合成工具确定其所应该采用的发音，有助于翻译工具确定其翻译时所应遵守的规则等等。 1&lt;html lang=&quot;zh-cmn-Hans&quot;&gt; 4、文档编码 为了防止文档在不同浏览器下出现乱码的问题，统一只用 utf-8 编码。 1&lt;meta charset=&quot;UTF-8&quot;&gt; 5、命名风格 HTML 标签名、ID 名、类名、标签属性和大部分属性值统一用小写，用中划线链接。 ID 名是唯一的，一般写在最外层元素上，禁止使用 ID 写 css 样式。 对于引号的运用，必须使用双引号，禁止使用单引号。 避免过度任意的简写，.btn 代表 button，但是 .b 不能表达任何意思。 使用 .js-* 来标识行为，并且不要将这些 class 写到 CSS 文件中(加具体的事件名)。 嵌套标签建议基于最近的父 class 或规定关键字作为新 class 的前缀。 123&lt;div class=&quot;demo&quot;&gt; &lt;div class=&quot;demo-info&quot;&gt;&lt;/div&gt;&lt;/div&gt; 6、标签 每个标签都有自己的定义，HTML 中必须使用语义化标签，禁止一直使用一类标签。 HTML 中使用双闭合标签时标签必须闭合，使用单闭合标签时尾部不加斜杠。 行内元素不要嵌套块级元素。p 标签中是不能嵌套块级元素的，浏览器会解析为两个独立的标签。 使用 img 标签时，建议定义好图片的尺寸，在加载时可以预留指定空间，减少闪烁。 7、关于 JS 和 CSS 根据 HTML5 规范，在引入 CSS 和 JavaScript 文件时一般不需要指定 type 属性，因为 text/css 和 text/javascript 分别是它们的默认值。这一点在老旧浏览器上也是支持的。 引入 JS 时 script 标签如无特殊情况统一放在 body 结束标签的前面，引入 CSS 时 link 标签统一放在 head 结束标签的前面，因为浏览器生成 Dom 树的时候是一行一行读 HTML 代码的，link 标签放在最后页面会出现短暂无样式的效果，script 标签放在最后面就不会影响前面的页面的渲染。 原则上禁止在 HTML 中编写 JS 代码，禁止在 HTML 中编写内联样式。 8、注释 HTML 中必要时增加注释代码。 注释内容前后各一个空格字符，注释位于要注释代码的上面，单独占一行。 123&lt;!-- Comment Text --&gt;&lt;div&gt;...&lt;/div&gt; 9、代码格式化 统一使用两个空格进行代码缩进，使得各编辑器表现一致（各编辑器有相关配置）（浏览器的配置文件）。 嵌套元素必须缩进一次（两个空格）。 元素嵌套时，每个块状元素独立一行，内联元素可选。","link":"/2020/08/28/HTML%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"},{"title":"从零创建Cordova插件-入门","text":"l 介绍本文将细致讲解cordova插件的创建、编写、配置、发布，涉及aar+jar+so、静态资源、四大组件等。 l 环境准备1.node 2.ionic 3.cordova 4.plugman plugman是用于安装和卸载用于Apache Cordova项目的插件的命令行工具,安装plugman 1$ npm install -g plugman 5.AndroidStudio l 一切都要从一个简单cordova插件开始l 创建ionic项目用于测试cordova的插件 1ionic start CordovaProject blank 此时cordovaProject下会生成如下结构 在添加platforms和plugins之后，可以在此目录下打包 1CordovaProject$ cordova build android l 创建插件创建一个最简单的Toast插件1plugins$ plugman create --name ThsToast --plugin_id cordova-plugin-ths-toast --plugin_version 1.0.0 创建插件的完整模版：为了方便在插件开发过程中进行测试，将插件创建在 cordovaPluginProject 项目目录下的 plugins 文件夹下 plugman platform add 创建ThsToast插件的平台基础代码进入具体的插件目录下，创建插件安卓和iOS平台基础代码 12cordova-plugin-ths-toast$ plugman platform add --platform_name androidcordova-plugin-ths-toast$ plugman platform add --platform_name ios 添加之后将在cordova-plugin-ths-toast目录下产生android和ios两个目录,生成的java文件内容如图所示 重命名ThsToast插件目录名称（可选）接着手动将ThsToast目录重命名为和上述plugin_id一样的值：cordova-plugin-ths-toast，命名方式和cordova插件命名规范保持一致，ths是公司的统一标识，通常是英文字符串 重命名ThsToast插件目录下android目录java代码中的package包名和api方法名需要将默认的包名改为[反向域值].cordova.[插件name]**，要注意的是，plugin.xml中配置的java文件target-dir输出目录需要和这里包名目录匹配**，如plugin.xml 1&lt;source-file src=&quot;src/android/ThsToast.java&quot; target-dir=&quot;src/org/apache/cordova/thstoast&quot; /&gt; 注意：起名不要和安卓原生方法冲突了，比如这里ThsToast如果改成Toast，就会和android.widget.Toast中的Toast类重名，主要是区分是系统的还是公司的插件 l 插件配置ThsToast插件目录下的plugin.xml配置js调用方法名和资源文件输出路径添加完平台后，cordova-plugin-ths-toast 目录下的 plugin.xml 文件将添加如下内容修改 plugin.xml 文件内容如下 1234567891011121314151617181920212223242526272829&lt;?xml version='1.0' encoding='utf-8'?&gt;&lt;plugin id=&quot;cordova-plugin-ths-toast&quot; version=&quot;1.0.0&quot; xmlns=&quot;http://apache.org/cordova/ns/plugins/1.0&quot; xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;name&gt;Toast&lt;/name&gt; &lt;js-module name=&quot;ThsToast&quot; src=&quot;www/ThsToast.js&quot;&gt; &lt;!-- target修改, 通过window.ThsToast.show或ThsToast.show即可调用api --&gt; &lt;clobbers target=&quot;ThsToast&quot; /&gt; &lt;/js-module&gt; &lt;platform name=&quot;android&quot;&gt; &lt;config-file parent=&quot;/*&quot; target=&quot;res/xml/config.xml&quot;&gt; &lt;feature name=&quot;ThsToast&quot;&gt; &lt;!-- param value修改，[包名].[文件名] --&gt; &lt;param name=&quot;android-package&quot; value=&quot;cn.com.ths.thstoast.ThsToast&quot; /&gt; &lt;/feature&gt; &lt;/config-file&gt; &lt;config-file parent=&quot;/*&quot; target=&quot;AndroidManifest.xml&quot; /&gt; &lt;!-- target-dir修改，最终打包出的java文件完整目录路径 --&gt; &lt;source-file src=&quot;src/android/ThsToast.java&quot; target-dir=&quot;src/cn/com/ths/thstoast&quot; /&gt; &lt;/platform&gt; &lt;platform name=&quot;ios&quot;&gt; &lt;config-file parent=&quot;/*&quot; target=&quot;config.xml&quot;&gt; &lt;feature name=&quot;ThsToast&quot;&gt; &lt;param name=&quot;ios-package&quot; value=&quot;ThsToast&quot; /&gt; &lt;/feature&gt; &lt;/config-file&gt; &lt;source-file src=&quot;src/ios/ThsToast.m&quot; /&gt; &lt;/platform&gt;&lt;/plugin&gt; ThsToast插件目录下的www/xxx.js 修改js api对象和调用函数修改exports处理逻辑，增强可读性（可选) 暴露给js的api方法名通过plugin.xml配置www/xxx.js中export的ThsToast在plugin.xml中是通过clobbers的target值暴露给js调用的，如果target值改为toast，通过target.show即可调用插件api 1234&lt;js-module name=&quot;ThsToast&quot; src=&quot;www/ThsToast.js&quot;&gt; &lt;!-- 通过window.ThsToast.show或ThsToast.show即可调用api --&gt; &lt;clobbers target=&quot;ThsToast&quot; /&gt;&lt;/js-module&gt; exec函数干了什么www/xxx.js中的exec函数可以理解为java中暴露给js的回调方法，用于触发java的excute方法，该js函数传的’show’和[arg0]，success,error参数将会以action和args，callbackContext.success，callbackContext.error参数的形式传入java中的excute方法 1234@Override public boolean execute(String action, JSONArray args, CallbackContext callbackContext) throws JSONException { …… } l 在ThsToast插件根目录里写好README，小盆友看了也会用1cordova-plugin-ths-toast$ touch README.md 一个简单模版 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788# cordova-plugin-ths-toast弹出提示框 cordova插件## 支持平台Android## 安装插件|```# 通过npm 安装插件cordova plugin add cordova-plugin-ths-toast# 通过github安装cordova plugin add https://github.com/THS-FE/cordova-plugin-ths-toast# 通过本地文件路径安装cordova plugin add 文件路径|```**说明： ionic 项目命令前加上ionic，即ionic cordova plugin xxxxx**参数说明：1. DEFAULT_DELAY 默认提示框延迟弹出的毫秒数## 配置文件修改在config.xml文件中 **platform name=&quot;android&quot;** 节点下添加以下配置|```xml&lt;preference name=&quot;DEFAULT_DELAY&quot; value=&quot;1000&quot;/&gt;|```## 使用方法显示提示框|```javascript /** * 显示提示框 * @param text 显示文字 * @param success 成功的回调函数 */ showToast(text, success) { try { ThsToast.show(text, success, err =&gt; { console.log('err', err); this.commUtilProvider.showToast('显示提示框失败'); }) } catch (err) { console.log(err); } };|```隐藏提示框|```javascript /** * 隐藏提示框 * @param success 成功的回调函数 */ hideToast(success) { try { ThsToast.hide(success, err =&gt; { console.log('err', err); this.commUtilProvider.showToast('隐藏提示框失败'); }) } catch (err) { console.log(err); } };|```**说明：使用ts 进行开发时，需要在文件上变声明下declare const ThsToast;**|```typescriptimport { Component, OnInit, Input } from '@angular/core';declare const ThsToast;@Component({ selector: 'app-explore-container', templateUrl: './explore-container.component.html', styleUrls: ['./explore-container.component.scss'],})|```## 常见错误后续更新|``` l 给ThsToast插件加上package.json，准备发布到npm进入ThsToast插件根目录下 第一种方式：npm init 1cordova-plugin-ths-toast$ npm init 第二种方式：plugman createpackagejson（推荐） 1cordova-plugin-ths-toast$ plugman createpackagejson ./ 上面的命令都将创建一个 package.json 文件，但第二种方式相对于npm init的优点是会生成”cordova”和”keywords”两个属性。 “cordova”用于说明插件支持的平台，”keywords”规定可以在cordova官网通过关键字搜索到该cordova插件，”engines”表示插件依赖的各平台版本号，详细内容请参考cordova创建插件 123456789101112131415161718192021222324252627{ &quot;name&quot;: &quot;cordova-plugin-ths-toast&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;cordova&quot;: { &quot;id&quot;: &quot;cordova-plugin-ths-toast&quot;, &quot;platforms&quot;: [ &quot;android&quot;, &quot;ios&quot; ] }, &quot;keywords&quot;: [ &quot;ecosystem:cordova&quot;, &quot;cordova-android&quot;, &quot;cordova-ios&quot;, &quot;toast&quot;, &quot;cordova-plugin-ths-toast&quot; ], engines: { cordovaDependencies: { &quot;1.0.0&quot;: { &quot;cordova-android&quot;: &quot;&gt;4.0.0&quot; }, &quot;&gt;1.0.0&quot;: { &quot;cordova-android&quot;: &quot;&gt;5.0.0&quot; } } }, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;} 注意：** “name”属性表示插件在npm仓库中的唯一id，”cordova”中的”id”必须和name保持一致，因为要通过此id才能找到具体哪个插件的平台支持**， 比如安装时就是通过name的值在npm仓库中查找对应插件并安装： 1cordova plugin add cordova-plugin-ths-toast 这里可以搜索keywords中的插件 l 发布插件到git上传到公司仓库: https://github.com/THS-FE 注意github地址一定要发布到公司git仓库，不然无法修改和维护源代码 l 发布插件到npm每次发布记得更新版本号，不然无法发布 12cordova-plugin-ths-toast$ npm login // 没有账号则需要到官网申请，登录过一次后就不用登了cordova-plugin-ths-toast$ npm publish l 安装插件1cordova plugin add cordova-plugin-ths-toast l 使用插件js环境 1ThsToast.show() ts环境 12declare const ThsToast;ThsToast.show() l 插件效果演示","link":"/2020/08/31/%E4%BB%8E%E9%9B%B6%E5%88%9B%E5%BB%BACordova%E6%8F%92%E4%BB%B6-%E5%85%A5%E9%97%A8/"},{"title":"JavaScript新特性","text":"1 前言我这里总结了一下ES6+中，一些比较实用的新特性。我们日常开发应该尽快使用这些新特性，能极大地提高我们的开发效率。 我刚开始实习的时候，对ES6都不太怎么了解，工作后学习并渐渐运用起来，越用越爽，两个字：简洁方便高效。 提一句：只要用了babel，所有的新特性请放心大胆地用。 2 你得尽快用上的“新特性” 为什么加引号，因为现在这些都不是多新的特性了，ES6是2015年就出了，到现在已经5年了。 2.1 模板字符串模版字符串：用 `（反引号）标识，用 ${} 将变量括起来 old： 场景：通常我们在自定义一些echarts或者地图上添加东西时，我们常会拼接一些html代码 1var html = '&lt;div style=&quot;color: ' + color + ';&quot;&gt;' + str + '&lt;div&gt;' 传统做法需要使用大量的“”（引号）和 + 来拼接才能得到我们需要的模版 new： 1let html = `&lt;div style=&quot;color: ${color} ;&quot;&gt; ${str} &lt;div&gt;` ${} 里可以放任意的JavaScript表达式，也可以调用函数： 123456789const count = 8, price = 10;console.log(`加购一个后数量：${++count}, 总价：${count*price}`); // 加购一个后数量：9, 总价：90console.log(`输出个字符串：${'cool'}`); // 输出个字符串：coolfunction myLove() { return &quot;as you love!&quot;;}console.log(`I love ${myLove()}`); // I love as you love! 需要注意的几个问题： 当需要在字符串里使用反引号的时候，需要转义； 1console.log(`模版字符串：用 \\`（反引号）标识`); 如果${}中的变量不是字符串类型，那么会按照一般的规则转化为字符串； 12const obj = {a:1, b:2};console.log(`a = ${obj}`); // a = [object Object] 模板字符串会保留所有的空格、缩进和换行； 12345let str = `I know , you know!`;console.log(str);// I know // , you know! 解决方案：使用\\解决换行符；使用+换行拼接；使用正则替换；使用变量替换； 1234567891011121314151617let str = `I know \\ , you know!`;console.log(str); // I know , you know!str = `I know ` + `, you know!`;console.log(str); // I know , you know!str = (`I know , you know!`).replace(/\\s+/gm, ' ');console.log(str); // I know , you know!const N = '';str = (`I know${ N}, you know${ N}, all we know!`);console.log(str); // I know, you know, all we know! 扩展了解： 实现原理（未验证）：通过正则匹配，替换原字符串中的变量。包括常见的{{}}, &lt;%=xx%&gt;等 12345function replace(str){ return str.replace(/\\$\\{([^}])\\}/g,function(matched,key){ return eval(key) })} 2.2 属性简写old： 一个属性名对应一个值 12345const pageNum = 0, pageSize = 10;const params = { pageNum: pageNum, pageSize: pageSize} new： 属性名和变量名保持一致，变量名尽量迎合属性名； 12345678910const pageNum = 0, pageSize = 10, password = '123123';const params = { pageNum, pageSize, password: encrypt(password) // 属性简写和键值对可以混写}// const params = {// pageNum: pageNum,// pageSize: pageSize// } question： 如果我们的需要的值不是一个单独变量，而是从某个对象取出属性 123456const pageNum = 0, pageSize = 10, user = {uid: 100000, password: '123123'};const params = { pageNum, pageSize, user.password ????} 答案：见 4.答案 2.3 方法属性old： 一个属性名对应一个值 12345let math = { add: function(a,b) { return a + b; }, sub: function(a,b) { return a - b; }, multiply: function(a,b) { return a * b; }} new： 自动识别方法名称作为属性名 12345let math = { add(a,b) { return a + b; }, sub(a,b) { return a - b; }, multiply(a,b) { return a * b; }} 取函数名为属性名称 微信小程序page结构： 1234567891011121314151617Page({ data: { isShowloading: true }, onLoad(options) { }, onReady() { }, handleTap(event) { }})// 给page传入一个对象，这个对象的所有函数都可以进行属性名简写 question: 下面两个表达式都正确吗？ 1234567let obj1 = { fn1(){}.bind() }let obj2 = { fn2: function(){}.bind() } 2.4 箭头函数箭头函数表达方式：=&gt;，因为像个箭头，所以叫箭头函数。 old： 123var f = function (v) { return v;}; new： 12345// 写法let f = v =&gt; v;// 完整写法let f = (v) =&gt; { return v; }; 如上，当函数只有一个形参时，=&gt;左侧可以省略()； 当函数返回值可以用一句简单表达式表示时，=&gt;右侧可以省略{}和return； 1234567let f = () =&gt; 5; // ()不可省略let sum = (num1, num2) =&gt; num1 + num2;//var sun = function(num1, num2){return num1 + num2;};this.httpUtil.get('xxxxxx.vm', params, true, res =&gt; { console.log(res)}); question: 以下会输出什么？ 12let getTempItem = () =&gt; { id: 's8309a82n', name: &quot;Temp&quot; };getTempItem(); 2.5 “你懂的”运算符Spread operator，这个中文名称有好几种说法（扩展运算符、延展操作符、展开运算符等等），而我给它起的名字就叫你懂的运算符。它表示方法前面见过了...，作用是可以将数组、字符串、对象等在语法层面上展开。 秘诀：给我“解压”到这里 “解压”数组 12345678const rgb = ['red', 'green', 'blue'];const colors = [...rgb]; // 巴啦啦魔仙变，给我把rgb解压到这个数组里// 结果： ['red', 'green', 'blue']const colorList = ['yellow', ...rgb]; // ['yellow', 'red', 'green', 'blue']console.log([...colors, ...colorList]); // ???? “解压”对象 123456789let you = { name: 'DJ', age: 16}you = { ...you, school: 'DLPU'}// {name: &quot;DJ&quot;, age: 16, school: &quot;DLPU&quot;} “解压”字符串 1234567let myCountry = 'China';console.log([...myCountry]); // [&quot;C&quot;, &quot;h&quot;, &quot;i&quot;, &quot;n&quot;, &quot;a&quot;]// 等同于：console.log(myCountry.split(''))cosnt resStr = {...myCountry};console.log(resStr); // {0: &quot;C&quot;, 1: &quot;h&quot;, 2: &quot;i&quot;, 3: &quot;n&quot;, 4: &quot;a&quot;}// 问题：怎么取值呢？ resStr[0] question: 以下分别会输出什么？ 123456789let obj = {a: 1, b: 2};console.log({a: 0, ...obj}); ????let arr = [2,3,4];console.log({...arr})????console.log([...obj]);???? 扩展了解：见下一章 2.6 解构赋值old: 获取对象中的值 123456789// res = {status: 200, data: {uid: 'ed9fa0', name: 'DJ', time: '1596808152'}}this.thsService.getLog().then(res=&gt;{ const status = res.status; const data = res.data; const name = res.data.name; const time = res.data.time; console.log(status, data, name, time);}) new: 123456789101112this.thsService.getLog().then(res=&gt;{ const { status, data } = res; const { status, data, data: { name, time } } = res; // console.log(status, data, name, time);})// 还可以这样写this.thsService.getLog().then({ status, data }=&gt;{ console.log(status, data);}) 数组： 123let arr = [1, 2, 3, 4];let [a, b, c] = arr; // a=1, b=2, c=3let [a, b, , d] = arr; // a=1, b=2, d=4 默认值： 12const { status = 500, data = null } = res;let [a=0, b=0, c=0, d=0, e=0] = arr; 扩展了解： 剩余运算符（ES2018） 秘诀：“剩下的”都是我的 “剩下的”属性 1234let obj = {a: 1, b: 2, c: _ =&gt; _};let {b, ...rest} = obj; // rest说：b属性你拿走吧，剩下的全是我的b // 2rest // {a: 1, c: ƒ} “剩下的”参数 12345let restParam = (p1, p2, ...p3) =&gt; { // p3说：前两个参数你们拿走，剩下的都是我的了 console.log(p1, p2, p3);};restParam(1,2,3,4,5); // p1 = 1, p2 = 2, p3 = [3, 4, 5] 2.7 数组新方法 find(): any：返回找到满足条件的第一项，否则返回undefined findIndex(): number：找到满足条件的一项的索引 includes(): boolean：是否包含一个值 在ES6之前，要判断一个数组中是否包含一个元素，是通过indexOf()返回不等于-1 ES6之后，相继扩充一些方法： find( fn(item, [index], [arr]) ): 1234let arr = [{ id: 1, checked: true }, { id: 2 }, { id: 2 }, 3, 4, NaN];arr.find( item =&gt; item.id === 1 ); // { id: 1, checked: true }arr.find( item =&gt; Object.is(NaN, item) ); // NaN find会将每一个元素挨个去运行回调函数，找到了第一项之后就不会再执行了； findIndex( fn(item, [index], [arr]) ): 12arr.findIndex( item =&gt; item.id === 1 ); // 0arr.findIndex( item =&gt; Object.is(NaN, item) ); // 5 includes(value, fromIdx): 12345678arr.includes(3); // truearr.includes(NaN); // truearr.includes({ id: 2 }) // falselet a1 = {id: 2}, a2 = {id: 2};a1 == a2; // falselet a = [a1, a2]; // [{id: 2}, {id: 2}]a.includes(a2); // true 字符串同样存在includes方法：'Made in China'.includes('o'), false some( fn(item, [index], [arr]) )：是否存在满足条件的一项，和includes是同样的作用。 区别（优缺点）：some传入的是回调函数，具有更强大的可操性；includes传入参数是具体的值，书写简便。 question: find()只能取出满足条件的一项，那如何取出数组中满足条件的所有项呢？ 12let arr = [{ id: 1, checked: true }, { id: 2 }, { id: 2 }, 3, 4, NaN];// ???? 扩展：数组所有方法参考手册 2.8 Promise、async/await 回调地狱：“无限”（大量）地使用嵌套回调函数，好像掉进了18层地狱 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 一个动画的回调地狱例子animate(ball1, 100, function () { animate(ball2, 200, function () { animate(ball3, 300, function () { animate(ball1, 200, function () { animate(ball3, 200, function () { animate(ball2, 180, function () { animate(ball2, 220, function () { animate(ball2, 200, function () { console.log(&quot;over&quot;); }) }) }) }) }) }) })});// promise优化后promiseAnimate(ball1, 500) .then(function () { return promiseAnimate(ball2, 200); }) .then(function () { return promiseAnimate(ball3, 300); }) .then(function () { return promiseAnimate(ball1, 200); }) .then(function () { return promiseAnimate(ball3, 200); }) .then(function () { return promiseAnimate(ball2, 180); }) .then(function () { return promiseAnimate(ball2, 220); }) .then(function () { return promiseAnimate(ball2, 200); })// async/await优化后async play() { await animate(ball1, 500); await animate(ball2, 200); await animate(ball3, 300); await animate(ball1, 200); await animate(ball4, 200); await animate(ball2, 180); await animate(ball2, 220); await animate(ball2, 200);} Promise: 基本用法： 12345678910111213141516171819202122232425262728293031function getUserData() { return new Promise((resolved, rejected) =&gt; { $.ajax({ type : &quot;get&quot;, url : &quot;api.com&quot;, success : res =&gt; { if(res.isSuccess) { resolved(res.data); }else { rejected({msg: '服务器错误', info: res.errmsg}); } }, error: err =&gt; { rejected({msg: '网络错误', info: err}); } }); })}getUserData().then(data =&gt; { console.log('success:', data);}).catch(err =&gt; { console.log(err.msg, err.info);})// 此外介绍一个方法，并行跑promise es2020有个新方法Promise.allSettledPromise.all([promise1, promise2, ...]).then(res =&gt; { console.log(res); // 由promise1,promise2正确执行结果组成的数组}).catch(err =&gt; { console.log(err);}) async/await： 是对Promise的优化，为Promise服务。一句话：用同步的风格写异步代码。 基础用法：https://patrick.js.org/post/1589841597 需要注意： async/await 就是一对“海尔兄弟”，缺一不可。async声明一个函数（函数返回会处理成一个Promise），函数里面必须要有await，await标识一个需要等一会（异步）的操作。函数内部使用了await，那么该函数就必须用async声明。 await、return和return await的陷阱：https://jakearchibald.com/2017/await-vs-return-vs-return-await/ 2.9 Modules模块化是ES6比较重要的特性，在此之前JS是不支持原生的模块化的，需要通过第三方库实现如RequireJS。 了解更多模块化：JavaScript模块化 模块化由export 和 import 组成，ES6视一个文件为一个模块，文件内通过export对外暴露接口，其他文件通过import引入使用。 export：可导出变量、常量和函数 12345678910111213141516171819// utils/test.js// 单个导出export let name = 'Patrick Jun';export const pi = Math.PI;export function whoIAm() { console.log(&quot;I'm a FE coder!&quot;);}// 等同于（会将export作为一个对象导出）let name = 'Patrick Jun';const pi = Math.PI;const whoIAm = () =&gt; console.log(&quot;I'm a FE coder!&quot;);export { name, pi, whoIAm };// this is an object, so.export { name: name, PI: pi, iAm: whoIAm }; import：导入 123456// home.jsimport { name, pi, whoIAm } from './utils/test.js';console.log(name, pi);whoIAm();// Patrick Jun 3.141592653589793 main.js:2 // I'm a FE coder! test.js:11 node无法直接运行module：https://nodejs.org/dist/latest-v10.x/docs/api/esm.html default：只能有一个 123456789// math.jsexport function add(a,b) { return a + b; };export function sub(a,b) { return a - b; };export default (a,b) =&gt; a * b;// main.jsimport mult, { add, sub } from './math'; 3 你可以尝试的新特性3.1 对象新方法 Object.values(obj): 返回由对象中属性值组成的数组； Object.entries(obj): 返回对象的每个属性名和所对应的值组成的数组：[[key, value],[key, value]] 之前通过Object.keys()，可以获取到对象的所有的key，而要获得所对应的值的时候： 123456let obj = {id: 1, value: '123', data: {code: 'EC109'}};Object.keys(obj); // [&quot;id&quot;, &quot;value&quot;, &quot;data&quot;]Object.keys(obj).forEach((key) =&gt;{ console.log(obj[key]); // [1, &quot;123&quot;, {code: 'EC109'}]}); Object.values()：无需先获取键名，直接可以拿到所有值 1Object.values(obj); // [1, &quot;123&quot;, {code: 'EC109'}] Object.entries(): 123456Object.entries(obj).forEach(([key, value]) =&gt;{ console.log(key + &quot;: &quot; + value);});// id: 1// value: 123// data: [object Object] 3.2 **指数操作符：类似数学的书写方式进行指数计算，可以看做是Math.pow()的简写 1let a = 7 ** 3; // a = 343，等同于 a = Math.pow(7, 3) 3.3 ??当我们查询某个属性时，经常会给没有该属性就设置一个默认的值，比如下面两种方式： 12let c = a ? a : b // 方式1let c = a || b // 方式2 这两种方式有个明显的弊端，它都会覆盖所有的假值，如(0, ‘’, false)，这些值可能是在某些情况下有效的输入。 空位合并操作符，用 ?? 表示。如果表达式在??的左侧运算符求值为 undefined 或 null，就返回其右侧默认值。 12let c = a ?? b;// 等价于let c = a !== undefined &amp;&amp; a !== null ? a : b; 3.4 padStart/padEnd用于在字符串开头或结尾添加填充字符串（ES2017） padStart(maxLength, [fillString])：从前面补充字符 padEnd(maxLength, [fillString])：从后面补充字符 1234567891011'es8'.padStart(2); // 'es8''es8'.padStart(5); // ' es8''es8'.padStart(6, 'woof'); // 'wooes8''es8'.padStart(14, 'wow'); // 'wowwowwowwoes8''es8'.padStart(7, '0'); // '0000es8''es8'.padEnd(2); // 'es8''es8'.padEnd(5); // 'es8 ''es8'.padEnd(6, 'woof'); // 'es8woo''es8'.padEnd(14, 'wow'); // 'es8wowwowwowwo''es8'.padEnd(7, '6'); // 'es86666' 应用场景： 1234567891011121314151617181920212223242526272829303132// 1.日期格式化const dt = new Date();console.log( `${dt.getFullYear()+''}-` +`${(dt.getMonth()+1+'').padStart(2, '0')}-` +`${(dt.getDate()+'').padStart(2, '0')}`);// 2020-08-07// 2.时间戳补位let timestamp = '1596808152';timestamp = +String(timestamp).padEnd(13, '0');// 1596808152000// 3.地区编码补位 省级编码2位，市级4位，区县6位，乡镇9位，村级12位。现在需要统一补充成12位/** * 格式化地区编码，按指定长度输出 * @param regionCode 地区编码 * @param length 需要的长度 */formateRegionCode(regionCode: string|number, length: number = 12): string { regionCode = String(regionCode); if(!regionCode || regionCode.length &lt; 2) { throw new Error('地区编码错误'); } if(length &lt; 2) { throw new Error('地区编码长度不能小于2'); } const tempCode = regionCode.split('').slice(0, length).join(''); return tempCode.length &lt; length ? tempCode.padEnd(length, '0') : tempCode;} 4 答案2.2 question: 123456789101112131415const pageNum = 0, pageSize = 10, user = {uid: 100000, password: '123123'};let params = { pageNum, pageSize, password: user.password // 需给定属性名，user.password是无法将其识别成属性名}// 还可以这样let params = { pageNum, pageSize, ...user // 2.5小节讲解}// {pageNum: 0, pageSize: 10, uid: 100000, password: &quot;123123&quot;}// 通过扩展符，可能会多出其他属性，如果多出来的属性对结果不影响，可以考虑这样做 2.3 question: obj1错误，obj2正确。简写方法的属性名总是变量本身作为字符串使用，bind函数本身返回一个函数，从解析器角度来说，这个返回的函数叫什么名字并没有办法确定，而第二种写法，是确定好了fn2 2.4 question: 123Uncaught SyntaxError: Unexpected token ':'let getTempItem = id =&gt; ({ id, name: &quot;Temp&quot; }); 2.5 question: 123456{a: 1, b: 2}{0: 2, 1: 3, 2: 4} // result.0 ????VM37:1 Uncaught TypeError: obj is not iterable at &lt;anonymous&gt;:1:17 2.7 question: 1arr.filter( item =&gt; item.id === 2 ); // [{id: 2}, {id: 2}] 5 参考资料 Modern JavaScript, 10 things you should be using, starting today - DEV 盘点ES7、ES8、ES9、ES10新特性 ES6，ES7，ES8，ES9，ES10新特性一览 ES2020新特性 种草 ES2020 新特性 异步Promise及Async/Await可能最完整入门攻略 刘哥金句：给别人讲述知识时可以发现自己掌握的是否牢固透彻，写的过程不断发现自己的不足，然后通过一些方式来解决问题，这也是一种学习过程；当然，给别人分享，也要从学习者的角度出发，考虑他们想要从你的分享中获得什么，还有就是你想表达些什么给他们。","link":"/2020/08/24/JavaScript%E6%96%B0%E7%89%B9%E6%80%A7/"},{"title":"Vue3.js模板项目创建","text":"基础环境 Vue CLI 版本为 4.5.6 Node.js 版本为 14.9.0 （官方建议是 10 以上版本，最低为 8.9） yarn 版本为 1.22.5 （推荐使用，用NPM也可以） 通过以下命令行查询对应版本号： 12345vue --version // @vue/cli 4.5.6node --v // v14.9.0yarn -v // 1.22.5 如发现版本不满足要求，可以分别通过： 运行以下命令行，更新 Vue CLI 至最新版本 1npm i -g @vue/cli 前往 Node.js 下载最新版本的程序，并安装。 运行以下命令行，更新 yarn 至最新版本 1npm i -g yarn 项目创建Vue 默认会通过以前选择过的包管理工具 yarn 或 NPM 来安装依赖。想全局修改的话，可在命令行中运行: 1vue config --set packageManager yarn // 或 npm 推荐 yarn 也可在创建项目时动态指定当前项目的包管理工具： 1vue create vue3-starter -m yarn 勾选以下几项(单击图片可看大图): 依次选择如下内容： 最后会问是否要保存当前这个配置，按自己的意愿选择和命名。 成功后，运行如下命令行： 12cd vue3-starteryarn serve 在浏览器中打开 http://localhost:8080/ 看到页面就算完成了。 项目改造默认结构1234567891011121314151617181920212223242526├── public // 静态资源 该文件夹下的内容在构建时会直接拷贝到dist文件夹下│ ├── favicon.ico // 网站图标│ └── index.html // HTML模板页├── src // 主要工作目录│ ├── assets // 静态资源 会被webpack打包处理│ │ └── logo.png│ ├── components // 组件(dumb components，获取props，派发事件)│ │ └── HelloWorld.vue // 示例组件│ ├── router // 路由（统一使用懒加载）│ │ └── index.ts // 组装各路由并导出│ ├── store // 状态管理（可选）│ │ └── index.ts│ ├── views // 页面(smart components，可以访问store，路由，window)│ │ ├── About.vue // 关于│ │ └── Home.vue // 首页│ ├── App.vue // 根组件│ ├── main.ts // 入口文件（引入全局的样式和脚本，可安装插件、注册组件或指令等）│ └── shims-vue.d.ts // 帮助IDE识别 .vue文件├── .browserslistrc // 目标浏览器配置├── .editorconfig // 代码风格规范├── .eslintrc.js // eslint配置├── .gitignore // git提交忽略文件├── babel.config.js // babel配置├── package.json // 项目依赖、脚本├── README.md // 项目命令行说明└── tsconfig.json // TypeScript配置文件 内容改造文件夹创建在 src 文件夹下创建 hooks、layouts、plugins、services、utils 文件夹（每个文件夹的作用在下方改造后的目录结构中有说明） 在 assets 文件夹下创建 fonts、icons、images、styles 文件夹，删除 logo.png （每个文件夹的作用在下方改造后的目录结构中有说明） 在 hooks 文件夹下创建 common 文件夹 在 store 文件夹下创建 modules 文件夹 在 utils 文件夹下创建 http 文件夹 文件删除删除 components 文件夹下HelllWorld.vue 删除 views 文件夹下About.vue 按 kebab-case 命名法，修改所有不符合规范的文件和对应文件中的引用App.vue -&gt; app.vue, Home.vue -&gt; home.vue 文件修改public/index.html12&lt;!-- &lt;html lang=&quot;en&quot;&gt; 改为中文，否则安装了翻译插件的浏览器会弹出是否要翻译本页对话框--&gt;&lt;html lang=&quot;zh&quot;&gt;&lt;/html&gt; main.ts12345678910111213141516// main.ts 将链式语法拆开，按需注释import { createApp } from 'vue';import App from './app.vue';import router from './router';import store from './store';import './plugins'; // 引入所需插件 TODO 根据具体插件添加import 'normalize.css'; // CSS reset的替代方案import './assets/styles/style.scss'; // 引入全局样式const app = createApp(App);app.use(store); // 按需使用状态管理app.use(router).mount('#app'); app.vue12345// app.vue 移除多余内容&lt;template&gt; &lt;router-view/&gt;&lt;/template&gt; home.vue12345678910111213141516171819202122// home.vue 引入hook示例组件&lt;template&gt; &lt;hooks :title=&quot;hookTitle&quot;&gt;&lt;/hooks&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import { defineComponent } from 'vue';import Hooks from '@/components/hooks.vue';export default defineComponent({ name: 'Home', components: { Hooks, }, setup() { return { hookTitle: 'Hooks使用示例', }; },});&lt;/script&gt; router/index.ts1234567891011121314151617181920212223242526272829303132333435// index.ts 删除了about 路由,自动合并当前文件夹下的文件到路由中去import { createRouter, createWebHashHistory, RouteRecordRaw } from 'vue-router';import Login from '../views/login.vue';// 首次必然要加载的路由const constRoutes: Array&lt;RouteRecordRaw&gt; = [ { path: '/', name: 'Login', component: Login, },];// 所有路由let routes:Array&lt;RouteRecordRaw&gt; = [];// 自动添加router目录下的所有ts路由模块const files = require.context('./', false, /\\.ts$/);files.keys().forEach((route) =&gt; { // 如果是根目录的 index.js、 不做任何处理 if (route.startsWith('./index')) { return; } const routerModule = files(route); // 兼容 import export 和 require module.export 两种规范 ES modules commonjs routes = [...constRoutes, ...(routerModule.default || routerModule)];});const router = createRouter({ history: createWebHashHistory(), routes,});export default router; router/index.ts123456789101112131415161718192021222324252627// index.ts 自动将modules下的所有模块添加进来import { createStore } from 'vuex';interface IModule { [key: string]: { namespaced: boolean }}// 自动添加mudules下的所有ts模块const modules: IModule = {};const files = require.context('./modules', false, /\\.ts$/);files.keys().forEach((key) =&gt; { const moduleKey = key.replace(/(\\.\\/|\\.ts)/g, ''); modules[moduleKey] = files(key).default; modules[moduleKey].namespaced = true; // 让 mutations、getters、actions 也按照模块划分});// 无需使用模块或者是一些通用的状态写在下方export default createStore({ state: { }, mutations: { }, actions: { }, modules,}); .eslintrc.js123456789101112131415161718// .eslintrc.jsmodule.exports = { root: true, env: { node: true, }, extends: ['plugin:vue/vue3-essential', '@vue/airbnb', '@vue/typescript/recommended'], parserOptions: { ecmaVersion: 2020, }, rules: { 'no-console': 'off', 'no-debugger': 'off', 'import/prefer-default-export': 'off', 'max-len': ['error', { code: 160 }], },}; 文件创建views/login.vue12345678910111213141516171819202122232425262728293031// login.vue 添加store actions以及 路由hook 的调用示例&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;handleLogin&quot;&gt;登录&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import { defineComponent } from 'vue';import { useRouter } from '@/hooks/common/use-router';import { useStore } from 'vuex';export default defineComponent({ name: 'Login', setup() { const store = useStore(); const { router } = useRouter(); const handleLogin = async () =&gt; { const data = await store.dispatch('user/login', { userName: 'zqc', password: '18' }); // 派发事件，调用actions if (data.accessToken) { router.push('home'); } }; return { handleLogin, }; },});&lt;/script&gt; router/home.ts1234567891011// home.ts 添加home相关的路由，按需添加或删除/* eslint-disable @typescript-eslint/explicit-module-boundary-types */export default [ { path: '/home', name: 'home', component: () =&gt; import('@/views/home.vue'), },]; stroe/modules/user.ts123456789101112131415161718192021222324252627282930313233// user.tsimport { ILogin, login } from '@/services/user';// 用常量替代 mutation 事件类型，当前模块所有mutation一目了然const SET_ACCESSTOKEN = 'SET_ACCESSTOKEN';// stateconst userState = { accessToken: '',};// getters// actionsconst actions = { async login({ commit }:{commit:(mutation:string, arg:string)=&gt;void}, userInfo:Record&lt;string, unknown&gt;):Promise&lt;ILogin&gt; { const { data } = await login(userInfo); commit(SET_ACCESSTOKEN, data.accessToken); return data; },};// mutationsconst mutations = { [SET_ACCESSTOKEN](state:{accessToken:string}, accessToken:string) :void{ state.accessToken = accessToken; },};export default { state: userState, actions, mutations,}; utils/http/index.ts123456789101112131415161718192021222324252627282930313233343536373839// index.ts 统一使用http来进行请求import axios from 'axios';const http = axios.create({ baseURL: process.env.VUE_APP_BASE_API, // url = base url + request url // withCredentials: true, // 如跨域请求时要带上cookie,则设置为true timeout: 1000 * 5, // 请求超时时长 5秒});http.interceptors.request.use( (config) =&gt; { if (config.method === 'post') { // 按需添加内容 } return config; }, (error) =&gt; { console.log(error); return Promise.reject(error); },);http.interceptors.response.use( (response) =&gt; { // 如果返回的状态不是200 就报错 按需修改 if (response.status &amp;&amp; response.status !== 200) { return Promise.reject(new Error('错误')); } return response; }, (error) =&gt; { console.log(error); return Promise.reject(error); },);export default http; hooks/common/use-debounce.ts1234567891011121314151617181920212223242526/** * 防抖 在事件被触发一定时间后再执行回调，如果在这段事件内又被触发，则重新计时 * 使用场景： * 1、搜索框中，用户在不断输入值时，用防抖来节约请求资源 * 2、点击按钮时，用户误点击多次，用防抖来让其只触发一次 * 3、window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次 * @param fn 回调 * @param duration 时间间隔的阈值(单位：ms) 默认1000ms */export function useDebounce&lt;F extends(...args: unknown[]) =&gt; unknown&gt; (fn: F, duration = 1000):() =&gt; void { let timeoutId: ReturnType&lt;typeof setTimeout&gt; | undefined; const debounce = (...args: Parameters&lt;F&gt;) =&gt; { if (timeoutId) { clearTimeout(timeoutId); } timeoutId = setTimeout(() =&gt; { fn(...args); timeoutId = undefined; }, duration); }; return debounce;} hooks/common/use-throttle.ts12345678910111213141516171819202122232425/** * 节流 规定在一段时间内，只能触发一次函数。如果这段时间内触发多次函数，只有一次生效 * 使用场景： * 1、鼠标不断点击触发，mousedown(单位时间内只触发一次) * 2、监听滚动事件，比如是否滑到底部自动加载更多 * @param fn 回调 * @param duration 时间间隔的阈值(单位：ms) 默认500ms */export function useThrottle&lt;F extends(...args: unknown[]) =&gt; unknown&gt;(fn: F, duration = 1000):() =&gt; void { let timeoutId: ReturnType&lt;typeof setTimeout&gt; | undefined; const throttle = (...args: Parameters&lt;F&gt;) =&gt; { if (timeoutId) { return; } timeoutId = setTimeout(() =&gt; { fn(...args); timeoutId = undefined; }, duration); }; return throttle;} hooks/common/use-router.ts1234567891011121314151617import { reactive, toRefs, watch, getCurrentInstance, Ref,} from 'vue';import { Router } from 'vue-router';/** * 获取路由 * @returns 当前路由以及Router实例 */export function useRouter():{route:Ref, router:Router } { const vm = getCurrentInstance(); const state = reactive({ route: vm?.proxy?.$route }); watch(() =&gt; vm?.proxy?.$route, (newValue) =&gt; { state.route = newValue; }); return { ...toRefs(state), router: vm?.proxy?.$router as Router };} components/hooks.vue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// hooks.vue 添加节流防抖的示例&lt;template&gt;&lt;div&gt; &lt;div class='title'&gt;{{myTitle}}&lt;/div&gt; &lt;button @click=&quot;handleCLick&quot;&gt;防抖测试&lt;/button&gt; &lt;div class='scroll-box' @scroll=&quot;handleScroll(throttleRef)&quot;&gt; {{throttleRef}}测试 &lt;div style=&quot;height: 200px&quot;&gt;&lt;/div&gt; &lt;div style=&quot;height: 200px&quot;&gt;&lt;/div&gt; &lt;div style=&quot;height: 200px&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import { ref, defineComponent } from 'vue';import { useDebounce } from '@/hooks/common/use-debounce';import { useThrottle } from '@/hooks/common/use-throttle';/** * hooks使用示例组件 */export default defineComponent({ name: 'Hooks', props: { title: String, }, setup(props) { const throttleRef = ref('节流'); const handleCLick = useDebounce((() =&gt; { console.log('防抖测试'); }), 500); const handleScroll = useThrottle(((message) =&gt; { console.log(`${message}测试`); }), 500); return { myTitle: props.title, throttleRef, handleCLick, handleScroll, }; },});&lt;/script&gt;&lt;style lang=&quot;scss&quot;&gt;.title{ text-align: center;}button{ margin-bottom: 8px;}.scroll-box{ height:300px; width:500px; background-color:rgb(209, 204, 204); overflow-y:scroll;}&lt;/style&gt; styles/common.scss12345678910111213141516171819202122232425262728293031// common.scss 通用样式/** ************************** 通用样式 ****************************** */ html, body { height: 100%; } /** ****************** 修改type=number的样式 ****************** */ input::-webkit-outer-spin-button, input::-webkit-inner-spin-button { -webkit-appearance: none; } input[type=&quot;number&quot;] { -moz-appearance: textfield; } /** ******************************************************** */ /* 修改谷歌浏览器记住密码后input默认样式 */ input:-webkit-autofill, textarea:-webkit-autofill, select:-webkit-autofill { -webkit-text-fill-color: #ededed !important; box-shadow: 0 0 0px 1000px transparent inset !important; background-color: transparent; background-image: none; transition: background-color 50000s ease-in-out 0s; } /** ******************************************************** */ styles/style.scss123// style.scss 全局变量都写在这里，默认引入 通用样式，被main.ts引入@import './common.scss'; 在根目录下添加 vue.config.js 文件来扩展 webpack 配置1234567891011121314151617181920212223242526/** * 判断是否是生产环境 * @returns {boolean} 是否是生产环境 */function isProd() { return process.env.NODE_ENV === 'production';}// 配置请求的基本API,当前开发模式配置的是淘宝的测试地址process.env.VUE_APP_BASE_API = isProd() ? '' : 'http://rap2api.taobao.org/app/mock/115307/user';module.exports = { publicPath: isProd() ? './' : '/', // 部署到生产环境时，按需修改前项为项目名称 productionSourceMap: false, // 不需要生产环境的 source map，减少构建时间 configureWebpack: (config) =&gt; { if (isProd()) { // 去除 console Object.assign( config.optimization.minimizer[0].options.terserOptions.compress, { drop_console: true, }, ); } },}; 依赖添加Normalize.css （初始化样式）1yarn add normalize.css axios（HTTP 请求）1yarn add axios 改造后的结构1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768├── public // 静态资源 该文件夹下的内容在构建时会直接拷贝到dist文件夹下│ ├── favicon.ico // 网站图标│ ├── index.html // HTML模板页│ └── ...├── src // 主要工作目录│ ├── assets // 静态资源 会被webpack打包处理│ │ ├── fonts // 字体文件（可选）│ │ │ └── ...│ │ ├── icons // 图标（可选）│ │ │ └── ...│ │ ├── images // 图片（可选）│ │ │ ├── exception // exception（通用异常页面）模块使用到的图片│ │ │ │ └── ...│ │ │ ├── module-a // 此处要用模块命名（可选）│ │ │ │ └── ... // 该模块下使用到的图片│ │ │ └── ... // 通用的图片（小项目就不用分文件夹了）│ │ └── styles // 样式│ │ ├── common.scss // 常用样式（提供通用的）│ │ ├── style.scss // 全局样式，组装各样式并导出最终被 main.js 引入│ │ └── ...│ ├── components // 组件(dumb components，获取props，派发事件)│ │ ├── common // 不同项目中的通用组件（可选）│ │ │ └── ...│ │ ├── module-a // 此处要用模块命名（可选）│ │ │ └── ... // 该模块下的组件│ │ └── ... // 当前项目中的通用组件│ ├── hooks // 钩子│ │ ├── common // 不同项目中的通用hooks│ │ │ ├── use-debounce.ts // 防抖hook│ │ │ ├── use-router.ts // 路由hook│ │ │ ├── use-throttle.ts // 节流hook│ │ │ └── ...│ │ └── ... // 本项目中通用的hooks│ ├── layouts // 布局（可选）│ │ └── ...│ ├── plugins // vue插件（如：Element,vuetify,antd）（可选）│ │ ├── index.ts // 组装各插件并导出│ │ └── ...│ ├── router // 路由（除必然要加载的以外，统一使用懒加载）│ │ ├── index.ts // 组装各路由并导出│ │ └── ...│ ├── services // 接口请求│ │ ├── module-a .ts // 各业务模块所有包含的请求和数据处理，此处要用模块命名│ │ └── ...│ ├── store // 状态管理（可选）│ │ ├── modules // 各模块│ │ │ └── ... // 尽量和views中的模块对应上│ │ ├── index.ts // 组装模块并导出│ ├── utils // 工具类│ │ ├── http // aixos封装│ │ │ └── index.ts│ │ └── ...│ ├── views // 页面(smart components，可以访问store，路由，window)│ │ ├── module-a.vue // 用模块命名,如该模块下页面较多，可建以模块为名称的文件夹，在其中创建多个页面│ │ │ └── ...│ │ └── ...│ ├── app.vue // 根组件│ ├── main.ts // 入口文件（引入全局的样式和脚本，可安装插件、注册组件或指令等）│ └── shims-vue.d.ts // 帮助IDE识别 .vue文件├── .browserslistrc // 目标浏览器配置├── .editorconfig // 代码风格规范├── .eslintrc.js // eslint配置├── .gitignore // git提交忽略文件├── babel.config.js // babel配置├── package.json // 项目依赖、脚本├── README.md // 项目命令行说明├── tsconfig.json // TypeScript配置文件└── vue.config.js // 自定义webpack配置","link":"/2020/09/14/Vue3-js%E6%A8%A1%E6%9D%BF%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/"},{"title":"if-else逻辑判断优化","text":"前言为什么要优化if else逻辑判断呢？我们应该如何去优化它呢？优化它有什么意义呢？ 在分享之前我们先看一段代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// 贷款申请操作的处理function check() { // 是否输入正确用户名 if (this.checkUsername(this.username)) { // 是否输入正确身份证号 if (this.checkIdCard(this.idCard)) { // 请输入正确的电话号码 if (this.checkTel(this.tel)) { // 担保人是本人 if (this.dbr === '担保人是本人') { // 是否存在身份证正面 if (document.querySelector('.sfzzm img')) { console.log('存在身份证正面') // 是否存在身份证反面 if (document.querySelector('.sfzfm img')) { console.log('存在身份证反面') // 是否存在学历证书 if (document.querySelector('.xlzs img')) { console.log('存在学历证书') if (this.ydxy) { this.tijiaoIsShow = false } } else { Toast('请上传学历证书') this.tijiaoIsShow = true } } else { Toast('请上传身份证反面') } } else { Toast('请上传身份证正面') } } else if (this.dbr == '担保人不是本人') { if (this.checkUsername(this.dbrname)) { if (this.checkIdCard(this.dbridCard)) { if (this.checkTel(this.dbrzyzh)) { if (document.querySelector('.sfzzm img')) { console.log('存在身份证正面') if (document.querySelector('.sfzfm img')) { console.log('存在身份证反面') if (document.querySelector('.xlzs img')) { console.log('存在学历证书') this.tijiaoIsShow = false } else { Toast('请上传学历证书') } } else { Toast('请上传身份证反面') } } else { Toast('请上传身份证正面') } } else { Toast('请输入担保人展业证号') } } else { Toast('请输入担保人身份证号') } } else { Toast('请输入担保人姓名') } } else { Toast('请选择担保人是否为本人') } } else { Toast('请输入正确的电话号码') } } else { Toast('请输入正确的身份证号') } } else { Toast('请输入正确的姓名') }} 看完这样一个代码后，相信大家和我的心情是一样的： 因为我们每次维护时要记住好几个逻辑判断分支，才能知道到底什么情况下才能得到那个结果，这种代码的可读性和可维护性自然就比较低了。 箭头式代码。 12345678910// ................... // ................... // ................... // ................... // ................... // ................... // ................... // ................... // ...................// ................... 那我这次分享的目的就是通过优化某种场景下的if else语句，使得优化后的代码看着比较清爽，从而提高代码的可读性和可维护性。 那接下来我就带大家了解一下具体场景下的if else优化方法有哪些，先从简单的场景入手。 单个if语句优化策略需求：当条件为真时打印出日志内容 优化前 12345678let flag = true;if (flag) { log();}function log() { console.log('如果flag值为真的时候打印这段文字');} 优化后 123456let flag = true;flag &amp;&amp; log();function log() { console.log('如果flag值为真的时候打印这段文字');} 好处：代码在一行很清晰，简洁，好读。 单个if else语句优化策略提前return需求：执行登录操作，如果用户名和密码输入框为空，那么我们就提示用户”用户名和密码不能为空”类似信息；如果都不为空，那我们就执行登录的操作。 优化前 12345678let user = 'silu';let password = 'solution';if (user &amp;&amp; password) { // 执行登录操作} else { return '用户名和密码不能为空';} 优化后：排非策略，先排除为false的情形，通过后再执行为true时的业务逻辑 1234567let user = 'silu';let password = 'solution';if(!user || !password) { return '用户名和密码不能为空';}// 执行登录操作 好处：可以干掉else，减少代码分支，提高代码的可维护性和可阅读性。 使用条件三目运算符使用场景：在不影响可读性的情况下，处理if else分支下简短的返回值、单个简短赋值语句、调用单个相应函数时，建议使用三目运算符。 示例一：if else分支下简短返回值 优化前： 1234567function demo(flag) { if (flag) { return 'true'; } else { return 'false'; }} 优化后 123function demo(falg) { return flag ? 'true' : 'false';} 示例二：if else分支下简短赋值 优化前： 12345678function demo(flag) { let val = ''; if (flag) { val = 'true'; } else { val = 'false'; }} 优化后： 123function demo(flag) { let val = flag ? 'true' : 'false';} 示例三：if else分支下调用单个函数 优化前： 1234567function demo(flag) { if (flag) { success(); } else { fail(); }} 优化后 123function demo(flag) { flag ? success() : fail();} 好处：在以上场景中，使用条件三目运算符相比if else来说，语句在一行中书写，代码非常精炼，执行效率更高 。 多个if else嵌套优化策略 需求：后端大哥说了，给你返回的数据里面如果有 userInfo字段，并且userInfo下面有hobby字段并且有值就显示 hobby里面的内容，否则页面 hobby这一块不显示 12345678910let result = { status: 200, msg: 'success', data: { userInfo: { name: 'doudou', hobby: ['吃饭', '睡觉', '打豆豆'] } }} 一般写法：“金字塔一样的if else嵌套” 1234567891011121314151617if (result.data) { if (result.data.userInfo) { if (Array.isArray(result.data.userInfo.hobby)) { if (result.data.userInfo.hobby.length) { // 进行业务逻辑操作 } else { return 'hobby字段为空'; } } else { return 'hobby字段不是一个数组'; } } else { return 'userInfo字段不存在'; }} else { return 'data字段不存在';} 但if else一般不建议嵌套超过三层，如果一段代码存在过多的if else嵌套，代码的可读性就会急速下降，后期维护难度也大大提高。所以，我们写这种代码时都应该尽量避免过多的if else嵌套。下面我就开始分享几个可以减少if else嵌套的方法。 第一种优化 123456if (!result.data) return 'data字段不存在';if (!result.data.userInfo) return 'userInfo字段不存在';if (!Array.isArray(result.data.userInfo.boddy)) return 'hobby字段不是一个数组';if (result.data.userInfo.hobby.length) { // 进行业务逻辑操作} 遵循的一般规则是，当发现无效条件时，提前返回。 好处：对于多层的if嵌套，使用此方法，代码看起来更简洁，可读性高，增强了代码的可维护性。 第二种优化 适合严谨又懒的前端 12345678try { // 有可能出现错误的代码写在这里 if (result.data.userInfo.hobby.length) { // 进行业务逻辑操作 }} catch (error) { // 出错后的处理写在这里} 采取的try catch策略 如果try中的代码没有出错，则程序正常运行try中的内容后，不会执行catch中的内容， 如果try中的代码一但出错，程序立即跳入catch中去执行代码，那么try中代码出错后的程序就不再执行了. 第三种优化 使用可选链（optional chaining)：我们都知道如果我们对一个空值进行属性读取的时候，程序会抛出异常。就像上面那个例子，在多级嵌套的对象中取属性值的时候更容易出现这个问题。那么我们为了保证程序的健壮性，就需要确保对象不为空时再读取下一级的值。 1234// 可选链优化if(result ?.data ?.userInfo ?.hobby ?.length) { // 进行业务逻辑操作} 再也不用为了解决容错而写过多重复代码了， 操作符 *?.* 会检查操作符左边的值是否是空值。如果是null 或 undefined，这个表达式就终止然后返回 undefined。否则，这个表达式继续执行检查。 可选链操作符( ?. )，当尝试访问可能不存在的对象属性时，可选链操作符将会使表达式更短、更简明 。 多个else if分支优化策略需求: 有多个按钮，点击按钮执行相应业务逻辑操作。 按钮点击后根据按钮的不同type分别做两件事，第一、打印出对应日志，第二、跳转到对应的页面。 1234567891011121314151617181920212223242526/** * 按钮点击事件 * @param { string } type // 1女装2男装3童装4美妆5箱包 */const onButtonClick = (type) =&gt; { if (type === '1') { showLog('女装'); jumpTo('womenPage'); } else if (type === '2') { showLog('男装'); jumpTo('menPage'); } else if (type === '3') { showLog('童装'); jumpTo('childPage'); } else if (type === '4') { showLog('美妆'); jumpTo('makeupPage'); } else if (type === '5') { showLog('箱包'); jumpTo('bagPage'); } else { showLog('推荐好物'); jumpTo('recommendPage'); }} 多数新人在工作中常用switch case进行改写。 12345678910111213141516171819202122232425262728293031/** * 按钮点击事件 * @param { string } type // 1女装2男装3童装4美妆5箱包 */const onButtonClick = (type) =&gt; { switch (type) { case '1': showLog('女装'); jumpTo('womenPage'); break; case '2': showLog('男装'); jumpTo('menPage'); break; case '3': showLog('童装'); jumpTo('childPage'); break; case '4': showLog('美妆'); jumpTo('makeupPage'); break; case '5': showLog('箱包'); jumpTo('bagPage'); break; default: showLog('推荐好物'); jumpTo('recommendPage'); }} 注：不要忘记在每个case语句后放一个break，case语句只是指明了想要执行代码的起点，并没有指明终点，如果没有在case语句中添加break语句，没有明确的中断流程，在每次条件判断后都会执行下次判断条件，可能会造成逻辑混乱。 使用 switch case 后的语句的确比if else看着清晰易读了些，但是当需求增多后代码看起来还是那么的臃肿，似乎并没有从根本上解决问题，和if else的写法对比也不是很明显的提高。 那接下来我们就换种方法,借助对象的{key，value}结构优化 1234567891011121314151617181920const actions = { '1': ['女装', 'womenPage'], '2': ['男装', 'menPage'], '3': ['童装', 'childPage'], '4': ['美妆', 'makeupPage'], '5': ['箱包', 'bagPage'], 'default': ['推荐好物', 'recommendPage']}/** * 按钮点击事件 * @param { string } type // 1女装2男装3童装4美妆5箱包 */function onButtonClick(type) { let action = actions[type] || actions['default']; // 打印日志 showLog(action[0]); // 跳转页面 jumpTo(action[1]);} 借助对象结构的这种写法，把判断条件作为对象的属性名，处理逻辑要传入的参数作为对象的属性值，在执行按钮点击事件时通过查询对象中的键，获取到键对应的值，然后执行对应的处理逻辑。这种写法非常的适合一元条件判断的情况。 问：那除了借助对象结构来实现优化，还有其它方法吗？ 答：我们还可以借助ES6中的 Map 数据结构来优化 ； Map 对象保存键值对。任何类型值(对象或者原始值) 都可以作为一个键或一个值。 123456789101112131415161718const actions = new Map([ ['1', ['女装', 'womenPage']], ['2', ['男装', 'menPage']], ['3', ['童装', 'childPage']], ['4', ['美妆', 'makeupPage']], ['5', ['箱包', 'bagPage']], ['default', ['推荐好物', 'recommendPage']]]);/** * 按钮点击事件 * @param { string } type // 1女装2男装3童装4美妆5箱包 */function onButtonClick(type) { let action = actions.get(type) || actions.get('default'); showLog(action[0]); jumpTo(action[1]);} 上面用到了es6里的Map对象。Map对象和Object对象的区别: 一个 Object 的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值。 Map 中的键值是有序的（FIFO 原则），而添加到对象中的键则不是。 Map 的键值对个数可以从 size 属性获取，而 Object 的键值对个数只能手动计算。 如果我们把问题再升级一下，在点击按钮时不仅要判断type，还要判断用户的身份——男用户or女用户。 123456789101112131415161718192021222324252627282930313233343536/** * 按钮点击事件 * @param { string } type // 1女装2男装3童装4美妆5箱包 * @param { string } sex // 男用户or女用户 */function onButtonClick(type, sex) { if (sex === 'women') { if (type === '1') { // do something } else if (type === '2') { // do something } else if (type === '3') { // do something } else if (type === '4') { // do something } else if (type === '5') { // do something } else { // do something } } else if (sex === 'men') { if (type === '1') { // do something } else if (type === '2') { // do something } else if (type === '3') { // do something } else if (type === '4') { // do something } else if (type === '5') { // do something } else { // do something } }} 从上方示例代码中可以看出，如果判断条件变为二元条件判断时，if else的数量就增加到一元判断条件的二倍，代码看着更臃肿了。那么对于二元的条件判断我们应该怎么去优化它们呢？ 1234567891011121314151617181920212223const actions = new Map([ ['women_1', () =&gt; {/* do something */}], ['women_2', () =&gt; {/* do something */}], ['women_3', () =&gt; {/* do something */}], ['women_4', () =&gt; {/* do something */}], ['women_5', () =&gt; {/* do something */}], ['men_1', () =&gt; {/* do something */}], ['men_2', () =&gt; {/* do something */}], ['men_3', () =&gt; {/* do something */}], ['men_4', () =&gt; {/* do something */}], ['men_5', () =&gt; {/* do something */}], ['default', () =&gt; {/* do something */}]]);/** * 按钮点击事件 * @param { string } type // 1女装2男装3童装4美妆5箱包 * @param { string } sex // 男用户or女用户 */function onButtonClick(type, sex) { let action = actions.get(`$(sex)_$(type)`) || actions.get('default'); action.call(this);} 上面这种处理思想是，把条件判断拼接成字符串作为键，每个分支下的处理逻辑作为值，在使用时传入参数使用Map查询，这种方法非常适合于二元或多元条件判断。 如果你不喜欢把查询条件拼接为字符串使用，这还有一种方法，把查询条件作为对象，借助Map数据结构实现。 1234567891011121314151617181920212223242526272829303132333435const actions = new Map([ [{ sex: 'women', type: '1' }, () =&gt; {/* do something */}], [{ sex: 'women', type: '2' }, () =&gt; {/* do something */}], [{ sex: 'women', type: '3' }, () =&gt; {/* do something */}], [{ sex: 'women', type: '4' }, () =&gt; {/* do something */}], [{ sex: 'women', type: '5' }, () =&gt; {/* do something */}], [{ sex: 'men', type: '1' }, () =&gt; {/* do something */}], [{ sex: 'men', type: '2' }, () =&gt; {/* do something */}], [{ sex: 'men', type: '3' }, () =&gt; {/* do something */}], [{ sex: 'men', type: '4' }, () =&gt; {/* do something */}], [{ sex: 'men', type: '5' }, () =&gt; {/* do something */}], ['default', () =&gt; {/* do something */}]]);/** * 按钮点击事件 * @param { string } type // 1女装2男装3童装4美妆5箱包 * @param { string } sex // 男用户or女用户 */function onButtonClick(type, sex) { // 根据条件使用filter查询 let action = [...actions].filter(([key, value])=&gt;(key.sex === sex &amp;&amp; key.type === type)); action.forEach(([key, value]) =&gt; value.call(this));}/** * 按钮点击事件 * @param { string } type // 1女装2男装3童装4美妆5箱包 * @param { string } sex // 男用户or女用户 */function onButtonClick(type, sex) { // 根据条件使用find查询 let action = [...actions].find(([key, value]) =&gt; (key.sex === sex &amp;&amp; key.type === type)); action[1].call(this);} 上方在执行按钮点击事件时，根据条件查询相应执行逻辑时，提供了filter和find两种查询方式，个人觉得使用filter更为正式，使用find更容易阅读，当然你也可以使用其它方法啦~ 从这里我们就看出了使用Map相对于Object存在的优势了，Map数据结构可以以任意类型的值作为key。 假如在women情况下，type为1,2,3,4时的处理逻辑都一样该怎么写呢？ 12345678const actions = new Map([ [{ sex: 'women', type: '1'}, ()=&gt;{ /* 执行A逻辑 */}], [{ sex: 'women', type: '2'}, ()=&gt;{ /* 执行A逻辑 */}], [{ sex: 'women', type: '3'}, ()=&gt;{ /* 执行A逻辑 */}], [{ sex: 'women', type: '4'}, ()=&gt;{ /* 执行A逻辑 */}], [{ sex: 'women', type: '5'}, ()=&gt;{ /* 执行B逻辑 */}], // ……]); 这样写的话Map里面就会显得比较臃肿，具体的执行逻辑处理过程都放在了Map里面。好点的写法可以是这样子。 12345678910const logicA = ()=&gt;{ /* 执行A逻辑 */ };const logicB = ()=&gt;{ /* 执行B逻辑 */ };const actions = new Map([ [{ sex: 'women', type: '1'}, logicA], [{ sex: 'women', type: '2'}, logicA], [{ sex: 'women', type: '3'}, logicA], [{ sex: 'women', type: '4'}, logicA], [{ sex: 'women', type: '5'}, logicB], // ……]); 上面的写法虽然Map中结构清晰了，日常需求的话可以这么写也是没什么问题的。但是，如果以后增加需求，women条件下type为6、7、8、10、11……的逻辑处理都是一样的。那么我们还要像上方那样的写法在Map中一一增加同样的执行逻辑吗？ 显然，这样的话会变得比较繁琐，那么我们还有其它办法来应对这种情况吗？ 123456789function actions() { const logicA = ()=&gt;{ /* 执行A逻辑 */ }; const logicB = ()=&gt;{ /* 执行B逻辑 */ }; const action = new Map([ [/^women_[1-4]$/, logicA], [/^women_5$/, logicB], // …… ]);} 利用正则进行判断条件匹配后，代码又清爽了许多。并且这里使用Map后的优势就更加的明显了，符合正则的条件的公共逻辑都会执行。 总结下这部分的内容： 一元条件判断：存到Object中。 一元条件判断：存到Map中。 二元或多元判断：将判断条件拼接成字符串存到Object中。 二元或多元判断：将判断条件拼接成字符串存到Map中。 多元判断时：将判断条件写成Object存到Map中。 多元判断时：将判断条件写成正则存到Map中。 使用数组新特性优化逻辑判断在工作中，巧妙的使用ES6中提供的数组新特性，也可以达到轻松优化逻辑判断的效果。 使用includes优化代码逻辑需求：判断animal是否属于cute类型。 当我们遇到多条件判断时，本能的写下以下代码。 123456const cuteAnimal = ['dog', 'cat', 'bird', 'panda'];function animalJudge(animal) { if (animal === 'dog' || animal === 'cat' || animal === 'bird' || animal === 'panda') { console.log('可爱的小动物'); }} 但是当cuteAnimal的种类多达十几种或者是更多的时候，我们就只能通过这种||的形式去维护吗？ 这时候我们可以试着使用includes方法 1234567const cuteAnimal = ['dog', 'cat', 'bird', 'panda'];function animalJudge(animal) { if (cuteAnimal.includes(animal)) { console.log('可爱的小动物'); }} 这个时候后期维护的话，增加动物类型时只需要在cuteAnimal数组中增加，当类型数量多时，代码看起来还是很简洁，不像上面使用很多||那么杂乱 使用every优化代码逻辑需求：判断animals数组中的动物是否都属于cute类型 every：判断数组的每一项是否都满足条件，都满足条件返回true，否则返回false 12345678910111213141516171819202122232425const animals = [{ name: 'dog', type: 'cute' }, { name: 'cat', type: 'cute' }, { name: 'elephant', type: 'tall' }];function type() { let isAllCute = true; // 判断条件：animals中的动物是否都是cute类型 for (let animal of animals) { if (!isAllCute) break; isAllRed = (animal.type === 'cute'); } console.log(isAllCute); // false} 使用every方法，更容易处理上面的判断逻辑 1234567891011121314151617181920const animals = [{ name: 'dog', type: 'cute' }, { name: 'cat', type: 'cute' }, { name: 'elephant', type: 'tall' }];function animals() { // 判断条件：animals中的动物是否都是cute类型 const isAllCute = animals.every(animal =&gt; animal.type === 'cute'); console.log(isAllCute); // false} 使用some方法优化代码逻辑需求：判断animals中的动物是否存在有tall类型的。 some()是对数组中每一项运行给定函数，如果有一项符合条件，则返回true，都不符合条件返回false。 1234567891011121314151617181920const animals = [{ name: 'dog', type: 'cute' }, { name: 'cat', type: 'cute' }, { name: 'elephant', type: 'tall' }];function animals() { // 判断条件：animals中的动物是否含有tall类型 const isHasTall = animals.some(animal =&gt; animal.type === 'tall'); console.log(isHasTall); // true} 默认值优化优化前 12345function request(options) { let method = options.method ? options.method : 'GET'; let data = options.data ? options.data : {} //...} 优化后 12345function request(options) { let method = options.method || 'GET'; let data = options.data || {}; //...} 基于ES6优化后 123456// 解析解构和默认参数搭配使用function request({ method, data } = { method: 'GET', data: {}}){ //... console.log(method); // GET console.log(data); // {}} 使用策略模式优化分支逻辑需求：咱马上要过国庆节啦，得打折清仓呀，有的商品5折，有的7折，有的9折~ 优化前 12345678910111213141516171819202122232425262728function percent50(price) { // 五折的算法}function percent70(price) { // 七折的算法}function percent90(price) { // 九折的算法}function calculatePrice(price) { if (五折的商品) { return percent50(price); } if (七折的商品) { return percent50(price); } if (九折的商品) { return percent50(price); }}calculatePrice(price); 写到这里需求又来了，那以后的中秋节、元旦、情人节、元宵节……都要促销呀！再来个满300减50，满500减80，vip用户满500-150上不封顶！对于这种越来越多的需求，还要深入函数内部一一增加if分支吗？ 以上写法的缺点： calculatePrice函数比较庞大，包含了很多if else语句 如果再增加更多相似需求，必须要深入到calculatePrice函数内部实现，违反了开放封闭原则。 使用策略模式优化策略模式(Strategy Pattern)：定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。 策略模式是一种对象行为型模式。 这里的算法其实就是业务逻辑，为了更形象，干脆将其理解为一个函数。其实这个定义的基本意思就是说，根据策略选择要执行的函数，而每一个策略都会有一个标识名，可以称为key。而策略名对应的函数，可以称为value，其实就是使用key寻找value，然后执行vlaue的过程。也就是说，根据条件去执行相应的业务逻辑，从这层意思上理解，就是if else要干的事。 使用策略模式优化后： 使用思路：定义一个对象封装不同的行为，提供选择接口，在不同条件下调用相应的行为。 12345678910111213141516171819202122232425262728293031323334// 策略类let strategy = { // 5折 percent50(price) { return price * 0.5; }, // 7折 percent70(price) { return price * 0.7; }, // 9折 percent90(price) { return price * 0.9; }, // 满300-50 fullReduce50(price) { // 执行满300-50的业务逻辑 }, // 满300-80 fullReduce80(price) { // 执行满300-80的业务逻辑 }, // vip用户五折 vip50(price) { // vip用户五折的业务逻辑 }};// 调用策略类中的方法// 环境类function calculatePrice(strategyName, price) { return strategy[strategyName] &amp;&amp; strategy[strategyName](price);};console.log(calculatePrice('percent50', 100)); // 50 使用策略类优化后，后期再增加需求时，我们就不需要再深入到calculatePrice函数内部增加分支了，只需要在strategy策略类中增加相应的算法就可以啦！这样的代码是不是在后期更好维护呢！！！ 上面例子中： 策略类 是指strategy对象，保存了所有的策略名对应的方法。 环境类 是用接收策略名和其它参数，然后调用对应的策略方法。 好处： 有效的避免了多重条件选择语句。 策略模式提供了对开放-封闭原则的完美支持，将算法独立封装在strategy中，使得这些算法易于切换、易于理解、易于扩展。 总结 更少的嵌套，尽早 return 。 倾向于使用对象或使用map结构来优化if else，而不是 Switch 语句 。 多重判断时使用 Array.includes 。 对 所有/部分 判断使用 Array.every &amp; Array.some 。 使用默认参数和解构 。 当一个项目中需要大量算法，大量匹配模式时可以考虑使用策略模式。 感想 让我们感到快乐和幸福的方法，无非是全身心的投入到我们稍微努力一下就能完成的事情中去。是这样的，太难的事情我们很难去完成最终丧失信心，而简单的事情又不能勾起我们的兴趣，只有像这种看似比较难，但是稍微努力就能完成的事情，才能给我们带来很大的快乐。","link":"/2020/09/30/if-else%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD%E4%BC%98%E5%8C%96/"},{"title":"if-else逻辑判断优化","text":"前言为什么要优化if else逻辑判断呢？我们应该如何去优化它呢？优化它有什么意义呢？ 在分享之前我们先看一段代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// 贷款申请操作的处理function check() { // 是否输入正确用户名 if (this.checkUsername(this.username)) { // 是否输入正确身份证号 if (this.checkIdCard(this.idCard)) { // 请输入正确的电话号码 if (this.checkTel(this.tel)) { // 担保人是本人 if (this.dbr === '担保人是本人') { // 是否存在身份证正面 if (document.querySelector('.sfzzm img')) { console.log('存在身份证正面') // 是否存在身份证反面 if (document.querySelector('.sfzfm img')) { console.log('存在身份证反面') // 是否存在学历证书 if (document.querySelector('.xlzs img')) { console.log('存在学历证书') if (this.ydxy) { this.tijiaoIsShow = false } } else { Toast('请上传学历证书') this.tijiaoIsShow = true } } else { Toast('请上传身份证反面') } } else { Toast('请上传身份证正面') } } else if (this.dbr == '担保人不是本人') { if (this.checkUsername(this.dbrname)) { if (this.checkIdCard(this.dbridCard)) { if (this.checkTel(this.dbrzyzh)) { if (document.querySelector('.sfzzm img')) { console.log('存在身份证正面') if (document.querySelector('.sfzfm img')) { console.log('存在身份证反面') if (document.querySelector('.xlzs img')) { console.log('存在学历证书') this.tijiaoIsShow = false } else { Toast('请上传学历证书') } } else { Toast('请上传身份证反面') } } else { Toast('请上传身份证正面') } } else { Toast('请输入担保人展业证号') } } else { Toast('请输入担保人身份证号') } } else { Toast('请输入担保人姓名') } } else { Toast('请选择担保人是否为本人') } } else { Toast('请输入正确的电话号码') } } else { Toast('请输入正确的身份证号') } } else { Toast('请输入正确的姓名') }} 看完这样一个代码后，相信大家和我的心情是一样的： 因为我们每次维护时要记住好几个逻辑判断分支，才能知道到底什么情况下才能得到那个结果，这种代码的可读性和可维护性自然就比较低了。 箭头式代码。 12345678910// ................... // ................... // ................... // ................... // ................... // ................... // ................... // ................... // ...................// ................... 那我这次分享的目的就是通过优化某种场景下的if else语句，使得优化后的代码看着比较清爽，从而提高代码的可读性和可维护性。 那接下来我就带大家了解一下具体场景下的if else优化方法有哪些，先从简单的场景入手。 单个if语句优化策略需求：当条件为真时打印出日志内容 优化前 12345678let flag = true;if (flag) { log();}function log() { console.log('如果flag值为真的时候打印这段文字');} 优化后 123456let flag = true;flag &amp;&amp; log();function log() { console.log('如果flag值为真的时候打印这段文字');} 好处：代码在一行很清晰，简洁，好读。 单个if else语句优化策略提前return需求：执行登录操作，如果用户名和密码输入框为空，那么我们就提示用户”用户名和密码不能为空”类似信息；如果都不为空，那我们就执行登录的操作。 优化前 12345678let user = 'silu';let password = 'solution';if (user &amp;&amp; password) { // 执行登录操作} else { return '用户名和密码不能为空';} 优化后：排非策略，先排除为false的情形，通过后再执行为true时的业务逻辑 1234567let user = 'silu';let password = 'solution';if(!user || !password) { return '用户名和密码不能为空';}// 执行登录操作 好处：可以干掉else，减少代码分支，提高代码的可维护性和可阅读性。 使用条件三目运算符使用场景：在不影响可读性的情况下，处理if else分支下简短的返回值、单个简短赋值语句、调用单个相应函数时，建议使用三目运算符。 示例一：if else分支下简短返回值 优化前： 1234567function demo(flag) { if (flag) { return 'true'; } else { return 'false'; }} 优化后 123function demo(falg) { return flag ? 'true' : 'false';} 示例二：if else分支下简短赋值 优化前： 12345678function demo(flag) { let val = ''; if (flag) { val = 'true'; } else { val = 'false'; }} 优化后： 123function demo(flag) { let val = flag ? 'true' : 'false';} 示例三：if else分支下调用单个函数 优化前： 1234567function demo(flag) { if (flag) { success(); } else { fail(); }} 优化后 123function demo(flag) { flag ? success() : fail();} 好处：在以上场景中，使用条件三目运算符相比if else来说，语句在一行中书写，代码非常精炼，执行效率更高 。 多个if else嵌套优化策略 需求：后端大哥说了，给你返回的数据里面如果有 userInfo字段，并且userInfo下面有hobby字段并且有值就显示 hobby里面的内容，否则页面 hobby这一块不显示 12345678910let result = { status: 200, msg: 'success', data: { userInfo: { name: 'doudou', hobby: ['吃饭', '睡觉', '打豆豆'] } }} 一般写法：“金字塔一样的if else嵌套” 1234567891011121314151617if (result.data) { if (result.data.userInfo) { if (Array.isArray(result.data.userInfo.hobby)) { if (result.data.userInfo.hobby.length) { // 进行业务逻辑操作 } else { return 'hobby字段为空'; } } else { return 'hobby字段不是一个数组'; } } else { return 'userInfo字段不存在'; }} else { return 'data字段不存在';} 但if else一般不建议嵌套超过三层，如果一段代码存在过多的if else嵌套，代码的可读性就会急速下降，后期维护难度也大大提高。所以，我们写这种代码时都应该尽量避免过多的if else嵌套。下面我就开始分享几个可以减少if else嵌套的方法。 第一种优化 123456if (!result.data) return 'data字段不存在';if (!result.data.userInfo) return 'userInfo字段不存在';if (!Array.isArray(result.data.userInfo.boddy)) return 'hobby字段不是一个数组';if (result.data.userInfo.hobby.length) { // 进行业务逻辑操作} 遵循的一般规则是，当发现无效条件时，提前返回。 好处：对于多层的if嵌套，使用此方法，代码看起来更简洁，可读性高，增强了代码的可维护性。 第二种优化 适合严谨又懒的前端 12345678try { // 有可能出现错误的代码写在这里 if (result.data.userInfo.hobby.length) { // 进行业务逻辑操作 }} catch (error) { // 出错后的处理写在这里} 采取的try catch策略 如果try中的代码没有出错，则程序正常运行try中的内容后，不会执行catch中的内容， 如果try中的代码一但出错，程序立即跳入catch中去执行代码，那么try中代码出错后的程序就不再执行了. 第三种优化 使用可选链（optional chaining)：我们都知道如果我们对一个空值进行属性读取的时候，程序会抛出异常。就像上面那个例子，在多级嵌套的对象中取属性值的时候更容易出现这个问题。那么我们为了保证程序的健壮性，就需要确保对象不为空时再读取下一级的值。 1234// 可选链优化if(result ?.data ?.userInfo ?.hobby ?.length) { // 进行业务逻辑操作} 再也不用为了解决容错而写过多重复代码了， 操作符 *?.* 会检查操作符左边的值是否是空值。如果是null 或 undefined，这个表达式就终止然后返回 undefined。否则，这个表达式继续执行检查。 可选链操作符( ?. )，当尝试访问可能不存在的对象属性时，可选链操作符将会使表达式更短、更简明 。 多个else if分支优化策略需求: 有多个按钮，点击按钮执行相应业务逻辑操作。 按钮点击后根据按钮的不同type分别做两件事，第一、打印出对应日志，第二、跳转到对应的页面。 1234567891011121314151617181920212223242526/** * 按钮点击事件 * @param { string } type // 1女装2男装3童装4美妆5箱包 */const onButtonClick = (type) =&gt; { if (type === '1') { showLog('女装'); jumpTo('womenPage'); } else if (type === '2') { showLog('男装'); jumpTo('menPage'); } else if (type === '3') { showLog('童装'); jumpTo('childPage'); } else if (type === '4') { showLog('美妆'); jumpTo('makeupPage'); } else if (type === '5') { showLog('箱包'); jumpTo('bagPage'); } else { showLog('推荐好物'); jumpTo('recommendPage'); }} 多数新人在工作中常用switch case进行改写。 12345678910111213141516171819202122232425262728293031/** * 按钮点击事件 * @param { string } type // 1女装2男装3童装4美妆5箱包 */const onButtonClick = (type) =&gt; { switch (type) { case '1': showLog('女装'); jumpTo('womenPage'); break; case '2': showLog('男装'); jumpTo('menPage'); break; case '3': showLog('童装'); jumpTo('childPage'); break; case '4': showLog('美妆'); jumpTo('makeupPage'); break; case '5': showLog('箱包'); jumpTo('bagPage'); break; default: showLog('推荐好物'); jumpTo('recommendPage'); }} 注：不要忘记在每个case语句后放一个break，case语句只是指明了想要执行代码的起点，并没有指明终点，如果没有在case语句中添加break语句，没有明确的中断流程，在每次条件判断后都会执行下次判断条件，可能会造成逻辑混乱。 使用 switch case 后的语句的确比if else看着清晰易读了些，但是当需求增多后代码看起来还是那么的臃肿，似乎并没有从根本上解决问题，和if else的写法对比也不是很明显的提高。 那接下来我们就换种方法,借助对象的{key，value}结构优化 1234567891011121314151617181920const actions = { '1': ['女装', 'womenPage'], '2': ['男装', 'menPage'], '3': ['童装', 'childPage'], '4': ['美妆', 'makeupPage'], '5': ['箱包', 'bagPage'], 'default': ['推荐好物', 'recommendPage']}/** * 按钮点击事件 * @param { string } type // 1女装2男装3童装4美妆5箱包 */function onButtonClick(type) { let action = actions[type] || actions['default']; // 打印日志 showLog(action[0]); // 跳转页面 jumpTo(action[1]);} 借助对象结构的这种写法，把判断条件作为对象的属性名，处理逻辑要传入的参数作为对象的属性值，在执行按钮点击事件时通过查询对象中的键，获取到键对应的值，然后执行对应的处理逻辑。这种写法非常的适合一元条件判断的情况。 问：那除了借助对象结构来实现优化，还有其它方法吗？ 答：我们还可以借助ES6中的 Map 数据结构来优化 ； Map 对象保存键值对。任何类型值(对象或者原始值) 都可以作为一个键或一个值。 123456789101112131415161718const actions = new Map([ ['1', ['女装', 'womenPage']], ['2', ['男装', 'menPage']], ['3', ['童装', 'childPage']], ['4', ['美妆', 'makeupPage']], ['5', ['箱包', 'bagPage']], ['default', ['推荐好物', 'recommendPage']]]);/** * 按钮点击事件 * @param { string } type // 1女装2男装3童装4美妆5箱包 */function onButtonClick(type) { let action = actions.get(type) || actions.get('default'); showLog(action[0]); jumpTo(action[1]);} 上面用到了es6里的Map对象。Map对象和Object对象的区别: 一个 Object 的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值。 Map 中的键值是有序的（FIFO 原则），而添加到对象中的键则不是。 Map 的键值对个数可以从 size 属性获取，而 Object 的键值对个数只能手动计算。 如果我们把问题再升级一下，在点击按钮时不仅要判断type，还要判断用户的身份——男用户or女用户。 123456789101112131415161718192021222324252627282930313233343536/** * 按钮点击事件 * @param { string } type // 1女装2男装3童装4美妆5箱包 * @param { string } sex // 男用户or女用户 */function onButtonClick(type, sex) { if (sex === 'women') { if (type === '1') { // do something } else if (type === '2') { // do something } else if (type === '3') { // do something } else if (type === '4') { // do something } else if (type === '5') { // do something } else { // do something } } else if (sex === 'men') { if (type === '1') { // do something } else if (type === '2') { // do something } else if (type === '3') { // do something } else if (type === '4') { // do something } else if (type === '5') { // do something } else { // do something } }} 从上方示例代码中可以看出，如果判断条件变为二元条件判断时，if else的数量就增加到一元判断条件的二倍，代码看着更臃肿了。那么对于二元的条件判断我们应该怎么去优化它们呢？ 1234567891011121314151617181920212223const actions = new Map([ ['women_1', () =&gt; {/* do something */}], ['women_2', () =&gt; {/* do something */}], ['women_3', () =&gt; {/* do something */}], ['women_4', () =&gt; {/* do something */}], ['women_5', () =&gt; {/* do something */}], ['men_1', () =&gt; {/* do something */}], ['men_2', () =&gt; {/* do something */}], ['men_3', () =&gt; {/* do something */}], ['men_4', () =&gt; {/* do something */}], ['men_5', () =&gt; {/* do something */}], ['default', () =&gt; {/* do something */}]]);/** * 按钮点击事件 * @param { string } type // 1女装2男装3童装4美妆5箱包 * @param { string } sex // 男用户or女用户 */function onButtonClick(type, sex) { let action = actions.get(`$(sex)_$(type)`) || actions.get('default'); action.call(this);} 上面这种处理思想是，把条件判断拼接成字符串作为键，每个分支下的处理逻辑作为值，在使用时传入参数使用Map查询，这种方法非常适合于二元或多元条件判断。 如果你不喜欢把查询条件拼接为字符串使用，这还有一种方法，把查询条件作为对象，借助Map数据结构实现。 1234567891011121314151617181920212223242526272829303132333435const actions = new Map([ [{ sex: 'women', type: '1' }, () =&gt; {/* do something */}], [{ sex: 'women', type: '2' }, () =&gt; {/* do something */}], [{ sex: 'women', type: '3' }, () =&gt; {/* do something */}], [{ sex: 'women', type: '4' }, () =&gt; {/* do something */}], [{ sex: 'women', type: '5' }, () =&gt; {/* do something */}], [{ sex: 'men', type: '1' }, () =&gt; {/* do something */}], [{ sex: 'men', type: '2' }, () =&gt; {/* do something */}], [{ sex: 'men', type: '3' }, () =&gt; {/* do something */}], [{ sex: 'men', type: '4' }, () =&gt; {/* do something */}], [{ sex: 'men', type: '5' }, () =&gt; {/* do something */}], ['default', () =&gt; {/* do something */}]]);/** * 按钮点击事件 * @param { string } type // 1女装2男装3童装4美妆5箱包 * @param { string } sex // 男用户or女用户 */function onButtonClick(type, sex) { // 根据条件使用filter查询 let action = [...actions].filter(([key, value])=&gt;(key.sex === sex &amp;&amp; key.type === type)); action.forEach(([key, value]) =&gt; value.call(this));}/** * 按钮点击事件 * @param { string } type // 1女装2男装3童装4美妆5箱包 * @param { string } sex // 男用户or女用户 */function onButtonClick(type, sex) { // 根据条件使用find查询 let action = [...actions].find(([key, value]) =&gt; (key.sex === sex &amp;&amp; key.type === type)); action[1].call(this);} 上方在执行按钮点击事件时，根据条件查询相应执行逻辑时，提供了filter和find两种查询方式，个人觉得使用filter更为正式，使用find更容易阅读，当然你也可以使用其它方法啦~ 从这里我们就看出了使用Map相对于Object存在的优势了，Map数据结构可以以任意类型的值作为key。 假如在women情况下，type为1,2,3,4时的处理逻辑都一样该怎么写呢？ 12345678const actions = new Map([ [{ sex: 'women', type: '1'}, ()=&gt;{ /* 执行A逻辑 */}], [{ sex: 'women', type: '2'}, ()=&gt;{ /* 执行A逻辑 */}], [{ sex: 'women', type: '3'}, ()=&gt;{ /* 执行A逻辑 */}], [{ sex: 'women', type: '4'}, ()=&gt;{ /* 执行A逻辑 */}], [{ sex: 'women', type: '5'}, ()=&gt;{ /* 执行B逻辑 */}], // ……]); 这样写的话Map里面就会显得比较臃肿，具体的执行逻辑处理过程都放在了Map里面。好点的写法可以是这样子。 12345678910const logicA = ()=&gt;{ /* 执行A逻辑 */ };const logicB = ()=&gt;{ /* 执行B逻辑 */ };const actions = new Map([ [{ sex: 'women', type: '1'}, logicA], [{ sex: 'women', type: '2'}, logicA], [{ sex: 'women', type: '3'}, logicA], [{ sex: 'women', type: '4'}, logicA], [{ sex: 'women', type: '5'}, logicB], // ……]); 上面的写法虽然Map中结构清晰了，日常需求的话可以这么写也是没什么问题的。但是，如果以后增加需求，women条件下type为6、7、8、10、11……的逻辑处理都是一样的。那么我们还要像上方那样的写法在Map中一一增加同样的执行逻辑吗？ 显然，这样的话会变得比较繁琐，那么我们还有其它办法来应对这种情况吗？ 123456789function actions() { const logicA = ()=&gt;{ /* 执行A逻辑 */ }; const logicB = ()=&gt;{ /* 执行B逻辑 */ }; const action = new Map([ [/^women_[1-4]$/, logicA], [/^women_5$/, logicB], // …… ]);} 利用正则进行判断条件匹配后，代码又清爽了许多。并且这里使用Map后的优势就更加的明显了，符合正则的条件的公共逻辑都会执行。 总结下这部分的内容： 一元条件判断：存到Object中。 一元条件判断：存到Map中。 二元或多元判断：将判断条件拼接成字符串存到Object中。 二元或多元判断：将判断条件拼接成字符串存到Map中。 多元判断时：将判断条件写成Object存到Map中。 多元判断时：将判断条件写成正则存到Map中。 使用数组新特性优化逻辑判断在工作中，巧妙的使用ES6中提供的数组新特性，也可以达到轻松优化逻辑判断的效果。 使用includes优化代码逻辑需求：判断animal是否属于cute类型。 当我们遇到多条件判断时，本能的写下以下代码。 123456const cuteAnimal = ['dog', 'cat', 'bird', 'panda'];function animalJudge(animal) { if (animal === 'dog' || animal === 'cat' || animal === 'bird' || animal === 'panda') { console.log('可爱的小动物'); }} 但是当cuteAnimal的种类多达十几种或者是更多的时候，我们就只能通过这种||的形式去维护吗？ 这时候我们可以试着使用includes方法 1234567const cuteAnimal = ['dog', 'cat', 'bird', 'panda'];function animalJudge(animal) { if (cuteAnimal.includes(animal)) { console.log('可爱的小动物'); }} 这个时候后期维护的话，增加动物类型时只需要在cuteAnimal数组中增加，当类型数量多时，代码看起来还是很简洁，不像上面使用很多||那么杂乱 使用every优化代码逻辑需求：判断animals数组中的动物是否都属于cute类型 every：判断数组的每一项是否都满足条件，都满足条件返回true，否则返回false 12345678910111213141516171819202122232425const animals = [{ name: 'dog', type: 'cute' }, { name: 'cat', type: 'cute' }, { name: 'elephant', type: 'tall' }];function type() { let isAllCute = true; // 判断条件：animals中的动物是否都是cute类型 for (let animal of animals) { if (!isAllCute) break; isAllRed = (animal.type === 'cute'); } console.log(isAllCute); // false} 使用every方法，更容易处理上面的判断逻辑 1234567891011121314151617181920const animals = [{ name: 'dog', type: 'cute' }, { name: 'cat', type: 'cute' }, { name: 'elephant', type: 'tall' }];function animals() { // 判断条件：animals中的动物是否都是cute类型 const isAllCute = animals.every(animal =&gt; animal.type === 'cute'); console.log(isAllCute); // false} 使用some方法优化代码逻辑需求：判断animals中的动物是否存在有tall类型的。 some()是对数组中每一项运行给定函数，如果有一项符合条件，则返回true，都不符合条件返回false。 1234567891011121314151617181920const animals = [{ name: 'dog', type: 'cute' }, { name: 'cat', type: 'cute' }, { name: 'elephant', type: 'tall' }];function animals() { // 判断条件：animals中的动物是否含有tall类型 const isHasTall = animals.some(animal =&gt; animal.type === 'tall'); console.log(isHasTall); // true} 默认值优化优化前 12345function request(options) { let method = options.method ? options.method : 'GET'; let data = options.data ? options.data : {} //...} 优化后 12345function request(options) { let method = options.method || 'GET'; let data = options.data || {}; //...} 基于ES6优化后 123456// 解析解构和默认参数搭配使用function request({ method, data } = { method: 'GET', data: {}}){ //... console.log(method); // GET console.log(data); // {}} 使用策略模式优化分支逻辑需求：咱马上要过国庆节啦，得打折清仓呀，有的商品5折，有的7折，有的9折~ 优化前 12345678910111213141516171819202122232425262728function percent50(price) { // 五折的算法}function percent70(price) { // 七折的算法}function percent90(price) { // 九折的算法}function calculatePrice(price) { if (五折的商品) { return percent50(price); } if (七折的商品) { return percent50(price); } if (九折的商品) { return percent50(price); }}calculatePrice(price); 写到这里需求又来了，那以后的中秋节、元旦、情人节、元宵节……都要促销呀！再来个满300减50，满500减80，vip用户满500-150上不封顶！对于这种越来越多的需求，还要深入函数内部一一增加if分支吗？ 以上写法的缺点： calculatePrice函数比较庞大，包含了很多if else语句 如果再增加更多相似需求，必须要深入到calculatePrice函数内部实现，违反了开放封闭原则。 使用策略模式优化策略模式(Strategy Pattern)：定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。 策略模式是一种对象行为型模式。 这里的算法其实就是业务逻辑，为了更形象，干脆将其理解为一个函数。其实这个定义的基本意思就是说，根据策略选择要执行的函数，而每一个策略都会有一个标识名，可以称为key。而策略名对应的函数，可以称为value，其实就是使用key寻找value，然后执行vlaue的过程。也就是说，根据条件去执行相应的业务逻辑，从这层意思上理解，就是if else要干的事。 使用策略模式优化后： 使用思路：定义一个对象封装不同的行为，提供选择接口，在不同条件下调用相应的行为。 12345678910111213141516171819202122232425262728293031323334// 策略类let strategy = { // 5折 percent50(price) { return price * 0.5; }, // 7折 percent70(price) { return price * 0.7; }, // 9折 percent90(price) { return price * 0.9; }, // 满300-50 fullReduce50(price) { // 执行满300-50的业务逻辑 }, // 满300-80 fullReduce80(price) { // 执行满300-80的业务逻辑 }, // vip用户五折 vip50(price) { // vip用户五折的业务逻辑 }};// 调用策略类中的方法// 环境类function calculatePrice(strategyName, price) { return strategy[strategyName] &amp;&amp; strategy[strategyName](price);};console.log(calculatePrice('percent50', 100)); // 50 使用策略类优化后，后期再增加需求时，我们就不需要再深入到calculatePrice函数内部增加分支了，只需要在strategy策略类中增加相应的算法就可以啦！这样的代码是不是在后期更好维护呢！！！ 上面例子中： 策略类 是指strategy对象，保存了所有的策略名对应的方法。 环境类 是用接收策略名和其它参数，然后调用对应的策略方法。 好处： 有效的避免了多重条件选择语句。 策略模式提供了对开放-封闭原则的完美支持，将算法独立封装在strategy中，使得这些算法易于切换、易于理解、易于扩展。 总结 更少的嵌套，尽早 return 。 倾向于使用对象或使用map结构来优化if else，而不是 Switch 语句 。 多重判断时使用 Array.includes 。 对 所有/部分 判断使用 Array.every &amp; Array.some 。 使用默认参数和解构 。 当一个项目中需要大量算法，大量匹配模式时可以考虑使用策略模式。 感想 让我们感到快乐和幸福的方法，无非是全身心的投入到我们稍微努力一下就能完成的事情中去。是这样的，太难的事情我们很难去完成最终丧失信心，而简单的事情又不能勾起我们的兴趣，只有像这种看似比较难，但是稍微努力就能完成的事情，才能给我们带来很大的快乐。","link":"/2020/09/30/%E4%BC%98%E5%8C%96if-else%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD/"},{"title":"函数式编程范式","text":"1 函数式编程概念1.1 定义函数式编程（Functional Programming: FP）是一种编程范式（指计算机中编程中的典范模式或方法），用于描述数据（函数）之间的映射关系。 函数式编程中的函数不是指程序中的函数（方法），而是数学中的函数（映射关系），如：y = f(x)，指x和y之间的关系。 常见的编程范式有：函数式编程、程序编程、面向对象编程、指令式编程、声明式编程等。 指令式编程：主要思想是关注计算机执行的步骤，即一步一步告诉计算机先做什么再做什么。 声明式编程：以数据结构的形式来表达程序执行的逻辑。它的主要思想是告诉计算机应该做什么，但不指定具体要怎么做。SQL 语句就是最明显的一种声明式编程的例子。 现代编程语言的发展趋势是支持多种范式，如C#、Java 8+、Kotlin、ES6+。 1.2 特点 代码简洁：函数式编程⼤大量量使⽤用函数，减少了了代码的重复； 接近自然语言，易于理解： 123var result = （1 + 2）* 3 - 4;var result = subtract(multiply(add(1, 2), 3), 4); 函数是“第一等公民”：函数与其他数据类型一样，处于平等地位，可以赋值给其它变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值； 闭包和高阶函数：函数式编程会使用较多的闭包和高阶函数； 没有“副作用”，方便与代码管理和单元测试：副作用 指函数内部与外部互动(最典型的情况，就是修改全局变量量的 值)，产⽣生运算以外的其他结果。函数式编程强调没有”副作用”，意味着函数要保持独立，所有功能就是返回一个新的值，没有其他⾏为，尤其是不得修改外部变量的值； 不修改变量：不会保留计算中间的结果，不修改变量，使用参数保留状态； 引用透明：函数的运行不依赖于外部变量或”状态”，只依赖于输入 的参数，任何时候只要参数相同，引用函数所得到的返回值总是相同的。 1.3 基本概念①函数式编程的思维方式： 把现实世界的事物和事物之间的联系抽象到程序世界（对运算过程进行抽象） ②程序的本质： 根据输入通过某种运算获得相应的输出，程序开发过程中会涉及很多有输入和输出的函数。 ③函数y=f(x)： x → f(映射) → y 图1 从x到y的函数关系 图2 从x到y不是函数关系 ④纯函数：相同的输入始终要得到相同的输出 ⑤函数式编程是用来描述数据（函数）之间的映射 2 头等函数2.1 函数是一等公民 函数可以存储在变量中 函数可以作为参数 函数可以作为返回值 函数可以存储在变量中： 123456789101112131415161718192021// 把函数赋值给变量const fn = () =&gt; { console.log('2.1 函数可以存储在变量中');};fn();// 属性赋值示例// const objController = {// getKeys(obj) {// return Object.keys(obj);// },// };// 优化// 上面代码中getKeys方法和内部调用Object.keys方法的参数和返回值一样，所以可以改写成下面const objController = { getKeys: Object.keys,};console.log(objController);const my = { name: 'Patrick Jun', constellation: 'Virgo' };console.log(objController.getKeys(my)); 2.2 高阶函数 把函数作为参数传递给另一个函数 可以把函数作为另一个函数的返回结果 2.2.1 函数作为参数1234567891011121314151617181920212223// 遍历function forEach(arr, fn) { for (let i = 0; i &lt; arr.length; i++) { fn(arr[i], i); }}// 筛选，返回符合条件的元素组成的新数组function filter(arr, fn) { const results = []; for (const item of arr) { if (fn(item)) { results.push(item); } } return results;}const colors = ['#FF0000', '#00FF00', 'blue'];forEach(colors, (item, index) =&gt; { console.log(index + 1, item);});console.log( filter(colors, (item) =&gt; item.length === 7),); 2.2.2 函数作为返回值1234567891011121314151617181920212223242526function makeFn() { const msg = 'hello function'; return function () { console.log(msg); };}const fn = makeFn();fn();// makeFn()()// 模拟lodash中的once函数 对一个函数只执行一次的函数(例如支付,不管用户点击多少次按钮，都只执行一次)function once(func) { let done = false; return function () { if (!done) { done = true; func.apply(this, arguments); } };}const pay = once((money) =&gt; { console.log(`支付${money}元`);});pay(20); // 支付20元pay(30);pay(40); 2.2.3 使用高阶函数意义 抽象可以帮我们屏蔽细节，只需要关注我们的目标 高阶函数用来抽象通用的问题 2.2.4 常用高阶函数模拟 map 通过指定函数处理数组的每个元素，并返回处理后的数组。 12345678910function map(arr, fn) { const res = []; for (const val of arr) { res.push(fn(val)); } return res;}let arr = [1, 2, 3, 4, 5];arr = map(arr, (item) =&gt; item * item);console.log(arr); //[ 1, 4, 9, 16, 25 ] every 用于检测数组所有元素是否都符合指定条件 1234567891011121314151617function every(arr, fn) { let res = true; for (const val of arr) { res = fn(val); if (!res) { break; } } return res;}const arr1 = [1, 2, 3, 4, 5];const arr2 = [4, 5, 6, 7];const res1 = every(arr1, (item) =&gt; item &gt; 3);console.log(res1); // falseconst res2 = every(arr2, (item) =&gt; item &gt; 3);console.log(res2); // true some 判断数组中是否至少有一个元素满足条件 1234567891011121314151617function some(arr, fn) { let res = false; for (const val of arr) { res = fn(val); if (res) { break; } } return res;}const arr1 = [1, 2, 3, 4, 5];const arr2 = [1, 3, 5, 7];const res1 = some(arr1, (item) =&gt; item % 2 === 0);console.log(res1); // trueconst res2 = some(arr2, (item) =&gt; item % 2 === 0);console.log(res2); // false find 返回数组中满足提供的测试函数的第一个元素的值，如果未找到，则返回undefined 123456789101112function find(arr, fn) { for (const item of arr) { if (fn(item)) { return item; } } return undefined;}const arr1 = [1, 2, 3, 4, 5];const res1 = find(arr1, (item) =&gt; item % 2 === 0);console.log(res1); // 2const res2 = find(arr1, (item) =&gt; item === 8);console.log(res2); // undefined findIndex 找到满足条件的第一个元素，返回其位置，如果未找到，则返回-1 1234567891011121314function findIndex(arr, fn) { for (let i = 0; i &lt; arr.length; i++) { if (fn(arr[i])) { return i; } } return -1;}const arr1 = [1, 2, 3, 4, 5];const res1 = findIndex(arr1, (item) =&gt; item % 2 === 0);console.log(res1); // 1const res2 = findIndex(arr1, (item) =&gt; item === 8);console.log(res2); // -1 3 闭包3.1 定义函数和其周围的状态的引用捆绑在一起形成的闭包。 可以在另一个作用域中调用一个函数内部的函数并访问到该函数的作用域中的成员； 闭包的本质：函数在执行的时候会放到一个执行栈上，当函数执行完毕后会从执行栈上删除，但是堆上作用域成员因为被外部引用而不能被释放，因此内部函数依然可以访问到作用域的成员； 3.2 案例12345678910111213141516171819202122232425function makePower(power) { return function (number) { return number ** power; };}// 平方const power2 = makePower(2);// 立方const power3 = makePower(3);console.log(power2(5));console.log(power2(2));console.log(power3(4));function makeSalary(base) { return function (performance) { return base + performance; };}// 底层打工人const sallaryLevel1 = makeSalary(1000);// 高级打工人const sallaryLevel2 = makeSalary(10000);console.log(sallaryLevel1(100)); // 1100console.log(sallaryLevel1(200)); // 1120console.log(sallaryLevel2(220)); // 40000 chorme开发者工具 &gt; Sources &gt; Call Stack(函数调用栈) / Scope(作用域) &gt; Global(var 全局) / Local(局部) / Closure(闭包) / Script(let 作用域) 12345678910111213// 查看函数栈和闭包作用域成员的访问function makeSalary() { let base = 1000; return function (performance) { // debugger; base += 1; return base + performance; };}const sallary = makeSalary();console.log(sallary(100));console.log(sallary(120)); 4 纯函数4.1 概念相同的输入永远会等到相同的输出，没有任何可观察的副作用 slice 和 splice 分别：纯函数和不纯函数 slice 返回数组中的指定部分，不会改变原数组 splice 对数组进行操作返回该数组，会改变原数组 12345678910111213141516// 纯函数 sliceconst numbers = [1, 2, 3, 4, 5];console.log(numbers.slice(0, 3)); // [ 1, 2, 3 ]console.log(numbers.slice(0, 3)); // [ 1, 2, 3 ]console.log(numbers.slice(0, 3)); // [ 1, 2, 3 ]// 不纯函数 spliceconsole.log(numbers.splice(0, 3)); // [ 1, 2, 3 ]console.log(numbers.splice(0, 3)); // [ 4, 5 ]console.log(numbers.splice(0, 3)); // []// 纯函数function getSum(a, b) { return a + b;}console.log(getSum(1, 2)); // 3console.log(getSum(1, 2)); // 3console.log(getSum(1, 2)); // 3 函数式编程不会保留计算中间结果，所以变量是不可变的（无状态） 我们可以把一个函数的执行结果交给另一个函数去处理 4.2 lodash官网：lodashlodash是一个纯函数的功能库，提供了对数组、数字、对象、字符串、函数等操作的一些方法。 123456789101112131415const _ = require('lodash');const arr = ['Tom', 'Jon', 'Kate'];console.log(_.first(arr));// console.log(_.last(arr));// console.log(_.toUpper(_.last(arr)));console.log(_.reverse(arr));console.log(_.first(arr));console.log(_.reverse(arr));console.log(_.each(arr, (item, index) =&gt; { console.log(item, index);}));// _.isEmpty(value); // 判断一个value 是否是empty(null,[],{}....) 4.3 纯函数的好处 可缓存：因为纯函数相同的输入永远会等到相同的输出，所以可以把纯函数结果缓存 123456789101112131415161718192021222324252627// 记忆函数const _ = require('lodash');function getArea(r) { console.log(r); return Math.PI * r * r;}// 这里使用lodash中的记忆函数const getAreaWithMemory = _.memoize(getArea);console.log(getAreaWithMemory(4));console.log(getAreaWithMemory(4));console.log(getAreaWithMemory(5));// js模拟 memoize 方法的实现function memoize(f) { const cache = {}; return function () { const key = JSON.stringify(arguments); cache[key] = cache[key] || f.apply(f, arguments); return cache[key]; };}const getAreaWithMemory = memoize(getArea);console.log(getAreaWithMemory(4));console.log(getAreaWithMemory(4));console.log(getAreaWithMemory(5)); 可测试：纯函数让测试更加方便，对单元化测试很友好 并行处理： 在多线程环境下并行操作共享的内存数据很可能会出现意外情况 纯函数不需要访问共享的内存数据，所以在并行环境下可以任意运行纯函数（Web Worker） 4.4 副作用纯函数：指相同的输入永远会得到相同的输出，而且没有可观察的副作用，而副作用让一个函数变的不纯（如下），纯函数根据相同的输入返回相同的输出，如果函数依赖于外部的状态就无法保证输出相同，就会带来副作用 1234567891011// 不纯的let mini = 18;function checkAge(age) { return age &gt;= mini;}// 纯的（有硬编码，后续可以通过柯里化解决）function checkAge2(age) { let mini = 18; return age &gt;= mini;} 副作用的来源： 配置文件 数据库 获取用户的输入： 所有的外部交互都有可能代理副作用，副作用也是的方法通用性下降不适合扩展和可重用性，同时副作用会给程序中带来安全隐患给程序员带来不确定性，但是副作用不可能完全禁止，尽可能控制他们在可控范围内发生。 5 柯里化柯里化（curry：咖喱）可以把多元函数转化成一元函数 当一个函数有多个参数的时候先传递一部分参数调用它（这部分参数以后永远不变） 然后返回一个新的函数接受剩余的参数，返回结果 5.1 柯里化示例(问题回顾)解决上面硬编码问题： 1234567// 普通纯函数function checkAge(age, min) { return age &gt;= min;}console.log(checkAge(20, 18)); // trueconsole.log(checkAge(17, 18)); // falseconsole.log(checkAge(24, 22)); // true 上面代码可以发现当基准值时18时，18是重复的 使用之前所学的闭包处理 1234567891011121314// 函数的柯里化function checkAge(min) { return function (age) { return age &gt;= min; };}const checkAge18 = checkAge(18);const checkAge22 = checkAge(22);console.log(checkAge18(17)); // falseconsole.log(checkAge18(20)); // trueconsole.log(checkAge22(20)); // falseconsole.log(checkAge22(30)); // true 使用ES6改造上面checkAge函数： 1let checkAge = min =&gt; age =&gt; age &gt;= min; 5.2 lodash.curry(fn) _.curry(fn) https://www.lodashjs.com/docs/lodash.curry 功能 创建一个函数，该函数接受fn的参数。如果fn所需的参数都被提供则执行fn并返回结果，否则继续返回该函数并等待接收剩余的参数。可以使用 fn.length 强制需要累积的参数个数。 12345678910const _ = require('lodash')function getSum(a, b, c) { return a + b + c}const curried=_.curry(getSum);console.log(curried(2, 3, 4)); // 9console.log(curried(2)(3)(4)); // 9console.log(curried(2)(3, 4)); // 9console.log(curried(2, 3)(4)); // 9 案例 123456789101112131415161718192021const _ = require('lodash');// eslint-disable-next-line arrow-body-styleconst match = _.curry((reg, str) =&gt; { return str.match(reg);});// 匹配所有数字const hasSpace = match(/\\s+/g);// 匹配所有空白字符const hasNumber = match(/\\d+/g);console.log(hasSpace('helloword')); // nullconsole.log(hasNumber('123213 123')); // [&quot;123213&quot;， &quot;123&quot;]console.log(hasNumber('helloword')); // null// eslint-disable-next-line arrow-body-styleconst filter = _.curry((func, array) =&gt; { return array.filter(func);});console.log(filter(hasSpace, ['Patrick Jun', 'Patrick_Jun'])); // [&quot;Patrick Jun&quot;]const findSpace = filter(hasSpace);console.log(findSpace(['Patrick Jun', 'Patrick_Jun'])); // [&quot;Patrick Jun&quot;] 模拟lodash中的curry方法 123456789101112131415161718192021function curry(func) { return function curriedFn(...args) { // 判断形参和实参的个数， // 如果 实参个数&lt;形参个数,将返回一个函数（该函数内如将再次调用curriedFn, 将第一次传入的参数和第二次传入的参数拼接起来。例如curried(2,3)(4) 第一次传入2,3，第二次传入4，这里将会返回curriedFn（2,3,4） // 否则返回传入的func 例如curried(2,3,4),直接返回传入的getSum(2,3,4),返回结果就是9 if (args.length &lt; func.length) { return function () { // 将...args与...arguments拼接传递给curriedFn（例如curried(2,3)(4)，这里就会将传递的2,3和4拼接起来） return curriedFn(...args, ...arguments); }; } return func(...args); };}function getSum(a, b, c) { return a + b + c;}const curried = curry(getSum);console.log(curried(2, 3)(4)); // 9console.log(curried(2)(3, 4)); // 9 5.3 总结 柯里化可以让我们给一个函数传递较少的参数得到一个已经记住了某些固定参数的新函数 这是一种对函数参数的’缓存’（闭包） 让函数变的更灵活，让函数的粒度更小 可以把多元函数转换成一元函数，可以组合使用函数产生强大的功能 6 函数组合6.1 概念函数组合(compose):如果一个函数要经过多个函数处理才能得到最终值，这个时候可以把中间过程的函数合并成一个函数 函数就像是数据的管道，函数组合就是把这些管道连接起来，让数据穿过多个管道形成最终结果 函数组合默认是从右到左执行 123456789101112131415161718// 函数组合演示function compose(f, g) { return function (value) { return f(g(value)); };}function reverse(array) { return array.reverse();}function first(array) { return array[0];}const last = compose(first, reverse);console.log(last([1, 2, 3, 4])); // 4 6.2 lodash组合函数lodash中组合函数flow()或者flowRight()，他们都可以组合多个函数 flow()是从左到右运行 flowRight()是从右到左运行，使用的更多一些 1234567const _ = require('lodash');const reverse = (arr) =&gt; arr.reverse();const first = (arr) =&gt; arr[0];const toUpper = (s) =&gt; s.toUpperCase();const f = _.flowRight(toUpper, first, reverse);console.log(f(['one', 'two', 'three'])); // ??? 模拟lodash中的flowRight()方法： 数组中的reduce() ：对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。 12345678910function compose(...args) { return function (val) { return args.reverse().reduce((acc, fn) =&gt; { return fn(acc); }, val); };}// ES6// const compose = (...args) =&gt; (val) =&gt; args.reverse().reduce((acc, fn) =&gt; fn(acc), val); 6.3 结合律函数的组合要满足结合律 例如compose(f,g,h)，我们既可以先把f和g组合在一起，还可以先把g和h组合 12345678910111213let f = compose(f, g, h);console.log(compose(compose(f, g), h) == compose(f, compose(g, h))); //trueconsole.log(compose(f, g, h) == compose(f, compose(g, h))); //trueconst _ = require('lodash')// 下面三种写法结果运行一样const f = _.flowRight(_.flowRight(_.toUpper, _.first), _.reverse);const f1 = _.flowRight(_.toUpper, _.flowRight(_.first, _.reverse));const f2 = _.flowRight(_.toUpper, _.first, _.reverse);console.log(f(['one', 'two', 'three']) === f1(['one', 'two', 'three'])); // trueconsole.log(f(['one', 'two', 'three']) === f2(['one', 'two', 'three'])); // trueconsole.log(f1(['one', 'two', 'three']) === f2(['one', 'two', 'three'])); // true 6.4 实战题目：将NEVER SAY DIE 转换为 never-say-die; 思路：分割，小写，join 分析： 函数组合只接受一个参数 柯里化可以将多元函数转化成一元函数 柯里化可以传递一部分参数，然后返回一个新的函数接受剩余的参数。 12345678910111213141516171819202122232425262728293031323334const _ = require('lodash');// _.split()// 因为我们需要传入str变量，所以str放在最后面传入。以下同理const split = _.curry((sep, str) =&gt; _.split(str, sep));// _.toLower()// ._joinconst join = _.curry((sep, array) =&gt; _.join(array, sep));// log用来检测数据管道中，哪部分值有错误const log = (v) =&gt; { console.log(v); // 继续返回值给下一个fn return v;};const f = _.flowRight(join('-'), log, split(' '), _.toLower);console.log(f('NEVER SAY DIE')); // never-say-die// // 考虑到数据管道很长的情况，如果多次log，打印的数据不够直观，于是改造log// const _ = require('lodash');// const trace = _.curry((tag, v) =&gt; {// console.log(tag, v);// return v;// });// const split = _.curry((sep, str) =&gt; _.split(str, sep));// const join = _.curry((sep, arr) =&gt; _.join(arr, sep));// const f = _.flowRight(join('-'), trace('after split：'), split(' '), trace('after toLower：'), _.toLower);// console.log(f('NEVER SAY DIE')); 7 总结 函数式编程是一种强调以函数使用为主的软件开发风格； 在函数式编程里面，将多个不同函数组合是一个非常非常非常重要的思想； 纯函数指没有副作用的函数，相同的输入有相同的输出； 函数式编程将函数视为积木，通过一等高阶函数来提高代码的模块化和可重用性。 通过柯里化将多元函数转化成一元函数，然后将柯里化后的函数，通过函数组合的方式合成一个组合函数。 进阶内容：lodash/fp、函子；（笔者还没学明白） 参考文章： 概念定义特点：https://juejin.im/post/6858129115598635015 函数式编程讲解：https://juejin.im/post/6844903743117361165 函数式编程讲解：https://juejin.im/post/6844903655397654535 拉勾教育大前端训练营笔记： https://zhuanlan.zhihu.com/p/162839608","link":"/2020/10/13/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/"},{"title":"从零创建Cordova插件-进阶","text":"l cordova开发进阶 l 开发进阶之插件配置 活动12345&lt;platform name=&quot;android&quot;&gt; &lt;config-file target=&quot;AndroidManifest.xml&quot; parent=&quot;/manifest/application&quot;&gt; &lt;activity android:name=&quot;cn.com.ths.thstoast.MyActivity&quot;/&gt; &lt;/config-file&gt;&lt;/platform&gt; 广播静态注册 12345678910&lt;platform name=&quot;android&quot;&gt; &lt;!-- 自定义的广播接收器 --&gt; &lt;receiver android:name=&quot;cn.com.ths.thstoast.MyBroadcastReceiver&quot; android:enabled=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;!-- 飞行模式开/关广播 --&gt; &lt;action android:name=&quot;android.intent.action.AIRPLANE_MODE&quot; /&gt; &lt;category android:name=&quot;$PACKAGE_NAME&quot; /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt;&lt;/platform&gt; 服务123456&lt;platform name=&quot;android&quot;&gt; &lt;service android:name=&quot;cn.com.ths.thstoast.MyService&quot; android:enabled=&quot;true&quot; android:exported=&quot;true&quot; /&gt;&lt;/platform&gt; 内容提供者1234567891011&lt;platform name=&quot;android&quot;&gt; &lt;!-- 访问其他应用的内容需要配置应用读写权限 --&gt; &lt;uses-permission android:name=&quot;android.permission.READ_CALENDAR&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_CALENDAR&quot;/&gt; &lt;!-- 如果不是上面Calendar这种系统provider(android.provider.*)，则需要注册 --&gt; &lt;provider android:name=&quot;org.apache.cordova.provider.TestContentProvider&quot; android:authorities=&quot;org.apache.cordova.provider.testprovider&quot; android:exported=&quot;false&quot; /&gt;&lt;/platform&gt; jar+aar+so配置jar配置123&lt;platform name=&quot;android&quot;&gt; &lt;lib-file src=&quot;src/android/libs/jpush-android-3.0.1.jar&quot; /&gt;&lt;/platform&gt; so配置so 路径so是在NDK平台开发的，NDK是用来给安卓手机开发软件用的，但是和SDK不同的是它用的是C语言，而SDK用的是Java语言。NDK开发的软件在安卓的环境里是直接运行的，一般只能在特定的CPU指令集的机器上运行。 so配置通常配置在libs目录下 so plugin.xml配置，注意输出路径子目录也要改123456&lt;source-file src=&quot;src/android/libs/armeabi/libjcore110.so&quot; target-dir=&quot;libs/armeabi&quot; /&gt; &lt;source-file src=&quot;src/android/libs/armeabi-v7a/libjcore110.so&quot; target-dir=&quot;libs/armeabi-v7a&quot; /&gt; &lt;source-file src=&quot;src/android/libs/arm64-v8a/libjcore110.so&quot; target-dir=&quot;libs/arm64-v8a&quot; /&gt; &lt;source-file src=&quot;src/android/libs/x86/libjcore110.so&quot; target-dir=&quot;libs/x86&quot; /&gt; &lt;source-file src=&quot;src/android/libs/x86_64/libjcore110.so&quot; target-dir=&quot;libs/x86_64&quot; /&gt;&lt;/source-file&gt; aar配置aar文件配置aar和jar类似，但是他包含了所有资源，class以及res资源文件，aar和gradle通常放在libs下 gradle配置gradle中要在repositories中配置flatDir，dependencies中配置compile的aar包 123456789101112repositories{ jcenter() flatDir{ dirs 'libs' }}dependencies { compile 'com.android.support:appcompat-v7:23.1.0' compile(name:'ijkplayer-java-debug', ext:'aar') compile(name:'giraffeplayer-debug', ext:'aar')} aar plugin.xml12345 &lt;platform name=&quot;android&quot;&gt; &lt;framework src=&quot;src/android/libs/giraffeplayer-build.gradle&quot; custom=&quot;true&quot; type=&quot;gradleReference&quot; /&gt; &lt;resource-file src=&quot;src/android/libs/giraffeplayer-debug.aar&quot; target=&quot;libs/giraffeplayer-debug.aar&quot; /&gt; &lt;resource-file src=&quot;src/android/libs/ijkplayer-java-debug.aar&quot; target=&quot;libs/ijkplayer-java-debug.aar&quot; /&gt;&lt;/platform&gt; 静态资源和java文件静态资源路径静态资源规定放在src/android/res目录下 静态资源输出目录配置 通过resource-file和source-file配置当前路径和输出路径，静态资源默认路径是src/android/res/xxx, 输出路径是res/xxx12345678910111213&lt;platform name=&quot;android&quot;&gt; &lt;source-file src=&quot;src/android/res/drawable-hdpi/jpush_richpush_btn_selector.xml&quot; target-dir=&quot;res/drawable&quot; /&gt; &lt;source-file src=&quot;src/android/res/drawable-hdpi/jpush_richpush_progressbar.xml&quot; target-dir=&quot;res/drawable&quot; /&gt; &lt;source-file src=&quot;src/android/res/drawable-hdpi/jpush_ic_richpush_actionbar_back.png&quot; target-dir=&quot;res/drawable-hdpi&quot; /&gt; &lt;source-file src=&quot;src/android/res/drawable-hdpi/jpush_ic_richpush_actionbar_divider.png&quot; target-dir=&quot;res/drawable-hdpi&quot; /&gt; &lt;source-file src=&quot;src/android/res/layout/jpush_popwin_layout.xml&quot; target-dir=&quot;res/layout&quot; /&gt; &lt;source-file src=&quot;src/android/res/layout/jpush_webview_layout.xml&quot; target-dir=&quot;res/layout&quot; /&gt; &lt;source-file src=&quot;src/android/res/layout/test_notification_layout.xml&quot; target-dir=&quot;res/layout&quot; /&gt; &lt;source-file src=&quot;src/android/res/values/jpush_style.xml&quot; target-dir=&quot;res/values&quot; /&gt;&lt;/platform&gt; java文件路径java文件通常放在src/android目录下 java文件输出目录配置 默认路径是src/android/Xxx.java 输出目录是src/包/名/字/，注意target-dir是目录路径，target才是文件路径。1234&lt;platform name=&quot;android&quot;&gt; &lt;source-file src=&quot;src/android/MyReceiver.java&quot; target-dir=&quot;src/cn/jpush/phonegap&quot; /&gt; &lt;source-file src=&quot;src/android/JPushPlugin.java&quot; target-dir=&quot;src/cn/jpush/phonegap&quot; /&gt;&lt;/platform&gt; meta-data拿一个分享插件举例做示范 plugin.xml：配置preference，用于接收用户传参variable的值，config-file中配置meta-data, 保存参数键值信息用于给java类调用。 1234567891011&lt;preference name=&quot;WEIXIN_APP_ID&quot; /&gt;&lt;platform name=&quot;android&quot;&gt; &lt;preference name=&quot;WEIXIN_APP_ID&quot; value=&quot;WEIXIN_APP_ID&quot; /&gt; &lt;!-- 友盟 AK --&gt; &lt;meta-data android:name=&quot;WEIXIN_APP_ID&quot; android:value=&quot;WEIXIN_APP_ID&quot; &gt; &lt;/meta-data&gt;&lt;/platform&gt; 权限当需要使用系统的某个功能时，一定要加上权限询问配置，所有的权限在这查看 1234567891011&lt;platform name=&quot;android&quot;&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_LOCATION_EXTRA_COMMANDS&quot; /&gt;&lt;/platform&gt; l 开发进阶之插件实现 开启活动简单来说，活动相当于angular的page，vue的vue，是一个可包含组件（fragment）的ui页面。 开启普通活动12345678910111213141516171819202122232425// 应用上下文Context context = cordova.getActivity().getApplicationContext();String pkgName = context.getPackageName();// 打开app应用Intent intent = context .getPackageManager() .getLaunchIntentForPackage(pkgName);// 打开XxxActivity// Intent intent=new Intent(cordova.getActivity(), XxxActivity.class);// 打开应用必须要加 CATEGORY_LAUNCHERintent.addCategory(Intent.CATEGORY_LAUNCHER);intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_SINGLE_TOP);// 启动应用context.startActivity(intent);// 启动活动// cordova.getActivity().startActivity(intent);// 启动有返回值的活动// cordova.startActivityForResult((CordovaPlugin) this, intent, 0); 本插件中开启活动代码 1234567891011public class ThsToast extends CordovaPlugin { private static final String TAG = &quot;ThsToast&quot;; @Override public boolean execute(String action, JSONArray args, CallbackContext callbackContext) throws JSONException { Log.d(TAG, &quot;start execute!&quot;); // 启动活动 Intent intent = new Intent(cordova.getActivity(), MyActivity.class); cordova.getActivity().startActivity(intent); }} 启动活动演示： 打开第三方Android SDK活动 如:百度地图uri12345678// 如果有百度地图 uri详情：http://lbsyun.baidu.com/index.php?title=uri/api/androidIntent intent = Intent.parseUri(&quot;intent://map/direction?&quot; + &quot;origin=&quot;+options.getOrigin4Baidu() + &quot;&amp;destination=&quot;+options.getDestination4Baidu() + &quot;&amp;mode=&quot;+options.getModel4Baidu() + &quot;&amp;coord_type=wgs84&amp;referer=Autohome|GasStation#Intent;scheme=bdapp;package=com.baidu.BaiduMap;end&quot;,0); cordova.getActivity().startActivity(intent); 使用广播广播其实就是一个在app范围内的事件推送和接受中心，类似于iframe的postMessage。 在cordova项目中使用和原生广播没有区别，一般静态广播用在插件比较多，如果是动态广播，则需要在activity中通过registerReceiver注册 12345678910111213public class ThsToast extends CordovaPlugin { private static final String TAG = &quot;ThsToast&quot;; @Override public boolean execute(String action, JSONArray args, CallbackContext callbackContext) throws JSONException { Log.d(TAG, &quot;start execute!&quot;); // 动态注册广播： MyBroadcastReceiver myReceiver = new MyBroadcastReceiver(); IntentFilter itFilter = new IntentFilter(); itFilter.addAction(&quot;android.intent.action.AIRPLANE_MODE&quot;); cordova.getContext().registerReceiver(myReceiver, itFilter); }} android/MyBroadcastReceiver.java 1234567891011public class MyBroadcastReceiver extends BroadcastReceiver { private String ACTION_BOOT = &quot;android.intent.action.AIRPLANE_MODE&quot;; @Override public void onReceive(Context context, Intent intent) { String action = intent.getAction(); if (ACTION_BOOT.equals(action)) { Toast.makeText(context, &quot;切换飞行模式！&quot;, Toast.LENGTH_SHORT).show(); } }} 广播效果演示： 使用服务服务可以同步或执行一些小任务、小进程，甚至对其他进程的ui页面做操作，可类比angular的service服务。 和原生Service一样的用法 12345678910public class ThsToast extends CordovaPlugin { private static final String TAG = &quot;ThsToast&quot;; @Override public boolean execute(String action, JSONArray args, CallbackContext callbackContext) throws JSONException { Log.d(TAG, &quot;start execute!&quot;); // 启动服务 cordova.getContext().startService(new Intent(cordova.getActivity(), MyService.class)); }} 使用内容提供者内容提供者其实是一个手机系统范围的API调度中心，比如可以读取和修改通讯录和相册的内容。 使用jar+aar+so使用jarjar包可以理解为api的集合，解压后全部是编译好的class，但是不包含资源文件，可以直接使用使用其中的类。jar包路径通常位于libs目录下查看依赖的api源文件 使用so通常在jar中使用 使用aar例如跳转activity 使用meta-data保存用户添加插件时传入的参数键值对象 meta-data 在java中获取参数对象Plugin.java：通过cordova.getActivity().getPackageManager().getApplicationInfo(cordova.getActivity().getPackageName(), PackageManager.GET_META_DATA)获取参数存储的对象appInfo，再通过appInfo.metaData.getType(key)取得参数value，getType有getString、getInt…… meta-data 如何传参传入插件参数有两种办法， 1.用cordova 安装时利用–variable key=value 传入 1cordova plugin add cordova-plugin-share --variable WEIXIN_APP_ID=xxx --variable WEIXIN_APP_SECRET=xxx 2.添加插件完成后，在项目的config.xml中手动添加，cordova build后生效 1234&lt;plugin name=&quot;cordova-plugin-share&quot; spec=&quot;1.0.0&quot;&gt; &lt;variable name=&quot;WEIXIN_APP_ID&quot; value=&quot;xxx&quot; /&gt; &lt;!--...--&gt;&lt;/plugin&gt; 使用权限1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import android.Manifest;public static final String WRITE = Manifest.permission.WRITE_EXTERNAL_STORAGE;public static final String READ = Manifest.permission.READ_EXTERNAL_STORAGE;public static final int REQ_CODE = 0;@Overridepublic boolean execute(String action, JSONArray args, CallbackContext callbackContext) throws JSONException { if (action.equals(&quot;show&quot;)) { this.args = args; this.callbackContext = callbackContext; if (cordova.hasPermission(READ) &amp;&amp; cordova.hasPermission(WRITE)) { // 有权限则跳转活动 this.launchActivity(); } else { // 若没有权限则请求 this.getPermission(); } return true; } return false;}/*** 请求权限**/protected void getPermission() { cordova.requestPermissions(this, REQ_CODE, new String[]{WRITE, READ});}@Overridepublic void onRequestPermissionResult(int requestCode, String[] permissions, int[] grantResults) throws JSONException { for (int r : grantResults) { if (r == PackageManager.PERMISSION_DENIED) { this.callbackContext.sendPluginResult(new PluginResult(PluginResult.Status.ERROR, PERMISSION_DENIED_ERROR)); return; } } switch (requestCode) { case REQ_CODE: launchActivity(); break; }} 使用生命周期和常用钩子excute：执行插件方法调用插件执行方法。第一个参数action是调用的方法名，第二个参数args是传入的参数数组，第三个参数CallbackContext是传入的回调函数上下文，可以通过callbackContext.success(message)和callbackContext.error(errorMessage)传入回调参数; 123@Overridepublic boolean execute(String action, JSONArray args, CallbackContext callbackContext) throws JSONException {} initialize：初始化在插件构造函数执行和字段初始化之后调用，此时尚未执行excute方法。 12@Overridepublic void initialize (CordovaInterface cordova, CordovaWebView webView) {} pluginInitialize：无参初始化在插件构造函数执行和字段初始化之后调用，没有参数，此时尚未执行excute方法，pluginInitialize 不支持 cordova 3.0-3.5 。 12@Overrideprotected void pluginInitialize() {} 插件初始化到执行的过程执行顺序如下，依次是initialize、pluginInitialize、execute： 1232020-09-03 00:20:34.928 19307-19435/com.ths.exam.lilin D/ThsToast: start initialize!2020-09-03 00:20:34.928 19307-19435/com.ths.exam.lilin D/ThsToast: start pluginInitialize!2020-09-03 00:20:34.929 19307-19435/com.ths.exam.lilin D/ThsToast: start execute! onStart：活动开始周期活动正在被启动，已经可见，但是还没位于前台。 12@Overridepublic void onStart() {} onResume：活动恢复周期活动位于前台，并且可以与用户交互了。 12345678910/** * 当活动将开始与用户互动时调用。 * * @param multitasking 表示是否为应用程序打开了多任务 */@Overridepublic void onResume(boolean multitasking) { super.onResume(multitasking); // deviceready();} onPause：活动暂停周期活动处于正在停止的状态，通常当要离开这活动的时候会被调用。接下去onStop()马上会被调用，如果是弹出一个对话框，那么onStop不会被调用。 123456789/** * 在系统即将开始恢复上一个活动时调用 * * @param multitasking 表示是否为应用程序打开了多任务 */@Overridepublic void onPause(boolean multitasking) { super.onPause(multitasking);} onStop：活动停止周期活动即将停止，活动完全不可见。 1234567/** * 活动停止前调用 */@Overridepublic void onStop() { super.onStop();} onReset：活动重置周期这个方法表示活动正在重新启动，活动由停止状态恢复为运行状态，通常由上一个活动返回到这个活动时，这个活动会调用此方法。 12345/** * 当视图导航时调用 */@Overridepublic void onReset() {} onActivityResult：返回活动数据当从另一个活动返回到当前活动时，当前活动中的onActivityResult可接收刚才活动的返回数据。 1234@Overridepublic void onActivityResult(int requestCode, int resultCode, Intent intent) { super.onActivityResult(requestCode, resultCode, intent);} onDestroy：活动销毁周期活动完全销毁前调用，可以在这做一些资源释放的操作。 1234567/** * 活动销毁前调用 */@Overridepublic void onDestroy() { // deviceready = false;} l 总结本文从创建一个简单的cordova自定义插件，到四大组件的配置和使用，以及如何导入和使用jar、aar、so、静态资源方面做了详细讲解，最后归纳了常用的生命周期和回调方法。看到这，我们应该已经具备独立创建和改写插件的基本能力，剩下的就只有自己多看多用cordova-plugin，实践出真知，若有总结不到位或者遗漏的地方，还请各位朋友多多指出，共同交流完善！如果这篇文章对前端或其他方向的你有所帮助或者启发，记得点个赞哦亲：） l 下载文中演示的插件1cordova plugin add cordova-plugin-ths-toast","link":"/2020/10/14/%E4%BB%8E%E9%9B%B6%E5%88%9B%E5%BB%BACordova%E6%8F%92%E4%BB%B6-%E8%BF%9B%E9%98%B6/"},{"title":"原型链详解","text":"原型链详解一、什么是原型链1994年，网景公司（Netscape）发布了Navigator浏览器0.9版后，意识到Web需要变得更加动态。该公司的创始人马克·安德森（Marc Andreessen）认为HTML需要一种“胶水语言”，Web设计人员和兼职程序员可以轻松地使用它们来组装诸如图像和插件之类的组件，这些代码可以直接在网页中编写。 1995年，该公司招募了Brendan Eich，其目标是创建一个脚本语言将补充Java，并且应具有相似的语法。艾克（Eich）在1995年5月的10天内就发明了一个。尽管该语言是以Mocha的名称开发的，但该语言在1995年9月首次发布于Netscape Navigator 2.0的Beta版本中时正式被称为LiveScript，但当它于12月在Netscape Navigator 2.0 beta 3中进行部署时被重新命名为JavaScript。 Javascript和基于类的语言（Java、C#）不同，它参考了Self语言（一种基于原型的面向对象程序设计语言），通过原型来实现继承（方法或属性的共享），确切地说是委托。 当在某个对象上的方法或属性不存在时，会在它的原型上去查找，如还不存在就会去它原型的原型上查找，这样形成一条链路就是原型链。 可以理解为下文要提到的 person.proto.proto.proto… 二、JS创建对象的三种方式有人说JS一切皆对象，是错误的！原始值就不是。那么对象如何创建呢？ 2.1 使用 new 加 函数创建对象12345var person = new Object();person.name = 'lili';person.sayHello = function() { console.log('Hello!')} 2.2 使用字面量创建对象 123456 var person = {​ name: 'lili',​ sayHello: function () {​ console.log('Hello!')​ } } 注：var person = {} 等同于 var person = new Object()。 2.3 使用Object.create()方法创建对象 123456789 var person = {​ name: 'lili',​ sayHello: function () {​ console.log('Hello!')​ } } var me = Object.create(person); me.name = 'wangwang'; Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__，即： me.__proto__=== person。 三、构造函数3.1构造函数是什么？通过 new 函数名来实例化对象的函数叫构造函数。 任何的函数都可以作为构造函数。 之所以有构造函数与普通函数之分，主要从功能上进行区别的，构造函数的主要功能为初始化对象,特点是和new一起使用。构造函数可以为初始化的对象添加属性和方法。 下面我们从例子看下构造函数。 123function Person() {}var person1 = new Person()var person2 = new Person() 上面的person1和person2都是通过Person函数实例化出来的。这个Person函数就是当前person1和person2的构造函数。对象上的constructor属性可以指明这个对象的构造函数是什么。 12person1.constructor === Person // trueperson2.constructor === Person // true 对于上面的Person函数来说，本身也是一个对象，那么这个对象是如何实例化出来的呢? 它的constructor又指向谁呢? 那就要说到创建函数对象的方法。 123456function foo() { console.log('你好');}var foo1 = new Function('console.log(&quot;你好2&quot;)');foo();foo1(); Person函数是由JS内置函数Function函数实例化，Person.constructor === Function。而Function本身还是个构造函数，它的constructor是本身。 3.2constructor 属性在哪里当你打开编辑器，按我上面的例子去打印上面的例子中的person1，查看它的constructor属性，会发现看不见constructor属性呢？打印如下： 为什么呢，明明可以访问到啊（person2.constructor === Person），这个问题先留着，接着往下看。 四、prototype是什么，有什么用呢4.1prototype的意义上面的通过new创建实例的方法中我们如何做到共享属性和方法呢？ 比如，所有的实例都具有黑色头发这个属性，都有可以说话这个方法，那么我们通过上面的方法创建实例，如何添加这个属性和方法呢。代码如下： 1234567891011function Person() {}var person1 = new Person()var person2 = new Person()person1.hairColor = 'black';person2.hairColor = 'black';person1.sayHello = function () { console.log('Hello!')};person2.sayHello = function () { console.log('Hello!')}; 如果，我现在要修改，所有这些实例的对象的头发都是红色，怎么办？又去每个对象都修改为红色？代码冗余。有人说，那我可以把属性的复制放在构造函数中完成，比如： 123456function Person() { this.hairColor = 'balck'; this.sayHello = function () { console.log('Hello!') };} 没有问题。那么我再提另一个问题，假如这些人都共享居所，或者资金，比如北京有一套房。那么，如果其中有一个人赚了一套房，这些人是可以共享的，那么上面的方法如何做到呢？ 同时，每次实例化都要为属性和方法开辟新的内存空间,那如果实例多个对象的话，非常浪费内存空间。 那么基于上面的问题，就需要说到prototype属性，给构造函数设置一个prototype属性。这个属性是一个对象，所有实例对象需要共享的属性和方法，都放在这个对象里面。代码示例如下： 1234567function Person() {}Person.prototype.hairColor = 'back';Person.prototype.sayHello = function () { console.log('Hello!')};var person1 = new Person()var person2 = new Person() 用上面的方法，可以解决内存浪费问题，所有共享属性和方法都放在prototype中，只需要开辟其相对应的内存，同时也能实现数据共享和继承。那么Function作为Person函数的构造函数，是不是也应该有个prototype属性，存放Person函数可以从Function那里共享的属性和方法呢。 上面已经说了prototype的作用，所有函数都可以是构造函数，所以，所有函数都具有prototype属性，里边可存放所有可供其实例继承的共享属性和方法。 总结：1.所有函数都具有prototype属性。2.prototype存放了实例的共享属性和方法。3.prototype是一个对象，有的人称它为显式原型。 4.2constructor的真正位置那么说到这里，我们解决下3留下的问题，为什么实例打印的时候没有显示它的constructor这个属性呢。假如每个实例都给赋值了一个constructor属性，类似于我们3中说的那样，那是不是就遇到了我们3说的问题呢，会不断开辟内存去存放，浪费内存，所以，同理，实例的constructor存放在这个实例的构造函数的prototype中共享。 五、__proto__是什么，有什么用？5.1 [[Prototype]]属性我们上面说到了prototype存放了共享的属性和方法，那么我们的实例是如何继承这些共享的属性和方法。我们自然会想到在每个实例对象内部创建一个属性等于自己的原型（构造函数上的prototype）。是不是就可以通过对象去获取到共享的属性和方法了呢？（及person1.这个属性 === Person.prototype，又因为Person.prototype里存放了hairColor属性，所以，通过person1.这个属性.hairColor就可以获取这个共享的hairColor的值是多少。） [[Prototype]]就是所说的这个对象属性，指向同构造函数上的prototype，也是这个实例真正意义上的原型对象，这个属性是内部隐藏属性，不对外提供访问，所以我们通过 对象.[[Prototype]] 无法查看和修改原型上的属性和方法。 那么说到这里，结合前面说到问题，是不是有人会问， 既然对象.[[Prototype]]=== 构造函数.prototype。那我是不是只要获取到构造函数的prototype，就可以查看原型对象和修改原型对象呢。没错，是的，只要你知道这个对象的构造函数。那你可能接着问，那还不简单，前面不是说了嘛，对象.constructor === 对象的构造函数。那我是不是就可以通过对象.constructor找到对象的构造函数呢。那么，我们接着往下看。 5.2 constructor不可信修改上面相关列子，如果定义一个Dog函数，Dog函数共享的头发颜色是红色， person1.constructor = Dog,那么这个时候person1的hairColor颜色是什么呢。代码如下 12345678910111213141516function Person() { } Person.prototype.hairColor = 'back'; Person.prototype.sayHello = function () { console.log('Hello!') }; var person1 = new Person(); var person2 = new Person(); function Dog(){ } person1.constructor = Dog; Dog.prototype.hairColor = 'red'; // 在Dog.prototype上定义hairColor属性 console.log(person1.constructor); // Dog console.log(person2.constructor); // Person console.log(person1.hairColor); // balck 所以从上面的例子可以看出person1.constructor是Dog，但是头发颜色是balck而不是red，所以通过constructor去获取实例的构造函数，然后获取共享属性（hairColor）的方法不可取。 那我想获取到原型对象，查看共享的属性和方法，以及实现修改共享的属性和方法咋办啊？ [[Prototype]]属性我又得不到。接着往下看。 5.3 __proto__为了实现上面我们说的问题，后来许多浏览器厂商实现了 __proto__属性 ，（最开始是火狐浏览器提供的__proto__）暴露了对象的[[Prototype]]。__proto__指向了[[Prototype]]，我们就可以通过对象.__proto__得到对象原型对象上的属性和方法，同样也可以去修改。 对象.[[Prototype]] = 创建自己的构造函数内部的prototype（原型对象） 对象.__proto__= 对象.[[Prototype]] 对象.__proto__ = 创建自己的构造函数内部的prototype（原型对象） 注意：__proto__在ES6以前不是JS标准，是浏览器给提供的。由于越来越流行，运用广泛，在es6规范中被标准化为传统功能，以确保Web浏览器的兼容性。它已被不推荐使用, 现在更推荐使用Object.getPrototypeOf，Object.setPrototypeOf。 那么，上面的图中Function函数也是一个对象，它的__proto__指向了什么呢？我们说了对象.__proto__ = 对象的构造函数.prototype。由于上面讲到过的，那么Function的构造函数是其本身，所以Function.__proto__ === Function.prototype。 六、原型模式 JavaScript 中除了基础类型外的数据类型，都是对象（引用类型）。但是由于其没有类（class，ES6 引入了 class，但其只是语法糖）的概念，如何将所有对象联系起来就成立一个问题，于是就有了原型和原型链的概念。 所有的引用类型（数组、对象、函数）都有一个 __proto__属性(隐式原型属性），本质是个对象。 所有的函数，都有一个 prototype(显式原型）属性，存放了其实例可共享的属性和方法。 对象的__proto__等于实例这个对象的构造函数的prototype。 Object.prototype没有 __proto__，这也是原型链的终点。 上面总结了下原型链的基本知识，下面我们通过例子详细说明。 七、通过例子详细说明原型链的查找7.1原型链上查找某个对象是否具有某个属性所谓的原型链上去查找，其实就是通过对象的__proto__去查找。（这个链可以理解为用__proto__去连接） 1.先查看实例上是否具有该属性。及对象.属性是否有值有就找到了。 2.如果1中没找到，就去实例的原型对象（proto ）找有没有该属性。及**对象.__proto__**上是否有值 。 3.如果2中没找到，就对象.__proto__.__proto__**找有没有该属性。一直通过.__proto__链接下去，直到终点。** 我们下面通过详细的例子说明原型链的查找，找下这个人的头发是什么颜色。 7.2 例子112345678function Person(name) { this.name = name; } var person1 = new Person('lili'); person1.hairColor = 'red'; console.log(person1); console.log(person1.hairColor); person1被Person构造函数实例化，我们给这个person1加了属性hairColor，这个时候 person1上具有hairColor的（person1.hairColor = ‘red’），就是我们后来给他赋值的颜色，红色。打印如下： 7.3例子2123456789function Person(name) { this.name = name; } Person.prototype.hairColor = 'black'; var person1 = new Person('lili'); console.log(person1); console.dir(Person); console.log(person1.hairColor); 第一步：person1被构造函数实例化的时候，是否初始化了hairColor的值呢。我们可以从上面的代码中看见，构造函数只初始化了一个属性name的值，所以personOne没有hairColor这个值。打印如下图： 第二步：这个对象是否有像例子1中（person1.hairColor = ‘red’），给实例对象赋值。显然也没有。对象实例上没有找到hairColor这个属性。 第三步：找这个对象的原型对象及person1.__proto__是否有hairColor的值； person1.__proto__ === person1的构造函数.prototype及Person.prototype； Person.prototype有没有hairColor这个属性呢？看代码Person.prototype.hairColor = ‘black’，是有的，黑色，原型链查找结束。所以我们知道了person1的原型的头发是黑色的，所以person1继承这个头发的颜色，也是黑色的。如下图： 所以person1.hairColor === ‘black’； 那么有个问题，原型链不断向上查找的头是哪里呢？ 我们再看个例子，去掉上个例子中Person.prototype.hairColor = ‘black’，如下： 7.4例子312345678function Person(name) { this.name = name; } var person1 = new Person('lili'); console.log(person1); console.dir(Person); console.log(person1.hairColor); 还是查找person1.hairColor的值。 第一步：如上个例子的第一步，不细说了。 第二步：如上个例子第二步，不细说了。 第三步：如上个例子第三步，这个时候我们发现，Person.prototype也没有hairColor的值。 及person1.__proto__上也没找到hairColor的值。 第四步：（1）查找person1.__proto__.__proto__，那么person1.__proto__.__proto__是什么呢？ （2）第三步中我们知道了person1.__proto__=== Person.prototype，person1.__proto__.__proto__ === Person.prototype.__proto__。 （3）那么Person.prototype是什么呢？是Person函数的原型，本身是个对象，那么对象.__proto__=== 对象的构造函数的prototype，那这个对象的构造函数是什么呢，是JS的内置Object函数实例化的。所以上面的问题就变成Person.prototype.__proto__=== Object.prototype。查找Object函数的prototype上是否有hairColor属性吗？显然也没有。继续查找。 第四步：查找person1.__proto__.__proto__.__proto__，及Object.prototype的__proto__，而Object.prototype是没有__proto__，所以到此结束。 八、JS的内置函数8.1Array ​ Array.prototype // [] ​ Array.__proto__ // Function.prototype Array.__proto__.__proto__ {}.__proto__ === Object.prototype 8.2 Object ​ Objecy.prototype // {} ​ Objecy.__proto__ // Function.prototype 8.3Function ​ Function.prototype // ƒ () ​ Function.__proto__ // Function.prototype 8.4String ​ String.prototype // 空字符串 ​ String.__proto__ // Function.prototype 就这些呢，其他自己看吧。 九、实战9.1 题1123456789101112131415 function A() {} function B(a) { this.a = a; } function C(a) { if (a) { ​ this.a = a; } } A.prototype.a = 1; B.prototype.a = 1; C.prototype.a = 1;​ console.log(new A().a);​ console.log(new B().a); console.log(new C(2).a); 9.2 题212345678910111213141516171819var F = function() {};Object.prototype.a = function() { console.log(&quot;a()&quot;);};Function.prototype.b = function() { console.log(&quot;b()&quot;);};var f = new F();F.a();F.b();f.a();f.b();console.log(new A().a);console.log(new B().a);console.log(new C(2).a); 答案：a() b() a() f.b is not a function 参考文章：https://juejin.im/post/6844903837623386126#heading-4","link":"/2020/10/19/%E5%8E%9F%E5%9E%8B%E9%93%BE%E8%AF%A6%E8%A7%A3/"},{"title":"HTTP协议演变","text":"简介HTTP（HyperText Transfer Protocol）是万维网（World Wide Web）的基础协议。自 Tim Berners-Lee 博士和他的团队在1989-1991年间创造出它以来，HTTP已经发生了太多的变化，在保持协议简单性的同时，不断扩展其灵活性。如今，HTTP已经从一个只在实验室之间交换文件的早期协议进化到了可以传输图片，高分辨率视频和3D效果的现代复杂互联网协议。 1 HTTP/0.9最初版本的HTTP协议并没有版本号，后来它的版本号被定位在 0.9 以区分以后的版本。 HTTP/0.9 极其简单：请求由单行指令构成，以唯一可用方法GET开头，其后跟目标资源的路径（一旦连接到服务器，协议、服务器、端口号这些都不是必须的）。 GET /mypage.html 响应也极其简单的：只包含响应文档本身。 123&lt;HTML&gt;这是一个非常简单的HTML页面&lt;/HTML&gt; 跟后来的版本不同，HTTP/0.9 的响应内容并不包含HTTP头，这意味着只有HTML文件可以传送，无法传输其他类型的文件；也没有状态码或错误代码：一旦出现问题，一个特殊的包含问题描述信息的HTML文件将被发回，供人们查看。 2 HTTP/1.01996年11月，一份新文档（RFC 1945）被发表出来，文档 RFC 1945 定义了 HTTP/1.0，但它是狭义的，并不是官方标准。新增了一下主要内容： 具备了传输除纯文本HTML文件以外其他类型文档的能力 引入了HTTP头的概念，无论是对于请求还是响应，允许传输元数据，使协议变得非常灵活，更具扩展性。 其次，除了GET命令，还引入了POST命令和HEAD命令，丰富了浏览器与服务器的互动手段。 状态码会在响应开始时发送，使浏览器能了解请求执行成功或失败，并相应调整行为协议版本信息现在会随着每个请求发送（HTTP/1.0被追加到了GET行）。 2.1 请求格式1234567891011GET /mypage.html HTTP/1.0User-Agent: NCSA_Mosaic/2.0 (Windows 3.1)200 OKDate: Tue, 15 Nov 1994 08:12:31 GMTServer: CERN/3.0 libwww/2.17Content-Type: text/html&lt;HTML&gt;一个包含图片的页面 &lt;IMG SRC=&quot;/myimage.gif&quot;&gt;&lt;/HTML&gt; 接下来是第二个连接，请求获取图片： 12345678GET /myimage.gif HTTP/1.0User-Agent: NCSA_Mosaic/2.0 (Windows 3.1)200 OKDate: Tue, 15 Nov 1994 08:12:32 GMTServer: CERN/3.0 libwww/2.17Content-Type: text/gif(这里是图片内容) 第一行是请求命令，必须在尾部添加协议版本（HTTP/1.0）。后面就是多行头信息，描述客户端的情况。回应的格式是”头信息 + 一个空行（\\r\\n） + 数据”。其中，头信息第一行是”协议版本 + 状态码（status code） + 状态描述”。 2.2 头信息中一些字段说明2.2.1 Content-Type 字段关于字符的编码，1.0版规定，头信息必须是 ASCII 码，后面的数据可以是任何格式。因此，服务器回应的时候，必须告诉客户端，数据是什么格式，这就是Content-Type字段的作用。下边常见Content-Type字段的值： 123456text/htmltext/cssimage/pngimage/gifapplication/javascriptapplication/octet-stream 这些数据类型总称为MIME type，MIME type还可以在尾部使用分号，添加参数。 Content-Type: text/html; charset=utf-8 客户端请求的时候也可以使用Accept声明自己接收的数据格式 accept: */* 2.2.2 Content-Encoding字段由于传输的数据可能比较大，一次可以将数据压缩后进行传输。Content-Encoding字段就是说明数据压缩的方法。 123content-encoding: gzipContent-Encoding: compressContent-Encoding: deflate 客户端在请求时，使用Accept-Encoding字段说明自己可以接受哪些压缩方法。 Accept-Encoding: gzip, deflate 2.3 缺点HTTP/1.0 版的主要缺点是，每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。TCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）。所以，HTTP 1.0版本的性能比较差。随着网页加载的外部资源越来越多，这个问题就愈发突出了。为了解决这个问题，有些浏览器在请求时，用了一个非标准的Connection字段。 Connection: keep-alive 这个字段要求服务器不要关闭TCP连接，以便其他请求复用。服务器同样回应这个字段。 Connection: keep-alive 一个可以复用的TCP连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段，不同实现的行为可能不一致，因此不是根本的解决办法。 3 HTTP/1.11997年1月，HTTP/1.1 版本发布，只比 1.0 版本晚了半年。它进一步完善了 HTTP 协议，一直用到了20年后的今天，直到现在还是最流行的版本。 3.1 持久连接 1.1 版的最大变化，就是引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明 Connection: keep-alive。 客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送 Connection: close，明确要求服务器关闭TCP连接。 目前，对于同一个域名，大多数浏览器允许同时建立6个持久连接。 3.2 管道机制1.1 版还引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。 举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求。管道机制则是允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。 3.3 Content-Length 字段 一个TCP连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的。这就是Content-length字段的作用，声明本次回应的数据长度。 Content-Length：3495 上面代码告诉浏览器，本次回应的长度是3495个字节，后面的字节就属于下一个回应了。 在1.0版中，Content-Length 字段不是必需的，因为浏览器发现服务器关闭了TCP连接，就表明收到的数据包已经全了。 3.4 分块传输编码使用 Content-Length 字段的前提条件是，服务器发送回应之前，必须知道回应的数据长度。 对于一些很耗时的动态操作来说，这意味着，服务器要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，采用”流模式”（stream）取代”缓存模式”（buffer）。 因此，1.1版规定可以不使用 Content-Length 字段，而使用”分块传输编码”（chunked transfer encoding）。只要请求或回应的头信息有Transfer-Encoding字段，就表明回应将由数量未定的数据块组成。 Transfer-Encoding: chunked 每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度。最后是一个大小为0的块，就表示本次回应的数据发送完了。下面是一个例子。 1234567891011121314151617HTTP/1.1 200 OKContent-Type: text/plainTransfer-Encoding: chunked25This is the data in the first chunk1Cand this is the second one3con8sequence0 3.5 其他功能1.1版还新增了许多动词方法 PUT、PATCH、HEAD、 OPTIONS、DELETE 。另外，客户端请求的头信息新增了 HOST 字段，用来指定服务器的域名。 Host: www.example.com 有了 HOST 字段，就可以将请求发往同一台服务器上的不同网站，为虚拟主机的兴起打下了基础。 3.6 缺点虽然1.1版允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为”队头堵塞”（Head-of-line blocking）。 为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久连接。这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入CSS代码、域名分片（domain sharding）等等。如果HTTP协议设计得更好一些，这些额外的工作是可以避免的。 4 SPDY 协议2009年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP/1.1 效率不高的问题。这个协议在Chrome浏览器上证明可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 之中得到继承。 5 HTTP/22015年，HTTP/2 发布。它不叫 HTTP/2.0，是因为标准委员会不打算再发布子版本了，下一个新版本将是 HTTP/3。RFC 7540 定义了 HTTP/2 的协议规范和细节。 在开放互联网上HTTP 2.0将只用于https://网址，而 http://网址将继续使用HTTP/1，目的是在开放互联网上增加使用加密技术，以提供强有力的保护去遏制主动攻击 。 5.1 http2优势5.1.1 二进制协议HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”（frame）：头信息帧和数据帧。 二进制协议的一个好处是，可以定义额外的帧。HTTP/2 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。 5.1.2 多工（多路复用）HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”。 举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。 这样双向的、实时的通信，就叫做多工（Multiplexing）。 5.1.3 数据流因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。 HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。 数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM 帧），取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP/2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。 客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。 5.1.4 头信息压缩HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie和 User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。 HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。 5.1.5 服务器推送HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。 常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。 6 HTTP与HTTPS由于http/2是完全使用https协议的，需要了解下http和https的区别。HTTPS协议可以理解为HTTP协议的升级，就是在HTTP的基础上增加了数据加密。在数据进行传输之前，对数据进行加密，然后再发送到服务器。这样，就算数据被第三者所截获，但是由于数据是加密的，所以你的个人信息仍然是安全的。这就是HTTP和HTTPS的最大区别。 6.1 SSL/TLS互联网的通信安全，建立在SSL/TLS协议之上，SSL“安全套接层”协议，TLS“安全传输层”协议，都属于是加密协议，在其网络数据传输中起到保护隐私和数据的完整性。保证该网络传输的信息不会被未经授权的元素拦截或修改，从而确保只有合法的发送者和接收者才能完全访问并传输信息。 SSL :（Secure Socket Layer，安全套接字层），位于可靠的面向连接的网络层协议和应用层协议之间的一种协议层。SSL通过互相认证、使用数字签名确保完整性、使用加密确保私密性，以实现客户端和服务器之间的安全通讯。该协议由两层组成：SSL记录协议和SSL握手协议。 TLS :（Transport Layer Security，传输层安全协议），用于两个应用程序之间提供保密性和数据完整性。该协议由两层组成：TLS记录协议和TLS握手协议。 6.2 作用不使用SSL/TLS的HTTP通信，就是不加密的通信。所有信息明文传播，带来了三大风险。 窃听风险（eavesdropping）：第三方可以获知通信内容。 篡改风险（tampering）：第三方可以修改通信内容。 冒充风险（pretending）：第三方可以冒充他人身份参与通信。 SSL/TLS协议是为了解决这三大风险而设计的，希望达到： 所有信息都是加密传播，第三方无法窃听。 具有校验机制，一旦被篡改，通信双方会立刻发现。 配备身份证书，防止身份被冒充。 互联网是开放环境，通信双方都是未知身份，这为协议的设计带来了很大的难度。而且，协议还必须能够经受所有匪夷所思的攻击，这使得SSL/TLS协议变得异常复杂。 6.3 历史互联网加密通信协议的历史，几乎与互联网一样长。 1994年，NetScape公司设计了SSL协议（Secure Sockets Layer）的1.0版，但是未发布。 1995年，NetScape公司发布SSL 2.0版，很快发现有严重漏洞。 1996年，SSL 3.0版问世，得到大规模应用。 1999年，互联网标准化组织ISOC接替NetScape公司，发布了SSL的升级版TLS 1.0版。 2006年和2008年，TLS进行了两次升级，分别为TLS 1.1版和TLS 1.2版。最新的变动是2011年TLS 1.2的修订版。 目前，应用最广泛的是TLS 1.0，接下来是SSL 3.0。但是，主流浏览器都已经实现了TLS 1.2的支持。TLS 1.0通常被标示为SSL 3.1，TLS 1.1为SSL 3.2，TLS 1.2为SSL 3.3。 6.4 基本的运行过程SSL/TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。 但是，这里有两个问题。 （1）如何保证公钥不被篡改？ 解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。（2）公钥加密计算量太大，如何减少耗用的时间？ 解决方法：每一次对话（session），客户端和服务器端都生成一个”对话密钥”（session key），用它来加密信息。由于”对话密钥”是对称加密，所以运算速度非常快，而服务器公钥只用于加密”对话密钥”本身，这样就减少了加密运算的消耗时间。 因此，SSL/TLS协议的基本过程是这样的： （1） 客户端向服务器端索要并验证公钥。（2） 双方协商生成”对话密钥”。（3） 双方采用”对话密钥”进行加密通信。 上面过程的前两步，又称为”握手阶段”（handshake）。 6.5 握手阶段的详细过程 “握手阶段”涉及四次通信，我们一个个来看。需要注意的是，”握手阶段”的所有通信都是明文的。 6.5.1 客户端发出请求（ClientHello）首先，客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做ClientHello请求。在这一步，客户端主要向服务器提供以下信息。 （1） 支持的协议版本，比如TLS 1.0版。（2） 一个客户端生成的随机数，稍后用于生成”对话密钥”。（3） 支持的加密方法，比如RSA公钥加密。（4） 支持的压缩方法。 这里需要注意的是，客户端发送的信息之中不包括服务器的域名。也就是说，理论上服务器只能包含一个网站，否则会分不清应该向客户端提供哪一个网站的数字证书。这就是为什么通常一台服务器只能有一张数字证书的原因。对于虚拟主机的用户来说，这当然很不方便。2006年，TLS协议加入了一个Server Name Indication扩展，允许客户端向服务器提供它所请求的域名。 6.5.2 服务器回应（SeverHello）服务器收到客户端请求后，向客户端发出回应，这叫做SeverHello。服务器的回应包含以下内容。 （1） 确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。（2） 一个服务器生成的随机数，稍后用于生成”对话密钥”。（3） 确认使用的加密方法，比如RSA公钥加密。（4） 服务器证书。 除了上面这些信息，如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供”客户端证书”。比如，金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供USB密钥，里面就包含了一张客户端证书。 6.5.3 客户端回应客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。 如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息。 （1） 一个随机数。该随机数用服务器公钥加密，防止被窃听。（2） 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。（3） 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。 上面第一项的随机数，是整个握手阶段出现的第三个随机数，又称”pre-master key”。有了它以后，客户端和服务器就同时有了三个随机数，接着双方就用事先商定的加密方法，各自生成本次会话所用的同一把”会话密钥”。 此外，如果前一步，服务器要求客户端证书，客户端会在这一步发送证书及相关信息。 6.5.4 服务器的最后回应服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的”会话密钥”。然后，向客户端最后发送下面信息。 （1）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。 至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用”会话密钥”加密内容。","link":"/2020/10/21/HTTP%E5%8D%8F%E8%AE%AE%E6%BC%94%E5%8F%98/"},{"title":"Nest.js-基本概念介绍","text":"Nest.js1 什么是nest.jsNest.js是用于构建高效且可伸缩的服务端应用程序的渐进式 Node.js 框架。 2 nestjs的优点 完美的支持typescript，因此可以使用日益繁荣的ts生态工具 兼容express中间件，因为express是最早出现的轻量级的node server端框架，nest.js能够利用所有express的中间件，使其生态完善 层层处理，一定程度上可以约束代码，比如何时使用中间件、何时需要使用guards守卫等 依赖注入以及模块化的思想，提供了完整的mvc的链路，使得代码结构清晰，便于维护 3 概念3.1 控制器 Controller(接收数据，返回响应)客户端的请求最终交给那个函数或者模块处理都需要通过预先处理，直接处理客户端请求（路由、方法等）的模块我们称之为控制器。 控制器的目的是接收应用的特定请求 路由机制控制哪个控制器接收哪些请求 每个控制器有多个路由 不同的路由可以执行不同的操作 3.2 提供者 Provider几乎所有的东西都可以被认为是提供者 - service, repository, factory, helper 等等。他们都可以通过 constructor 注入依赖关系，也就是说，他们可以创建各种关系。但事实上，提供者不过是一个用@Injectable() 装饰器注解的简单类。 3.2.1 什么是依赖注入？ 依赖注入（Dependency Injection，简称DI） 是实现 控制反转（Inversion of Control，缩写为**IoC**） 的一种常见方式。 3.2.2 什么是控制反转？ 控制反转，是面向对象编程中的一种设计原则，可以用来降低计算机代码之间的耦合度。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象。 把有依赖关系的类放到容器中，解析出这些类的实例，就是依赖注入。目的是实现类的解耦。 实例：Class A中用到了Class B的对象b，一般情况下，需要在A的代码中显式的new一个B的对象。采用依赖注入技术之后，A的代码只需要定义一个私有的B对象，不需要直接new来获得这个对象，而是通过相关的容器控制程序来将B对象在外部new出来并注入到A类里的引用中。 举例（摘抄）：假设你是一个想开公司的富二代，开公司首先需要一间办公室。那么你不用自己去买，你只需要在你的清单列表上写上办公室这么一项，那么，你老爸已经派人给你安排好了办公室，这间办公室长什么样？多大？在哪里？是租的？还是买的？你根本不知道，你也不需要知道。 现在你又在清单上写了需要80台办公电脑，你老爸又给你安排好了80台， 你自己并不需要关心这些电脑是什么配置，买什么样的CPU性价比更高，只要他们是能办公的电脑就行了。那么你的老爸就是所谓的 IoC 容器，你在编写 Company 这个 class 的时候，你内部用到的 Office、Computers 对象不需要你自己导入和实例化，你只需要在 Company 这个类的 Constructor （构造函数） 中声明你需要的对象，IoC 容器会帮你把所依赖的对象实例注入进去。 Nest 就是建立在依赖注入这种设计模式之上的，所以它在框架内部封装了一个IoC容器来管理所有的依赖关系。 3.3 模块 Module模块是具有 @Module() 装饰器的类。 @Module() 装饰器提供了元数据，Nest 用它来组织应用程序结构。 每个 Nest 应用程序至少有一个模块，即根模块。根模块是 Nest 开始安排应用程序树的地方。事实上，根模块可能是应用程序中唯一的模块，特别是当应用程序很小时，但是对于大型程序来说这是没有意义的。在大多数情况下，您将拥有多个模块，每个模块都有一组紧密相关的功能。 @module() 装饰器接受一个描述模块属性的对象： providers controllers imports exports 3.3.1 模块声明与配置 @Module()装饰的类为模块类，该装饰器的典型用法如下： 123456789@Module({ providers: [UserService], controllers: [UserController], imports: [OrderModule], exports: [UserService]})export class UserModule {} 3.3.2 参数说明 proviers 服务提供者列表，本模块可用，可以自动注入 controllers 控制器列表，本模块可用，用来绑定路由访问 imports 本模块导入的模块，如果需要使用到其他模块的服务提供者，此处必须导入其他模块 exports 本模块导出的服务提供者，只有在此处定义的服务提供者才能在其他模块使用 3.3.3 模块化有以下优点 业务低耦合、边界清晰、便于排查错误、便于维护。 3.4 中间件 Middleware中间件是在路由处理程序 之前 调用的函数。 中间件函数可以访问请求和响应对象，以及应用程序请求响应周期中的 next() 中间件函数。 next() 中间件函数通常由名为 next 的变量表示。 中间，是客户端和路由处理的中间，我们前面提到路由交给了控制器处理，如果我们想请求在到达控制器之前或者在响应发送给客户端之前对request和response做一些处理，就可以使用中间件，在中间件定义的过程中，有一个很重要的函数——next()，他决定了请求-响应的循环系统。 中间件函数可以执行以下任务: 执行任何代码。 对请求和响应对象进行更改。 结束请求-响应周期。 调用堆栈中的下一个中间件函数。 如果当前的中间件函数没有结束请求-响应周期, 它必须调用 next() 将控制传递给下一个中间件函数。否则, 请求将被挂起。 Nest 中间件可以是一个函数，也可以是一个带有 @Injectable() 装饰器的类。 3.5 异常过滤器 Filter内置的异常层负责处理整个应用程序中的所有抛出的异常。当捕获到未处理的异常时，最终用户将收到友好的响应。 当你的项目中出现了异常，而代码中却没有处理，那么这个异常就会到Nestjs内建的异常处理层，我们通过预定义异常处理过滤器，就能将异常更友好地响应给前端。 当异常无法识别时 (既不是 HttpException 也不是继承的类 HttpException ) , 用户将收到以下 JSON 响应: 1234{ &quot;statusCode&quot;: 500, &quot;message&quot;: &quot;Internal server error&quot;} 3.6 管道 Pipe管道就是一个实现了 PipeTransform 接口并用 @Injectable() 装饰器修饰的类。 管道的作用简单来说就是，可以将输入的数据处理过后输出。 转换：将输入数据转换为所需的输出 验证：验证输入的内容是否满足预先定义的规则，当数据不正确时可能会抛出异常 把参数转化成十进制的整型数字 12345678910@Injectable()export class ParseIntPipe implements PipeTransform&lt;string, number&gt; { transform(value: string, metadata: ArgumentMetadata): number { const val = parseInt(value, 10); if (isNaN(val)) { throw new BadRequestException('Validation failed'); } return val; }} 对于get请求中的参数id，调用new ParseIntPipe方法来将id参数转化成十进制的整数。 1234@Get(':id')async findOne(@Param('id', new ParseIntPipe()) id) { return await this.catsService.findOne(id);} 3.7 守卫 Guard应用中有些请求处理不是对所有前来请求的用户完全开放的，只有具有指定身份的人才能请求某些接口，负责这一职责的功能模块称之为守卫。 Guards守卫的作用是决定一个请求是否应该被处理函数接受并处理，也可以在middleware中间件中来做请求的接受与否的处理，与middleware相比，Guards可以获得更加详细的关于请求的执行上下文信息。 举例：我们的房子为什么需要钥匙？因为我们不允许外人进入我们的房间。 通常Guards守卫层，位于middleware之后，管道之前（请求正式被处理函数处理之前）。一般使用看守器来做接口权限的验证，比如验证请求是否包含 token 或者 token 是否过期。 123456789101112import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';import { Observable } from 'rxjs';@Injectable()export class AuthGuard implements CanActivate { canActivate( context: ExecutionContext, ): boolean | Promise&lt;boolean&gt; | Observable&lt;boolean&gt; { const request = context.switchToHttp().getRequest(); return validateRequest(request); }} 1234567export interface ArgumentsHost { getArgs&lt;T extends Array&lt;any&gt; = any[]&gt;(): T; getArgByIndex&lt;T = any&gt;(index: number): T; switchToRpc(): RpcArgumentsHost; switchToHttp(): HttpArgumentsHost; switchToWs(): WsArgumentsHost;} 1234export interface ExecutionContext extends ArgumentsHost { getClass&lt;T = any&gt;(): Type&lt;T&gt;; getHandler(): Function;} 3.8 拦截器 interceptor拦截器就是使用 @Injectable 修饰并且实现了 NestInterceptor 接口的类。 拦截器可以简单理解为关卡，它可以给每一个需要执行的函数绑定，拦截器将在该函数执行前或者执行后运行。可以转换函数执行后返回的结果等。 拦截器具有一系列有用的功能，这些功能受面向切面编程（**AOP**）技术的启发。它们可以： 在函数执行之前/之后绑定额外的逻辑 转换从函数返回的结果 转换从函数抛出的异常 重写函数 举例：所有接口返回的数据结构处理。具体看项目代码 interceptors拦截器在函数执行前或者执行后可以运行，如果在执行后运行，可以拦截函数执行的返回结果，修改参数等。* 3.9 装饰器装饰器是一种特殊类型的声明，本质上就是一个方法，可以注入到类、方法、属性、参数上，扩展其功能。 通过装饰器，可以方便的修饰类，以及类的方法，类的属性等，装饰器可分为以下几种： 类的装饰器 类方法的装饰器 类函数参数的装饰器 类的属性的装饰器 举例：查看项目代码 main.ts页面 3.10 路由控制器的目的是接收应用程序的特定请求。基于路由机制来实现请求的分发。通常，每个控制器具有多个路由，并且不同的路由可以执行不同的动作。 为了创建一个基本的控制器，我们使用类和装饰器。装饰器将类与所需的元数据相关联，并使Nest能够创建路由映射（将请求绑定到相应的控制器）。 3.10.1 路由指向 打开 src 下的 main.ts，应该会看到下列代码： { NestFactory } from '@nestjs/core';1234567import { AppModule } from './app.module';async function bootstrap() { const app = await NestFactory.create(AppModule); await app.listen(3000);}bootstrap(); await NestFactory.create(AppModule)表示使用 Nest 的工厂函数创建了 AppModule。 await app.listen(3000) 表示监听的是 3000 端口，可以自定义。http://localhost:3000/thsapp/疑问：thsapp哪里来的？输出的结果是哪里来的？ 3.10.2 全局路由前缀 12345678910// src/main.tsimport { NestFactory } from '@nestjs/core';import { AppModule } from './app.module';async function bootstrap() { const app = await NestFactory.create(AppModule); app.setGlobalPrefix('thsapp'); // 全局路由前缀 await app.listen(3000);}bootstrap(); http://localhost:3000/thsapp/user2疑问：user2哪里来的？输出的结果是哪里来的？ 3.10.3 局部路由前缀 12345678910111213141516import {Controller, Get} from '@nestjs/common';@Controller('user')export class User2Controller { // http://localhost:3000/thsapp/user @Get() async getUserInfo() { return '我是用户信息'; } // http://localhost:3000/thsapp/user/info // @Get('info') // async getUserInfo() { // return '获取用户信息'; // }} 12345678910111213// src/app.controller.tsimport { Controller, Get } from '@nestjs/common';import { AppService } from './app.services';@Controller()export class AppController { constructor(private readonly appService: AppService) {} @Get() getHello(): string { return this.appService.getHello(); }} 123456789// src/app.service.tsimport { Injectable } from '@nestjs/common';@Injectable()export class AppService { getHello(): string { return 'Hello World!'; }} 3.10.4 AOP（Aspect Oriented Programming） 面向切面编程，是通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术。在运行时，动态地将代码切入到类的指定方法、指定位置上。 我们管切入到指定类指定方法的代码片段称为切面，而切入到哪些类、哪些方法则叫切入点。有了AOP，我们就可以把几个类共有的代码，抽取到一个切片中，等到需要时再切入对象中去，从而改变其原有的行为。 优点： 降低业务逻辑各部分之间的耦合度 提高程序的可重用性 提高了开发的效率 提高代码的灵活性和可扩展性 将日志记录，性能统计，安全控制，事务处理，异常处理等代码从业务逻辑代码中划分出来，通过对这些行为的分离，我们希望可以将它们独立到非指导业务逻辑的方法中，进而改变这些行为的时候不影响业务逻辑的代码。 4 层级关系 5 装饰器补充知识点在ES5中，对象中的每个属性都有一个特性值来描述这个属性的特点，他们分别是：configurable: 属性是否能被delete删除，当值为false时，其他特性值也不能被改变，默认值为trueenumerable： 属性是否能被枚举，也就是是否能被for in循环遍历。默认为truewritable: 是否能修改属性值。默认为truevalue：具体的属性值是多少，默认为undefinedget：当我们通过person.name访问name的属性值时，get将被调用。该方法可以自定义返回的具体值是多少。get默认值为undefinedset：当我们通过person.name = 'Jake'设置name属性值时，set方法将被调用，该方法可以自定义设置值的具体方式，set默认值为undefined需要注意的是，不能同时设置value，writeable与get set。我们可以通过Object.defineProperty(操作单个)与Object.defineProperties（操作多个）来修改这些特性值。 123var person = { name: 'Lily'} 123456789// 三个参数分别为 target, key, descriptor(特性值的描述对象)Object.defineProperty(person, 'name', { value: 'Lucy'})// 新增Object.defineProperty(person, 'age', { value: 20}) 123456function nameDecorator(target, key, descriptor) { descriptor.value = () =&gt; { return 'Tom'; } return descriptor;} 函数nameDecorator的定义会重写被他装饰的属性(getName)。方法的三个参数与Object.defineProperty一一对应，分别指当前的对象Person，被作用的属性getName，以及属性特性值的描述对象descriptor。函数最后必须返回descriptor。 123456789101112class Person { constructor() { this.name = 'Lily' } @nameDecorator getName() { return this.name; }}let p1 = new Person();console.log(p1.getName()) @nameDecorator，就是装饰器语法自定义函数nameDecorator的参数中，target，就是装饰的对象Person，key就是被装饰的具体方法getName。 项目开发流程上面进行了一些基本概念的介绍，相信你已经对nest有了一定的认识，下面将会对项目开发的流程做一下详细的介绍。 1 环境准备node.js: 11.13.0+npm: 6.7.0+nestjs: 6.0.0mongodb 安装MongoDBWindows: https://docs.qq.com/doc/DWG1TZkRnZ0pyT2Rn?tdsourcetag=s_macqq_aiomsg&amp;jumpuin=5682206Mac: https://sevenlet.github.io/mongodb/ 2 开始1$ npm i tfbi -g 1$ fbi init 项目名 nest-starter 1$ npm i 12345678# development$ npm run start# watch mode$ npm run start:dev# production mode$ npm run start:prod 3 目录介绍 https://github.com/THS-FE/nest-starter 4 开始编写代码4.1 配置、连接数据库1234567891011121314151617181920import { Module } from '@nestjs/common';import { AppController } from './app.controller';import { AppService } from './app.service';import { MongooseModule } from '@nestjs/mongoose';@Module({ imports: [ MongooseModule.forRoot( 'mongodb://localhost/nest-blog', // uri { // options useNewUrlParser: true }), ], controllers: [AppController], providers: [AppService],})export class AppModule { } forRoot() 方法来完成与数据库的连接 4.2 创建数据库Schema、接口 interface、DTO 数据库schema： 这是一种数据组织，它是定义数据库需要存储的数据结构和类型的蓝图。 接口 interface：TypeScript 接口用于类型检查。它可以用来定义在应用中传递的数据的类型。 数据传输对象 DTO： 这个对象定义了数据是以何种形式通过网络发送的以及如何在进程之间进行传输的。 4.21 创建schemasrc/schemas/user.schema.ts 12345678import * as mongoose from 'mongoose';export const UserSchema = new mongoose.Schema({ userName: String, password: String, realName: String, token: String,}); 4.22 创建interfacesrc/interfaces/user.interface.ts 1234567export interface User { userName: string; // 用户名 password?: string; // 密码 realName?: string; // 真实姓名 token?: string; salt?: string;} 4.23 创建DTO（data transform object 数据传输对象）src/modules/user/dtos/LoginDto.dto.ts 12345678910111213141516171819import { MinLength, IsNotEmpty } from 'class-validator';import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';import { User } from 'src/interfaces/user.interface';export class LoginDto implements User { @IsNotEmpty({ message: '不能为空' }) @ApiProperty({ description: '用户名', example: 'zhangjx' }) userName: string; // 字段——用户名 @MinLength(6, { message: '长度不能小于6', }) @ApiProperty({ description: '密码', example: '123456' }) password: string; // 字段——密码 @IsNotEmpty({ message: '不能为空' }) @ApiPropertyOptional({ description: '用户名', example: '张金秀' }) realName: string; // 字段——真实姓名} 4.3 nest-cli 创建文件指令使用 nest-cli 提供的指令可以快速创建文件，语法如下： 1$ nest g [文件类型] [文件名] [文件目录（src目录下）] 4.31 创建模块 Module1$ nest g module user modules 1234import { Module } from '@nestjs/common';@Module({})export class UserModule {} 自动在根模块引入 4.32 创建控制器 Controller1$ nest g controller user2 modules 1234import { Controller } from '@nestjs/common';@Controller('user2')export class User2Controller {} 自动在模块内引入 4.33 创建服务 Services1$ nest g service user2 modules 1234import { Injectable } from '@nestjs/common';@Injectable()export class User2Service {} 自动在模块内引入 4.34 中间件1$ nest g middleware logger middleware 4.35 拦截器1$ nest g interceptor transform interceptor 4.36 过滤器1$ nest g filter any-exception filters 1$ nest g filter http-exception filters 4.37 管道1$ nest g pipe validation pipes 5 Swagger UI查看接口文档http://localhost:3000/api-doc","link":"/2020/10/23/Nest-js-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D/"},{"title":"从零开始搭建前端项目开发环境","text":"1 写在最前为何大多数人觉得搭建一个前端项目的开发环境很困难。首先，一个完整的开发环境需要依赖多个工具，每个工具又有不计其数的配置项，想要全部理解需要花费大量的时间。其次，一些官方文档中文翻译滞后，而且结构组织的也不是很好，没有从一个具体的项目出发讲解如何配置，只看API没有什么针对性。最后，好多国内相关博客要么没有标注工具的版本，导致按照步骤进行配置时会发现自己下载的和讲述的某些地方会不一致；要么只讲如何配置，不讲配置的原因，导致大家仍是云里雾里。不过所幸，大部分CLI实现了脚手架的功能，帮助快速生成项目，而不用了解工具的具体配置。 但是，作文里总会有个转折不是。当我们需要自己独立去创建一个项目的时候…该怎么办哖，Don’t be afraid，I’m here. 接下来会先介绍一下几个常用工具（Babel 7.9.0，Browserslist 4.11.1, ESLint 7.0.0, EditorConfig）的核心概念、安装和配置，最后会结合 TypeScript + SASS + webpack5 的项目来说如何将它们整合起来形成一个完整的前端项目开发环境。 Here we go. 2 Babel (7.9.0)Babel是一个Javascript编译器。主要用于将 ECMAScript 2015+ 版本的代码转换为向后兼容(backwards compatible)的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其它环境(如：node)中。 2.1 安装123npm i -D @babel/core @babel/cli @babel/preset-envnpm i -D core-js 运行此命令之前要先初始化项目，新建项目文件夹 xxx , 在该文件夹下 运行： 1npm init 尽量不要一路回车，建议按实际内容来。 2.1.1 @babel/core主要用于将源代码(JS\\TS)解析为AST(抽象语法树)。 2.1.2 @babel/cli用于从命令行编译文件。 2.1.3 @babel/preset-env预设环境。源代码解析成AST后，还需要进行转换和生成，这是由插件来做的。@babel/preset-env(预设环境)是常用预设和插件的集合（babel-preset-es2015，babel-preset-es2016，babel-preset-es2017，babel-preset-latest，babel-preset-node5, babel-preset-es2015-node等，@babel/preset-env不支持stage-x插件）。 最初每年EcmaScript标准更新，都需要使用者手动添加最新年份的预设才能进行新语法的转换: 12345&quot;presets&quot;: [ &quot;es2015&quot;, &quot;es2016&quot;, &quot;es2017&quot; ], 后来改成了 babel-preset-latest，意思为最新的预设（包含了以往所有年份），不用每年都需要手动添加一把。最终 latest 也被废弃，变成了目前的 preset-env。开发人员可以在代码中直接书写已经正式发布的特性。不过，当ES更新时，肯定还需要更新一下 @babel/preset-env。 2.1.4 core-jsBabel 默认只转换新的 JavaScript 语法，如： 类、箭头函数、扩展运算（spread），而不转换新的 API ，如：Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise 等全局对象，以及一些定义在全局对象上的方法（如：Object.assign）。不转码的 API 详细清单可以查看 definitions.js 文件。 core-js 提供了es5、es6+的polyfills(填充物，用于实现浏览器并不支持的原生API的代码，它将一个新的 API 引入到一个旧的环境中，仅靠旧环境中已有的技术手段实现)，包括promises, symbols, collections, iterators, typed arrays等等。 这里不得不提一下该库和它的俄罗斯作者。该库一周的下载量比大家熟知的 Angular、 React、Vue加一起的下载量还要多的多。就这样的一个库谁能想到它的作者竟然需要在命令行里 looking for a good job，后来该作者又因为骑摩托车撞死一人，伤一人，被判入狱18个月, 现在应该已经处于服刑期间了… @babel/polyfill 已废弃。 2.2 配置可以在三类文件中对Babel进行配置，在项目的根目录中创建babel.config.*、.babelrc.* (* 可为 空，json, js, cjs 或 mjs) ，或在package.json中添加。 如果扩展名为 json，那一般的内容是： 1234{ &quot;presets&quot;: [...], &quot;plugins&quot;: [...]} 如果扩展名为 js，则内容为： 1234const presets = [ ... ];const plugins = [ ... ];module.exports = { presets, plugins }; 在 package.json 中： 123456789{ &quot;name&quot;: &quot;my-package&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;babel&quot;: { &quot;presets&quot;: [ ... ], &quot;plugins&quot;: [ ... ], }} 我们一般使用 babel.config.js 作为配置文件，因为在JS中可以写注释，方便理解（JSON不方便）。其它工具的配置文件能采用 js 做扩展名的也尽量使用 .js。 在项目文件夹下创建 src 目录，新建 index.js。编写内容： 12345const userInfo = new Map();userInfo.set('name', '天下布武');userInfo.set('age', 18);console.log(Object.entries(userInfo)); 在package.json中添加： 123&quot;scripts&quot;: { &quot;build&quot;: &quot;./node_modules/.bin/babel src/index.js --out-dir dist&quot;}, 2.2.1 @babel/preset-env最简设置如下(不建议，转换后会多出很多冗余代码，至少要配置一个targets)： 1234567module.exports = { presets: [ [ '@babel/preset-env', ], ],}; 在命令行中运行： 1npm run build 就能在新生成的dist文件夹中看到 编译后的 index.js ： 可以看到之前的 const 被转译成了 var。 下面对两个常用参数进行说明： 2.2.1.1 targets设置编译代码的目标平台，可以是浏览器也可以是node环境。如不设置，会将所有ES6+的代码编译为ES5-。建议设置，这样可以按目标平台来决定是否进行转换，以避免增加不必要的补丁，减少打包后的代码体积。 常见设置如下： 123456789module.exports = { presets: [ [ '@babel/preset-env', { targets: '&gt; 1%, last 2 versions, ie &gt; 8', }, ], ],}; 以上配置的意思是要兼容全球范围内使用量大于1%的浏览器和它们最新的两个版本，加上IE 9-11。这里既可以指定浏览器的版本，也可以通过查询的方式来确定要支持的浏览器。详情见Browserslist这一章节。 若设置 targets: ‘&gt; 10%’ , 再运行一次 npm run build ，因为大于 10% 的浏览器只有谷歌，它是支持 const 的, 因此编译结果几乎原封未动： 建议使用 .browserslistrc 文件来定义targets，这样其它工具(Autoprefixer、PostCSS、Stylelint 等)也能通过该配置获取到目标浏览器，从而做有针对性的处理。 2.2.1.2 useBuiltIns是否内置兼容。如果设置，就可以不用在HTML中引入polyfill的JS文件来处理浏览器的兼容性问题了。常见设置如下： 1234567891011module.exports = { presets: [ [ '@babel/preset-env', { useBuiltIns: 'usage', corejs: 3, }, ], ],}; 可选值包括：”usage” | “entry” | false。 false：默认值，即不引入polyfills，不做浏览器兼容。 entry：根据配置的浏览器，引入这些浏览器不兼容的polyfill。这个是在文件中已经明确写了import “core-js” 或其中具体某个模块（如：import “core-js/es/array”）的情况下，babel会根据 browserslist 自动添加指定浏览器不兼容的该模块下的所有polyfill，无论当前代码是否需要。 usage：会根据配置的浏览器以及代码中用到的 API 自动添加polyfill，实现了按需引入。一般使用这个配置。 只有当 useBuiltIns 的值为 entry 或 usage 时，”corejs” 这个选项才会起作用。这里如无特殊情况尽量指定 core-js 的版本为 3（默认为 2）, 因为它有很多2没有的新特性： “corejs”: 3。 这里运行 npm run build, 运行结果为： 可以看出它在全局作用域下添加了 Map 变量，同时在 Object 原型中添加了 entries 方法。 babel默认转出的是模块规范为 commonJS，只能在 Node 环境中使用，如果想在浏览器环境中使用，一般有两种方式：1、 结合 rollup2、 结合 webpack我们一般使用 第二种方式，参看最后 webpack 实例。 2.2.2 @babel/plugin-transform-runtime对于一般应用开发来说，直接使用上述的 polyfill 方案是比较方便的，但如果是开发工具、库的话，这种方案未必适合(由上图可以看出，polyfill 是添加自定义全局对象 或向对象的 prototype 上添加方法实现的)。使用 @babel/plugin-transform-runtime 这个插件就可以解决这个问题。 安装： 1npm i -D @babel/plugin-transform-runtime @babel/runtime-corejs3 配置： 123456789101112131415module.exports = { presets: [ [ '@babel/preset-env', ], ], plugins: [ [ '@babel/plugin-transform-runtime', { corejs: 3, }, ], ],}; 该插件无法读取 preset-env 的 targets 或者是 browserlist 中的目标平台参数，因此不会根据目标平台来决定是否进行转换和注入 polyfills，而是全转换和注入所有。以后可能会在 useBuiltIns 中增加一个参数 “runtime” 来代替该插件。可参见：https://github.com/babel/babel/issues/10133 再运行 npm run build，得到： 凡是require进来的模块都直接赋值给普通变量，不会对 Map 、 Object 等全局变量造成影响。 注：这里的和上边所有提到的“编译”一词更准确的说法应该是“转译（Transpile）”。 3 Browserslist (4.11.1)Browserslist 是一个能够在不同的前端工具间共享目标浏览器的配置。看配置就知道当前项目支持的浏览器有哪些。它使用 Can I Use 的数据做查询。 在项目中添加 Browserslist，常用有两种方式(不能同时在 .browserslistrc 和 package.json 中配置，否则使用 Babel 转译的时候会报错)： 在项目的根目录下添加 .browserslistrc 文件 123&gt; 1%last 2 versionsie &gt; 8 在package.json文件中增加 browserslist 节点 123456789101112{ &quot;private&quot;: true, &quot;dependencies&quot;: { }, &quot;browserslist&quot;: [ &quot;last 2 version&quot;, &quot;&gt; 1%&quot;, &quot;ie &gt; 8&quot; ]} 查询结果可通过 https://browserl.ist/ 来查看。 运行命令行： 1npx browserslist 可查看当前项目目标浏览器列表。*如果只是在 babel.config. 文件中配置了 target 是检测不出来的（会优先使用），因此建议使用 单独的 .browserslistrc 来设置。** 4 ESLint (7.0.0)是一个可以查找并且修复JavaScript(TypeScript)中错误的工具，目的是为了保证代码风格统一，避免出错。 4.1 概念4.1.1 extends（扩展）扩展里填的内容是包含了一系列规则的配置文件。这个一般不需要自己定义，因为有很多现成的：如ESLint自身的 eslint:recommended、eslint:all 和社区的 google、airbnb。 配置的模块名(npm的包名)要为 eslint-config-xxx，在配置中可缩写为 xxx。 例： 4.1.2 plugins（插件）extends 中是对 eslint 现有规则的一系列预设（开启或关闭），而 plugins 不仅可以定义预设，也可以自定义规则（比如自己创建一个 no-console2，区别于ESLint的 no-console），甚至可对不是JavaScript类型的文件（如 *ts，*.md，*.vue）扩展自己的规则。 插件的模块名一般为 eslint-plugin-xxx，在配置中可缩写为 xxx。 例： 4.1.3 rules（规则）直接配置已有规则的开启、关闭。比如强制在JavaScript中使用单引号（”quotes”: [2, “single”]）。规则定义中参数的设置说明： “off” 或 0：关闭规则 “warn” 或 1：警告，不会影响程序执行 “error” 或 2：错误，程序不能执行 4.2 安装4.2.1 针对 JavaScript1npm i -D eslint eslint-config-airbnb-base eslint-plugin-import 4.2.1.1 eslint-config-airbnb-base包含了airbnb 最基础（不包含 React 相关）的JS编码风格规则。 4.2.1.2 eslint-plugin-import上边的插件依赖这个。😛 4.2.2 针对 TypeScript1npm i -D eslint eslint-config-airbnb-typescript eslint-plugin-import @typescript-eslint/eslint-plugin 4.2.2.1eslint-config-airbnb-typescriptAirbnb 风格的 TypeScript 支持。它将一些常见配置都加了进去，省下了好多工作量。ps. 这是一个匈牙利布达佩斯技术和经济大学的学生做的，想想自己的大学生活都在做啥… 该插件包含了@typescript-eslint/parser（TypeScript 解析器），它调用@typescript-eslint/typescript-estree（通过在给定的源代码上调用 TypeScript 编译器，就是 npm i typescript -D 安装的那个，以产生TypeScript AST，然后将该AST转换为ESLint期望的格式）。ESlint默认的解析器叫 espree。 4.2.2.2 @typescript-eslint/eslint-plugin与 @typescript-eslint/parser 结合使用时，运行 TypeScript 的分析规则。 4.3 配置可使用 .eslintrc.( 可为 空，js, yaml, yml, json）或在 package.json 中配置，这里使用 .eslintrc.js 来进行配置。 一个项目中在不同的文件夹下可以有多个 .eslintrc. 配置文件，这样可以约束不同文件夹下的文件使用不同的风格，这一点和 editorConfig 一样。 4.3.1 针对 JavaScript一般配置如下： 1234567891011121314151617module.exports = { root: true, // 意思是到头啦，不要再向上找了 env: { // 代码将会在哪些环境中运行。每个环境都附带了一组特定的预定义全局变量，如 browser 中有 window，document等，添加后可以直接在代码中使用，而不报错。 browser: true, node: true, es2020: true, }, extends: 'airbnb-base', // 使用airbnb风格 parserOptions: { ecmaVersion: 2020, // 启用ES2020的语法 }, rules: { 'no-console': process.env.NODE_ENV === 'production' ? 'warn' : 'off', // 只在打包时强制不使用console 'no-debugger': process.env.NODE_ENV === 'production' ? 'warn' : 'off', // 只在打包时强制不使用debugger },}; 4.3.2 针对 TypeScript一般设置如下： 123456789101112131415161718192021module.exports = { root: true, // 意思是到头啦，不要再向上找了 env: { // 代码将会在哪些环境中运行。每个环境都附带了一组特定的预定义全局变量，如 browser 中有 window，document等，添加后可以直接在代码中使用，而不报错。 browser: true, node: true, }, extends: [ 'airbnb-typescript/base', // 使用airbnb风格 'plugin:@typescript-eslint/eslint-recommended', 'plugin:@typescript-eslint/recommended', 'plugin:@typescript-eslint/recommended-requiring-type-checking', ], parserOptions: { project: './tsconfig.json', // 要在tsconfig中设置编译的版本 }, rules: { 'no-console': process.env.NODE_ENV === 'production' ? 'warn' : 'off', // 只在打包时强制不使用console 'no-debugger': process.env.NODE_ENV === 'production' ? 'warn' : 'off', // 只在打包时强制不使用debugger },}; 最后要在 VS Code 中安装 ESLint 插件，配置相关参数，使之能够在文件保存时自动修复格式错误；WebStrom中则需设置允许 ESLint（最新的2020.1.1 版本中也能够在文件保存时自动修复错误）。 5 EditorConfig帮助在不同的编辑器或IDE上从事同一项目的多个开发人员保持一致的编码样式。 一个项目里可以有多个.editorconfig 分别放置在不同的文件夹中，当 VS Code 这类编辑器打开一个文件时，它会检查这个文件所在目录和它的父级文件夹（直到项目根目录或者是是某个文件夹中的 .editorconfig 里标识了 root = true 才会停止)中是否存在 .editorconfig。被打开的文件格式会以距当前文件最近的 .editorconfig 中的内容为准。 一般配置如下： 123456789101112131415# 告诉编辑器这是最顶层的（不要再向上找了） EditorConfig 文件root = true[*]charset = utf-8 # 设置编码为utf-8indent_style = space # 缩进方式为空格indent_size = 2 # 缩进大小为2个字符end_of_line = lf # 换行符，可选&quot;lf&quot;、&quot;cr&quot;、&quot;crlf&quot;trim_trailing_whitespace = true # 删除行尾空格insert_final_newline = true # 始终在文件末尾插入一个新行[*.md]insert_final_newline = falsetrim_trailing_whitespace = false 6 webpack (v5.0.0-beta.16)webpack是用于现代 JavaScript 应用程序的静态模块打包器。当webpack处理应用程序时，它会在内部构建一个依赖关系图，该图映射项目所需的每个模块最终会生成一个或多个包。 6.1 概念6.1.1 moduleswebpack中，无论是 JS 、CSS 还是图片等，总之一切皆模块。 有点像RxJS，一切皆数据流。模块间依赖的表述有很多种方式，如：import，require，define，@import，url(…), &lt;img src=…&gt; 等等。 6.1.2 Entry &amp; Output入口指示webpack应该使用哪个模块开始构建其内部依赖关系图。默认为： ./src/index.js。 出口告诉webpack在何处发出它创建的包文件以及如何命名这些文件。默认为： ./dist/main.js 6.1.3 Loaderswebpack 默认只能解析JavaScript和JSON，可以通过添加 Loaders 来处理其他类型的文件。 6.1.4 Plugins可以利用插件来执行更广泛的任务，例如打包优化，资产管理和环境变量的注入。 6.1.5 Mode分development、production、none三种，每种都会对应一系列默认配置。 6.2 实战接下来以初始化一个 TypeScript + SCSS 项目为例，介绍下webpack5的配置流程。 在开始之前先说下，为何没用 ts-loader 和 TSLint： 由于 TSLint 的性能不如 ESLint，再加上有很多热门的社区（React Hooks、Vue），都是通过 ESLint 来构建规则，因此，TypeScript 团队决定专注支持 ESLint。 Babel7 虽然不支持TS类型检查，但已经支持转译。 构建需要安装的插件、工具太多，能少一个就少一个，一个编译器既能支持JS，又能支持TS，为何不用。因此，感觉 ts-loader 的生命也不会太长了… Node 环境要求至少为：10.13.0。 6.2.1 初始化项目1npm init 在命令行中填入项目相关信息，不建议一路回车… 6.2.2 安装 webpackwebpack@next 是最新的 webpack5。不写@next，就是 webpack4。 1npm i -D webpack@next webpack-cli 如果需要一个web服务器做调试和热更新，则需安装： 1npm i -D webpack-dev-server 6.2.3 创建 .editorconfig统一编码样式。 123456789101112131415# 告诉编辑器这是最顶层的（不要再向上找了） EditorConfig 文件root = true[*]charset = utf-8 # 设置编码为utf-8indent_style = space # 缩进方式为空格indent_size = 2 # 缩进大小为2个字符end_of_line = lf # 换行符，可选&quot;lf&quot;、&quot;cr&quot;、&quot;crlf&quot;trim_trailing_whitespace = true # 删除行尾空格insert_final_newline = true # 始终在文件末尾插入一个新行[*.md]insert_final_newline = falsetrim_trailing_whitespace = false 6.2.4 安装 TypeScript 编译器并配置安装编译器的目的是为了配合ESLint做代码检查和自动修复。 1npm i -D typescript 在项目根目录下创建 tsconfig.json，其中可定义入口文件以及编译的参数，用于将 TypeScript 转译为 JavaScript。 一定要设置，否则在IDE做语法校验的时候，新JavaScript API（如： Object.fromEntries ）会报错。 12345678{ &quot;compilerOptions&quot;: { &quot;lib&quot;: [ &quot;ESNext&quot;, &quot;DOM&quot; ] }} ESNext 指的是TypeScript支持的最新版本的ES。它会随着ES版本的更新而自动更新，一劳永逸。DOM 类型定义，允许在TS中直接写window，document。 6.2.5 安装 ESLint 并配置1npm i -D eslint eslint-config-airbnb-typescript eslint-plugin-import @typescript-eslint/eslint-plugin .eslintrc.js 123456789101112131415161718192021module.exports = { root: true, // 这个配置同 editorConfig，意思是不要找了 env: { // 代码将会在哪些环境中运行。每个环境都附带了一组特定的预定义全局变量，如 browser 中有 window，document等，添加后可以直接在代码中使用，而不报错。 browser: true, node: true, }, extends: [ 'airbnb-typescript/base', // 使用airbnb风格 'plugin:@typescript-eslint/eslint-recommended', 'plugin:@typescript-eslint/recommended', 'plugin:@typescript-eslint/recommended-requiring-type-checking', ], parserOptions: { project: './tsconfig.json', // 要在tsconfig中设置编译的版本 }, rules: { 'no-console': process.env.NODE_ENV === 'production' ? 'warn' : 'off', // 只在打包时强制不使用console 'no-debugger': process.env.NODE_ENV === 'production' ? 'warn' : 'off', // 只在打包时强制不使用debugger },}; 6.2.6 创建 .gitignore提交Git服务器时，忽略的文件列表。使用SVN的就不需要这个了。 1234567891011121314151617181920212223.DS_Storenode_modules/dist# local env files.env.local.env.*.local# Log filesnpm-debug.log*yarn-debug.log*yarn-error.log*# Editor directories and files.idea.vscode*.suo*.ntvs**.njsproj*.sln*.sw?.git 6.2.7 创建 .browserslistrc这里设置兼容IE11。当前项目如果是作为库使用的话，该设置不会起作用。详情见：babel-plugin-transform-runtime 1234&gt; 1%last 2 versionsnot ie &lt; 11 6.2.8 安装 webpack loaders所有 Loaders 都在 webpack.config.js 文件中的 module 节点中进行添加。 6.2.8.1 转译6.2.8.1.1 babel-loader及相关webpack本身只能打包（模块合并）而没有转译的能力，TS转译成JS用的是 Babel ，并没有使用 TypeScript 编译器。 123npm i -D babel-loadernpm i -D @babel/core @babel/preset-env @babel/preset-typescript core-js babel.config.js： 12345678910module.exports = { presets: [ [ &quot;@babel/preset-env&quot;,{ &quot;useBuiltIns&quot;: &quot;usage&quot;, &quot;corejs&quot;: 3 }], &quot;@babel/preset-typescript&quot; ]} webpack.config.js 片段: 12345678910module: { rules: [ // 使用 babel-loader 解析 ts, js, tsx, jsx 文件. { test: /\\.(ts|js)x?$/, // 匹配扩展名为 .ts,.js,.tsx.jsx 的文件 use: 'babel-loader', // 使用 babel-loader 来进行解析 exclude: /node_modules/, // 排除 node_modules 文件下的文件 }, ]} 更多配置可见下方完整的配置。 当前项目将要作为库的话，还得安装： 1npm i -D @babel/plugin-transform-runtime @babel/runtime-corejs3 同时 babel.config.js 中的配置改成下面这个： 123456789101112131415module.exports = { presets: [ '@babel/preset-env', '@babel/preset-typescript', ], plugins: [ [ '@babel/plugin-transform-runtime', { corejs: 3, }, ], ],}; 6.2.8.2 样式6.2.8.2.1 sass-loader加载 SASS/SCSS 文件 并将其编译为 CSS。 1npm i -D sass-loader node-sass sass-loader 要求要安装 Dart Sass 或者是 Node Sass。弄过 NPM 下载下来的这两者只是个编译器。据说前者在node环境中性能比后者要差，因此一般都会使用 node-sass。 webpack.config.js 一般配置如下： 123456789101112131415// 执行顺序：从右到左 { test: /\\.s[ac]ss$/i, use: [ // 从字符串中创建style标签到HTML的Header中 'style-loader', // 转换CSS为字符串 'css-loader', // 给CSS添加前缀以适应各浏览器 'postcss-loader', // 编译 Sass 到 CSS 'sass-loader', ], }, 6.2.8.2.2 postcss-loader PostCSS是CSS语法转换的工具。它提供API来对CSS文件进行分析和修改它的规则。利用其插件 autoprefixer ，可以给 CSS 添加目标浏览器（Browserslist中定义的）前缀。 1234-moz- /* 火狐等使用Mozilla浏览器引擎的浏览器 */-webkit- /* Safari, 谷歌浏览器等使用Webkit引擎的浏览器 */-o- /* Opera浏览器(早期) */-ms- /* Internet Explorer */ 1npm i -D postcss-loader autoprefixer 创建 postcss.config.js, 定义 PostCSS 的插件为 autoprefixer： 123456module.exports = { plugins: { autoprefixer: {}, },}; 6.2.8.2.3 css-loader加载CSS文件，并以JS模块（CSS样式以字符串的形式封装在其中）的形式返回。 如果只使用 css-loader，解析出的CSS内容都在打包后的js代码中，没有任何作用。 只有配合 style-loader 或 mini-css-extract-plugin 等，引用的样式才会起作用。 1npm i -D css-loader 6.2.8.2.4 style-loader将CSS样式注入到DOM中。默认是在&lt;header&gt;最后添加&lt;style&gt;，这是通过生成JS方法动态添加的。 1npm i -D style-loader 一般这样配置： 12345{ test: /\\.css$/, use: ['style-loader', 'css-loader', 'postcss-loader'],}, 6.2.8.3 文件6.2.8.3.1 url-loader将小于一个限制大小的文件转换为base64 URIs。超过限制的，会默认使用 file-loader来做处理。所以这里一定要把 file-loader 也安装上。 1npm i -D url-loader file-loader 6.2.8.3.2 file-loader生成文件到输出的文件夹中，并返回相对路径URL 。 1npm i -D file-loader 6.2.9 安装 webpack plugins6.2.9.1 HTMLWebpackPlugin会生成一个HTML5文件，其中body中会加入所有webpack打包出来的内容。 1npm i -D html-webpack-plugin 6.2.9.2 clean-webpack-plugin移除或清空构建出的文件夹。 1npm i -D clean-webpack-plugin 6.2.9.3 mini-css-extract-plugin将CSS提取到单独的CSS文件中。 1npm i -D mini-css-extract-plugin 一般的配置如下： 1234567891011121314151617181920212223242526272829303132const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;); module: { rules: [ ... { test: /\\.s[ac]ss$/i, use: [ // 提取到单独的CSS文件 MiniCssExtractPlugin.loader, // 转换 CSS 到 CommonJS 'css-loader', // 给 CSS 添加前缀以适应各浏览器 'postcss-loader', // 编译 Sass 到 CSS 'sass-loader', ], }, ], },plugins: [ ...js new MiniCssExtractPlugin({ filename: 'css/[name].css', chunkFilename: 'css/[id].css', }),], 6.2.9.4 webpack-bundle-analyzer可视化webpack输出文件的大小。 1npm i -D webpack-bundle-analyzer 1234567const { BundleAnalyzerPlugin } = require('webpack-bundle-analyzer');module.exports = { plugins: [ new BundleAnalyzerPlugin() ]} 6.2.10 创建 webpack.config.js配置webPack来处理TypeScript。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475const { CleanWebpackPlugin } = require('clean-webpack-plugin');const HtmlWebpackPlugin = require('html-webpack-plugin');const MiniCssExtractPlugin = require('mini-css-extract-plugin');const path = require('path');const config = { entry: './src/index.ts', // 入口文件 externals: { cesium: 'Cesium', }, module: { rules: [ // 使用 babel-loader 解析 ts, js, tsx, jsx 文件. { test: /\\.(ts|js)x?$/, use: 'babel-loader', exclude: /node_modules/, }, // 执行顺序：从右到左 { test: /\\.s[ac]ss$/i, use: [ // 提取到单独的CSS文件 MiniCssExtractPlugin.loader, // 转换 CSS 到 CommonJS 'css-loader', // 给 CSS 添加前缀以适应各浏览器 'postcss-loader', // 编译 Sass 到 CSS 'sass-loader', ], }, // 使用 url-loader 将小于 4KB 图片 转换为 base64 URIs { test: /\\.(png|jpe?g|gif|webp)$/i, use: [ { loader: 'url-loader', options: { name: 'images/[name].[hash:8].[ext]', limit: 4096, esModule: false, }, }, ], }, ], }, resolve: { extensions: ['.ts', '.tsx', '.js', '.jsx', '.json'], // 按顺序解析以上扩展名的文件(必须添加，否则通过import进来的文件无法解析。import时可不写扩展名 默认值为 ['.wasm', '.mjs', '.js', '.json'] }, output: { filename: 'bundle.js', path: path.resolve(__dirname, 'dist'), }, plugins: [ new CleanWebpackPlugin(), new HtmlWebpackPlugin({ template: 'public/index.html', title: 'TypeScript-Webpack-starter' }), new MiniCssExtractPlugin({ filename: 'css/[name].css', chunkFilename: 'css/[id].css', }), ],};module.exports = (env, argv) =&gt; { if (argv.mode === 'development') { config.devtool = 'source-map'; // 导出SourceMap供调试 } if (argv.mode === 'production') { } return config;}; 某些开源项目会在项目的根目录下创建一个 build 文件夹，将 webpack 的配置拆分为base(存放公用配置)、dev(开发环境特有的配置)、prod(生产环境特有的配置)，利用合并插件将dev或prod和base合并。个人认为其拆分的思想没有问题，但如果配置项没达到一定规模(500行以上?)可以不用这么麻烦。如上方配置所示：只使用 webpack.config.js ，先添加公用配置(一个对象)，然后通过判断当前是开发还是生产模式，补充相应配置。 6.2.11 添加脚本package.json 12345 &quot;scripts&quot;: { &quot;serve&quot;: &quot;webpack-dev-server --mode development --open&quot;, &quot;dev&quot;: &quot;webpack-dev-server --mode development --open&quot;, &quot;build&quot;: &quot;webpack --mode production&quot; }, 6.2.12 形成项目结构创建libs、public、src文件夹 12345678910111213141516171819├── libs // 第三方库├── public│ ├── index.html├── src│ ├── assets // 资源│ │ ├── images // 图片│ │ ├── styles // 样式文件 scss、less、css│ └── index.ts├── .browserslistrc├── .editorconfig├── .eslintrc.js├── .gitignore├── babel.config.js├── package.json├── postcss.config.js├── README.md├── tsconfig.json└── webpack.config.js 其中index.html 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-cmn-Hans&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt; &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;noscript&gt; &lt;strong&gt;We're sorry but &lt;%= htmlWebpackPlugin.options.title %&gt; doesn't work properly without JavaScript enabled. Please enable it to continue.&lt;/strong&gt; &lt;/noscript&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 6.2.13 源码地址https://github.com/THS-FE/typescript-webpack-starter 7 备注7.1 为什么好多配置文件的后缀是 rc [Unix: from runcom files on the CTSS system 1962-63, via the startup script /etc/rc] Script file containing startup instructions for an application program (or an entire operating system), usually a text file containing commands of the sort that might have been invoked manually once the system was running but are to be executed automatically each time the system starts up. rc代表短语 runcom （运行命令），unix的爷爷CTSS系统中的脚本文件，里边包含了应用或者整个系统启动时要执行的命令。 现在更通用的含义可能是 runtime configration，即应用运行时的配置。 参考：https://stackoverflow.com/questions/11030552/what-does-rc-mean-in-dot-files https://unix.stackexchange.com/questions/3467/what-does-rc-in-bashrc-stand-for","link":"/2020/05/21/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"},{"title":"前端开发必须掌握的基本概念","text":"编译型(compiled) VS 解释型(interpreted)计算机语言通常分为三类：即机器语言，汇编语言和高级语言 机器语言（machine language）（1）概念：机器语言是用二进制代码(0和1)表示的、计算机能直接识别和执行的一种机器指令的集合。它是计算机的设计者通过计算机的硬件结构赋予计算机的操作功能。 （2）特点：不同种类的计算机其机器语言是不兼容的，按某种计算机的机器指令编制的程序不能在另一种计算机上执行。在现今，除了计算机生产厂家的专业人员外，绝大多数程序员已经不再学习机器语言。 （3) 示例 图1 机器语言 （4）指令集架构 又称指令集或指令集体系（英语：Instruction SetArchitecture，缩写为ISA），是计算机体系结构中与程序设计有关的部分，包含了基本数据类型，指令集，寄存器，寻址模式，存储体系，中断，异常处理以及外部I/O。指令集架构包含一系列的opcode即操作码（机器语言），以及由特定处理器执行的基本命令。 计算机微处理器的指令集架构（Instruction Set Architecture）常见的有两种： 精简指令集运算（Reduced Instruction SetComputing，RISC）：该指令集较为简单，每个指令的运行时间较短，完成的操作也简单，指令的执行性能较佳；但是要做复杂的事情，就需要由多个指令配合完成。当前有UNIX、Linux、MacOS以及包括iOS、Android、WindowsPhone、WindowsRT等在内的大多数移动操作系统运行在精简指令集的处理器上。 复杂指令集运算（Complex Instruction SetComputing，CISC）：与RISC不同的是，CISC在指令集的每个小指令可以执行一些较低级的硬件操作，指令数目多而且复杂，每条指令的长度不同。因为指令执行较为复杂，所以每条指令花费的时间较长，但每个指令可以处理的工作较为丰富。常见的CISC指令集的CPU有AMD、intel、VIA等X86架构的CPU。当前x86架构微处理器如Intel的Pentium/Celeron/Xeon与AMD的Athlon/Duron/Sempron；以及其64位扩展系统的x86-64架构的Intel64的Intel Core/Core2/Pentium/Xeon与AMD64的Phenom II/Phenom/Athlon64/Opteron/Ryzen/EPYC都属于复杂指令集。主要针对的操作系统是微软的Windows和苹果公司的OSX。另外Linux，一些UNIX等，都可以运行在x86（复杂指令集）架构的微处理器。 参考：https://www.processon.com/view/link/5dad48c8e4b0e4339303ebe2 汇编语言（assembly language） 概念：是用与代码指令实际含义相近的英文缩写词、字母和数字等符号来取代指令代码的一种符号语言（汇编语言亦称符号语言）。所以说,汇编语言是一种用助记符表示的仍然面向机器的计算机语言。 特点：机器语言和汇编语言都是面向硬件(CPU)的语言，语言对机器过分依赖。在不同的设备中，汇编语言对应着不同的机器语言指令集。一种汇编语言专用于某种计算机系统结构，而不像许多高级语言，可以在不同系统平台之间移植。使用汇编语言编写的源代码，然后通过相应的汇编程序将它们转换成可执行的机器代码。这一过程被称为汇编过程。 （3）示例：如用ADD表示运算符号“＋”的机器代码 图2 汇编语言 高级语言（High-level programming language）（1）概念：高级编程语言是高度封装了的编程语言。它是以人类的日常语言为基础的一种编程语言，使用一般人易于接受的文字来表示，有较高的可读性，以方便对电脑认知较浅的人亦可以大概明白其内容。由于早期电脑业的发展主要在美国，因此一般的高级语言都是以英语为蓝本。 （2）示例：现在开发人员使用的大部分都是高级语言，如Java、JavaScript、Python等等 （3）特点：高级语言是面向用户的语言。无论何种机型的计算机,只要配备上相应的高级语言的编译或解释程序,则用该高级语言编写的程序就可以通用 编译型语言和解释型语言 分类依据根据高级程序语言的运行方式不同，分为两种：编译型语言和解释型语言 根本区别：把高级语言编译成机器语言，执行这个编译过程的时机不同，即运行方式不同 概念（1）编译型语言 在程序运行之前 ：使用针对特定CPU体系的编译器，将源代码（高级程序语言编写的代码）一次性的编译成目标代码（机器语言编写的代码）（源代码——机器码）； 程序运行时，直接运行编译好的目标代码； 再次运行时，可直接使用上一次编译好的机器码，不需要重新编译。 (2) 解释型语言 程序运行时：即边编译边运行，每编译一行程序（高级语言——机器语言），就立刻运行，然后再编译下一行，再运行，如此不停地进行下去； 再次运行时，需要重新进行编译。 （3）比较 图3 高级语言执行过程 用解释器来运行程序会比直接运行编译过的机器代码来得慢，但是相对的这个解释的行为会比编译再运行来得快。这在程序开发的雏型化阶段和只是撰写试验性的代码时尤其来得重要，因为这个“编辑-解释-调试”的循环通常比“编辑-编译-运行-调试”的循环来得省时许多。所以解释型语言可以达到较快的开发速度，编译型语言可以达到较快的运行进度之间。 常用语言分类编译型语言：C、C++ 解释型语言：JavaScript、Python、MATLAB、TypeScript 总结编译型与解释型，两者各有利弊。 Java语言虽然比较接近解释型语言的特征，但在执行之前已经预先进行一次预编译，生成的代码是介于机器码和Java源代码之间的中介代码，运行的时候则由JVM（Java的虚拟机平台，可视为解释器）解释执行。它既保留了源代码的高抽象、可移植的特点，又已经完成了对源代码的大部分预编译工作，所以执行起来比“纯解释型”程序要快许多。 既然编译型与解释型各有优缺点又相互对立，所以一批后来诞生的语言都有把两者折衷起来的趋势。总之，随着设计技术与硬件的不断发展，编译型与解释型两种方式的界限正在不断变得模糊。 其他概念【源程序】又叫源码，用非机器语言书写好的符号程序称源程序 【目标程序】指源程序经编译后可直接被不同CPU架构运行的机器码集合 图4 编译器 图5 解释器 转自：https://blog.csdn.net/qq_41026740/article/details/96009765 https://www.cnblogs.com/clemente/p/10413618.html 静态类型(Static Typing) VS 动态类型(Dyn amic Typing)分类标准编程语言里会有类型检查的机制，类型检查的目的是避免程序发生一些未预料到的错误。 编程语言按照类型检查可以分为两大类：静态类型和动态类型。二者的根本区别在于：进行类型检查的时机，类型检查可以理解为：确定变量的类型，并实行类型的约束操作（类型转换） 概念 静态类型 在运行前进行数据类型检查的语言，即静态类型语言中，变量的类型必须先声明，即在创建的那一刻就已经确定好变量的类型 动态类型 在程序运行时才做数据类型检查的语言，即动态类型语言中，声明变量时无需指定类型，第一次将某类型的数据赋值给变量，在内部会将数据类型记录下来，成为该变量的类型 【注意】静态类型在编译型语言中较为普遍，动态类型在解释型语言中较为普遍，但不是绝对的，如TypeScript是解释型语言，静态类型语言 讨论静态类型在程序运行前，就能可靠地发现类型错误。因此通常能增进最终程序的可靠性。然而，有多少的类型错误发生，以及有多少比例的类型错误能被静态类型所捕捉，目前对此仍有争论。静态类型的拥护者认为，当程序通过类型检查时，它才有更高的可靠性。但是动态类型的拥护者指出，大部分软件证明，两者在可靠性上并没有多大差别。 常用语言分类静态类型语言：Java、C、C++、TypeScript 动态类型语言：JavaScript、Python 【补充】前端最常用见的10个错误中，有7个是类型错误，ts它是静态类型语言。在没运行的时候，IDE就帮我们做类型检查了，能减少错误，所以前端开发就这方面而言ts优于js。 转自：https://www.jianshu.com/p/bc492fcbf18f 强类型(Strong Typing) VS 弱类型(Weak Typing)分类标准按编程语言对类型检查的严格程度的强弱之分：分为强类型定义语言和弱类型定义语言 概念 强类型语言 一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了 2、弱类型语言 对于变量类型的检查比较宽松，容忍隐式类型转换这种事情的发生，包括相关类型之间隐式转换和不相关类型之隐式间转换 常用语言分类强类型语言：Python、Java、C# 弱类型语言：JavaScript、TypeScript 【注意点】“这门语言是不是动态语言”与“这门语言是否类型安全”之间是完全没有联系的 例如： Python是动态语言，是强类型定义语言（类型安全的语言） JavaScript是动态语言，是弱类型定义语言（类型不安全的语言） JAVA是静态语言，是强类型定义语言（类型安全的语言） 对强弱类型的深入理解虽然对这两个词是这样定义的，但是在技术含义上这两个术语尚未达成共识。相比之下，静态类型化意味着程序在执行之前就经过检查，程序可能在启动前被拒绝。动态类型化意味着在执行过程中会检查值的类型，而类型错误的操作可能会导致程序停止运行或在运行时发出错误信号。静态类型化的主要原因是要排除可能具有此类“动态类型错误”的程序。 强类型通常意味着类型系统中没有漏洞，而弱类型意味着类型系统可以被破坏。但是C语言，在编译时对语言进行类型检查（静态类型），但是仍然存在很多漏洞。几乎可以将任何类型的值转换为相同大小的另一类型，特别是可以自由地转换指针类型。 所以不同的人对“强”和“弱”两个程度副词的理解和定义是不同的。所以避免使用这两个词对语言做区分。 转自：https://blog.csdn.net/m0_37828249/article/details/87971474 集成开发环境(IDE(IntegratedDevelopmentEnvironment)) VS 编辑器(Editor)概念 1、编辑器 就是基于对一个文件、一个视频、一串数字等进行编辑或者再次编辑的工具。一般是为了文件、视频或者字符有更好的体现功能才进行的编辑，总的来说大概就是修改与编写的意思，可编写代码，也可编写文字，编辑图片等。常见的编辑器有文本编辑器、网页编辑器、源程序编辑器、图像编辑器，声音编辑器，视频编辑器等 示例：Notepad++等 2、IDE 集成开发环境（IDE，Integrated Development Environment）,是用于提供程序开发环境的应用程序，一般包括代码编辑器、编译器、调试器和图形用户界面等工具。集成了代码编写功能、分析功能、编译功能、调试功能等一体化的开发软件服务套。所有具备这一特性的软件或者软件套（组）都可以叫集成开发环境。编译器、编辑器、调试器都可以属于IDE，如微软的VisualStudio系列，Borland的C++Builder、Delphi系列等。该程序可以独立运行，也可以和其它程序并用。IDE多被用于开发HTML应用软件。 简单说，就是集成了编辑器、编译器以及链接器等众多功能的一个集成开发环境。 示例：Visual Studio系列、webstorm等(vs code加上它一大堆插件) 转自：https://blog.csdn.net/pointer_5/article/details/94242888 语法糖(Syntactic sugar) VS 语法盐(syntactic salt)概念 语法糖 语法糖是在不改变其所在位置的语法结构的前提下，实现了运行时等价。可以简单理解为，加糖后的代码编译后跟加糖前一模一样，只是更方便程序员使用，让程序更加简洁，有更高的可读性 示例：ES6的箭头函数、解构赋值等 2、语法盐 语法盐是指那些为避免容易犯的语法错误加上的额外语法限制。这些特性强迫程序员做出一些基本不用于描述程序行为，而是用来证明他们知道自己在做什么的额外举动。 示例： 类型检查 有人建议在用end if, end while等代替现在的统一的end C++ 通过引入 static_cast、reinterpret_cast、const_cast 和 dynamic_cast 这四种转换来强迫程序员多敲键盘，从而令他们少用转换 C#在switch语法中的case标记代码块内，如果没有goto、return、throw跳离语法，一定得加上break语法 如果非常仔细、小心，这些语法盐可能就是多余的 转自：https://segmentfault.com/a/1190000010159725 重复发明轮子(Reinvent the wheel)来源我们都知道轮子应该是圆的最省力，但是当我们的祖先不知道什么形状最省力的情况下，就可能会发明出三角轮、四边轮、五边轮等等。当大家都知道圆形的轮子是最省力的，是最好的形状之后，再发明其他形状的轮子就没有什么意义了。当大家都知道圆形的轮子是最省力的、是最好的形状之后，如何改进现有的圆形轮子，才是最重要的。 为什么是轮子因为轮子是人类历史上最伟大的发明之一。轮子是人类的早期发明物之一。早期的轮子，是光滑的圆木，人们借助于这些圆木在地面上移动物体。历史上没有记录表明轮子是在什么年代、由谁发明的。然而，当“第一个发明者”把轮子安装在轴上时，人们就开始利用轮子把物体从一个地方移动到另一个地方。人们发现，在公元前2000年埃及古文物中，便有了轮子；古代中国文明也有发明使用轮子的记载和考古发现。 尽管轮子如此强烈地吸引着人类，可是人们却花费了几个世纪的时间来建造使用轮子的机器，而且大约有400多年，轮子的基本形状一直没有变化。 概念 概念 是指前人已经指明了方向，我们需要了解之前轮子的原理和利弊，加以改进或修改，使它更好或者满足自己新的需求。 2、示例 Linus在上大学的时候，他觉得老师教学用的操作系统Minix不够好用，于是就自己写了一个操作系统来代替，这东西就叫Linux,市场份额占到了服务器市场的一半甚至更多在与其他人开发Linux的过程中，他们一直使用的版本控制系统Bitkeeper终止了授权，而Torvalds觉得其他的版本控制系统太蠢了，于是花了一周又自己写了一个东西，叫做Git。于是这个东西又占到了版本控制系统市场的七成甚至八成以上的份额。 脚手架(Scaffolding)概念在计算中使用的脚手架指的是两种技术之一： 第一种是与某些MVC 框架中的数据库访问相关的代码生成技术; 第二种是由各种工具支持的项目生成技术。 “脚手架”是一种元编程的方法，用于构建基于数据库的应用。许多MVC框架都有运用这种思想。程序员编写一份specification（规格说明书），来描述怎样去使用数据库；而由（脚手架的）编译器来根据这份specification生成相应的代码，进行增、删、改、查数据库的操作。我们把这种模式称为”脚手架”，在脚手架上面去更高效的建造出强大的应用。 前端开发中脚手架的作用是创建项目的初始文件，本质是方案的封装。前端工程体系的功能涵盖范围广，封装的方案类型多，对应的配置项也非常复杂。而且，大多数前端工程体系的开发者并不是一线的业务开发者。对于业务开发者来说，这套工程体系就是一个黑盒，他们不需要了解其中的复杂原理，只需要知道如何配置即可。所以业务开发者的需求就是快速开发快速配置，并且生成的配置项跟项目要对应，既要满足项目的功能需求，又不能有“混淆视听”的冗余功能。 CLI(command-line interface)CLI为command-line interface的缩写，意为：命令行界面，是脚手架的实现方式之一。VueCLI 是一个 Vue.js快速开发的完整系统（或者俗称为：命令行工具），它所具有的一项功能是：快速搭建繁杂的单页面应用。 vue的 clivue是一套渐进式（就是你需要什么就用什么，不需要什么就可以不用，强制你遵守的规则很少），自底向上增量开发（就是根据系统和硬件编写出基层的基本需求代码，再慢慢增加模块），由于他要求遵守的规则较少，你可以引不同自己需要的东西，就需要配合webpack打包工具把引入的不同模块的东西打包 webpack是一个工具，俗称打包工具，就是把所以浏览器不能识别的东西如（less，scss）等转换为浏览器可以识别的语言如（css），因为vue中需要引入大量的各种各样的模块所以很依赖webpack 。在webpack看来 一切皆模块。 cli他能快速生成webpack打包结构，就跟‘！’可以动态生成html框架一样。 转自：https://blog.csdn.net/pojpoj/article/details/100737194 银弹(Silver Bullet)来源 在古老的传说里，狼人是不死的。想要杀死狼人有几种方法： １.像杀死吸血鬼那样用木桩钉住狼人的心脏； ２.将月光遮住 ３.用银子做的子弹射穿透狼人的心脏或头 当然现实中是没有狼人的。但现实中确实有银弹这个东西。而其意义也类似于能杀死狼人的最好办法。现实中的狼人可以是一个棘手的项目，或者一件不可能的事。而“银弹”就是指能解决这些事的方法，或者技术手段。如果看过《人月神话》，那一定对银弹这个词并不陌生。不过在IT行业中，只有张嘴不办事的人会去幻想银弹技术。《没有银弹》（NoSilver Bullet）是IBM大型电脑之父佛瑞德·布鲁克斯（FredBrooks）在1987年所发表的一篇关于软体工程的经典论文。该论述中强调由于软体的复杂性本质，而使真正的银弹并不存在；所谓的没有银弹是指没有任何一项技术或方法可使软件工程的生产力在十年内提高十倍。 概念本意是指万金油、万能药、一个完美的解决方案。在软件开发中，银弹是指使得使生产率、可靠性或简洁性获得数量级上的进步。但是软件开发本身具备复杂性，不可见性，可变性，随着计算机历史的发展，软件开发次要困难从很大程度上已经得到解决，但从某种程度上来说，无论怎么发展，软件本身具有的复杂性都没有从根本上得到解决。 转自：https://www.zhihu.com/question/20829469 https://www.zhihu.com/question/20829469/answer/16319016 Shim VS polyfill概念 shim shim一般指一些做兼容性的库,用来弥补旧浏览器对新特性支持的不足。它将一个新的API引入到一个旧的环境中,而且仅靠旧环境中已有的手段实现，即把不同API封装成一种。 polyfill 一个polyfill就是一个用在浏览器API上的shim，也是·对浏览器的不足做补充。但是它的做法是先检查当前浏览器是否支持某个API,如果不支持的话就加载对应的polyfill.然后新旧浏览器就都可以使用这个API了 示例：旧浏览器不支持 ES6 的 Array.prototype.find 方法,我们想要在项目中使用Array.prototype.find, Shim：function arrayFind() { if (Array.prototype.find) {// … } else {// … }} Polyfill：if (!Array.prototype.find) { Array.prototype.find = function() {// …}} 转自：https://www.jianshu.com/p/26d34cebf6be?utm_source=oschina-app 库 (library) VS 框架(framework)概念1、库 库是一系列预先定义好的数据结构和函数(对于面向对象语言来说，是类)的集合，提供给开发者使用，程序员通过使用这些数据结构和函数实现功能。库没有控制权，控制权在使用者手中，在库中查询需要的功能在自己的应用中使用。 2、框架 框架也是一系列预先定义好的数据结构和函数，一般用于作为一个软件的骨架，会基于自身的特点向用户提供一套相当于叫完整的解决方案，而且控制权的在框架本身，使用者要找框架所规定的某种规范进行开发。 本质区别 框架与库之间最本质区别在于控制权：you call libs, frameworks call you（控制反转） 联系和区别二者联系紧密，他们以聚合的形式让我们在所要开发的应用中使用，在框架中我们完全可以自由的使用库，同时也可以没有框架的基础之上使用库，使用库的控制权始终在我们的手中，但是使用框架时候就必须按照它的规范来进行模块化的开发。 图6 库和框架的关系 图7 应用、库和框架的关系 转自：https://www.jianshu.com/p/60100985dd7f 方法(method ) VS 函数(function)函数属于整个文件, 方法属于某一个对象，函数可以直接调用,方法必须用对象或者类来调用 URL VS URI VS URN概念1、URI：Uniform Resource Identifier，统一资源标识符 URI是以某种统一的（标准化的）方式标识资源的简单字符串，一般由三部分组成： （1）访问资源的命名机制。 （2）存放资源的主机名。 （3）资源自身的名称，由路径表示 2、URL：Uniform Resource Locator，统一资源定位符 URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上。采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。 URL的格式由下列三部分组成： （1）协议（或称为服务方式）； （2）存有该资源的主机IP地址（有时也包括端口号）； （3）主机资源的具体地址。如目录和文件名等。 第一部分和第二部分之间用”：//”符号隔开，第二部分和第三部分用”/”符号隔开。第一部分和第二部分是不可缺少的，第三部分有时可以省略。 URN：Uniform Resource Name，统一资源名称 URN是用特定命名空间的名字标识资源 联系和区别 联系 URL和URN都是URI的一种，URI的范畴位于体系的顶层，URL和URN的范畴位于体系的底层。这种排列显示URL和URN都是URI的子范畴。 图8 三者的关系 不同 URI 指的是一个资源,URL是用地址定位一个资源，URN是用名称定位一个资源 转自：https://www.cnblogs.com/wxlzhizu/archive/2010/06/04/1751517.html localStorage VS sessionStorage概念localStorage和sessionStorage一样都是用来存储客户端临时信息的对象，他们均只能存储字符串类型的对象（虽然规范中可以存储其他原生类型的对象，但是目前为止没有浏览器对其进行实现） 异同点 相同点 存储大小都是5MB 都保存在客户端，不与服务端交互通信 只能存储字符串类型，对于复杂的对象可以使用ECMAScript提供的JSON对象的stringify和 parse来处理 不同点 生命周期不同 localStorage生命周期是永久，关闭页面或浏览器之后localStorage存储的数据也不会丢失，除非用户显式地在浏览器提供的UI上清除localStorage信息，否则这些信息将永远存在 sessionStorage生命周期为当前窗口或标签页，一旦窗口或标签页被永久关闭了，那么所有通过sessionStorage存储的数据也就被清空了 数据共享机制 不同浏览器无法共享localStorage或sessionStorage中的信息。 相同浏览器的不同页面间可以共享相同的 localStorage（页面属于相同域名和端口） 不同页面或标签页间无法共享sessionStorage的信息。这里需要注意的是，页面及标签页仅指顶级窗口，如果一个标签页包含多个iframe标签且他们属于同源页面，那么他们之间是可以共享sessionStorage的。 转自：https://www.cnblogs.com/vickylinj/p/10883256.html 向前兼容(Foreward Compatibility) VS 向后兼容(Backward Compatibility)概念 兼容包括：硬件兼容性和软件兼容性 Forward意思是向前进，指未来，向前兼容是站在旧版本的立场讨论未来版本的兼容性问题。在计算机中指在较低档计算机上编写的程序，可以在同一系列的较高档计算机上运行，或者在某一平台的较低版本环境中编写的程序可以在较高版本的环境中运行，都称为向上兼容，前者是硬件兼容，而后者是软件兼容。向上兼容具有非常重要的意义，一些大型软件的开发，工作量极大，如这些软件都能做到兼容，则无需在其它机器上重新开发，就可节省庞大的人力和物力。 Backward意思是向后退，指过去，站在新版本的立场讨论过去版本的兼容性问题。在计算机中指在一个程序或者类库更新到较新的版本后，旧的版本程序创建的文档或系统仍能被正常操作或使用，或在旧版本的类库的基础上开发的程序仍能正常编译运行的情况。例如较高档的计算机或较高版本的软件平台可以运行较为低档计算机或早期的软件平台所开发的程序。向下兼容可以使用户在进行软件或硬件升级时，厂商不必为新设备或新平台从头开始编制应用程序，以前的程序在新的环境中任然有效。 转自：https://blog.csdn.net/wangxufa/java/article/details/72846362 正向代理(Forward proxy) VS 反向代理(Reverse proxy) 网络代理分为正向代理和反向代理。 正向代理（1）概念 当客户端无法访问外部资源的时候，可以通过一个正向代理去间接地访问，所以客户端需要配置代理服务器的ip。 正向代理是一个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须设置正向代理服务器，当然前提是要知道正向代理服务器的IP地址，还有代理程序的端口。 图9 正向代理 （2）举例 我是一个用户，我访问不了某网站，但是我能访问一个代理服务器，这个代理服务器呢,他能访问那个我不能访问的网站，于是我先连上代理服务器,告诉他我需要那个无法访问网站的内容，代理服务器去取回来,然后返回给我。从网站的角度，只在代理服务器来取内容的时候有一次记录，有时候并不知道是用户的请求，也隐藏了用户的资料，这取决于代理告不告诉网站。 图10 反向代理 作用 访问原来无法访问的资源，如google 可以做缓存，加速访问资源 对客户端访问授权，上网进行认证 代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息 反向代理 概念 反向代理实际运行方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。客户端是感知不到代理的存在的，反向代理对外都是透明的，访问者者并不知道自己访问的是一个代理。因为客户端不需要任何配置就可以访问。 作用 保证内网的安全，可以使用反向代理提供WAF功能，阻止web攻击大型网站，通常将反向代理作为公网访问地址，Web服务器是内网 负载均衡，通过反向代理服务器来优化网站的负载 转自：https://www.jianshu.com/p/a1c35f5d27f7 ES6 VS ES2015ECMAScript 和 JavaScript 的关系ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现。 JavaScript是Netscape创造的并交给了国际标准化组织ECMA，之所以不叫做JavaScript由于商标的问题，java是sun公司的商标，根据授权协议只有Netscape公司可以合法使用JavaScript这个名字，另外就是为了体现JavaScript的标准的制定者不是ECMA所以取名为ECMAScript ECMAScript 的历史ECMAScript 1.0 是 1997 年发布的，接下来的两年，连续发布了 ECMAScript 2.0（1998年 6 月）和 ECMAScript 3.0（1999 年 12 月）。3.0版是一个巨大的成功，在业界得到广泛支持，成为通行标准，奠定了 JavaScript语言的基本语法，以后的版本完全继承。直到今天，初学者一开始学习JavaScript，其实就是在学 3.0 版的语法。 2000 年，ECMAScript 4.0 开始酝酿。这个版本最后没有通过，但是它的大部分内容被 ES6继承了。因此，ES6 制定的起点其实是 2000 年。 为什么 ES4 没有通过呢？因为这个版本太激进了，对 ES3做了彻底升级，导致标准委员会的一些成员不愿意接受。2008 年 7月，由于对于下一个版本应该包括哪些功能，各方分歧太大，争论过于激烈，ECMA开会决定，中止 ECMAScript 4.0 的开发，将其中涉及现有功能改善的一小部分，发布为ECMAScript3.1，而将其他激进的设想扩大范围，放入以后的版本，由于会议的气氛，该版本的项目代号起名为Harmony（和谐）。会后不久，ECMAScript 3.1 就改名为 ECMAScript 5。 ES6 与 ECMAScript 2015 的关系ES6是ECMA的为JavaScript制定的第6个版本的标准，标准委员会最终决定，标准在每年的 6月份正式发布一次，作为当年的正式版本。ECMAscript 2015是在2015年6月份发布的ES6的第一个版本。依次类推ECMAscript 2016 是ES7、 ECMAscript2017 是ES8……，最新的是ECMAscript 2019，即ES10 转自：https://es6.ruanyifeng.com/#docs/intro 进程(process) VS 线程(thread)进程和线程是操作系统的基本概念 概念进程：是执行中一段程序，即一旦程序被载入到内存中并准备执行，它就是一个进程。进程是表示资源分配的的基本概念，又是调度运行的基本单位，是系统中的并发执行的单位。 线程：单个进程中执行中每个任务就是一个线程。线程是进程中执行运算的最小单位。 从CPU运行的角度理解CPU+RAM+各种资源（比如显卡，光驱，键盘等等外设）构成我们的电脑，但是电脑的运行，实际就是CPU和相关寄存器以及RAM之间的事情。 执行一段程序代码，实现一个功能的过程是：当得到CPU的时候，相关的资源必须也已经就位，然后CPU开始执行。这里除了CPU以外所有的就构成了这个程序的执行环境，也就是我们所定义的程序上下文。当这个程序执行完了，或者分配给他的CPU执行时间用完了，那它就要被切换出去，等待下一次得到CPU。在被切换出去的最后一步工作就是保存程序上下文，因为这个是下次他得到CPU的运行环境，必须保存。 所以计算机工作的过程是：先加载程序A的上下文，然后开始执行A，保存程序A的上下文，调入下一个要执行的程序B的程序上下文，然后开始执行B,保存程序B的上下文。 进程和线程就是这样的背景出来的，两个名词是对应的CPU时间段的描述。进程就是包换上下文切换的程序执行时间总和，即CPU加载上下文、CPU执行、CPU保存上下文之和。进程的颗粒度太大，每次都要有上下的调入，保存，调出。如果我们把进程比喻为一个运行在电脑上的软件，那么一个软件的执行不可能是一条逻辑执行的，必定有多个分支和多个程序段，就好比要实现程序A，实际分成a，b，c等多个块组合而成。那么这里具体的执行就可能变成：程序A得到CPU，然后CPU加载上下文，开始执行程序A的a小段，然后执行A的b小段，然后再执行A的c小段，最后CPU保存A的上下文。这里a，b，c的执行是共享了A的上下文，CPU在执行的时候没有进行上下文切换的。这里的a，b，c就是线程，也就是说线程是共享了进程的上下文环境，的更为细小的CPU时间段。 二者关系（1）根本区别：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位 （2）资源开销：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。 （3）包含关系：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。 （4）内存分配：同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的 （5）影响关系：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。 （6）执行过程：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行 转自：https://blog.csdn.net/ThinkWon/java/article/details/102021274 https://blog.csdn.net/ThinkWon/article/details/102021274 参考：http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html 形参（parameter） VS 实参 (argument)概念1、实参 全称为”实际参数”，是在调用时传递给函数的参数。实参可以是常量、变量、表达式、函数等 2、形参 全称为”形式参数”由于它不是实际存在变量，所以又称虚拟变量。是在定义函数名和函数体的时候使用的参数,目的是用来接收调用该函数时传入的参数 VR（Virtual Reality）VS AR（Augmented Reality） VS MR（Mixed Reality）概念1、VR（虚拟现实） 是指利用计算机技术模拟产生一个为用户提供视觉、听觉、触觉等感官模拟的三度空间虚拟世界，用户借助特殊的输入/输出设备，与虚拟世界进行自然的交互。用户进行位置移动时，电脑可以通过运算，将精确的三维世界视频传回产生临场感，令用户及时、无限制地观察该空间内的事物，如身临其境一般。 简单地说，VR看到的图像全是计算机模拟出来的，都是虚假的 2、AR（增强现实） 是一种实时计算摄影机影像位置及角度，并辅以相应图像的技术。这种技术可以通过全息投影，在镜片的显示屏幕中将虚拟世界与现实世界叠加，操作者可以通过设备互动。 AR是将虚拟信息加在真实环境中，来增强真实环境，因此看到的图像是半真半假，如Faceu激萌特效相机APP，这款APP会自动识别人脸，并在人脸上叠加动态贴图和道具，从而创造出卖萌搞笑效果的照片，例如加兔子耳朵、加彩虹特效 3、MR（混合现实） 指的是结合真实和虚拟世界创造了新的环境和可视化三维世界，物理实体和数字对象共存、并实时相互作用，以用来模拟真实物体，是虚拟现实技术的进一步发展。 MR是将真实世界和虚拟世界混合在一起，可以说它呈现的图像令人真假难辨 三者关系VR概念最小，AR概念包含了VR，MR概念最大，包含了VR和AR AR和MR的辨别虚拟物体与真实物体是不是被肉眼分离出来，如果不能被肉眼分离的就是MR，可以的就是AR。例如之前提到的Faceu激萌特效相机APP以及不少AR应用一眼就可以知道哪些是真的，哪些是假的。而MR直接向视网膜投射整个4维光场，所以用户看到的物体和看真实的物体，从数学上是没有区别的。 转自：https://www.sohu.com/a/203516748_100033040 yarn VS npm二者都是JS依赖包管理工具，Yarn 是由 Facebook，google，Exponent 和 Tilde制作的一种新的JavaScript 软件包管理器。可以在官方公告上看到，其目的是解决团队在npm 面临的问题，即安装包不够快、有安全隐患，npm 允许安装包执行代码。 npm的问题 npm install的时候非常慢，删除node_modules，重新install的时候依旧如此； 同一个项目，安装的时候无法保持一致性。由于package.json文件中版本号的特点，下面三个版本号在安装的时候代表不同的含义。 图11 npm版本控制 “5.0.3”表示安装指定的5.0.3版本，“～5.0.3”表示安装5.0.X中最新的版本，“^5.0.3”表示安装5.X.X中最新的版本。这就会导致同一个项目，由于安装的版本不一致出现bug。 安装的时候，包会在同一时间下载和安装，中途某个时候，一个包抛出了一个错误，但是npm会继续下载和安装包。因为npm会把所有的日志输出到终端，有关错误包的错误信息就会在一大堆npm打印的警告中丢失掉，使得不太容易注意到实际发生的错误。 yarn的优点1、速度快，速度快主要来自以下两个方面： （1）并行安装：无论 npm 还是 Yarn 在执行包的安装时，都会执行一系列任务。npm是按照队列执行每个 package，也就是说必须要等到当前 package安装完成之后，才能继续后面的安装。而 Yarn 是同步执行所有任务，提高了性能。 （2）离线模式：如果之前已经安装过一个软件包，用Yarn再次安装时之间从缓存中获取，就不用像npm那样再从网络下载了。 2、安装版本统一 为了防止拉取到不同的版本，Yarn 有一个锁定文件 (lock file)记录了被确切安装上的模块的版本号。每次只要新增了一个模块，Yarn就会创建（或更新）yarn.lock这个文件。这么做就保证了，每一次拉取同一个项目依赖时，使用的都是一样的模块版本。 3、更简洁的输出 npm 的输出信息比较冗长。在执行 npm install &lt;package&gt;的时候，命令行里会不断地打印出所有被安装上的依赖。相比之下，Yarn简洁太多：默认情况下，结合了emoji直观且直接地打印出必要的信息，也提供了一些命令供开发者查询额外的安装信息。 转自：https://www.jianshu.com/p/254794d5e741 K VS P（Progressive）我们在下载电影时，通常有标清、高清、全高清甚至超高清的源，再细心一点我们会发现它们分别又叫480p、720p、1080p…，那么这些数字背后意味着什么，K和p又分别代表什么含义？ 概念 P是Progressive,逐行的意思，P是逐行扫描，表示的是“视频像素的总行数”，几P就是纵向有多少行像素，例如，1080p就是纵向有1080行像素，1080x1080（1:1），1440x1080（1.33），1920x1080（1.78），2581x1080（2.39），3840x1080（3.56）等都是1080P K表示的是“视频像素的总列数”， “几K”的原始定义是：横向大约有几个1024列像素，1K就是1024，2K就是2048，4K就是4096，以此类推。但在电视领域，这些“几K”都被加上了一个固定分辨率标准，比如2K是2560x1440，4K是3840x2160，大家平时所说的这些所谓标准，都是16：9的电视标准（TV Standard） K”和“P”能否同时出现？要想准确描述一个屏幕或视频的分辨率，这两者必须同时出现，否则就会出现歧义 电视标准仅仅只在电视领域或日常生活中16:9的视频和显示器比例中适用，一旦脱离了电视领域，或者屏幕及视频比例不再是16：9，该规则即作废，定义一个视频有几K的方法只有一个：横向像素数有几个1024，定义一个视频有几P的方法也只有一个：纵向有多少行像素 4K（超高清）、1080P（全高清）、720P（超清）、480P（高清） 转自：https://www.bilibili.com/read/cv2889564/","link":"/2020/05/21/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%BF%85%E9%A1%BB%E6%8E%8C%E6%8F%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"title":"跨域解决","text":"什么导致了跨域跨域首先，网络是没有绝对安全可言的，但是，我们又需要使用浏览器来访问网络，所以浏览器能存在的安全基础就是有相对较高的安全性，提升了别人做坏事的成本。 Same-origin policy(同源策略,以下简写为 CORS)就是浏览器安全的一个重要部分。 同源策略是一个重要的安全策略，它用于限制一个源(Origin)的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。 同源策略的目的有两个： 对系统用户：保证用户信息的安全，防止恶意的网站窃取数据。 对开发人员：约束网站使用的资源尽可能是同源可控或者信任的资源，减少问题的可能性，从而来增强网站的安全性。 真实案例（仅限演示例子使用）：在登录腾讯文档后，打开一个文档，在控制台调用下面的代码，将会给一个好友分配该文档的编辑权限。 123456789$.ajax({ type: &quot;post&quot;, url: 'https://docs.qq.com/cgi-bin/redirect/300000000/ep/api/setpadinfo?localPadId=BYtWkVVnlVCW&amp;type=1&amp;ver=2&amp;route_ip=&amp;room_route_ip=&amp;get_vip_info=1', data: 'corp_id=&amp;data=%7B%22policy%22%3A1%2C%22addmemlist%22%3A%5B%7B%22uintype%22%3A0%2C%22uin%22%3A2803621806%2C%22work_id%22%3A%22%22%2C%22info%22%3A2%2C%22new%22%3A1%7D%5D%2C%22submemlist%22%3A%5B%5D%7D&amp;message=%7B%22seq%22%3A%2272bcde05-6052-44f2-be8c-b6454a3e6716%22%2C%22action%22%3A1%7D&amp;xsrf=ac8bd23b7c50fa4b&amp;dataType=0', success: function(data) { console.log(data); }, error: function(err) {}}); 退出账号后，调用相同代码，不能给相同好友分配该文档的编辑权限。并报下面的错误。 123cgicode: 11000msg: &quot;no correct p_uin or p_skey or uid or uid_key in cookie [errcode:11000:0]&quot;retcode: 11000 由报错可以看出，出现问题是因为cookie中缺少相关信息，导致服务端认证失败。 在其他网站的控制台调用相同代码会报如下错误： 1Access to XMLHttpRequest at 'https://docs.qq.com/cgi-bin/redirect/300000000/ep/api/setpadinfo?localPadId=BYtWkVVnlVCW&amp;type=1&amp;ver=2&amp;route_ip=&amp;room_route_ip=&amp;get_vip_info=1' from origin 'https://fanyi.baidu.com' has been blocked by CORS policy: 、No 'Access-Control-Allow-Origin' header is present on the requested resource. 现在根据上面的情况试想在没有同源策略的情况下：在你登陆腾讯文档后，再打开一个其他源的网站，调用上面的代码，也是会成功给好友分配编辑权限的。进而联想到在一个第三方网站掌握腾讯文档的接口信息规则后，就可以假冒你对你的账号进行任意操作，这是十分可怕的。 那么怎么判断是同一个源呢，它的定义是什么呢？ 同源的定义：如果两个 URL的协议、主机 和 端口 (如果有指定的话) 都相同的话，则这两个 URL 是同源。这个方案也被称为“协议/主机/端口元组”。 注： 只有浏览器才会有跨域问题，因为只有浏览器才有同源策略。 恶意文档：可能导致推栈缓冲区溢出，从而在电脑中执行一些代码的文件，一般指病毒或者木马的运行程序。 跨域示例下表给出了与 URL：http://store.company.com/dir/page.html 的源进行对比的示例: URL 结果 原因 http://store.company.com/dir2/other.html 同源 只有路径不同 http://store.company.com/dir/inner/another.html 同源 只有路径不同 https://store.company.com/secure.html 失败 协议不同 http://store.company.com:81/dir/etc.html 失败 端口不同 ( http: 默认端口是80;https: 默认端口是443) http://news.company.com/dir/other.html 失败 主机不同 注：域名和IP指向一样，但是还是会引起跨域的。例如：http://www.ths.com.cn/和http://223.223.179.206/都指向同一个地方 限制范围随着互联网的发展，”同源策略”越来越严格。目前，如果非同源，共有三种行为受到限制。 Cookie、LocalStorage、SessionStorage 和 IndexDB 无法读取。 脚本API访问。 AJAX 请求不能发送。 常见跨域错误缺少可跨域响应头 关键字： No ‘Access-Control-Allow-Origin’ header （Access-Control-Allow-Origin 翻译：允许访问的源）注：客户端发送的叫请求，服务器端返回的叫响应生动例子：客户端向服务器借钱是请求，服务器不给钱是对客户端的响应 允许跨域的值重复 关键字： The ‘Access-Control-Allow-Origin’ header contains multiple values ‘*, *‘, but only one is allowed。 （”允许访问的源“响应头包含重复的两个*号，但是只有一个是允许的）原因： 多次代理的时候配置的允许跨域的值有重复的。 不允许访问其他域的对象或者数据存储（cookie等） 关键字：block a frame with origin form accessing a cross-origin frame （访问了一个跨域的源） 解决跨域跨域网络访问（Cross-origin network access）因为跨域产生的原因是两个资源不在同一个域，所以有四种解决的办法： 把两个资源放到同一个域中 服务器允许资源跨域共享(CORS) 浏览器插件 利用一些不受同源策略影响的标签实现（script） 把两个资源放到同一个域中 反向代理：通过 nginx 把多个资源代理到一块 参考 nginx说明文档注： 在能操作文件的情况下，不建议多次代理，因为这样会导致网络传输变慢，影响系统的流畅性。 正向代理：通过同域的接口返回其他域的资源 注： 反向代理：访问自定义的接口来返回其他接口的资源，通过自定义接口已经不能分出真实资源来自哪里。 正向代理：由代理服务器去请求资源并返回给你，访问还是原来的真实网址。 不管是正向代理还是反向代理，都是由服务器端去进行访问的，所以要保证在服务器端能访问到真实地址。 服务器允许资源跨域共享 Tomcat 在 Tomcat根目录 –&gt; conf –&gt; web.xml 的 web-app 节点下加入如下代码。 1234567891011121314&lt;filter&gt; &lt;filter-name&gt;CorsFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.catalina.filters.CorsFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;cors.allowed.origins&lt;/param-name&gt; &lt;param-value&gt;*&lt;/param-value&gt; &lt;!-- 当指定部分可跨域时，使用下面代码配置指定域 --&gt; &lt;!-- &lt;param-value&gt;http://127.0.0.1:10229&lt;/param-value&gt; --&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CorsFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 注: Tomcat配置修改后必须重启Tomcat才会生效。 Nginx在 Nginx的根目录 –&gt; conf –&gt; nginx.conf 文件适当写入下述代码。 全局可跨域12345# 在 server 节点下添加以下语句add_header Access-Control-Allow-Origin *;add_header 'Access-Control-Allow-Credentials' 'true';add_header Access-Control-Allow-Methods 'GET,POST';add_header Access-Control-Allow-Headers 'Content-Type,*'; 指定接口可跨域12345678# 在指定的 location 节点下添加，示例如下：location /tomcat/ { proxy_pass http://localhost:8090/; add_header Access-Control-Allow-Origin *; add_header 'Access-Control-Allow-Credentials' 'true'; add_header Access-Control-Allow-Methods 'GET,POST'; add_header Access-Control-Allow-Headers 'Content-Type,*';} 注： Nginx配置修改后必须重启才会生效。 同时添加全局可跨域和指定接口可跨域时，访问指定接口会产生可跨域响应头重复的问题，可使用指定接口代理，因此不推荐使用全局可跨域。 注意localtion的匹配规则 当配置指定域可跨域时，可把*换为具体的域名或者IP，多个之间用逗号隔开。 多次代理设置具体相同的域也是会报允许跨域的值重复错误 多次代理设置域时，http:127.0.0.1:10229/ === http:127.0.0.1:10229 补：location和proxy_pass易混淆点 location (后面两点为URL访问的相关知识补充) location 后面带不带 / 都是一样的 如果URL的格式为http://my.suyp.com/或者http://127.0.0.1:10229/，**尾部有没有/都不会造成重定向**。因为这种情况下，浏览器请求时会在后面默认加上/。可以这样理解，没有请求是访问的http://my.suyp.com,都是访问的http://my.suyp.com/,所以没有重定向。 如果URL的格式为http:127.0.1:10229/node/。尾部如果缺少/将导致重定向。因为根据约定，URL尾部的/表示目录，没有/表示文件。所以访问/node/时，服务器会自动去该目录下找对应的默认文件或者返回该目录的文件列表。如果访问/node的话，服务器会先去找node文件，找不到的话会将node当成目录重定向到/node/，去该目录下找默认文件或者返回该目录的文件列表。 proxy_pass假设下面四种情况分别用 http://192.168.1.1/proxy/test.html 进行访问。 1234location /proxy/ { proxy_pass http://127.0.0.1:10229/;}# 代理到URL：http://127.0.0.1:10229/test.html 1234location /proxy/ { proxy_pass http://127.0.0.1:10229; # （相对于第一种，最后少一个 / ）}# 代理到URL：http://127.0.0.1:10229/test.html 1234location /proxy/ { proxy_pass http://127.0.0.1:10229/aaa/;}# 代理到URL：http://127.0.0.1:10229/aaa/test.html 1234location /proxy/ { proxy_pass http://127.0.0.1:10229/aaa; # （相对于第三种，最后少一个 / ）}# 代理到URL：http://127.0.0.1:10229/aaatest.html 理解：如果最后有/，就是把URL以location路由切割，把后面的部分放到代理地址的后面，如果没有，就是把路由加上后面的部分放到代理地址的后面。（注意: http://127.0.0.1===http://127.0.0.1/）。 推荐配置代理的写法： 123456789location /proxy/ { proxy_pass http://127.0.0.1/;}location /proxy/ { proxy_pass http://127.0.0.1/aaa/;}# location 的路由最后也加上/# proxy_pass 的最后也加上/# 好处：访问的地址和真实地址在/proxy/之后是完全一样的，便于理解记忆 Node 全局可跨域123456789app.all('*', (req, res, next) =&gt; { // 设置允许跨域的域名，*代表允许任意域名跨域 res.header('Access-Control-Allow-Origin', '*'); // 允许的header类型 res.header('Access-Control-Allow-Headers', 'content-type'); // 跨域允许的请求方式 res.header('Access-Control-Allow-Methods', 'DELETE,PUT,POST,GET,OPTIONS'); next();}); 指定接口可跨域12345678app.get('/node', (req, res) =&gt; { // 设置允许跨域的域名，*代表允许任意域名跨域 res.header('Access-Control-Allow-Origin', '*'); // 允许的header类型 res.header('Access-Control-Allow-Headers', 'content-type'); // 跨域允许的请求方式 res.header('Access-Control-Allow-Methods', 'DELETE,PUT,POST,GET,OPTIONS');}); 注：因为Node的路由是由上到下匹配的，有符合的默认就不继续向下匹配了 指定全局可跨域时，一定要先写 app.all 在 app.all 中，一定要加next(), 来让路由继续向下匹配 浏览器插件在chrome网上商店中搜索 Allow CORS: Access-Control-Allow-Origin 插件安装，在需要的时候运行即可。 利用一些不受同源策略影响的标签JSONPJSONP是服务器与客户端跨源通信的一种方法。最大特点就是简单适用，老式浏览器全部支持，服务器不用做任何改造。 理论基础：Web页面上调用js文件时是不受否跨域的影响（不仅如此，凡是拥有”src”这个属性的标签都拥有跨域的能力，比如&lt;script&gt;、&lt;img&gt;、&lt;iframe&gt;）。 因为JSONP是利用script标签的特性来实现跨域的，所以不支持post请求。 基本思想：在远程服务器上设法把数据装进 js 格式的文件里，供客户端调用和进一步处理。 首先，网页动态插入&lt;script&gt;元素，由它向跨源网址发出请求。 1234567891011121314151617function addScriptTag(src) { var script = document.createElement('script'); script.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;); script.src = src; document.body.appendChild(script);}window.onload = function () { // 这里使用一个文本来模拟jsonp服务端返回的最终数据格式 // 文本内容：jsonpExe({&quot;data&quot;:&quot;我是jsonp的数据&quot;}); addScriptTag('http://localhost:1000/jsonp.txt?callback=jsonpExe');}function jsonpExe(param) { // jsonp方式传回来的数据本身就是json对象 alert(JSON.stringify(param));} 上面代码通过动态添加&lt;script&gt;元素，向服务器localhost:1000发出请求。注意，该请求的查询字符串有一个callback参数，用来指定回调函数的名字，这对于JSONP是必需的。 服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。 1jsonpExe({&quot;data&quot;:&quot;我是jsonp的数据&quot;}); 由于&lt;script&gt;元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了foo函数，该函数就会立即调用。作为参数的JSON数据被视为JavaScript对象，而不是字符串，因此避免了使用JSON.parse的步骤。 或者使用AJAX调用，示例如下： 12345678910111213141516function getJSONPData() { $.ajax({ type: &quot;get&quot;, url: 'http://localhost:1000/jsonp.txt', dataType: 'jsonp', // 一定要使用 jsonp 类型 success: function(data) { console.log(data); }, error: function(err) {} });}function jsonpExe(param) { // jsonp方式传回来的数据本身就是json对象 alert(JSON.stringify(param));} 表单提交数据不受同源策略的影响 表单提交:123456789101112131415&lt;!-- 成功 --&gt;&lt;form action=&quot;http://localhost:10229/setUserInfo&quot; method=&quot;post&quot;&gt; &lt;p&gt; &lt;label&gt;用户名：&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;user&quot; /&gt; &lt;/p&gt; &lt;p&gt; &lt;label&gt;密&amp;nbsp;&amp;nbsp;&amp;nbsp;码：&lt;/label&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&quot;submit&quot; name=&quot;&quot; value=&quot;提交1&quot;&gt; &lt;input type=&quot;reset&quot; name=&quot;&quot; value=&quot;重置1&quot;&gt; &lt;/p&gt;&lt;/form&gt; ajax请求：12345678910111213// err 跨域$.ajax({ type: &quot;post&quot;, url: 'http://localhost:10229/setUserInfo', data: { user: 'suyp' }, success: function(data) { console.log(data); $('.txt-erea').text(data); }, error: function(err) {}}); 发散一下思维：虽然form标签只能发送数据，但是没有跨域问题，所以在只需要发送消息的时候也可以使用form来进行单方面通信。Canvas中的跨域问题受影响的方法如下： getImageData()：返回一个ImageData对象，用来描述canvas区域隐含的像素数据 toBlob()：创造Blob对象，用以展示canvas上的图片；这个图片文件可以被缓存或保存到本地，由用户代理端自行决定。如不特别指明，图片的类型默认为 image/png，分辨率为96dpi。 toDataURL() ：返回一个包含图片展示的 data URI 。可以使用 type 参数其类型，默认为 PNG 格式。图片的分辨率为96dpi。 下面以toDataURL() 为例。 在使用Canvas绘制不同域的图片然后转为Base64时，会有跨域问题。但是，不影响Canvas绘制展示图片。 1234567891011121314151617&lt;body&gt; &lt;canvas id=&quot;myCanvas&quot; width=&quot;1920&quot; height=&quot;1080&quot; style=&quot;border: 2px solid grey&quot;&gt;当前浏览器不支持canvas&lt;/canvas&gt;&lt;/body&gt;&lt;script&gt; var canvas = document.getElementById(&quot;myCanvas&quot;) var context = canvas.getContext(&quot;2d&quot;) var img = new Image() // img.src = './img/思路logo紫.png'; // 同源图片 img.src = 'http://localhost:8090/CORS/思路logo蓝.png'; // 不同源图片 //图片加载完后，将其显示在canvas中 img.onload = function() { context.drawImage(this, 0, 0, 1920, 1080) // 改变图片大小到1080*980 // toDataURL是向canvas转为Base64的一个方法 console.log(canvas.toDataURL('image/png')); }&lt;/script&gt; 报错： 解决方式： 设置图片的crossOrigin = 'anonymous',来让toDataURL方法不因跨域报错 设置图片可跨域二者缺一不可。1234567891011121314151617&lt;body&gt;&lt;canvas id=&quot;myCanvas&quot; width=&quot;1920&quot; height=&quot;1080&quot; style=&quot;border: 2px solid grey&quot;&gt;当前浏览器不支持canvas&lt;/canvas&gt;&lt;/body&gt;&lt;script&gt;var canvas = document.getElementById(&quot;myCanvas&quot;)var context = canvas.getContext(&quot;2d&quot;)var img = new Image()img.src = 'http://localhost:8090/CORS/思路logo蓝.png'; // 不同源图片img.crossOrigin = 'anonymous';//图片加载完后，将其显示在canvas中img.onload = function() { context.drawImage(this, 0, 0, 1920, 1080) // 改变图片大小到1080*980 // toDataURL是向canvas转为Base64的一个方法 console.log(canvas.toDataURL('image/png'));}&lt;/script&gt; 不允许IFrame被嵌入在响应头中有这么一个配置项 X-Frame-Options来标识一个页面是否可以被其他页面嵌入。可选值： deny：表示该页面不允许在 frame 中展示，即便是在相同域名的页面中嵌套也不允许。 sameorigin：表示该页面可以在相同域名页面的 frame 中展示。 allow-from uri：表示该页面可以在指定来源的 frame 中展示。（uri为指定源的地址） 配置： Tomcat 在 Tomcat根目录 –&gt; conf –&gt; web.xml 的 web-app 节点下加入如下代码。 1234567891011121314151617 &lt;!-- 配置页面是否能被其他页面展示 --&gt;&lt;filter&gt; &lt;filter-name&gt;httpHeaderSecurity&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.catalina.filters.HttpHeaderSecurityFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;antiClickJackingOption&lt;/param-name&gt; &lt;!-- 配置的具体值 --&gt; &lt;param-value&gt;sameorigin&lt;/param-value&gt; &lt;/init-param&gt; &lt;async-supported&gt;true&lt;/async-supported&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;httpHeaderSecurity&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt; &lt;dispatcher&gt;FORWARD&lt;/dispatcher&gt;&lt;/filter-mapping&gt; 12345678910111213141516171819202122 &lt;!-- 配置页面是否能被其他页面展示 --&gt;&lt;filter&gt; &lt;filter-name&gt;httpHeaderSecurity&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.catalina.filters.HttpHeaderSecurityFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;antiClickJackingOption&lt;/param-name&gt; &lt;!-- 配置的具体值 --&gt; &lt;param-value&gt;allow-from&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 当指定部分域可展示时，使用下面代码配置指定域 --&gt; &lt;init-param&gt; &lt;param-name&gt;antiClickJackingUri&lt;/param-name&gt; &lt;param-value&gt;http://127.0.0.1:10229&lt;/param-value&gt; &lt;/init-param&gt; &lt;async-supported&gt;true&lt;/async-supported&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;httpHeaderSecurity&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt; &lt;dispatcher&gt;FORWARD&lt;/dispatcher&gt;&lt;/filter-mapping&gt; 注：目前测试指定域可嵌入无效，错误如下： 1testIframe.html:1 Invalid 'X-Frame-Options' header encountered when loading 'http://localhost:8090/CORS/testIframe.html': 'ALLOW-FROM http://127.0.0.1:10229' is not a recognized directive. The header will be ignored. Nginx配置 nginx 发送 X-Frame-Options 响应头，把下面这行添加到 ‘http’, ‘server’ 或者 ‘location’ 的配置中:add_header X-Frame-Options sameorigin always;add_header X-Frame-Options deny always;add_header X-Frame-Options allow-from 'http://127.0.0.1,http://127.0.0.2' always;小结：跨域网络访问推荐做法： 在能随意操作文件的情况优先把资源分类放到一起，这样既不会有跨域请求问题，也方便管理。 不行的话，使用Nginx代理。 跨域数据存储访问（Cross-origin data storage access）使用域名document.domain 属性中存入的是主机信息，并且可以设置为当前域或者当前域的父域。如果将其设置为其当前域的父域，则这个较短的父域将用于后续源检查。另外，任何对document.domain的赋值操作，包括 document.domain = document.domain 都会导致端口号被重写为 null。因此 company.com:8080 不能仅通过设置 document.domain = “company.com” 来与company.com 通信。必须在他们双方中都进行赋值，以确保端口号都为 null 。 由于以上的情况，我们可以在多个只有二级域名不同的网页进行以下操作。 注： 域名 域名分类 CookieCookie 是服务器写入浏览器的一小段信息，只有同源的网页才能共享。但是，两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置 document.domain共享 Cookie。 举例来说，A网页是http://w1.example.com/a.html，B网页是http://w2.example.com/b.html，那么只要设置相同的document.domain，两个网页就可以共享Cookie。 1document.domain = 'example.com'; 现在，A网页通过脚本设置一个 Cookie。 1document.cookie = &quot;test1=hello&quot;; B网页就可以读到这个 Cookie。 1var allCookie = document.cookie; 另外，服务器也可以在设置Cookie的时候，指定Cookie的所属域名为一级域名，这样二级域名和三级域名不用做任何设置，都可以读取这个Cookie。 DOM如果两个窗口一级域名相同，只是二级域名不同，那么设置上一节介绍的 document.domain属性，就可以规避同源策略，拿到DOM。 父页面： 123456window.onload = function() { document.domain = 'suyp.com'; document.cookie = 'username=suyp';} 子页面： 1234567891011121314151617181920window.onload = function() { document.domain = 'suyp.com'}// 这里请求时，会带上父页面的cookie: document.cookie = 'username=suyp';function getData() { $.ajax({ type: &quot;get&quot;, url: 'http://localhost:10229/node', // 默认情况下，标准的跨域请求是不会发送cookie的 xhrFields: { withCredentials: true }, success: function(data) { console.log(data); // $('.txt-erea').text(data); }, error: function(err) {} });} Node服务端： 123456789101112131415161718192021222324252627// 在开启服务的代码基础上新加如下代码const express = require('express');const app = express();const cookieParser = require('cookie-parser');app.use(cookieParser());app.get('/node', (req, res) =&gt; { // 使用cookie时不能设置域为 * res.header('Access-Control-Allow-Origin', req.headers.origin); // 允许的header类型 res.header('Access-Control-Allow-Headers', 'content-type'); // 跨域允许的请求方式 res.header('Access-Control-Allow-Methods', 'DELETE,PUT,POST,GET,OPTIONS'); // 要设置允许客户端携带验证信息 res.header('Access-Control-Allow-Credentials', true); console.log('cookie信息'); console.log(req.cookies); res.end('');});/** * 开启监听 */app.listen(port, function(){ console.log('ok')}); 注： 同源ajax请求是可以自动携带cookie的 而非同源需要客户端和服务端都做处理： 客户端需要对xhr对象设置withCredentials:true 服务端需要设置响应头 access-control-allow-credentials:true 同时必须指明 access-control-allow-origin 为服务方的origin， 不能为* 新增属性：Chrome 51 开始，浏览器的 Cookie 新增加了一个SameSite属性，用来防止 CSRF 攻击和用户追踪。可选值： StrictStrict最为严格，完全禁止第三方 Cookie，跨站点时，任何情况下都不会发送 Cookie。换言之，只有当前网页的 URL 与请求目标一致，才会带上 Cookie。 LaxLax规则稍稍放宽，大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外。 NoneNone相当于忽略该属性。不过，前提是必须同时设置Secure属性（Cookie 只能通过 HTTPS 协议发送），否则无效。 相关东西，后面补充。 小结：跨域数据存储访问推荐做法： 把文件放在一起或者使用Nginx代理到一起 （推荐） 如果使用的域名可以考虑设置document.domain属性 完全不同源，可以考虑通过跨域通信的方式传递相关参数 跨域脚本API访问（Cross-origin script API access）如果两个网页不同源，就无法拿到对方的DOM。典型的例子是iframe窗口和window.open方法打开的窗口，它们与父窗口无法通信。 比如，父窗口运行下面的命令，如果iframe窗口不是同源，就会报错。 12document.getElementById(&quot;myIFrame&quot;).contentWindow.document// Uncaught DOMException: Blocked a frame with origin &quot;http://127.0.0.1:5500&quot; from accessing a cross-origin frame. 上面命令中，父窗口想获取子窗口的DOM，因为跨源导致报错。 反之亦然，子窗口获取主窗口的DOM也会报错。 12window.parent.document.body// Uncaught DOMException: Blocked a frame with origin &quot;http://localhost:1000&quot; from accessing a cross-origin frame. 对于完全不同源的网站，目前有四种方法，可以解决跨域窗口的通信问题。 片段标识符（fragment identifier） window.name 跨文档通信API（Cross-document messaging） WebSocket 片段标识符片段标识符（fragment identifier）指的是，URL的#号后面的部分，比如http://example.com/x.html#fragment的#fragment。如果只是改变片段标识符，页面不会重新刷新。也可以叫做锚点, 用作页面定位. 父窗口可以把信息，写入子窗口的片段标识符。 12var srcStr = document.getElementsByClassName(&quot;iframe&quot;)[0].src.split('#')[0] + '#' + encodeURI(value);$('.iframe').attr('src', srcStr); 子窗口通过监听hashchange事件得到通知。 123456window.onhashchange = checkMessage;function checkMessage() { var message = window.location.hash; // ...} 同样的，子窗口也可以改变父窗口的片段标识符。 1parent.location.href= target + &quot;#&quot; + hash; 注意：如果修改后的hash值和原来的一样，不会进片段标识符改变的监听 window.name浏览器窗口有window.name属性。这个属性的最大特点是，无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页可以读取它。 父窗口先打开一个子窗口，载入一个不同源的网页，该网页将信息写入window.name属性。 1window.name = '{&quot;name&quot;: &quot;lisi&quot;}'; 接着，子窗口跳回一个与主窗口同域的网址。 12// 把子页面的window.location 设置为域和父页面同源的window.location = 'http://127.0.0.1:5500/windowName/testWN.html'; 然后，主窗口就可以读取子窗口的window.name了。 1var data = document.getElementById('myFrame').contentWindow.name; 这种方法的优点是，window.name容量很大，可以放置非常长的字符串；代码实现： 123456789101112131415161718var state = 0;iframe = document.createElement('iframe'), loadfn = function() { if (state === 1) { var data = iframe.contentWindow.name; // 读取数据 alert(data); // 你好，我是子页面的window.name， 携带了一些数据 } else if (state === 0) { state = 1; iframe.contentWindow.location = &quot;http://127.0.0.1:10229/page/windowName/null.html&quot;; // 设置的代理文件 } }; iframe.src = 'http://localhost:1000/windowname-nginx.html'; if (iframe.attachEvent) { iframe.attachEvent('onload', loadfn); } else { iframe.onload = loadfn; } document.body.appendChild(iframe); window.postMessage上面两种方法都属于破解，HTML5为了解决这个问题，引入了一个全新的API：跨文档通信 API（Cross-document messaging）。 这个API为window对象新增了一个方法 window.postMessage，允许跨窗口通信，不论这两个窗口是否同源，只要你能获取到目标对象的window对象。 举例来说，父窗口http://aaa.com向子窗口http://bbb.com发消息，调用postMessage方法就可以了。 12var popup = window.open('http://aaa.com', 'title');popup.postMessage('Hello World!', 'http://aaa.com'); postMessage方法的第一个参数是具体的信息内容，第二个参数是接收消息的窗口的源（origin），即”协议 + 域名 + 端口”。也可以设为*，表示不限制域名，向所有窗口发送. 子窗口向父窗口发送消息的写法类似。 1window.opener.postMessage('Nice to see you', 'http://bbb.com'); 注：window.opener 属性是一个可读可写的属性，可返回对创建该窗口的 Window 对象的引用。 父窗口和子窗口都可以通过message事件，监听对方的消息。 123window.addEventListener('message', function(e) { console.log(e.data);},false); 下面的例子是，子窗口通过event.source属性引用父窗口，然后发送消息。 1234window.addEventListener('message', receiveMessage);function receiveMessage(event) { event.source.postMessage('Nice to see you!', '*');} event.origin属性可以过滤不是发给本窗口的消息。 123456789window.addEventListener('message', receiveMessage);function receiveMessage(event) { if (event.origin !== 'http://bbb.com') return; if (event.data === 'Hello World') { event.source.postMessage('Hello', event.origin); } else { console.log(event.data); }} message事件的事件对象event，提供以下三个属性。 event.source：发送消息的窗口 event.origin: 消息发向的网址 event.data: 消息内容 下面的例子是，子窗口通过event.source属性引用父窗口，然后发送消息。 12345678910111213141516window.addEventListener('message', receiveMessage);function receiveMessage(event) { event.source.postMessage('Nice to see you!', '*');}``````event.origin``属性可以过滤不是发给本窗口的消息。```javascriptwindow.addEventListener('message', receiveMessage);function receiveMessage(event) { if (event.origin !== 'http://bbb.com') return; if (event.data === 'Hello World') { event.source.postMessage('Hello', event.origin); } else { console.log(event.data); }} 通过window.postMessage，读写其他窗口的 LocalStorage 或者 SessionStorage也成为了可能。 下面是一个例子，主窗口写入iframe子窗口的localStorage。 1234567window.onmessage = function(e) { if (e.origin !== 'http://bbb.com') { return; } var payload = JSON.parse(e.data); localStorage.setItem(payload.key, JSON.stringify(payload.data));}; 上面代码中，子窗口将父窗口发来的消息，写入自己的LocalStorage。 父窗口发送消息的代码如下。 123var win = document.getElementsByTagName('iframe')[0].contentWindow;var obj = { name: 'Jack' };win.postMessage(JSON.stringify({key: 'storage', data: obj}), 'http://bbb.com'); 加强版的子窗口接收消息的代码如下。 1234567891011121314151617window.onmessage = function(e) { if (e.origin !== 'http://bbb.com') return; var payload = JSON.parse(e.data); switch (payload.method) { case 'set': localStorage.setItem(payload.key, JSON.stringify(payload.data)); break; case 'get': var parent = window.parent; var data = localStorage.getItem(payload.key); parent.postMessage(data, 'http://aaa.com'); break; case 'remove': localStorage.removeItem(payload.key); break; }}; 加强版的父窗口发送消息代码如下。 1234567891011var win = document.getElementsByTagName('iframe')[0].contentWindow;var obj = { name: 'Jack' };// 存入对象win.postMessage(JSON.stringify({key: 'storage', method: 'set', data: obj}), 'http://bbb.com');// 读取对象win.postMessage(JSON.stringify({key: 'storage', method: &quot;get&quot;}), &quot;*&quot;);window.onmessage = function(e) { if (e.origin != 'http://aaa.com') return; // &quot;Jack&quot; console.log(JSON.parse(e.data).name);}; SessionStorage同理。 WebSocketWebSocket是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源策略，只要服务器支持，就可以通过它进行跨源通信。 下面是一个例子，浏览器发出的WebSocket请求的头信息（摘自维基百科）。 12345678GET /chat HTTP/1.1Host: server.example.comUpgrade: websocketConnection: UpgradeSec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==Sec-WebSocket-Protocol: chat, superchatSec-WebSocket-Version: 13Origin: http://example.com 上面代码中，有一个字段是Origin，表示该请求的请求源（origin），即发自哪个域名。 正是因为有了Origin这个字段，所以WebSocket才没有实行同源策略。因为服务器可以根据这个字段，判断是否许可本次通信。如果该域名在白名单内，服务器就会做出如下回应。 12345HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=Sec-WebSocket-Protocol: chat 示例： Node服务端:123456789101112131415161718192021222324252627282930313233const WebSocket = require('ws');// websocket服务的端口const wsport = 3006;var wss = new WebSocket.Server({ port: wsport, path: '/ws'});let webSocketServer = wss.on('connection', function connection(ws) { console.log('ws连接') ws.isAlive = true; ws.on('pong', heartbeat); ws.on('message', function incoming(message) { message = JSON.parse(message); sendAllMessage(webSocketServer, message) });});// 广播消息function sendAllMessage (server, message) { server.clients.forEach(ws=&gt; { ws.send(JSON.stringify(message)); });}// 定时每30s发送ping监测连接是否中断const interval = setInterval(function ping() { wss.clients.forEach(function each(ws) { if (ws.isAlive === false) return ws.terminate(); ws.isAlive = false; ws.ping(); });}, 30000); 页面1：12345678910111213141516171819202122232425var ws = new WebSocket('ws://localhost:3006/ws', 'suyp');ws.onopen = function(param) { console.log('WebSocket连接成功！'); ws.onmessage = function(param) { console.log('这是WebSocket接收的消息 --- ' + param.data); // 接收消息这里推荐写try catch 来捕捉错误，因为消息有可能不是JSON格式 try { var message = JSON.parse(param.data); } catch (e) { console.log(e); } if (message) { switch (message.key) { case 'closeInfoWindow': console.log('弹窗已关闭'); break; default: break; } } } ws.onclose = function() { console.log('ws关闭了'); }} 页面2123456789// 向父页面发送消息,来关闭弹窗function closeInfowWindow2() { if (ws) { ws.send(JSON.stringify({ key: 'closeInfoWindow', msg: '' })) }} 小结跨域脚本API访问推荐做法： Nginx代理到一起 （最好） 使用postMessaget通信 （挺好） 参考资料 什么是JSONP — HansExploration JSONP — 百度百科 浏览器同源策略及其规避方法 — 阮一峰 WebSocket 教程 — 阮一峰 X-Frame-Options — MDN SameSite — MDN","link":"/2020/08/27/%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3/"},{"title":"Vue.js2最佳实践(持续更新至Vue.js3出来😁)","text":"1 写在开头 文档较长，可按需耐心反复阅读。其中带（官）的是直接引用了Vue官方的风格指南。针对Vue性能优化相关内容，单独在内容后进行了标注，可通过搜索“性能优化”四个字查找。 2 Vue.js2模板工程说明2.1 目的封装常用功能和配置，规范代码编写，保证输出的一致性，方便前端人员在此基础上快速开发新项目的业务模块。 2.2 下载模板项目（Boilerplate）分为JavaScript和TypeScript两个版本。 JS： git clone https://github.com/THS-FE/vue2-starter-js.git TS： git clone https://github.com/THS-FE/vue2-starter-ts.git 2.3 目录结构该目录结构适合中大型项目，如果是小型项目，可对目录或模块进行适当删减（尤其是后面有可选标识的）。 2.3.1 JavaScript版123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869├── public // 静态资源 该文件夹下的内容在构建时会直接拷贝到dist文件夹下 ├── favicon.ico // 网站图标 ├── index.html // HTML模板页│ └── ...├── src // 主要的工作目录 ├── assets // 静态资源 会经过webpack打包处理 ├── fonts // 字体文件（可选） └── ... ├── images // 图片 ├── error // error（通用出错页面）模块 └── ... // 使用到的图片 ├── module-a // 用模块命名（可选） └── ... // 该模块下使用到的图片 └── ... // 通用的图片（小项目就不用分文件夹了） └── styles // 样式 ├── common.scss // 常用样式（提供通用的） ├── element-variables.scss // 自定义element样式 ├── global.scss // 全局样式 ├── style.scss // 组装各样式并导出，最终被 main.js 引入 └── ... ├── components // 组件(dumb components，获取props，派发事件) ├── common └── ... // 不同项目中的通用组件 ├── module-a // 用模块命名（可选） └── ... // 该模块下的组件 └── ... // 当前项目中的通用组件 ├── directives // 指令（可选） └── ... // 自定义指令 ├── layouts // 布局（可选） └── ... ├── plugins // vue插件（如：Element，vuetify） ├── element.js // Element按需加载 ├── index.js // 插件的入口文件，组装各插件并导出 └── ... // 自定义插件 ├── router // 路由（统一使用懒加载） ├── index.js // 路由的入口文件，组装各路由并导出 └── ... ├── services // 接口请求 ├── config.js // 常量 ├── index.js // 服务调用的入口文件，组装各模块请求方法并导出 └── ... ├── store // 状态管理（可选） ├── modules // 各模块 └── ... // 命名尽量和views中的模块对应上 ├── actions.js // 根级别的 action ├── getters.js // 根级别的 getter ├── index.js // 状态管理的入口文件，组装各模块并导出 ├── mutation-types.js // mutation事件类型定义 └── mutations.js // 根级别的 mutation ├── utils // 工具类 ├── config.js // 常量 ├── common.js // 常用功能（通用的） ├── request.js // HTTP请求封装 ├── validator.js // 表单验证 └── ... ├── views // 页面(smart components，可以访问store，路由，window) ├── exception // 通用异常页面 ├── not-found.vue // 404页面 └── unauthorized.vue // 403页面 ├── module-a.vue // 用模块命名,如该模块下页面较多，可建以模块为名称的文件夹，在其中创建多个页面 └── ... ├── app.vue // 根组件 └── main.js // 入口文件（引入全局的样式和脚本，可安装插件、注册组件或指令等）├── .browserslistrc // 目标浏览器配置├── .editorconfig // 代码风格规范，如：缩进├── .eslintrc.js // eslint配置├── babel.config.js // babel配置├── package.json // 项目依赖、脚本└── vue.config.js // webpack打包配置 在创建该项目时，没有添加PWA、单元测试和端到端测试。原因：PWA并没有普及，没多少人会使用；各类测试对于需求经常变化的项目来说就是个累赘，测试用例还没有写完，需求变了… 对项目相关工具配置项不了解的，可参看 《从零开始搭建前端项目开发环境》 2.3.2 TypeScript版因Vue3.0取消了基于类的组件（class based component），使用functional based component+hooks(也就是Composition API)，为了降低学习成本，在使用脚手架创建项目时，没有启用vue-class-component。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273├── public // 静态资源 该文件夹下的内容在构建时会直接拷贝到dist文件夹下 ├── favicon.ico // 网站图标 ├── index.html // HTML模板页│ └── ...├── src // 主要工作目录 ├── assets // 静态资源 会被webpack打包处理 ├── fonts // 字体文件（可选） └── ... ├── images // 图片 ├── exception // exception（通用异常页面）模块使用到的图片 └── ... ├── module-a // 此处要用模块命名（可选） └── ... // 该模块下使用到的图片 └── ... // 通用的图片（小项目就不用分文件夹了） └── styles // 样式 ├── common.scss // 常用样式（提供通用的） ├── element-variables.scss // 自定义element样式 ├── global.scss // 全局样式 ├── style.scss // 组装各样式并导出最终被 main.js 引入 └── ... ├── components // 组件(dumb components，获取props，派发事件) ├── common └── ... // 通用组件 ├── module-a // 此处要用模块命名（可选） └── ... // 该模块下的组件 └── ... // 当前项目中的通用组件 ├── directives // 指令（可选） └── ... // 自定义指令 ├── layouts // 布局（可选） └── ... ├── plugins // vue插件（如：Element，vuetify） ├── element.ts // Element按需加载 ├── index.ts // 组装各插件并导出 └── ... ├── router // 路由（统一使用懒加载） ├── index.ts // 组装各路由并导出 └── ... ├── services // 接口请求 ├── config.ts // 常量 ├── index.ts // 组装各请求并导出 └── ... ├── store // 状态管理（可选） ├── modules // 各模块 └── ... // 尽量和views中的模块对应上 ├── actions.ts // 根级别的 action ├── getters.js // 根级别的 getter ├── index.ts // 组装模块并导出 ├── mutation-types.ts // mutation事件类型定义 └── mutations.ts // 根级别的 mutation ├── utils // 工具类 ├── config.ts // 常量 ├── common.ts // 常用功能（提供通用的） ├── request.ts // HTTP请求 ├── validator.ts // 表单验证 └── ... ├── views // 页面(smart components，可以访问store，路由，window) ├── exception // 通用异常展示页面 ├── NotFound.vue // 404页面 └── Unauthorized.vue // 401页面 ├── module-a.vue // 用模块命名,如该模块下页面较多，可建以模块为名称的文件夹，在其中创建多个页面 └── ... ├── app.vue // 根组件 ├── main.ts // 入口文件（引入全局的样式和脚本，可安装插件、注册组件或指令等） ├── shims-tsx.d.ts // 允许使用tsx的文件，用于编写jsx风格的ts代码 └── shims-vue.d.ts // 帮助IDE识别 .vue文件├── .browserslistrc // 目标浏览器配置├── .editorconfig // 代码风格规范├── .eslintrc.js // eslint配置├── babel.config.js // babel配置├── package.json // 项目依赖、脚本├── postcss.config.js// postcss配置├── tsconfig.json // TypeScript配置文件└── vue.config.js // webpack打包配置 2.4 配置变更以下内容均已在模板项目里添加，这里只是做个说明。 2.4.1 新增依赖2.4.1.1 Normalize.css 6.2k为默认的HTML元素样式上提供了跨浏览器的高度一致性。相比于传统的CSS reset，Normalize.css是一种现代的、为HTML5准备的优质替代方案。 安装： npm i normalize.css -S 已在main.js文件中引入： import 'normalize.css'; 2.4.1.2 moment 239.1kDay.js 6.3k是一个轻量的处理时间和日期的 JavaScript 库，和 Moment.js 的 API 设计保持完全一样，用于解析、检验、操作、以及显示日期。 安装： npm i dayjs -S 可在任何需要的文件中引入： 1234import dayjs from 'dayjs';import 'dayjs/locale/zh-cn';dayjs.locale('zh-cn'); // 使用中文 2.4.1.3 Element 637.7k一套为开发者、设计师和产品经理准备的基于 Vue2.0 的桌面端组件库。 安装： npm i element-ui -S 已在plugins/index.js文件中引入： 12345import ElementUI from 'element-ui';import '@/assets/styles/element-variables.scss';Vue.use(ElementUI); 项目中已改成按需加载。 2.4.1.4 axios 12.9k是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。 安装： npm i axios -S 已在utils/request.js文件中引入： import axios from 'axios'; 2.4.1.5 vue-event-proxy 1.79kb让Vue.js支持全局事件的库。 通过增加前缀实现全局事件，能在不同组件间进行数据通信 组件销毁自动移除注册的事件 安装： npm i vue-event-proxy -S 已在plugins/index.js文件中引入： 123import EventBus from 'vue-event-proxy';Vue.use(EventBus); TS版需要同时在shims-vue.d.ts文件中添加模块申明： declare module 'vue-event-proxy' 在非父子组件间使用（相当于事件总线）： 12345// 发布this.$emit('global:你的事件名字');// 监听this.$on('global:你的事件名字', () =&gt; {}); 如不加 global: 前缀，则和平时使用的方式一致。 2.4.2 新增功能2.4.2.1 request定义拦截器对HTTP请求配置做统一处理。 已写在utils/request.js文件中，需按实际项目需要进行修改： 123456789101112131415161718192021222324252627282930313233343536373839import axios from 'axios';const service = axios.create({ baseURL: process.env.VUE_APP_BASE_API, // url = base url + request url// withCredentials: true, // 如跨域请求时要带上cookie,则设置为true timeout: 5000, // 请求超时时长});service.interceptors.request.use( (config) =&gt; { // 按需添加内容 // eslint-disable-next-line no-empty if (config.method === 'post') { } return config; }, (error) =&gt; { console.log(error); return Promise.reject(error); },);service.interceptors.response.use( (response) =&gt; { // 如果返回的状态不是200 就报错 按需修改 if (response.status &amp;&amp; response.status !== 200) { return Promise.reject(new Error('Error')); } return response; }, (error) =&gt; { console.log(error); return Promise.reject(error); },);export default service; 如果使用同一个服务地址，那么还需要在vue.config.js中要修改： // 设置HTTP请求的base url，需修改 12// 设置HTTP请求的base url，需修改process.env.VUE_APP_BASE_API = isProd() ? '这里要修改成实际的地址' : ''; 2.4.2.2 导航守卫通过跳转或取消的方式守卫导航。 已写在router/index.js文件中，需按实际项目需要进行修改： 1234567891011121314router.beforeEach((to, from, next) =&gt; { // 如果登录的时候设置过; if (localStorage.getItem('token') != null) { next(); } else { // 如果没有设置这个值为空,说明没有登录，导向登录页 // eslint-disable-next-line no-lonely-if if (to.name === 'login') { next(); } else { next({ path: '/login' }); } }}); 2.4.2.3 路由拆分按模块拆分成不同的路由文件，方便多人协作同步开发，互不影响。 可在router/index.js 文件中添加： 1234567891011121314151617181920212223import homeRoutes from './home'; // 引入首页模块的路由// routes 需要定义类型let routes: RouteConfig[] = [{ path: '/', redirect: '/login',},{ path: '/login', name: 'login', component: Login,},...];routes = [...routes, ...homeRoutes]; // 合并它模块的路由const router = new Router({ mode: 'history', base: process.env.BASE_URL, routes,}); 2.4.2.4 store拆分如果项目非常大状态就会有很多，如不进行分类处理，所有的状态和对状态的处理都放一个文件里面，代码会很臃肿，不利于后期的维护。 在store/index.js 文件中： 12345678910111213141516171819import mutations from './mutations';import actions from './actions';import getters from './getters';import user from './modules/user';const state = {};export default new Vuex.Store({ state, getters, actions, mutations, modules: { user, },}); 2.4.2.5 Vue Composition API方便以后平滑过渡到 Vue.js3.0。 安装： npm i @vue/composition-api -S 已在plugins/index.js文件中引入： 123import VueCompositionApi from '@vue/composition-api'Vue.use(VueCompositionApi) 2.4.2.6 主题切换使用CSS Variables 2.4.3 配置新增2.4.3.1 vue.config.js为了不改变默认配置，在 configureWebpack 中通过 Object.assign 的方式合并配置，这种方式只会对配置进行新增、修改，而不会过多地改变默认配置。 2.4.3.1.1 去除console1234// 去除 consoleObject.assign(config.optimization.minimizer[0].options.terserOptions.compress, { drop_console: true,}); 2.4.3.1.2 分离第三方库123456789// 单独将 elementUI 拆包Object.assign(config.optimization.splitChunks.cacheGroups, { elementUI: { name: 'chunk-elementUI', priority: 20, // 权重要大于 vendors 和 app 不然会被打包进 vendors 或者 app test: /[\\\\/]node_modules[\\\\/]element-ui[\\\\/]/, chunks: 'all', },}); 2.4.3.2 Element 按需加载 (性能优化1)安装： npm install babel-plugin-component -D 修改babel.config.js： 123456789101112131415module.exports = { presets: [ '@vue/cli-plugin-babel/preset', ], // element按需加载 plugins: [ [ 'component', { libraryName: 'element-ui', styleLibraryName: 'theme-chalk', }, ], ],}; 2.5 安装运行在项目所在文件夹下运行命令行安装依赖： npm install 如果NPM下载慢的话，可使用以下命令： npm install --registry=https://registry.npm.taobao.org 项目启动： npm run serve 项目打包： npm run build 3 命名3.1 组件尽量将组件放在对应目录所属模块的文件夹之下，若只有一个文件的则直接放在components或views目录下，如：login，home。 组件名尽量为名词，开头的单词就是所属模块的名字。 3.1.1（官）使用两个或以上单词根组件 App 以及 &lt;transition&gt;、&lt;component&gt; 之类的 Vue 内置组件除外。这样做可以避免跟现有的以及未来的 HTML 元素相冲突，因为所有的 HTML 元素名称都是单个单词的。 Bad 123Vue.component('todo', { // ...}) 1234export default { name: 'Todo', // ...} Good 123Vue.component('todo-item', { // ...}) 1234export default { name: 'TodoItem', // ...} 常用的结尾单词有 123456789***-detail.vue***-edit.vue***-list.vue***-info.vue***-report.vue 3.1.2（官）使用PascalCase或kebab-case命名组件文件单词大写开头对于代码编辑器的自动补全最为友好。 Bad 12components/|- mycomponent.vue 12components/|- myComponent.vue Good 123components/|- my-component.vue 3.1.3（官）JS/JSX 中的组件名应该始终使用 PascalCase 进行命名在 JavaScript 中，PascalCase 是类和构造函数 (本质上任何可以产生多份不同实例的东西) 的命名约定。Vue 组件也有多份实例，所以同样使用 PascalCase 是有意义的。额外的好处是，在 JSX (和模板) 里使用 PascalCase 使得代码的读者更容易分辨 Vue 组件和 HTML 元素。 然而，对于只通过 Vue.component 定义全局组件的应用来说，推荐 kebab-case 作为替代。原因是： 全局组件很少被 JavaScript 引用，所以遵守 JavaScript 的命名约定意义不大。 这些应用往往包含许多 DOM 内的模板，这种情况下是必须使用 kebab-case 的。 Bad 123Vue.component('myComponent', { // ...}) 1import myComponent from './MyComponent.vue' 1234export default { name: 'myComponent', // ...} 1234export default { name: 'my-component', // ...} Good 123Vue.component('MyComponent', { // ...}) 123Vue.component('my-component', { // ...}) 1import MyComponent from './MyComponent.vue' 1234export default { name: 'MyComponent', // ...} 3.1.4（官）和父组件紧密耦合的子组件应该以父组件名作为前缀命名可以试着通过在其父组件命名的目录中嵌套子组件以解决这个问题。比如： 123456components/|- TodoList/ |- Item/ |- index.vue |- Button.vue |- index.vue 或： 123456components/|- TodoList/ |- Item/ |- Button.vue |- Item.vue|- TodoList.vue 但是这种方式并不推荐，因为这会导致： 许多文件的名字相同，使得在编辑器中快速切换文件变得困难。 过多嵌套的子目录增加了在编辑器侧边栏中浏览组件所花的时间。 Bad 1234components/|- TodoList.vue|- TodoItem.vue|- TodoButton.vue 123components/|- SearchSidebar.vue|- NavigationForSearchSidebar.vue Good 1234components/|- TodoList.vue|- TodoListItem.vue|- TodoListItemButton.vue 123components/|- SearchSidebar.vue|- SearchSidebarNavigation.vue 3.1.5（官）以高级别的(通常是一般化描述的) 单词开头，以描述性的修饰词结尾比如对于一个带搜索表单的应用来说，它可能包含这样的组件： 1234567components/|- ClearSearchButton.vue|- ExcludeFromSearchInput.vue|- LaunchOnStartupCheckbox.vue|- RunSearchButton.vue|- SearchInput.vue|- TermsCheckbox.vue 很难看出来哪些组件是针对搜索的。现根据规则给组件重新命名： 1234567components/|- SearchButtonClear.vue|- SearchButtonRun.vue|- SearchInputExcludeGlob.vue|- SearchInputQuery.vue|- SettingsCheckboxLaunchOnStartup.vue|- SettingsCheckboxTerms.vue 因为编辑器通常会按字母顺序组织文件，所以现在组件之间的重要关系一目了然。 若换成多级目录的方式，把所有的搜索组件放到“search”目录，把所有的设置组件放到“settings”目录。只推荐在非常大型 (如有 100+ 个组件) 的应用下才考虑这么做，因为： 在多级目录间找来找去，要比在单个 components 目录下滚动查找花费更多的精力。 存在组件重名 (比如存在多个 ButtonDelete 组件) 的时候在编辑器里更难快速定位。 让重构变得更难，为一个移动了的组件更新相关引用时，查找/替换通常并不高效。 Bad 1234567components/|- ClearSearchButton.vue|- ExcludeFromSearchInput.vue|- LaunchOnStartupCheckbox.vue|- RunSearchButton.vue|- SearchInput.vue|- TermsCheckbox.vue Good 1234567components/|- SearchButtonClear.vue|- SearchButtonRun.vue|- SearchInputQuery.vue|- SearchInputExcludeGlob.vue|- SettingsCheckboxTerms.vue|- SettingsCheckboxLaunchOnStartup.vue 3.1.6（官）使用完整单词而不是缩写编辑器中的自动补全已经让书写长命名的代价非常之低了，而其带来的明确性却是非常宝贵的。不常用的缩写尤其应该避免。 Bad 123components/|- SdSettings.vue|- UProfOpts.vue Good 123components/|- StudentDashboardSettings.vue|- UserProfileOptions.vue 3.1.7（官）基础组件(也就是展示类的、无逻辑的或无状态的组件) 应该全部以一个特定的前缀开头，比如 Base 当在编辑器中以字母顺序排序时，应用的基础组件会全部列在一起，这样更容易识别。 因为组件名应该始终是多个单词，所以这样做可以避免在包裹简单组件时随意选择前缀 (比如 MyButton、VueButton)。 因为这些组件会被频繁使用，所以可能想把它们放到全局而不是在各处分别导入它们。 Bad 1234components/|- MyButton.vue|- VueTable.vue|- Icon.vue Good 1234components/|- BaseButton.vue|- BaseTable.vue|- BaseIcon.vue 3.1.8（官）单个活跃实例的组件应该以The前缀命名，以示其唯一性这不意味着组件只可用于一个单页面，而是每个页面只使用一次。这些组件永远不接受任何 prop，因为它们是为应用定制的，而不是它们在应用中的上下文。如果发现有必要添加 prop，那就表明这实际上是一个可复用的组件，只是目前在每个页面里只使用一次。 Bad 123components/|- Heading.vue|- MySidebar.vue Good 123components/|- TheHeading.vue|- TheSidebar.vue 3.2 Prop3.2.1（官）应该始终使用camelCase，而在模板和 JSX 中应该始终使用 kebab-case我们单纯的遵循每个语言的约定。在 JavaScript 中更自然的是 camelCase。而在 HTML 中则是 kebab-case。 Bad 123props: { 'greeting-text': String} 1&lt;WelcomeMessage greetingText=&quot;hi&quot;/&gt; Good 123props: { greetingText: String} 1&lt;WelcomeMessage greeting-text=&quot;hi&quot;/&gt; 3.3 method3.3.1 要是动宾短语Bad go、nextPage、show、open、login Good jumpPage、openCarInfoDialog 尽量使用常用单词开头： set、get、open、close、jump 3.3.2 使用camelCase进行命名Bad get_list_data、getlistData Good getListData 3.4 事件3.4.1（官）使用kebab-case进行命名无论是camelCase 或 PascalCase的命名，都能被监听到，但 DOM 模板中使用会感觉怪怪的。 3.4.2 以动词或是名词结尾如：upload-success、upload-error 、 dropzone-upload-success、dropzone-upload-error。 3.5 文件夹3.5.1 尽量是小写的单个名词有复数结构时，要采用复数命名法。例：scripts, styles, images。 3.5.2 如不是单个，则使用 kebab-case进行命名使用kebab-case命名的文件夹比camelCase命名的文件夹看起来更清晰，可参考node_modules文件夹里的内容。 Bad 123errorPageErrorPage Good 1error-page 3.6 文件3.6.1 *.js文件命名规范统一使用kebab-case风格 3.6.2 *.ts文件命名规范统一使用kebab-case风格 3.6.3 *.scss文件命名规范统一使用kebab-case命名风格 3.6.4 其它文件命名规范统一使用kebab-case命名风格 4 一般约束4.1（官）顶级App组件和布局组件中的样式可以是全局的，但是其它所有组件都应该是有作用域的这条规则只和单文件组件有关。不一定要使用 scoped 特性。设置作用域也可以通过 CSS Modules，那是一个基于 class 的类似 BEM 的策略，当然也可以使用其它的库或约定。 Bad 123456789&lt;template&gt; &lt;button class=&quot;btn btn-close&quot;&gt;X&lt;/button&gt;&lt;/template&gt;&lt;style&gt;.btn-close { background-color: red;}&lt;/style&gt; Good 123456789101112131415&lt;template&gt; &lt;button class=&quot;button button-close&quot;&gt;X&lt;/button&gt;&lt;/template&gt;&lt;!-- 使用 `scoped` 特性 --&gt;&lt;style scoped&gt;.button { border: none; border-radius: 2px;}.button-close { background-color: red;}&lt;/style&gt; 123456789101112131415&lt;template&gt; &lt;button :class=&quot;[$style.button, $style.buttonClose]&quot;&gt;X&lt;/button&gt;&lt;/template&gt;&lt;!-- 使用 CSS Modules --&gt;&lt;style module&gt;.button { border: none; border-radius: 2px;}.buttonClose { background-color: red;}&lt;/style&gt; 123456789101112131415&lt;template&gt; &lt;button class=&quot;c-Button c-Button--close&quot;&gt;X&lt;/button&gt;&lt;/template&gt;&lt;!-- 使用 BEM 约定 --&gt;&lt;style&gt;.c-Button { border: none; border-radius: 2px;}.c-Button--close { background-color: red;}&lt;/style&gt; 4.2（官）始终为插件、混入等不考虑作为对外公共API的自定义私有属性使用 $_ 前缀。并附带一个命名空间以回避和其它作者的冲突Vue 使用 _前缀来定义其自身的私有属性，所以使用相同的前缀 (比如_update) 有覆写实例属性的风险。即便检查确认 Vue 当前版本没有用到这个属性名，也不能保证和将来的版本没有冲突。 对于 $ 前缀来说，其在 Vue 生态系统中的目的是暴露给用户的一个特殊的实例属性，所以把它用于私有属性并不合适。 不过，推荐把这两个前缀结合为 $_，作为一个用户定义的私有属性的约定，以确保不会和 Vue 自身相冲突。。 Bad 12345678var myGreatMixin = { // ... methods: { update: function () { // ... } }} 12345678var myGreatMixin = { // ... methods: { _update: function () { // ... } }} 12345678var myGreatMixin = { // ... methods: { $update: function () { // ... } }} Good 12345678var myGreatMixin = { // ... methods: { $_myGreatMixin_update: function () { // ... } }} 12345678910111213141516// 甚至更好！var myGreatMixin = { // ... methods: { publicMethod() { // ... myPrivateFunction() } }}function myPrivateFunction() { // ...}export default myGreatMixin 4.3（官）在单文件组件、字符串模板和JSX中没有内容的组件应该是自闭合的——但在 DOM 模板里永远不要这样做自闭合组件表示它们不仅没有内容，而且刻意没有内容。其不同之处就好像书上的一页白纸对比贴有&quot;本页有意留白&quot;标签的白纸。而且没有了额外的闭合标签，代码也更简洁。 不幸的是，HTML 并不支持自闭合的自定义元素——只有官方的&quot;空&quot;元素。所以上述策略仅适用于进入 DOM 之前 Vue 的模板编译器能够触达的地方，然后再产出符合 DOM 规范的 HTML。 Bad 12&lt;!-- 在单文件组件、字符串模板和 JSX 中 --&gt;&lt;MyComponent&gt;&lt;/MyComponent&gt; 12&lt;!-- 在 DOM 模板中 --&gt;&lt;my-component/&gt; Good 12&lt;!-- 在单文件组件、字符串模板和 JSX 中 --&gt;&lt;MyComponent/&gt; 12&lt;!-- 在 DOM 模板中 --&gt;&lt;my-component&gt;&lt;/my-component&gt; 4.4（官）组件的data必须是一个函数当在组件中使用 data 属性的时候 (除了 new Vue 外的任何地方)，它的值必须是返回一个对象的函数。 当 data 的值是一个对象时，它会在这个组件的所有实例之间共享。若希望每个组件实例都管理其自己的数据。为了做到这一点，每个实例必须生成一个独立的数据对象。在 JavaScript 中，在一个函数中返回这个对象就可以了。 Bad 12345Vue.component('some-comp', { data: { foo: 'bar' }}) 12345export default { data: { foo: 'bar' }} Good 1234567Vue.component('some-comp', { data: function () { return { foo: 'bar' } }}) 12345678910// In a .vue file 尽量使用简写export default { data () { // 可以在这里写很多的前置数据操作 ... return { foo: 'bar' } }} 1234567// 在一个 Vue 的根实例上直接使用对象是可以的，// 因为只存在一个这样的实例。new Vue({ data: { foo: 'bar' }}) 4.5（官）Prop定义要详细：类型、必填、验证细致的 prop定义有两个好处： 它们写明了组件的 API，所以很容易看懂组件的用法； 在开发环境下，如果向一个组件提供格式不正确的 prop，Vue 将会告警，以帮助你捕获潜在的错误来源。 Bad 123Vue.component({ props: ['status']}) Good 123456789Vue.component({ props: { status: { type: String, required: true, validator: (value) =&gt; ['syncing', 'synced', 'error'].includes(value); } }}) 4.6（官）尽量使用指令缩写，而且要么都用要么都不用用 : 表示 v-bind: 、用 @ 表示 v-on: 和用 # 表示 v-slot。 Bad 1234&lt;input v-bind:value=&quot;newTodoText&quot; :placeholder=&quot;newTodoInstructions&quot;&gt; 1234&lt;input v-on:input=&quot;onInput&quot; @focus=&quot;onFocus&quot;&gt; 1234567&lt;template v-slot:header&gt; &lt;h1&gt;Here might be a page title&lt;/h1&gt;&lt;/template&gt;&lt;template #footer&gt; &lt;p&gt;Here's some contact info&lt;/p&gt;&lt;/template&gt; Good 1234&lt;input :value=&quot;newTodoText&quot; :placeholder=&quot;newTodoInstructions&quot;&gt; 1234&lt;input v-bind:value=&quot;newTodoText&quot; v-bind:placeholder=&quot;newTodoInstructions&quot;&gt; 1234&lt;input @input=&quot;onInput&quot; @focus=&quot;onFocus&quot;&gt; 1234&lt;input v-on:input=&quot;onInput&quot; v-on:focus=&quot;onFocus&quot;&gt; 1234567&lt;template v-slot:header&gt; &lt;h1&gt;Here might be a page title&lt;/h1&gt;&lt;/template&gt;&lt;template v-slot:footer&gt; &lt;p&gt;Here's some contact info&lt;/p&gt;&lt;/template&gt; 1234567&lt;template #header&gt; &lt;h1&gt;Here might be a page title&lt;/h1&gt;&lt;/template&gt;&lt;template #footer&gt; &lt;p&gt;Here's some contact info&lt;/p&gt;&lt;/template&gt; 4.7（官）应该优先通过Vuex管理全局状态，而不是通过 this.$root 或一个全局事件总线通过 this.$root和/或全局事件总线管理状态在很多简单的情况下都是很方便的，但是并不适用于绝大多数的应用。Vuex 提供的不仅是一个管理状态的中心区域，还是组织、追踪和调试状态变更的好工具。 Bad 1234567891011121314151617// main.jsnew Vue({ data: { todos: [] }, created: function () { this.$on('remove-todo', this.removeTodo) }, methods: { removeTodo: function (todo) { var todoIdToRemove = todo.id this.todos = this.todos.filter(function (todo) { return todo.id !== todoIdToRemove }) } }}) Good 12345678910111213141516// store/modules/todos.jsexport default { state: { list: [] }, mutations: { REMOVE_TODO (state, todoId) { state.list = state.list.filter(todo =&gt; todo.id !== todoId) } }, actions: { removeTodo ({ commit, state }, todo) { commit('REMOVE_TODO', todo.id) } }} 1234567891011121314151617181920212223&lt;!-- TodoItem.vue --&gt;&lt;template&gt; &lt;span&gt; {{ todo.text }} &lt;button @click=&quot;removeTodo(todo)&quot;&gt; X &lt;/button&gt; &lt;/span&gt;&lt;/template&gt;&lt;script&gt;import { mapActions } from 'vuex'export default { props: { todo: { type: Object, required: true } }, methods: mapActions(['removeTodo'])}&lt;/script&gt; 4.8（官）简单逻辑可在模板中使用表达式，中等逻辑操作使用computed ，复杂或需调用异步方法时使用watch模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。例如： 123&lt;div id=&quot;example&quot;&gt; {{ message.split('').reverse().join('') }}&lt;/div&gt; 在这个地方，模板不再是简单的声明式逻辑。你必须看一段时间才能意识到，这里是想要显示变量message的翻转字符串。当你想要在模板中多次引用此处的翻转字符串时，就会更加难以处理。所以，对于任何复杂逻辑，你都应当使用计算属性。 1234&lt;div id=&quot;example&quot;&gt; &lt;p&gt;Original message: &quot;{{ message }}&quot;&lt;/p&gt; &lt;p&gt;Computed reversed message: &quot;{{ reversedMessage }}&quot;&lt;/p&gt;&lt;/div&gt; 12345678910111213var vm = new Vue({ el: '#example', data: { message: 'Hello' }, computed: { // 计算属性的 getter reversedMessage: function () { // `this` 指向 vm 实例 return this.message.split('').reverse().join('') } }}) 虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么 Vue 通过watch选项提供了一个更通用的方法，来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。 123456789101112131415161718192021222324252627282930313233&lt;script&gt;var watchExampleVM = new Vue({ el: '#watch-example', data: { question: '', answer: 'I cannot give you an answer until you ask a question!' }, watch: { // 如果 `question` 发生改变，这个函数就会运行 question: function (newQuestion, oldQuestion) { this.answer = 'Waiting for you to stop typing...'this.debouncedGetAnswer() } }, created: function () { // `_.debounce` 是一个通过 Lodash 限制操作频率的函数。// 在这个例子中，我们希望限制访问 yesno.wtf/api 的频率// AJAX 请求直到用户输入完毕才会发出。想要了解更多关于// `_.debounce` 函数 (及其近亲 `_.throttle`) 的知识，// 请参考：https://lodash.com/docs#debouncethis.debouncedGetAnswer = _.debounce(this.getAnswer, 500) }, methods: { getAnswer: function () { if (this.question.indexOf('?') === -1) { this.answer = 'Questions usually contain a question mark. ;-)'return } this.answer = 'Thinking...'var vm = this axios.get('https://yesno.wtf/api') .then(function (response) { vm.answer = _.capitalize(response.data.answer) }) .catch(function (error) { vm.answer = 'Error! Could not reach the API. ' + error }) } }})&lt;/script&gt; 4.9 生命周期函数调用规则 5 编程思想5.1（官）组件模板应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法复杂表达式会让模板变得不那么声明式。应该尽量描述应该出现的是什么，而非如何计算那个值。而且计算属性和方法使得代码可以重用。Bad 12345{{ fullName.split(' ').map(function (word) { return word[0].toUpperCase() + word.slice(1) }).join(' ')}} Good 12&lt;!-- 在模板中 --&gt;{{ normalizedFullName }} 12345678// 复杂表达式已经移入一个计算属性computed: { normalizedFullName: function () { return this.fullName.split(' ').map(function (word) { return word[0].toUpperCase() + word.slice(1) }).join(' ') }} 5.2（官）应该优先通过prop和事件进行父子组件之间的通信，而不是 this.$parent 或改变 prop一个理想的 Vue 应用是 prop 向下传递，事件向上传递的。遵循这一约定会让组件更易于理解。访问组件之外的上下文违反了基于模块开发的第一原则。因此应该尽量避免使用 this.$parent。 组件必须相互保持独立，Vue 组件也是。如果组件需要访问其父层的上下文就违反了该原则。 如果一个组件需要访问其父组件的上下文，那么该组件将不能在其它上下文中复用。 在有些情况下，可能需要对一个 prop 进行&quot;双向绑定&quot;。不幸的是，真正的双向绑定会带来维护上的问题，因为子组件可以修改父组件，且在父组件和子组件都没有明显的改动来源，推荐以 update:myPropName 的模式触发事件取而代之。在子组件中通过.sync/emit模式来改变父组件传入的Props的值。 Bad 1234567891011121314151617181920212223Vue.component('TodoItem', { props: { todo: { type: Object, required: true } }, methods: { removeTodo () { var vm = this; vm.$parent.todos = vm.$parent.todos.filter(function (todo) { return todo.id !== vm.todo.id }) } }, template: ` &lt;span&gt; {{ todo.text }} &lt;button @click=&quot;removeTodo&quot;&gt; X &lt;/button&gt; &lt;/span&gt; `}) Good 123456789101112131415161718192021222324// parent template&lt;todo-item :todo.sync=&quot;todoObj&quot;&gt;// childVue.component('TodoItem', { props: { todo: { type: Object, required: true } }, methods: { removeTodo: (newFoo) =&gt; { this.$emit('update:todo', newTodoObj); } }， template: ` &lt;span&gt; {{ todo.text }} &lt;button @click=&quot;removeTodo&quot;&gt; X &lt;/button&gt; &lt;/span&gt; `}) 5.3 谨慎使用 this.$refsVue.js 支持通过 ref 属性来访问其它组件和 HTML 元素。并通过 this.$refs 可以得到组件或 HTML 元素的上下文。在大多数情况下，通过 this.$refs来访问其它组件的上下文是可以避免的。在使用的的时候你需要注意避免调用了不恰当的组件 API，所以应该尽量避免使用 this.$refs。 当遇到 props 和 events 难以实现的功能时，通过 this.$refs来实现。 当需要操作 DOM 无法通过指令来做的时候可使用 this.$ref 而不是 JQuery、document.getElement*、document.queryElement。 Good 12345678&lt;!-- 推荐，并未使用 this.$refs --&gt;&lt;range :max=&quot;max&quot; :min=&quot;min&quot; @current-value=&quot;currentValue&quot; :step=&quot;1&quot;&gt;&lt;/range&gt; 123456789101112131415161718192021222324252627282930313233343536373839&lt;!-- 使用 this.$refs 的适用情况--&gt;&lt;modal ref=&quot;basicModal&quot;&gt; &lt;h4&gt;Basic Modal&lt;/h4&gt; &lt;button class=&quot;primary&quot; @click=&quot;$refs.basicModal.hide()&quot; &gt;Close &lt;/button&gt;&lt;/modal&gt;&lt;button @click=&quot;$refs.basicModal.open()&quot; &gt;Open modal&lt;/button&gt;&lt;!-- Modal component --&gt;&lt;template&gt; &lt;div v-show=&quot;active&quot;&gt; &lt;!-- ... --&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default { // ... data() { return { active: false, }; }, methods: { open() { this.active = true; }, hide() { this.active = false; }, }, // ... };&lt;/script&gt; 5.4 按照一定的结构顺序来组织组件 导出一个清晰、组织有序的组件，使得代码易于阅读和理解。同时也便于标准化。 按首字母排序 properties、data、computed、watches 和 methods 使得这些对象内的属性便于查找。 合理组织，使得组件易于阅读。（name; extends; props, data 和 computed; components; watch 和 methods; lifecycle methods 等）。 使用 name 属性。借助于 vue devtools 可以让你更方便的测试。 合理的 CSS 结构，如 BEM。 使用单文件 .vue 文件格式来组件代码。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;template&gt; &lt;div class=&quot;Ranger__Wrapper&quot;&gt; &lt;!-- ... --&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default { // 不要忘记 name 属性 name: 'RangeSlider', // 使用组件 mixins 共享通用功能 mixins: [], // 使用其它组件 components: {}, // 组成新的组件 extends: {}, // 指令 directives: {}, // 组件属性、变量 props: { bar: {}, // 按字母顺序 foo: {}, fooBar: {}, }, // 变量 data() { return {} }, // 方法 computed: {}, watch: {}, methods: {}, // 生命周期函数（按顺序） ... beforeCreate() {}, created () {}, mounted() {} ... };&lt;/script&gt;&lt;style scoped&gt; .Ranger__Wrapper { &lt;!-- ... --&gt; }&lt;/style&gt; 5.5 接口调用流程未使用状态管理时： 在services文件夹下按模块添加方法，该方法包括调用接口以及返回数据的处理。（方便复用） 在单文件组件中调用上述方法。 使用状态管理时： 在services文件夹下按模块添加方法，该方法包括调用接口以及返回数据的处理。（方便复用） 在store的actions中调用上述方法，commit到mutation，mutation改变state的值。 在单文件组件中调用actions中的方法。 5.6 每个分类都只有一个入口（如：router、store、plugins等分类下）即每个文件夹下都会有一个index.js/ts, 目的是对外隔离，当引入该分类下的文件时，不用按每个JS模块路径引入，否则调整单个模块位置需要修改依赖它的所有模块。 5.7 每个分类内部模块互相引用时，使用相对路径; 分类之间模块引用时，使用绝对路径相对路径目的是对外隔离，不和分类外的路径产生关系，同时方便分类复用。如 plugins 文件夹下的 index 文件。 12// Elementimport './element'; 绝对路径目的是从语义上区分模块是否是同一分类，分类路径发生改变时一次性全局替换。如在 main.js 中引入 plugins。 1import '@/plugins'; // 按需引入插件 vue组件、assets等其它各模块的引用路径，类似如下，用&quot;@&quot;直接引用src目录下的，而不是使用相对路径。 12import AjaxTree from '@/components/tree/ajax-tree'import VmTable from '@/components/table/vm-table' css的文件引用路径如下，用&quot;~@&quot;替换之前的&quot;../../&quot;： 1234&lt;style lang=&quot;scss&quot;&gt;@import '~@/assets/styles/common.scss';@import '~@/assets/styles/table.scss';&lt;/style&gt; 5.8 组件封装组件分为dumb component（普通组件，一般是components里的一个单文件组件） 和 smart component（容器组件，一般是views里的一个单文件组件）两种。 普通组件尽量只通过 props 接收容器组件传来的数据，向父组件派发消息，而不做其它任何主动调取数据等工作。 6 性能优化6.1（官）总是用key配合 v-for (性能优化2)在组件上总是必须用 key 配合 v-for，以便维护内部组件及其子树的状态。 同时，Key不要为index，尽量是一个唯一值，因为数据发生变化时，index可能不变。 Bad 12345&lt;ul&gt; &lt;li v-for=&quot;todo in todos&quot;&gt; {{ todo.text }} &lt;/li&gt;&lt;/ul&gt; Good 12345678&lt;ul&gt; &lt;li v-for=&quot;todo in todos&quot; :key=&quot;todo.id&quot; &gt; {{ todo.text }} &lt;/li&gt;&lt;/ul&gt; 6.2（官）永远不要把v-if 和 v-for 同时用在同一个元素上 (性能优化3)一般在两种常见的情况下会倾向于这样做： 为了过滤一个列表中的项目 (比如 v-for=&quot;user in users&quot; v-if=&quot;user.isActive&quot;)。在这种情形下，请将 users 替换为一个计算属性 (比如 activeUsers)，让其返回过滤后的列表。会获得如下好处： 过滤后的列表只会在 users 数组发生相关变化时才被重新运算，过滤更高效。 使用 v-for=&quot;user in activeUsers&quot; 之后，在渲染的时候只遍历活跃用户，渲染更高效。 解耦渲染层的逻辑，可维护性 (对逻辑的更改和扩展) 更强。 为了避免渲染本应该被隐藏的列表 (比如 v-for=&quot;user in users&quot; v-if=&quot;shouldShowUsers&quot;)。这种情形下，请将 v-if 移动至容器元素上 (比如 ul, ol)。 通过将 v-if 移动到容器元素，不会再对列表中的每个用户检查 shouldShowUsers。取而代之的是，只检查它一次，且不会在 shouldShowUsers 为否的时候运算 v-for。 Bad 123456789&lt;ul&gt; &lt;li v-for=&quot;user in users&quot; v-if=&quot;user.isActive&quot; :key=&quot;user.id&quot; &gt; {{ user.name }} &lt;/li&gt;&lt;/ul&gt; 123456789&lt;ul&gt; &lt;li v-for=&quot;user in users&quot; v-if=&quot;shouldShowUsers&quot; :key=&quot;user.id&quot; &gt; {{ user.name }} &lt;/li&gt;&lt;/ul&gt; Good 12345678910111213141516&lt;ul&gt; &lt;li v-for=&quot;user in activeUsers&quot; :key=&quot;user.id&quot; &gt; {{ user.name }} &lt;/li&gt;&lt;/ul&gt;computed: { activeUsers: function () { return this.users.filter(function (user) { return user.isActive }) }} 12345678&lt;ul v-if=&quot;shouldShowUsers&quot;&gt; &lt;li v-for=&quot;user in users&quot; :key=&quot;user.id&quot; &gt; {{ user.name }} &lt;/li&gt;&lt;/ul&gt; 6.3 组件销毁时及时清除事件监听、定时器等 (性能优化4)一般在 created 或 mounted 生命周期函数中添加 事件总线和 window上的事件监听或定时器，在 beforeDestroy 或 destroyed 中，添加以上三类事件的移除方法。 12345678910111213created() { this.$eventHub.$on('logged-in', this.getCurrentUser);},beforeDestroy() { this.$eventHub.$off('logged-in');},methods: { getCurrentUser(){ ... }} 12345678910111213mounted() { window.addEventListener('scroll', this.scrollhandle);},beforeDestroy() { window.removeEventListener('scroll', this.scrollhandle);},methods: { scrollhandle(event) { ... },}, 1234567mounted() { this.interVal = setInterval(callback,millisec,args);},beforeDestroy() { clearInterval(this.interVal);} 6.4 通过ES6动态导入的方式引入异步组件 (性能优化5)在平时的开发工作中，为了减少首屏代码体积，往往会把一些非首屏的组件设计成异步组件，按需加载。 基于路由 1234567891011121314151617181920212223import Vue from 'vue';import Router from 'vue-router';import Home from '../views/Home.vue';Vue.use(Router);export default new Router({ routes: [ { path: '/', name: 'home', component: Home, }, { path: '/about', name: 'about', // route level code-splitting // this generates a separate chunk (about.[hash].js) for this route // which is lazy-loaded when the route is visited. component: () =&gt; import(/* webpackChunkName: &quot;about&quot; */ '../views/About.vue'), }, ],}); 本地注册 1234567891011121314&lt;!-- App.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;message&gt;&lt;/message&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { components: { Message: () =&gt; import(&quot;./Message&quot;) }};&lt;/script&gt; 6.5 VueX状态管理6.5.1 不要过度使用Store (性能优化6)把所有逻辑移到Store中会导致更多的性能开销和不必要的复杂性。 在严格模式下，无论何时发生了状态变更且不是由 mutation 函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。 开启严格模式： 1234const store = new Vuex.Store({ // ... strict: process.env.NODE_ENV !== 'production'}) 不要在发布环境下启用严格模式！严格模式会深度监测状态树来检测不合规的状态变更——请确保在发布环境下关闭严格模式，以避免性能损失。 6.5.2 State6.5.2.1 将数组转化为对象进行存储 (性能优化7)即使从接口中返回的数据就是对象数组的形式，并且视图需要将其显示为使用v-for指令映射的数组，也应考虑将其作为对象放在存储中。 可以轻松地使用ES6+内置的Object.keys，Object.values和Object.entries方法从任何对象中获取数组，但反之则有些复杂。 作为一种算法，通过键从对象中检索到的内容的时间复杂度为O(1)，如果使用搜索或过滤器来查找相同的数据，则是O(n)。 Bad 1234const initialState = { partnersList: [], // array of all partners currentPartner: {}, // current partner object.}; Good 1234const initialState = { partnersList: {}, // object with all partners keyed by ID currentPartnerId: ``, // a string contining the ID of the current partner.}; 6.5.3 Getter6.5.3.1 需要包含一些逻辑如果要访问子属性，通过mapState。 Bad 123getters: { getProducts: state =&gt; state.products,} Good 123getters: { getFeaturedProducts: state =&gt; state.products.filter(p =&gt; p.isFeatured),} 6.6 数据冻结 (性能优化8)如果有一个巨大的数组或Object，并且确信数据不会修改，使用 Object.freeze() 可以让Vue不会给对象加上 getter/setter,性能会大幅提升。 在组件中： 123456789export default { data: () =&gt; ({ users: {} }), async created() { const users = await axios.get(&quot;/api/users&quot;); this.users = Object.freeze(users); }}; 在store中： 1234567const mutations = { setUsers(state, users) { state.users = Object.freeze(users); // 也可以做修改 // state.users = Object.freeze([...state.users, user]); }}; 如果是嵌套对象，则使用深度冻结，也就是遍历对象，用下方的 deepFreeze 替换上边写的 Object.freeze。 123456789101112131415161718/** * 深度冻结对象 * @param target 要冻结的嵌套对象 */function deepFreeze(target) { Object.freeze(target); Object.getOwnPropertyNames(target).forEach((prop) =&gt; { if (target.hasOwnProperty(prop) &amp;&amp; target[prop] !== null &amp;&amp; (typeof target[prop] === 'object' || typeof target[prop] === 'function') &amp;&amp; !Object.isFrozen(target[prop])) { deepFreeze(target[prop]); } }); return target;} 6.7 图片压缩 (性能优化9)使用 image-webpack-loader 对图片进行压缩。安装： 1npm i -D image-webpack-loader 在 vue.config.js 中 添加配置： 1234567891011module.exports = { configureWebpack: (config) =&gt; { // 压缩图片 config.module.rules.push({ test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, use: [{ loader: 'image-webpack-loader', }], }); }} 6.8 使用KeepAlive 按需缓存路由页面 (性能优化10)123&lt;keep-alive include='要缓存的组件名称,要缓存的组件名称'&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt; 6.9 使用CDN或者引入其它服务器上的文件地址实现对静态资源并行请求 (性能优化11)浏览器针对每个域名能创建的最大TCP连接数是有限制的（谷歌浏览器6个），通过将静态资源放在不同的域中可以增加并行请求数。 6.10 GZip (性能优化12)使用 Nginx 进行动态压缩，具体请看Nginx相关的文档（待补充）。 7 其它7.1 静态分析使用ESLint作为代码静态分析工具，遵从 Airbnb+自定义风格。 7.2 常用插件Vue-Awesome-Swiper：基于 Swiper4、适用于 Vue 的轮播组件。 Vue-Lazyload：图片懒加载。 (性能优化13) vue-svg-icon：可定义svg图标的颜色。 7.3 常用工具Octotree：GitHub可视化代码树插件。 npm-check-updates：更新package.json中的所有依赖到最新版本。 7.4 资源一张思维导图辅助你深入了解Vue | Vue-Router | Vuex 源码架构 8 写在最后看过一篇文章，觉得观点挺好的，就直接拿来用了。 Best Practice ：最佳实践。Wikipedia 上对其解释为：A best practice is a method or technique that has been generally accepted as superior to any alternatives because it produbces results that are superior to those achieved by other means or because it has become a standard way of doing things. (最佳实践是一种：因其产生的结果优于其它选择下的结果，或其已经成为一种做事的标准，从而被普遍认可优于任何替代方案的方法或技术。) 最佳实践本身是美好的存在，犹如夜空中的一轮明月，照亮黑暗中的方向，指引着摸索前行的凡人。 但凡事有度，子曰：&quot;过犹不及。&quot; 首先，最佳实践容易带来思想包袱，让人无法专注于解决问题本身。 总是希望采用最好的技术方法，不愿意在不正确的做法上浪费时间，导致瞻前顾后，甚至裹足不前。此时的最佳实践，已然成为了一种毒药，一旦偏离了问题本身这个出发点，就会不知不觉走进&quot;宏大构想&quot;的思维陷阱。把简单的问题复杂化，阻碍了迈出第一步，直到能规划出&quot;包罗万象&quot;的解决方案后才肯动手，拖延症就这样来了，时间却走了。 其次，对最佳实践的执念容易让人钻牛角尖，将目标的重心带偏。 过度关注实施过程是否符合标准化，忽视了项目中其它重要的东西，比如用户体验，比如实际需求。 再次，工程师思维，沉迷于奇技淫巧中无法自拔。 比如性能优化。&quot;优秀的程序员应该榨干每一字节内存&quot;，听起来很熟悉，不是吗？但经济学上来讲，边际效应决定了一次项目中，越优化性价比越低。有一个很容易被忽略的事实：硬件其实比程序员要便宜。 再比如对设计模式的崇拜。设计模式当然是好东西，但如果像强迫症一样使用它们，坚持用上它们才是正确的编程，就会导致按图索骥，强行让问题去适应设计模式，而不是让解决方案针对问题，这就本末倒置了。 最后，一个项目的开发顺利与否，并不在于技术选型是否为最佳实践。 工作数年，大小项目经历若干，慢慢体会到，一个项目的开发顺利与否，并不在于技术选型是否为最佳实践，更多的时候，取决于开发方案和技术储备之间的平衡。做项目毕竟是要讲方案落地的，如果最佳实践中的技术成本，超出了开发者的落实能力，那就是坑，这时盲从最佳实践无异于挖坟。如果是一个人的项目，抽时间恶补一通，兴许能填填坑，这取决于IQ。但要是一个团队，那就不是什么 IQ，EQ，QQ 的问题了，这中间产生的学习成本，集体培训成本，反复沟通成本，大量的初级错误，千奇百怪的代码，互相冲突引发的焦躁情绪等等。这些负面的东西如果不能妥善的处理，足以抵消掉最佳实践带来的好处。别忘了，deadline 正在迫近。 当尘埃落定，蓦然回首，最佳实践很可能没你想象中那么重要。它更多的是一种精神层面的求道，并非物质世界的必要。 全篇能全部看下来，觉得自己基础扎实，想在前端道路上有进一步发展的请加微信： zapzqc只要你肯努力，这里将会为你提供充足的发展空间。","link":"/2020/04/29/Vue-js2%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"},{"title":"Storybook的基本使用指南","text":"1 什么是 Storybook让我们来看看 Storybook 的官网咋说的： ”Build bulletproof UI components faster” ——更快地创建一个坚不可摧的 UI 组件库。 “Storybook is an open source tool for developing UI components in isolation for React,Vue, Angular, and more. It makes building stunning UIs organized and efficient.”——故事书是一个开源的工具，用于独立开发 React、Vue、Angular 等的 UI 组件。它能有组织且高效地构建 UI 组件。 简而言之，Storybook 是一个开源的项目，该项目已经为我们搭好了架子，我们只需要在该架子的基础上添砖加瓦，就能够将所有 UI 组件集成在一个项目中，展示和分类组件，提供组件全面的示例，并进行组件测试。 每一个 UI 组件的示例就是一个 story 。所有的示例的集合，就是 Storybook 了。 2 Storybook 的开发流程一般在开发完成一个 UI 组件之后，如果你想让其他人查看并复用你的 UI 组件，就可以进行 story 的开发了。当前的开发流程如下图所示： 未来我们还会走另一种开发流程，Storybook 项目将作为 vue-component-ts 的一部分，直接导入 vue-component-ts 中的 UI 组件。所以未来我们会省去在 npm 上注册插件的这一步，而改为导入组件库中的 UI 组件。 3 Storybook 的文件目录1234567891011121314151617│ .eslintrc.js│ babel.config.js│ package.json│├─.Storybook│ main.js // 配置Storybook的行为信息，还可以在次配置webpack、babel信息。│ manager.js // 设置插件的行为信息，比如修改插件主题色。│├─src│ ├─components // 若不使用组件注册的方式来引用UI组件，还可以将UI组件放在该文件夹下，然后在story中引用。│ │ └─t-button.vue // UI组件源码│ ││ └─stories // 所有的UI组件示例都会放在该文件夹下│ └─charts.stories.js // 这是一个关于charts组件的stories，里面包含了多个charts的story│└─static // 静态目录，放置静态文件 └─mds // 存放有关于story介绍的markdown文档 注意：修改 main.js 后要想使其生效，需要重启项目。 4 快速构建一个 Storybook4.1 编写一个最基本的 story一个组件可以编写多个 story 。编写一个组件的 story 有两种方式，一种是 CSF 方式，另一种是 StoriesOf 方式。由于 StoriesOf 是新出的写法，在实践的过程中会存在一些问题，所以还是比较推荐 CSF 方式 首先，我们需要新建一个 xxx.stories.js 文件，或者新建一个文件夹，里面包含着该 UI 组件的所有，每个 UI 组件的 story 都写在这里面。 4.1.1 CSF（ Component Story Format ）方式123456789101112131415const TVue = require('ths-vue');// 控制页面如何绘制出你的story，以及如何提供插件使用的信息export default { title: ‘echarts/xx’}// 柱状统计图就相当于一个story了，所有有关于该story的参数在配置项中配置export const 柱状统计图 = () =&gt; ({ props: {…}, data (){…}, components: {thsBarChart: TVue.thsBarChart.thsBarChart}, template: ` &lt;ths-bar-chart :basic=&quot;basic“ :options=&quot;options&quot;&gt;&lt;/ths-bar-chart&gt; `}) export default 的常用参数介绍: 12345678import md from '../../static/mds/thsBarChart.md';export default: {title: ‘大标题|文件夹/组件名’, // story所在文件目录的定义，可以控制左侧菜单栏的显示// story的参数可以用于在story或stories的层次上为各种插件提供配置parameters: { notes: md, // notes是一个插件}} 4.1.2 StoriesOf 方式12345678910import {storiesOf} from '@storybook/vue';import TButton from '../components/t-button.vue';storiesOf('PC|统计图', module).add('柱图', () =&gt; ({ components: {TButton}, props: { color: '#FF0000', label: '确定', }, template: '&lt;t-button :color=&quot;color&quot; &gt;{{label}}&lt;/t-button&gt;',})); 注：两种方式不建议写在同一个 story 里。 4.2 Storybook 插件的安装与配置 npm i –D 插件名 以 addon-knobs 插件为例在 .storybook/main.js 中 module.exports 导出的对象中添加以下内容： 1addons: ['@storybook/addon-knobs']; 在 story 中引用该插件就 OK 了： 1import {color, text, boolean} from '@storybook/addon-knobs'; 4.3 常用插件的使用4.3.1 Storybook 插件之 KnobsKnobs 可以用于设置组件传入的参数信息，并实时更新，查看效果（不会改变组件的源码）。 使用方法（这是一段关键代码，props 为一个 story 的其中一个配置参数）： 123456789101112import { object } from '@storybook/addon-knobs';props:{ basic: { default: object( '基础配置', { width: '100%', height: '240', backgroundColor: '#fff', }, ), }, 效果： 修改 width 、height 、backgroundColor 参数就可以在界面上给组件传参啦~ 4.3.2 Storybook 插件之 notesNotes 可以用于读取指定的 markdown 文档，展示组件的配置参数的类型、含义，介绍组件的配置方式和安装方式等信息。 使用方法： 123456import md from '../../static/mds/thsBarChart.md';export default { parameters: { notes: md, },}; 这样就能将 markdown 文档引入到故事中显示了~ 友情链接： Storybook 官网链接 Storybook 使用示例：http://182.48.115.106:8090/svn/Products/前端开发1.0/工程/代码/思路组件库/Vue/storybook 5 md 示例一个组件主要要介绍的内容有：组件功能简介、组件引用配置示例（即组件源码）和组件配置项说明。以 thsBarChart 组件为例，列举了该组件的 markdown 文档该具备哪些内容： 5.1 组件功能简介用 vue + echars 实现的柱状统计图，可以选择性地显示多个系列的数据。鼠标 hover 上某段数据能够显示该段数据上所有系列的数据信息。 5.2 组件引用配置示例在 main.js 中： 123import Vue from 'vue';import {thsBarChart} from 'ths-vue';Vue.use(thsBarChart); 在 xxx.vue 文件中： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223&lt;template&gt; &lt;ths-bar-chart :basic=&quot;basic&quot; :options=&quot;options&quot; :nameAlias=&quot;nameAlias&quot; :valueAlias=&quot;valueAlias&quot; :data=&quot;data&quot; &gt;&lt;/ths-bar-chart&gt;&lt;/template&gt;&lt;script&gt;export default { data() { return { basic: { width: '100%', height: '240', backgroundColor: '#fff', }, options: { color: [ '#538FFF', '#FFBF27', '#FC807A', '#7BD25F', '#BE90EA', '#FF9F37', ], tooltip: { show: true, backgroundColor: '#fff', textStyle: { color: '#333', fontSize: '12', fontFamily: 'PF', fontWeight: 'normal', }, }, title: { show: false, text: '这是标题', textStyle: { color: '#666', fontSize: '16', fontFamily: 'PF', fontWeight: 'bold', }, left: 'center', }, legend: { padding: [0, 0, 0, 50], show: true, left: 'center', top: 20, orient: 'horizontal', textStyle: { color: '#666', fontSize: '12', fontFamily: 'PF', fontWeight: 'normal', }, data: ['示例', '示例2'], }, grid: { left: 40, right: 30, top: 50, bottom: 40, }, xAxis: { show: true, name: '', nameTextStyle: { color: '#666', fontSize: '12', fontFamily: 'PF', fontWeight: 'normal', }, nameGap: 10, boundaryGap: true, axisLine: { show: true, lineStyle: { color: '#eee', width: 1, type: 'solid', }, }, axisTick: { show: false, }, splitLine: { show: false, lineStyle: { color: '#eee', width: 1, type: 'solid', }, }, axisLabel: { show: true, interval: 0, color: '#666', rotate: 0, fontFamily: 'PF', fontSize: '12', }, data: ['周一', '周二', '周三', '周四', '周五', '周六', '周日'], }, yAxis: { show: true, name: '单位', nameTextStyle: { color: '#666', fontSize: '12', fontFamily: 'PF', fontWeight: 'normal', }, nameGap: 10, inverse: false, boundaryGap: false, splitNumber: 15, axisLine: { show: true, lineStyle: { color: '#eee', width: 1, type: 'solid', }, }, axisTick: { show: false, }, splitLine: { show: true, lineStyle: { color: '#eee', width: 1, type: 'dashed', }, }, axisLabel: { show: true, interval: 0, color: '#666', rotate: 0, fontFamily: 'PF', fontSize: '12', }, }, series: [ { name: '示例', label: { show: false, position: 'top', distance: 5, color: '#666', fontFamily: 'PF', fontSize: '12', }, barColor: '', barWidth: 4, borderColor: 'rgba(0,0,0,0)', borderWidth: 2, backgroundColor: '', data: [120, 132, 101, 134, 90, 230, 210], stack: '示例2', }, { name: '示例2', label: { show: false, position: 'top', distance: 5, color: '#666', fontFamily: 'PF', fontSize: '12', }, barColor: '', barWidth: 4, borderColor: 'rgba(0,0,0,0)', borderWidth: 2, backgroundColor: '', data: [12, 13, 10, 13, 9, 23, 21], }, { name: '示例3', label: { show: false, position: 'top', distance: 5, color: '#666', fontFamily: 'PF', fontSize: '12', }, barColor: '', barWidth: 4, borderColor: 'rgba(0,0,0,0)', borderWidth: 2, backgroundColor: '', data: [122, 13, 10, 13, 9, 23, 21], }, ], dataZoom: { show: false, maxPointNum: 10, }, }, nameAlias: 'date', valueAlias: 'revenue', data: [ {date: '星期一', revenue: 43}, {date: '星期二', revenue: 54}, {date: '星期三', revenue: 82}, {date: '星期四', revenue: 48}, {date: '星期五', revenue: 10}, {date: '星期六', revenue: 82}, {date: '星期天', revenue: 28}, ], }; },};&lt;/script&gt; 5.3 组件配置项说明 basic（即 knobs 中的基础配置） 属性名 属性含义 数值类型 示例（默认值） width 整个统计图的宽度 百分比 | 数值 “width”: “500” height 整个统计图的高度 数值 “height”: “400” backgroundColor 统计图背景颜色 颜色值 “backgroundColor”: “#fff” options options 的配置项比较多，配置了 tooltip 、title 、legend 、grid 、xAxis 、yAxis 、series： （以下仅举例 tooltip 、title 、legend 这三种配置项的说明作为参考） tooltip（提示框组件） 属性名 属性含义 数值类型 示例（默认值） show 是否显示提示框组件 布尔值 “show”: true textStyle 提示框组件的字体样式配置 对象 “textStyle”: { “color”: “#333”, “fontSize”: “12”, “fontFamily”: “PF”, “fontWeight”: “normal” } backgroundColor 统计图背景颜色 颜色值 backgroundColor: ‘#fff’ title（统计图标题） 属性名 属性含义 数值类型 示例（默认值） show 是否显示统计图标题 布尔值 “show”: false text 统计图标题的文本内容 字符串 “text”: “这是标题” textStyle 统计图标题的字体样式配置 对象 “textStyle”: { “color”: “#666”, “fontSize”: “16”, “fontFamily”: “PF”, “fontWeight”: “bold” } left 统计图标题的排版设置 字符串 | 数字 “left”: “center” legend（图例） 属性名 属性含义 数值类型 示例（默认值） padding 图例的内边距 数组 “padding”: [0, 0, 0, 50] show 是否显示图例 布尔值 “show”: true left 图例的排版设置 字符串 | 数字 “left”: “center” top 图例到统计图顶部距离 字符串| 数字 “top”: 20 orient 图例的排列方向 字符串 “orient”: “horizontal”（水平排列） textStyle 图例的字体样式 对象 “textStyle”: { “color”: “#666”, “fontSize”: “12”, “fontFamily”: “PF”, “fontWeight”: “normal” } data 图例的数据 数组 “data”: [“示例”, “示例 2”]","link":"/2020/09/27/storybook%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"}],"tags":[{"name":"Blog","slug":"Blog","link":"/tags/Blog/"},{"name":"HTTP","slug":"HTTP","link":"/tags/HTTP/"},{"name":"TypeScript","slug":"TypeScript","link":"/tags/TypeScript/"},{"name":"Module","slug":"Module","link":"/tags/Module/"},{"name":"Rap2","slug":"Rap2","link":"/tags/Rap2/"},{"name":"Mock","slug":"Mock","link":"/tags/Mock/"},{"name":"PWA","slug":"PWA","link":"/tags/PWA/"},{"name":"Vue.js2","slug":"Vue-js2","link":"/tags/Vue-js2/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"cordova","slug":"cordova","link":"/tags/cordova/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"Vue.js3","slug":"Vue-js3","link":"/tags/Vue-js3/"},{"name":"if-else","slug":"if-else","link":"/tags/if-else/"},{"name":"优化","slug":"优化","link":"/tags/%E4%BC%98%E5%8C%96/"},{"name":"原型链","slug":"原型链","link":"/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"},{"name":"HTTP&#x2F;HTTPS","slug":"HTTP-HTTPS","link":"/tags/HTTP-HTTPS/"},{"name":"Nest.js","slug":"Nest-js","link":"/tags/Nest-js/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"},{"name":"ESLint","slug":"ESLint","link":"/tags/ESLint/"},{"name":"Babel","slug":"Babel","link":"/tags/Babel/"},{"name":"Browserslist","slug":"Browserslist","link":"/tags/Browserslist/"},{"name":"概念","slug":"概念","link":"/tags/%E6%A6%82%E5%BF%B5/"},{"name":"CORS","slug":"CORS","link":"/tags/CORS/"},{"name":"Storybook","slug":"Storybook","link":"/tags/Storybook/"}],"categories":[{"name":"周边","slug":"周边","link":"/categories/%E5%91%A8%E8%BE%B9/"},{"name":"协议","slug":"协议","link":"/categories/%E5%8D%8F%E8%AE%AE/"},{"name":"TypeScript","slug":"TypeScript","link":"/categories/TypeScript/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"博客","slug":"周边/博客","link":"/categories/%E5%91%A8%E8%BE%B9/%E5%8D%9A%E5%AE%A2/"},{"name":"开发周边","slug":"开发周边","link":"/categories/%E5%BC%80%E5%8F%91%E5%91%A8%E8%BE%B9/"},{"name":"跨平台","slug":"跨平台","link":"/categories/%E8%B7%A8%E5%B9%B3%E5%8F%B0/"},{"name":"HTTP","slug":"协议/HTTP","link":"/categories/%E5%8D%8F%E8%AE%AE/HTTP/"},{"name":"JS框架","slug":"JS框架","link":"/categories/JS%E6%A1%86%E6%9E%B6/"},{"name":"CSS","slug":"CSS","link":"/categories/CSS/"},{"name":"编码规范","slug":"TypeScript/编码规范","link":"/categories/TypeScript/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"},{"name":"HTML","slug":"HTML","link":"/categories/HTML/"},{"name":"安卓","slug":"安卓","link":"/categories/%E5%AE%89%E5%8D%93/"},{"name":"模块化","slug":"JavaScript/模块化","link":"/categories/JavaScript/%E6%A8%A1%E5%9D%97%E5%8C%96/"},{"name":"Rap2","slug":"开发周边/Rap2","link":"/categories/%E5%BC%80%E5%8F%91%E5%91%A8%E8%BE%B9/Rap2/"},{"name":"PWA","slug":"跨平台/PWA","link":"/categories/%E8%B7%A8%E5%B9%B3%E5%8F%B0/PWA/"},{"name":"Vue.js2","slug":"JS框架/Vue-js2","link":"/categories/JS%E6%A1%86%E6%9E%B6/Vue-js2/"},{"name":"编码规范","slug":"CSS/编码规范","link":"/categories/CSS/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"},{"name":"编码规范","slug":"HTML/编码规范","link":"/categories/HTML/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"},{"name":"cordova","slug":"安卓/cordova","link":"/categories/%E5%AE%89%E5%8D%93/cordova/"},{"name":"新特性","slug":"JavaScript/新特性","link":"/categories/JavaScript/%E6%96%B0%E7%89%B9%E6%80%A7/"},{"name":"Vue.js3","slug":"JS框架/Vue-js3","link":"/categories/JS%E6%A1%86%E6%9E%B6/Vue-js3/"},{"name":"优化if-else","slug":"JavaScript/优化if-else","link":"/categories/JavaScript/%E4%BC%98%E5%8C%96if-else/"},{"name":"if-else优化","slug":"JavaScript/if-else优化","link":"/categories/JavaScript/if-else%E4%BC%98%E5%8C%96/"},{"name":"编程范式","slug":"JavaScript/编程范式","link":"/categories/JavaScript/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/"},{"name":"原型链","slug":"JavaScript/原型链","link":"/categories/JavaScript/%E5%8E%9F%E5%9E%8B%E9%93%BE/"},{"name":"Nest.js","slug":"Nest-js","link":"/categories/Nest-js/"},{"name":"Node.js","slug":"Node-js","link":"/categories/Node-js/"},{"name":"基础建设","slug":"基础建设","link":"/categories/%E5%9F%BA%E7%A1%80%E5%BB%BA%E8%AE%BE/"},{"name":"概念","slug":"概念","link":"/categories/%E6%A6%82%E5%BF%B5/"},{"name":"安全","slug":"安全","link":"/categories/%E5%AE%89%E5%85%A8/"},{"name":"项目搭建","slug":"基础建设/项目搭建","link":"/categories/%E5%9F%BA%E7%A1%80%E5%BB%BA%E8%AE%BE/%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"},{"name":"基础","slug":"概念/基础","link":"/categories/%E6%A6%82%E5%BF%B5/%E5%9F%BA%E7%A1%80/"},{"name":"跨域","slug":"安全/跨域","link":"/categories/%E5%AE%89%E5%85%A8/%E8%B7%A8%E5%9F%9F/"},{"name":"组件库","slug":"基础建设/组件库","link":"/categories/%E5%9F%BA%E7%A1%80%E5%BB%BA%E8%AE%BE/%E7%BB%84%E4%BB%B6%E5%BA%93/"}]}