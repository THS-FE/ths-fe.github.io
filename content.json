{"pages":[{"title":"关于我们","text":"思路大前端团队于2018年成立，分布北京、成都、深圳、西安四地，是由UI设计师、前端开发工程师、GIS开发工程师共同组成的集设计、开发于一体的综合性团队。我们致力于产品的用户体验设计，利用各种可视化技术手段进行信息展现，为各业务线提供可视化解决方案，增强产品的核心竞争力。 愿景成为一个学习型且有影响力的团队，成为业内一流的可视化解决方案提供者 使命利用技术提升产品的核心竞争力 文化开心、乐观、自驱、互助、专业、创新 职责 参与产品设计讨论，结合用户体验为公司新产品与新功能提供创意及设计方案，跟踪设计效果，把控产品最终界面的实现效果 结合项目的整体计划和安排，协助其他开发人员解决项目开发过程中的技术难题 参与前端工程构建系统的研发，包括开发规范、自动化工具、框架研发、可视化搭建、数据埋点、持续集成、应用监控、安全保障、性能优化等 实现界面和交互的开发需求，确保不同平台、设备上具有优秀的用户体验 负责数据可视化前沿技术的研究，可视化平台整体架构设计和研发 加入我们对用户来说，界面就是一切。想做一个掌控一切的人吗？加入我们吧！","link":"/about/index.html"},{"title":"大前端技术体系","text":"核心 网页行为：JavaScript ✅ 编码规范 thanks to airbnb 😂 ⬜ JavaScript 简介 ⬜ 变量提升(Variable Hoisting)、事件冒泡(Event Bubbling)、严格模式(Strict) ⬜ this ⬜ 闭包(Closure) ⬜ 原型(Prototype)与原型链(Prototype Chain) ⬜ JSON(JavaScript Object Notation) ⬜ 作用域(Scope)与作用域链(Scope Chain) ⬜ AJAX(Asynchronous Javascript And XML) ✅ 跨域解决 苏永蓬 ⬜ 模块化(Module) ⬜ 事件循环(Event Loop) ✅ 正则表达式(Regular expressions) 吴俊 ⬜ Web API(CustomEvent、WebSockets、Web Workers.etc) ES5-ES6+ ✅ JavaScript 新特性 吴俊 图形 ⬜ Canvas ⬜ WebGL ⬜ SVG Web Component ⬜ Shadow DOM TypeScript ✅ 编码规范 刘莹鑫 ⬜ 类型(Type) ⬜ 接口、类、命名空间、模块 ⬜ 装饰器 ⬜ 声明文件 网页样式：CSS ✅ CSS 编码规范 刘燕 ✅ CSS 变量的基本用法 刘燕 ⬜ CSS 实战 ⬜ BEM ⬜ 响应式和媒体查询 ⬜ Sass 编码规范 刘燕 网页结构：HTML ✅ HTML 编码规范 刘燕 ⬜ HTML 简介 ⬜ HTML5 特性 概念 基本 ✅ 前端开发必须掌握的基本概念 段美霞 ⬜ 值 🆚 引用类型，栈 🆚 堆 ⬜ 形参 🆚 实参，转译 🆚 编译 ⬜ BOM 🆚 DOM ⬜ 对称加密 🆚 非对称加密 ⬜ 逻辑像素 🆚 物理像素 rem 🆚 em pt 🆚 dp ⬜ 标准化组织 进阶 ✅ 函数式编程范式 吴俊 ⬜ 字符编码(Character Encodings) ⬜ SOAP 和 RESTful 能做比较吗？ ⬜ 开源协议 ⬜ 命令式 🆚 声明式 开发周边 ⬜ 命令行 ⬜ JSDoc ⬜ Markdown ⬜ GitHub ⬜ 蓝湖 ⬜ Fiddler ⬜ Chrome DevTools ⬜ PostWoman ✅ RAP2 入门 刘莹鑫 ✅Storybook的基本使用指南 老吕 协议相关 ⬜ OSI 模型 ⬜ DNS ✅ HTTP 协议演变 马文超 ✅ HTTP 请求方法的异同 天下布武 ✅ 浅谈HTTPS 苏永蓬 ⬜ 端口 ⬜ URI 🆚 UDP 浏览器 ⬜ 浏览器历史 ⬜ 主流浏览器对比 ⬜ 浏览器工作原理 JS 框架 Vue.js ✅ Vue.js2 最佳实践 天下布武 ✅ Vue 组件开发及 NPM 发布（TS 版） 天下布武 ⬜ SSR Angular ⬜ Angular 组件开发及 NPM 发布 ReactUI 框架 ⬜ Element ⬜ Ionic 库 ⬜ ECharts ⬜ D3 ⬜ three.js ⬜ RxJS 跨平台 ✅ PWA–下一代的 web 应用模型 曹芯萍 ⬜ Cordova ⬜ Electron ⬜ Flutter？ ⬜ Service Worker 服务器&amp;操作系统&amp;中间件 ✅ nginx 使用 马文超 ⬜ Tomcat ⬜ IIS 添加 HTTPS ⬜ Redis ⬜ RabbitMQ ⬜ CentOS Node.js ⬜ NPM ✅ Nest.js 张金秀 ⬜ mongoose ⬜ socket.io 数据库 ⬜ MongoDB ⬜ PostgreSQL 编辑器&amp;IDE ⬜ VS Code ⬜ WebStrom ⬜ Xcode ⬜ Android Studio 持续集成&amp;交付&amp;部署 ⬜ SVN ⬜ Git ⬜ 常用构建、静态分析工具及配置 ⬜ Jenkins ⬜ Docker 监控 ⬜ Sentry ⬜ New Relic 数据结构&amp;算法 ⬜ 时间复杂度、空间复杂度 设计思想&amp;模式 性能 安全 ⬜ JWT 管理 ⬜ 招聘 ⬜ 团队管理 ⬜ 项目管理 ⬜ PPT ⬜ Word ⬜ 设计说明书 其它 ⬜ WebRTC ⬜ WebAssembly ⬜ Tensorflow.js ⬜ GraphQL ⬜ Serverless 大前端技术体系一张图","link":"/fe/index.html"},{"title":"gis","text":"概念 ⬜ 地理坐标系 ⬜ 插值 ⬜ WebGL ⬜ 空间坐标系 ⬜ 正交投影 🆚 透视投影 ⬜ 上帝说有光，于是便有了光 ⬜ 纹理 ⬜ 旋转、跳跃，我闭着眼 ⬜ 粒子系统 ⬜ 着色器 桌面软件ArcMapQGIS服务器ArcGIS ServerGeoServer数据库PostGIS工具库ArcpyGDAL2D Map库ArcGIS API for JavaScriptTurf3D Map库three.jsCesium","link":"/gis/index.html"}],"posts":[{"title":"博客使用指南","text":"我们现在使用的博客框架是 Hexo，感兴趣的同学可以去了解下。 1 下载源码从 GitHub 的仓库中下载博客工具源码到自己机器上 1git clone https://github.com/THS-FE/blog.git 2 安装依赖进入项目所在文件夹，执行 12# npm install -g hexo-clinpm install 3 新建帖子1npx hexo new post '博客的名称' 需要用到图片等资源都放进新生成的文件夹中，图片尽量是 JPG 格式。使用以下语句来引入图片 1{% asset_img 你的图片名称.jpg %} 4 删除帖子直接在 source_posts 文件夹下删除对应的 md 文件和文件夹，再运行命令 12npx hexo cleannpx hexo g 5 运行博客1npx hexo s 执行成功后，在浏览器中输入 http://localhost:4000/ 6 发布博客前提是你有这个仓库的修改权限。修改提交说明 运行命令 12npx hexo gnpx hexo deploy 第一次会要求输入你 Github 的用户名和密码。 如果部署以后发现 https://ths-fe.github.io/ 博客没有更新，需要手动删除项目中的.deploy_git 文件夹，重新运行命令 12npx hexo cleannpx hexo g -d 7 文章规范7.1 多级标题要加上数字编号标题最多分 6 级，即对应 h1 ~ h6。 如： 3.2 我的世界 7.2 段落之间要有空行图片与图片，图片与段落、段落与段落前后都要留有空行。 7.3 中英文（数字）前后要留出空格当数字、英文在句子开头，前面不需留空格；当数字、英文在句子末尾，后面亦不需留空格。 错误： 有些英文拼写要正确，比如说 iPhone 不要写成 iphone。虽然 2020 年已经奔 3 了，但还要继续学习。 正确： 有些英文拼写要正确，比如说 iPhone 不要写成 iphone。虽然 2020 年已经奔 3 了，但还要不断学习。 7.4 标识重点使用加粗，但首尾的标点符号不要加粗被加粗的语句、短语前后，如果有标点符号，不要对它加粗，句子中间的标点符号可正常加粗。 错误：要学会如何使用加粗啊，兄弟。 正确：要学会如何使用加粗啊，兄弟。 7.5 正确拼写英文单词英文的拼写，如 GraphQL 而不是 graphql，Node.js 而不是 nodejs，iPhone 而不是 iphone，Apple 而不是 apple，Java 而不是 java，Aliyun 而不是 aliyun，UED 而不是 ued，RDS MySQL 而不是 rds mysql，OSS 而不是 oss 等等，使用前，先网上查下正确使用。 8 注意事项 文章写完后别忘记先提交 github，然后再发布 上传的图片大小尽量不大于 50 KB，文章标题图片大小要为 760*325（小于的不用太调整），统一命名为 cover.jpg，其它无限制。在线压缩网址：https://www.yasuotu.com/ 在 VS Code 中安装插件：markdownlint，用以检查 md 文件中，要保证上传的 md 中没有错误 在大前端技术体系的对应模块中添加该文章的链接 发现依赖有更新是，需先执行 npm i 或 yarn install 安装最新的依赖，再发布","link":"/2020/04/24/%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"title":"HTTP请求方法的异同","text":"HTTP（HyperText Transfer Protocol，超文本传输协议）中定义的请求方法共八种（GET、HEAD、POST、PUT、DELETE、CONNECT、OPTIONS、TRACE，参看RFC7231）。工作中我们最常接触到的是其中的 GET、POST、PUT 和 DELETE。网上有很多针对这四种方法的说明和比较，但内容都不尽如人意。为了能让大家更清晰地了解这些方法，在实际工作中灵活运用，我将从定义和实现两个方面详细地阐述一下它们的异同。 首先，看一些基本概念。超文本传输协议是网络七层结构中应用层的协议。我们看到“超文本”一般会联想到另一个词：HTML(HyperText Mark-up Language，超文本标记语言)。那什么是“超文本”？“超文本”是 1965 年美国人Ted Nelson 创造的，简单的说就是包含有其他文本链接的文本 (Hypertext is text which contains links to other texts)，通过这些链接可以访问指向的文本。HTML 就是用来创建超文本(如 Web 页面)的。最初设计 HTTP 的目的是为了能够在客户端和服务器端之间传输超文本文档 (HTML)**。不过随着时代的发展，“超文本”已经从最初的纯文本扩展成为包括文本、图像、音频、视频等在内的多媒体。现今，把 HTTP 称为超媒体传输协议可能更为合适些**。 针对 HTTP，有文档明确定义的版本有 0.9（1991）、1.0（1996）、1.1（1997）和 2（2015）。目前使用最广泛的是 1.1，该规范由 IETF（Internet Engineering Task Force，互联网工程任务组）中的HTTP Working Group（HTTP 工作组）于 2014 年更新，定义的内容在 RFC7230–RFC7235 六个文档中。 接下来，开始正式的对比： 1 定义上RFC 文档定义了三种方法属性：安全、幂等、可缓存。 安全 如果请求方法的语义是只读的(如 GET、HEAD、OPTIONS、TRACE )，那么该方法就是安全的。也就是说客户端不会请求和期望改变服务器上目标资源的任何状态。 幂等 如果使用该方法对服务器发送多次相同请求和一次请求的效果是一样的，那么该方法就被认为是幂等的。PUT, DELETE 及上面提到的安全方法都是幂等的。 可缓存 对于请求方法的响应被允许存储以备将来重用，那么该方法就可以定义为“可缓存”。一般来说，不依赖于当前响应的安全方法被定义为可缓存的。规范将 GET，HEAD 和 POST 定义为可缓存，尽管绝大多数缓存实现只支持 GET 和 HEAD。 属性 GET POST PUT DELETE 安全 是 否 否 否 幂等 是 否 是 是 可缓存 是 是 否 否 语义 检索信息（查） 创建或附加资源（增、改） 创建或替换资源（增、改） 删除资源（删） ⚠️ 以上的“是”，指的是定义中有明确要求的。“否”指的是没有明确要求，可做可不做的。 稍微解释下： 安全：使用 GET 方法，不能修改服务器上的数据，而其它方法是可以的。 幂等：同样是添加资源，使用 PUT 只能添加一条数据，无论执行多少次。而使用 POST 可以是执行一次就添加一条新数据。 补充： 所有通用的服务器必须支持 GET 和 HEAD 方法，其他方法是可选的。这和大部分的实现还算是比较吻合，因为一般的服务器是做网站用途的，在地址栏中访问对应的 URL 地址、图片引入、JS 文件引入、CSS 文件引入等都是发送的 GET 请求。 无论是 GET 还是 POST 都没有限制请求参数的长度和位置（URL 后还是消息体 message body 里）。 2 实现上 GET 能被缓存，POST 很少能被缓存 。 GET 和 POST 请求参数的位置不同，GET 请求的参数放在 URL 中（以?分割 URL 和传输数据，参数之间以&amp;相连，如：login?name=zqc&amp;password=zqc。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用 BASE64 编码，得出如：%E4%BD%A0%E5%A5%BD，其中％XX 中的 XX 为该符号以 16 进制表示的 ASCII），而 POST 请求的参数放在消息体中。 由于以上 2 的缘故，再加上有些服务器会记录和打印 GET 请求的地址，因此，POST 比 GET 相对安全一些。但是使用抓包工具的话，只要不加密，参数都能被轻而易举地获取。 华为手机浏览器不支持 PUT 方法，因此有些公司会规定添加和修改都使用 POST。 GET 和 POST 请求参数的大小主要是由浏览器和 Web 服务器决定。以下是利用 node.js 做服务端进行的一系列测试（感谢 橘子君）： 浏览器 请求类型 GET(Bytes) POST(Bytes) IE11 地址栏 2047 -- ajax 81593 102400 IE11 地址栏 2047 -- ajax Edge 地址栏 2083 -- ajax 81488 102400 Chrome 地址栏只粘贴 81550 -- 粘贴加输入 如果超32791，则为：32791+一次性新输入个数 -- ajax 有可能是服务器端限制 81459 102400 python ajax 81825 102400 也就是说除了在地址栏中输入 URL 发送 GET 请求有明显的限制，而直接通过代码发送请求，Get(80K 左右)和 Post(100K)发送的数据大小相差不多。 3 误区 一般认为 HTTP 请求方法与CRUD(Create, Read, Update, Delete)操作的对应关系如下：而实际上，除了 GET 和 DELETE 可以这样对应，POST 和 PUT 都可以作为增加或修改操作。 CRUD HTTP 增加 POST 查询 GET 更新 PUT 删除 DELETE GET 请求能够被保存在浏览器的浏览历史里面 不准确！只有是在浏览器地址栏内输入的 URL 地址才可以在浏览器历史中查看。 GET 参数是带在 URL 后面，传统 IE 中 URL 的最大可用长度为 2048 字符，其他浏览器对 URL 长度限制实现上有所不同，POST 请求无长度限制 不准确！上方已经写出了结论：除了在地址栏中输入 URL 发送 GET 请求有明显的限制，而直接通过代码发送请求，Get(80K 左右)和 Post(100K)发送的数据大小相差不多。 最后，再看下 HTTP 状态码，简单易懂：","link":"/2020/04/26/HTTP%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%E7%9A%84%E5%BC%82%E5%90%8C/"},{"title":"TypeScript编码规范","text":"1 命名及约定1.1 类使用 PascalCase 进行命名。 Bad 1class foo {} Good 1class Foo {} 1.2 类成员（变量、方法）使用 camelCase 进行命名。 Bad 1234class Foo { Bar: number; Baz(): number {}} Good 1234class Foo { bar: number; baz(): number {}} 1.3 接口使用 PascalCase 进行命名，不要在接口名前加“I”。 接口成员使用 camelCase 进行命名。 Bad 1234interface IFoo { Bar: number; Baz(): number;} Good 1234interface Foo { bar: number; baz(): number;} 1.4 命名空间使用 PascalCase 进行命名。 Bad 1namespace foo {} Good 1namespace Foo {} 1.5 枚举 使用 PascalCase 进行命名。 Bad 1enum color {} Good 1enum Color {} 枚举成员使用 PascalCase 进行命名。 Bad 123enum Color { red,} Good 123enum Color { Red,} 1.6 文件名 使用破折号分隔描述性单词，比如：hero-list.ts。 使用点将描述性名称与类型分开，比如：user-info.page.ts。 尽量使用常规的几种类型名，包括.page,.service,.component,.pipe,.module,.directive,.controller 和.middleware。当然也可以自己创建其他类型，但不宜太多。 类名与文件名匹配，并遵循类命名规范。 类名 文件名 export class AppComponent { } app.component.ts export class HeroListComponent { } hero-list.component.ts export class UserProfileService { } user-profile.service.ts 2 类型 需显式地为变量、数组和方法编写类型（类型推论能够推断出类型的不需要声明类型）。 Bad 1234567891011121314class Bar { bar(input) { let isZero; const foo: number = 5; if (input === 5) { isZero = false; } const resultObject = { fo: foo, isZeroRes: isZero, }; return resultObject; }} Good 12345678910111213141516171819class Bar { bar(input: number): BarResult { let isZero: boolean; const foo = 5; if (input === 0) { isZero = true; } const resultObject = { fo: foo, isZeroRes: isZero, }; return resultObject; }}interface BarResult { fo: number; isZeroRes: boolean;} 不要使用 Number、String、Boolean、Object 为变量、数组和方法设置类型。 Bad 123baz(foo: String): String {} Good 123baz(foo: string): string {} 3 声明变量 如果变量在其生命周期可能发生改变，尽量使用 let。 如果一个值在程序生命周期内不会改变，尽量使用 const。 Bad 123456var bar = &quot;bar&quot;;var count;if (true) { console.log(bar); count += 1;} Good 123456const bar = &quot;bar&quot;;let count: number;if (true) { console.log(bar); count += 1;} 4 对象 使用{}进行对象创建。 Bad 1const item = new Object（）; Good 1const item = {}; 在对象字面量里使用属性简写。 Bad 1234const lukeSkywalker = &quot;Luke Skywalker&quot;;const obj = { lukeSkywalker: lukeSkywalker,}; Good 1234const lukeSkywalker = &quot;Luke Skywalker&quot;;const obj = { lukeSkywalker,}; 仅使用引号用于属于无效标识符的属性。 Bad 12345const bad = { foo: 3, bar: 4, &quot;data-blah&quot;: 5,}; Good 12345const good = { foo: 3, bar: 4, &quot;data-blah&quot;: 5,}; 5 字符串 使用单引号声明字符串。 Bad 1const bar = &quot;bar&quot;; Good 1const bar = 'bar'； 6 解构 访问和使用对象的多个属性时，使用对象解构。 Bad 12const foo = user.firstName;const bar = user.lastName; Good 1const { foo, bar } = user; 访问数组中的多个数据时，使用解构。 Bad 123const arr = [1, 2, 3, 4];const first = arr[0];const second = arr[1]; Good 12const arr = [1, 2, 3, 4];const [first, second] = arr; 7 空格 在定义类型前面加上空格。 赋值等号两边加上空格。 方法、类大括号前空格。 对象冒号后空格。 Bad 12345678910class Foo { openDetail(item: string): void { let foo: string; foo = &quot;&quot;; const foa = { name: &quot;foo&quot;, }; console.log(item); }} Good 12345678910class Foo { openDetail(item: string): void { let foo: string; foo = &quot;&quot;; const foa = { name: &quot;foo&quot;, }; console.log(item); }} 8 缩进使用两个空格缩进。 9 分号语句结尾添加分号。 Bad 1const foo = &quot;foo&quot;; Good 1const foo = &quot;foo&quot;; 10 数组 使用[]定义数组。 Bad 1let foos: Array&lt;Foo&gt;; Good 1let foos: Foo[]; 使用 push 添加数据 Bad 12const foos = [];foos[foos.length] = &quot;abracadabra&quot;; Good 12const foos = [];foos.push(&quot;abracadabra&quot;);","link":"/2020/05/24/TypeScript%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"},{"title":"JavaScript模块化","text":"模块化的理解1、什么是模块化 将一个复杂的程序，依据一定的规则(规范)封装成一个或多个块(文件), 并进行组合在一起。 块的内部数据与实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信。 2、模块化的进化过程无模块时代 在 ajax 还未提出之前，js 还只是用来在网页上进行表单校验、提交，对 DOM 渲染操作。 1234567891011121314151617var str, num;//......function submit() { str = document.getElementById(&quot;xx&quot;).value; if (str) { //...... } else { //...... } num = 1; for (var i = 0; i &lt; 10; i++) { num++; //...... } //...... form.submit();} 1234&lt;script type=&quot;text/javascript&quot; src=&quot;a.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;b.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;c.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;main.js&quot;&gt;&lt;/script&gt; 缺点： 全局变量污染 函数命名冲突 文件依赖顺序 模块雏形时代 2006 年，ajax 的概念被提出，前端拥有了主动向服务端发送请求并操作返回数据的能力，传统的网页向“富客户端”发展，出现了简单的功能对象封装。 namespace 模式 12345678//模块jsvar myModule = { first_name: &quot;www.&quot;, second_name: &quot;baidu.com&quot;, getFullName: function () { return this.first_name + this.second_name; },}; 1234//调用jsconsole.log(myModule.getFullName());myModule.first_name = &quot;img.&quot;;console.log(myModule.getFullName()); 优点: 减少了全局变量，解决命名冲突缺点: 数据不安全(外部可以直接修改模块内部的数据)，模块名称会暴露在全局，存在命名冲突，依赖顺序问题 自执行匿名函数（闭包）模式 1234567891011//模块js(function (window) { let _moduleName = &quot;module&quot;; function setModuleName(name) { _moduleName = name; } function getModuleName() { return _moduleName; } window.moduleA = { setModuleName, getModuleName };})(window); 1234//调用jsmoduleA.setModuleName(&quot;html-module&quot;);console.log(moduleA.getModuleName());console.log(moduleA._moduleName); //模块不暴露，无法访问模块内属性方法 优点：变量、方法全局隐藏，模块私有化缺点：模块名称会暴露在全局，存在命名冲突，依赖顺序问题 3、面临的问题从以上的尝试中，可以归纳出 js 模块化需要解决那些问题： 如何安全的包装一个模块的代码？（不污染模块外的任何代码） 如何唯一标识一个模块？ 如何优雅的把模块的 API 暴漏出去？（不能增加全局变量） 如何方便的使用所依赖的模块？ 模块化的规范1、CommonJS2009 年 Nodejs 发布，采用 CommonJS 模块规范。 特点： 每个文件都是一个模块实例，代码运行在模块作用域，不会污染全局作用域。 文件内通过 require 对象引入指定模块，通过 exports 对象来向往暴漏 API，文件内定义的变量、函数，都是私有的，对其他文件不可见。 每个模块加载一次之后就会被缓存。 所有文件加载均是同步完成，加载的顺序，按照其在代码中出现的顺序。 模块输出的是一个值的拷贝，模块内部的变化不会影响该值。 123456789//模块jslet _moduleName = &quot;module&quot;;function setModuleName(name) { _moduleName = name;}function getModuleName() { return _moduleName;}module.exports = { setModuleName, getModuleName }; 1234//调用jsimport { getModuleName, setModuleName } from &quot;./es6.module&quot;;setModuleName(&quot;es6 Module&quot;);console.log(getModuleName()); 缺点：模块同步加载，资源消耗和等待时间，适用于服务器编程 2、AMD/RequireJSCommonjs 局限性很明显： 基于 Node 原生 api 在服务端可以实现模块同步加载，但是仅仅局限于服务端，客户端如果同步加载依赖的话时间消耗非常大，所以需要一个在客户端上基于 Commonjs 但是对于加载模块做改进的方案，于是 AMD 规范诞生了。 AMD 是”Asynchronous Module Definition”的缩写，意思就是”异步模块定义”。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到所有依赖加载完成之后（依赖前置），这个回调函数才会运行。 RequireJS 是一个工具库，主要用于客户端的模块管理。它的模块管理遵守 AMD 规范，RequireJS 的基本思想是，通过 define 方法将代码定义为模块，通过 require 方法实现代码的模块加载。 12345678// module1.js 定义没有依赖的模块define(function () { let _moduleName = &quot;module&quot;; function getName() { return _moduleName; } return { getName }; // 暴露模块}); 123456789101112// module2.js 定义有依赖的模块define([&quot;module1&quot;], function (module1) { let _firstName = &quot;AMD&quot;; function getFullName() { return _firstName + &quot; &quot; + module1.getName(); } function setFirstName(name) { _firstName = name; } // 暴露模块 return { _firstName, getFullName, setFirstName };}); 12345678910111213141516//mian.jsrequire.config({ paths: { module1: &quot;./modules/module1&quot;, module2: &quot;./modules/module2&quot;, // 第三方库模块 jquery: &quot;./libs/jquery.min&quot;, },});require([&quot;module2&quot;, &quot;jquery&quot;], function (module2, jquery) { console.log(module2.getFullName()); module2.setFirstName(&quot;AMD-AMD&quot;); console.log(module2.getFullName()); console.log(module2._firstName); jquery(&quot;#moduleId&quot;).html(&quot;&lt;i&gt;My name is jquery-module&lt;/i&gt;&quot;);}); 12//html中引入工具库，并定义js主文件&lt;script data-main=&quot;./main&quot; src=&quot;./libs/require.js&quot;&gt;&lt;/script&gt; 特点：浏览器直接运行无需编译，异步加载，依赖关系清晰 3、CMD/SeaJSCMD 规范专门用于浏览器端，同样是受到 Commonjs 的启发，国内（阿里）诞生了一个 CMD（Common Module Definition）规范。该规范借鉴了 Commonjs 的规范与 AMD 规范，在两者基础上做了改进。 与 AMD 相比非常类似，CMD 规范（2011）具有以下特点： define 定义模块，require 加载模块，exports 暴露变量。 不同于 AMD 的依赖前置，CMD 推崇依赖就近（需要的时候再加载） 推崇 api 功能单一，一个模块干一件事。 SeaJs 是 CMD 规范的实现，跟 RequireJs 类似，CMD 是 SeaJs 推广过程中诞生的规范。CMD 借鉴了很多 AMD 和 Commonjs 优点。 123456//module.1define(function (require, exports, module) { module.exports = { msg: &quot;I am module1&quot;, };}); 12345678//module.2define(function (require, exports, module) { var module2 = require(&quot;./module1&quot;); function show() { console.log(&quot;同步引入依赖模块1 &quot; + module2.msg); } exports.showModule = show;}); 12345//main.jsdefine(function (require) { var m2 = require(&quot;./modules/module2&quot;); m2.showModule();}); 12345//html中引入工具库，并定义js主文件&lt;script type=&quot;text/javascript&quot; src=&quot;./libs/sea.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; seajs.use('./main')&lt;/script&gt; AMD、CMD 区别 AMD 推崇依赖前置 CMD 推崇依赖就近 12345678//AMDdefine(['./a', './b'], function(a, b) { // 依赖必须一开始就写好 a.doSomething() ... // 此处略去 100 行 b.doSomething() ...}) 12345678910//CMDdefine(function(require, exports, module) { var a = require('./a') a.doSomething() ... // 此处略去 100 行 var b = require('./b') // 依赖可以就近书写 b.doSomething() ...} 4、ES62015 年，ES6 规范中，终于将模块化纳入 JavaScript 标准，从此 js 模块化被 ECMA 官方扶正，也是后来 js 的标准。ES6 中的模块化在 CommonJS 的基础上有所不同，关键字有 import，export，default，as，from。 123456789//模块jslet _moduleName = &quot;module&quot;;function setModuleName(name) { _moduleName = name;}function getModuleName() { return _moduleName;}export { setModuleName, getModuleName }; 1234//调用jsimport { getModuleName, setModuleName } from &quot;./es6.module&quot;;setModuleName(&quot;es6 Module&quot;);console.log(getModuleName()); CommonJS 和 ES6 区别 CommonJS 模块输出的是一个值的拷贝，即原来模块中的值改变不会影响已经加载的该值。ES6 模块输出的是值的只读引用，模块内值改变，引用也改变。 CommonJS 模块是运行时加载，加载的是整个模块，即将所有的接口全部加载进来。ES6 模块是编译时输出接口，可以单独加载其中的某个接口。 总结 CommonJS 规范主要用于服务端编程，加载模块是同步的，不适合在浏览器环境，存在阻塞加载，浏览器资源是异步加载的，因此有了 AMD、CMD 解决方案。 AMD 规范在浏览器环境中异步加载模块，而且可以并行加载多个模块。 CMD 规范与 AMD 规范很相似，都用于浏览器编程，依赖就近，代码更简单。 ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。","link":"/2020/05/29/JavaScript%E6%A8%A1%E5%9D%97%E5%8C%96/"},{"title":"Rap2入门","text":"1 写在最前面1.1 是什么是阿里妈妈前端团队出品，是一个接口可视化管理平台。 使用了Mock.js作为 Mock 引擎，用于前后端分离的开发模式中，根据约定接口自动生成模拟数据。 1.2 能解决什么问题 前端独立开发，不受后端接口开发进度的影响。 无需前后端联调，避免频繁沟通，减少双方时间成本。 支持生成随机的文本、数字、布尔值、日期、邮箱、链接、图片、颜色等模拟数据，可实现真实接口请求效果。 1.3 最终目的提升协作效率，少加班，少熬夜。 2 快速上手2.1 登录打开 Rap2 官方服务站点rap2.taobao.org之后进行登录，新用户需要注册。 说明：rap2 为开源项目，也可以通过下载官方源码，自行编译本地部署。rap2 源码传送门注意：公司内部用户请使用内部服务，数据进行了定期备份，更安全，更可靠。内部地址：http://xxx.xx.xxx.108:8887/ths-rap2，地址全路径请咨询组内人员。 2.2 新建仓库一般一个项目建立一个仓库，仓库中存放这个项目的所有接口。按照以下步骤进行操作: 操作说明： 新建仓库：发起仓库新建操作。 仓库名称（必填）：建议与项目名称保持一致。 简介（非必填）：对仓库名称进行补充描述。 成员（非必填）：被添加的成员可以获得这个仓库内接口的操作权限，一般为这个项目的前后端开发人员。 团队（非必填）：被添加的团队，团队内成员可以获得这个仓库内接口的操作权限。 协同仓库 ID（非必填）：在当前仓库中无法匹配到接口时，将会从协同仓库中寻找，便于大的项目按不同仓库拆分管理。 2.3 新建模块一般仓库下可以按照功能划分出来多个模块，每个模块放对应的接口，方便接口查找。按照以下步骤进行操作: 操作说明： 新建模块：发起模块新建操作。 模块名称（必填）：这里的模块名称，可以按照功能划分。 模块简介（非必填）：对模块名称进行补充描述。 2.4 新建接口按照以下步骤进行操作: 操作说明： 新建接口：发起接口新建操作。 名称（必填）：接口文本描述。 地址（必填）：接口的访问地址。 类型：请求类型。 请求码：http 状态码。 简介：对名称的补充描述。 2.5 设置请求参数&amp;响应结果2.5.1 请求参数示例数据 JSON： 1234567891011121314{ &quot;token&quot;: &quot;&quot;, &quot;login_name&quot;: &quot;&quot;, &quot;code_region&quot;: &quot;&quot;, &quot;trade_code&quot;: &quot;&quot;, &quot;sync_nation&quot;: &quot;&quot;, &quot;code_land&quot;: &quot;&quot;, &quot;scflag&quot;: &quot;&quot;, &quot;longitude_d&quot;: &quot;&quot;, &quot;latitude_d&quot;: &quot;&quot;, &quot;pageSize&quot;: &quot;&quot;, &quot;pageMum&quot;: &quot;&quot;, &quot;&quot;: &quot;&quot;} 按照以上操作进入接口编辑状态。 进入编辑状态后操作说明： 这个区域可以设置请求头，参数传输方式。这两个都需要提前跟后端沟通好。 导入：该操作可以根据提前跟后端沟通定义好的 JSON 格式对象进行参数的快速导入注意：也可以通过单行方式导入，具体参照下图 2.5.2 响应参数示例数据 JSON： 1234567891011121314151617181920{ &quot;data&quot;: [ { &quot;LANDNAME&quot;: &quot;@cword(1, 3)污染地块&quot;, &quot;CODE_LAND&quot;: &quot;&quot;, &quot;CODE_STAGE_NAME&quot;: &quot;初步调查&quot;, &quot;NEW_SUPERVISETIME&quot;: &quot;@now(yyyy-MM-dd)&quot;, &quot;SUPERVISENUM&quot;: &quot;1&quot;, &quot;DISTANCE&quot;: &quot;@natural(10, 1000)&quot;, &quot;LONGITUDE&quot;: &quot;@float(109,120)&quot;, &quot;LATITUDE&quot;: &quot;@float(20,30)&quot;, &quot;TRADENAME&quot;: &quot;采矿业&quot;, &quot;REGIONNAME&quot;: &quot;白云区&quot;, &quot;SYNC_NATION&quot;: &quot;&quot;, &quot;FAVOURITE_ID&quot;: &quot;&quot;, &quot;CODE_STAGE&quot;: &quot;SURVEP&quot;, &quot;SEEMINFO_ID&quot;: &quot;6f2b8060- 34a1-446f-8f80-a771df3e1a20&quot; } ]} 注意：所有设置完成后，记得点击右上角的保存，不然接口设置不生效。 操作说明： 导入：该操作可以根据提前跟后端沟通定义好的 JSON 格式对象进行参数的快速导入注意：也可以通过单行方式导入。 2.6 接口访问地址 注意：由于演示地址为 post 请求，必须在程序中或 Postman 等工具发起请求，这里只是为了获取到地址。 地址说明： 基础地址：对应生成环境中的项目服务地址。 接口地址：接口相对地址，定义时建议和实际接口保持一致，这样只需修改基础地址即可切换生产环境。 到此为止，一个可以在程序中访问的模拟接口已经完成了。 3 补充看到这里，大家肯定有疑问，模拟随机数据怎么模拟的呢？上边一些截图中带@符号的是什么啊？我模拟数据是个列表，现在才生成一条啊。 下面为大家讲解下，两个比较重要的东西：生成规则和初始值。 生成规则和初始值这两个是配合着使用的，也可以单独设置一个。在文章刚开始，讲到 rap2 使用了Mock.js作为 Mock 引擎,所以这两个的设置是遵循 Mock.js 语法规范的。 比如快速上手部分例子，我们要让列表生成 10 条数据，如何设置呢？我们只需要把生成规则列设置成 10 就行了。 我是如何知道这个设置 10 可以生成 10 条数呢？查看 Mockjs 官方文档示例。传送门 再比如我们还想设置地块列表中地块名称为 xxx 污染地块，每一条都不一样，那就需要像上边截图中那样设置初始值了。@cword(1, 3)污染地块。[传送门](&lt;http://mockjs.com/examples.html#Random.cword( pool?, min?, max? )&gt;) Mockjs 示例文档与 Rap2 设置对应关系说明（有其他模拟数据需求，都可以查看Mockjs给出的示例）:","link":"/2020/06/01/Rap2%E5%85%A5%E9%97%A8/"},{"title":"PWA--下一代的web应用模型","text":"概述 不知道从什么时候开始，当我们在浏览网页时，页面会出现一个弹窗，询问我们是否要将此网页保存到本地，如果我们选择了确定，在设备的主屏上就会出现一个新的 app，而它就是我们刚才浏览的网页。这种 app 我们并没有从应用商店去下载，但是我们可以像使用 app 一样去使用它，也可以像卸载其他 app 一样去将它卸载，那么这究竟是个什么东西呢，它就是这篇文章的主角——PWA。 什么是 PWAPWA 是 Progressive Web App 的简写，中文名称为渐进式 web 应用。它是 Google 在 2016 年提出的概念，2017 年落地的 web 技术，一种在移动端利用提供的标准化框架，在网页应用中实现和原生应用相近的用户体验的渐进式网页应用。PWA 不单指一种技术，你也可以将其理解为一种思想和概念，目的就是对标原生 app，将 Web 网站通过一系列的 Web 技术去优化它，提升其安全性，性能，流畅性，用户体验等各方面指标，最后达到用户就像在用 app 一样的感觉。 PWA 为什么会出现说到 app，我们就不得不提起 native app 即原生 app，现在非常主流的移动端应用。原生 app 使用起来会很流畅，性能好，安全性也可以很高，这是它很显著的优势。但是缺点呢，也很明显，比如： 开发成本很昂贵 软件上线，版本更新都需要发布到不同的商店，并通过审核 这对开发人员来说是比较麻烦的事情。而对于用户来说，有些 APP 可能使用频率特别少，但还是不得不去商店中下载庞大的安装包，或者可能一段时间不使用以后，随着版本的更新，也不得不去重新更新并安装。 PWA 则完美地避免了这些问题。 如何判断一个 web 应用是 PWA要判断一个 web 应用是否是 PWA，可以从以下几个方面去考虑： 可发现的—— 内容可以通过搜索引擎发现。 可安装—— 可以出现在设备的主屏幕。 可链接—— 你可以简单地通过一个 URL 来分享它。 独立于网络——它可以在离线状态或者是在网速很差的情况下运行。 渐进式—— 它在老版本的浏览器仍旧可以使用，在新版本的浏览器上可以使用全部功能。 可重用—— 无论何时有新的内容它都可以发送通知。 响应性—— 它在任何具有屏幕和浏览器的设备上可以正常使用——包括手机，平板电脑，笔记本，电视，冰箱，等。 安全—— 在你和应用之间的连接是安全的，可以阻止第三方访问你的敏感数据。 当然，在安装方式上 PWA 应用与原生 app 有很大的不同，但是在实际使用上，与原生应用的差距非常小，对于用户来说，几乎是无感的。 核心功能Service-WorkersService Workers 是浏览器和网络之间的虚拟代理，运行在一个与页面的 JavaScript 主线程独立的线程上，并且没有对 DOM 结构的任何访问权限，并且可以在不同的上下文之间发送和接收信息。 您可分配给 Service Worker 一些任务，并使用基于 Promise 的方法在任务完成时收到结果。他们不仅仅提供离线功能，还提供包括处理通知，在单独的线程上执行繁重的计算等。Service workers 非常强大，因为他们可以控制网络请求，修改网络请求，返回缓存的自定义响应，或合成响应。因为它们非常强大，所以 Service Workers 只能在安全的上下文中执行（即 HTTPS ）。 注册 service worker123456789101112if (&quot;serviceWorker&quot; in navigator) { // 浏览器支持SW // Service Worker 的注册路径决定了其 scope 默认作用页面的范围。如果存放在网站的根路径下，则将会收到该网站的所有 fetch 事件。如果希望改变它的作用域，可在第二个参数设置 scope 范围 navigator.serviceWorker .register(&quot;serviceWorker.js&quot;) .then(function (registration) { console.log(&quot;ServiceWorker注册成功: &quot;, registration.scope); }) .catch(function (err) { console.log(&quot;ServiceWorker注册失败: &quot;, err); });} 注册完成后，serviceWorker.js 文件会自动下载，然后安装，最后激活。 service worker 中的常用事件 install 12345678910111213141516171819202122var cacheName = &quot;hello-pwa&quot;;// install 事件，它发生在浏览器安装并注册 Service Worker 时self.addEventListener(&quot;install&quot;, (event) =&gt; { // event.waitUtil 用于在安装成功之前执行一些预装逻辑,但是建议只做一些轻量级和非常重要资源的缓存，减少安装失败的概率,安装成功后 ServiceWorker 状态会从 installing 变为 installed event.waitUntil( caches .open(cacheName) .then((cache) =&gt; cache.addAll( [ &quot;/&quot;, // 这个一定要包含整个目录，不然无法离线浏览 &quot;./images/cat2.jpg&quot;, &quot;./index.html&quot;, &quot;./style.css&quot;, ] // 如果所有的文件都成功缓存了，便会安装完成。如果任何文件下载失败了，那么安装过程也会随之失败。 ) ) .then(() =&gt; self.skipWaiting()) );}); service worker 会等到 waitUntil 里面的代码执行完毕之后才开始安装，它返回一个 promise。caches 是一个特殊的 CacheStorage 对象，它能在 Service Worker 指定的范围内提供数据存储的能力。 fetch 每次当我们的应用发起一个 http 请求时，我们还有一个 fetch 事件可以使用。这个事件对我们来说非常有用，它允许我们拦截请求并对请求作出自定义的响应。 1234567891011121314151617// 为 fetch 事件添加一个事件监听器,service worker将从缓存中请求所需的数据，从而提供离线应用功能self.addEventListener(&quot;fetch&quot;, function (e) { event.respondWith( // 使用 caches.match() 函数来检查传入的请求 URL 是否匹配当前缓存中存在的任何内容，如果存在的话，返回缓存的资源；如果资源并不存在于缓存当中，通过网络来获取资源，并将资源存储到缓存中。 caches.match(e.request).then(function (r) { return ( r || fetch(e.request).then(function (response) { return caches.open(cacheName).then(function (cache) { cache.put(e.request, response.clone()); return response; }); }) ); }) );}); Manifest为了成为可安装网站，需要下列事情就位： 一份网页清单，填好正确的字段 网站的域必须是安全（HTTPS）的 一个本设备上代表应用的图标 一个注册好的 service worker，可以让应用离线工作（这仅对于安卓设备上的 Chrome 浏览器是必需的） 清单文件清单文件通常位于网页应用的根目录，包含一些有用的信息，比如应用的标题，在一个移动 OS 上显示的代表该应用的不同大小的图标（例如，主屏图标）的路径，和用于加载或启动画面的背景颜色。这些信息是浏览器在安装 web 应用时和在主屏上显示应用需要的，这些信息是以 JSON 的形式列出来的。 12345678910111213141516171819202122232425262728{ &quot;name&quot;: &quot;Minimal PWA&quot;, //网站应用的全名 &quot;short_name&quot;: &quot;PWA Demo&quot;, // 显示在主屏上的短名 &quot;description&quot;: &quot;The app that helps you understand PWA&quot;, //一两句话解释你的应用的用途 &quot;display&quot;: &quot;standalone&quot;, // 应用的显示方式：可以是全屏，独立，最小ui或者浏览器 &quot;start_url&quot;: &quot;/&quot;, //应用启动的index文档 &quot;theme_color&quot;: &quot;#313131&quot;, // ui的主题色，这是操作系统使用的 &quot;background_color&quot;: &quot;#313131&quot;, // 背景色，用于安装程序时和启动应用时 &quot;icons&quot;: [ { &quot;src&quot;: &quot;icon/lowres.webp&quot;, &quot;sizes&quot;: &quot;48x48&quot;, &quot;type&quot;: &quot;image/webp&quot; }, { &quot;src&quot;: &quot;icon/lowres&quot;, &quot;sizes&quot;: &quot;48x48&quot; }, { &quot;src&quot;: &quot;icon/hd_hi.ico&quot;, &quot;sizes&quot;: &quot;72x72 96x96 128x128 256x256&quot; }, { &quot;src&quot;: &quot;icon/hd_hi.svg&quot;, &quot;sizes&quot;: &quot;72x72&quot; } ] //一串图标信息——源URL,大小和类型，确保包含一些图标，这样有一个最适合用户设备的图标可以被选中} 一份网页清单最少需要 name 和一个图标 (带有 src, size 和 type)。description, short_name, 和 start_url 最好要提供。 扩展以下，过去有一些常用的扩展名用于清单：manifest.webapp 在 Firefox OS 应用清单中很流行，许多人使用 manifest.json 作为网页清单因为内容是 JSON 格式的。但是，.webmanifest 扩展名是在 W3C 清单规范中显示指定的，建议使用清单文件使用.webmanifest 作为后缀 。 添加到主屏“添加到主屏”是移动浏览器实现的一个特性，它利用网页清单中的信息来在设备主屏上显示应用图标和文字。当用户使用一个支持的移动浏览器访问一个 PWA 时，会显示一个弹框表示可以安装这个应用，用户确认之后应用就被安装到主屏了，用户可以立刻启动并使用应用。在一些浏览器中，可以通过清单信息产生一个启动画面，当 PWA 启动时显示，图标、主题和背景色用于创建这个启动画面。 在 ios 上和 android 手机上打开 vue 的官网，可以将其添加到设备主屏： ios android Push&amp;NotificationPush&amp;Notification 即推送和通知，通过推送 API 和通知 API 来实现。 推送可以实现从服务端推送新的内容而不需要客户端发起请求，它是由应用的 service worker 来实现的。通知功能则可以通过 service worker 来向用户展示一些新的信息，或者至少提醒用户应用已经更新了某些功能。 这些工作是在浏览器外部实现的，跟 service worker 一样，所以即使应用被隐藏到后台甚至应用已经被关闭了，我们仍然能够推送更新或者推送通知给用户。 推送 API 和通知 API 可以独立工作，也可以结合到一起使用。 通知 API——请求授权当用户确定接收通知，我们的应用就可以获得推送通知的功能。用户的授权的结果有三种，default，granted 或者 denied，当用户没有做出选择的时候，授权结果会返回 defalut，另外两种结果分别是用户选择了授权或者拒绝授权。一旦用户选择授权，这个授权结果对通知 API 和推送 API 两者都有效。 12345678910var button = document.getElementById(&quot;notifications&quot;);console.log(button);button.addEventListener(&quot;click&quot;, function (e) { Notification.requestPermission().then(function (result) { if (result === &quot;granted&quot;) { // randomNotification(); console.log(&quot;授权&quot;); } });}); 推送推送比通知要复杂一些，我们需要从服务端订阅一个服务，之后服务端会推送数据到客户端应用。应用的 Service Worker 将会接收到从服务端推送的数据，这些数据可以用来做通知推送，或者实现其他的需求，这个技术还处在非常初级的阶段。为了接收到推送的消息，你需要有一个 service worker，在 service worker 内部，存在一个消息推送服务订阅机制。 1registration.pushManager.getSubscription().then(/* ... */); 一旦用户订阅服务，他们就能接收到服务器推送的通知。为了能够接收到推送的消息，我们需要在 Service Worker 文件里面监听 push 事件。 123self.addEventListener(&quot;push&quot;, function (e) { /* ... */}); 这个技术还处在非常初级的阶段，从服务端的角度来看，出于安全的目的，这整个过程必须使用非对称加密技术进行加密。而VAPID可以为你的应用提供一层额外的安全保护。 发展趋势既然谈到 PWA 的发展趋势，就不得不说说它的优势和劣势了。 优势 无需安装，无需下载，只要你输入网址访问一次，然后将其添加到设备桌面就可以持续使用。 发布不需要提交到 app 商店审核，更新迭代版本不需要审核 现有的 web 网页都能通过改进成为 PWA， 能很快的转型，上线，实现业务、获取流量 不需要开发 Android 和 IOS 两套不同的版本 劣势 浏览器对技术支持还不够全面， 不是每一款游览器都能 100%的支持所有 PWA 需要通过第三方库才能调用底层硬件（如摄像头） PWA 现在还没那么火，国内一些手机生产上在 Android 系统上做了手脚，似乎屏蔽了 PWA PWA 作为一个 2016 年才落地的新技术，经过四年的发展，基于 Chromium 的浏览器 Chrome 和 Opera 已经完全支持 PWA 了，随着 iOS 11.3 的发布，iOS 正式开始支持 PWA，Windows Edge 也支持 PWA 了。越来越多的游览器大厂，相继的对 PWA 做出了支持和优化，想必 PWA 的时代即将到来。 关于 PWA，你怎么看呢？","link":"/2020/08/06/PWA-%E4%B8%8B%E4%B8%80%E4%BB%A3%E7%9A%84web%E5%BA%94%E7%94%A8%E6%A8%A1%E5%9E%8B/"},{"title":"Vue组件开发及NPM发布（TS版）","text":"1 创建项目123npm install -g @vue/cli // 安装Vue命令行工具，最新为vue create vue-components-ts // 项目名称自取,使用TS来开发项目 2 修改项目结构 将 src 文件夹改为 examples 作为组件的示例展示 删除 src 中的 assets，components 文件夹 将 public 中的 index.html 移入 examples 文件夹后，删除 public 文件夹 在项目根目录下，新增: components 文件夹：用于存放组件源码及导出文件 types 文件夹：用于添加 TypeScript 的类型定义文件 vue.config.js：用于修改默认的构建配置 .npmignore 文件：设置要忽略发布的文件 最终项目主要结构如下： 123456789101112131415161718192021├── components│ ├── category-name // 分类名（可选，如ECharts）│ │ ├── component-name // 单个组件│ │ │ ├── index.ts // 对外提供对组件的引用│ │ │ └── component-name.vue│ └── index.ts // 所有组件的导出文件├── examples│ ├── router│ │ ├── index.ts // 各个组件示例的路由│ ├── views│ │ ├── category-name // 分类名（可选，如ECharts）│ │ │ │── component-name // 单个组件│ │ │ │ └── component-name.vue // 封装组件的示例│ ├── App.vue│ ├── index.html│ └── main.ts // 导入所有的组件├── types // 类型定义文件夹│ └── index.d.ts // 所有组件类型的导出文件├── package.json├── README.md└── vue.config.js 3 修改构建配置3.1 添加 vue.config.js12345678910111213141516171819module.exports = { // 修改 src 目录 为 examples 目录 pages: { index: { // page 的入口 entry: 'examples/main.ts', // 模板来源 template: 'examples/index.html', // 在 dist/index.html 的输出 filename: 'index.html', }, }, // 扩展 webpack 配置 chainWebpack: (config) =&gt; { // 没有任何具名导出并直接暴露默认导出 config.output .libraryExport('default'); },}; 3.2 修改 package.json123456789101112131415name: 包名，该名不能和NPM中已有的名称冲突；version: 版本号，不能和当前包的历史版本号相同；description: 简介；keyword：关键字，以空格分割，方便别人搜索到本模块author：作者；private：是否私有，需要修改为 false 才能发布到 npm；license：开源协议main: 入口文件，应指向编译后的包文件； 1234567891011{ &quot;name&quot;: &quot;ths-vue&quot;, &quot;version&quot;: &quot;0.2.5&quot;, &quot;private&quot;: false, &quot;description&quot;: &quot;基于Vue的业务组件库&quot;, &quot;main&quot;: &quot;./dist/ths-vue.umd.min.js&quot;, &quot;author&quot;: &quot;ths-fe &lt;zapzqc@qq.com&gt;&quot;, &quot;license&quot;: &quot;MIT&quot;, &quot;keyword&quot;: [&quot;ths&quot;, &quot;vue&quot;, &quot;components&quot;], &quot;typings&quot;: &quot;types/index.d.ts&quot;} 在 scripts 中添加： 123456&quot;scripts&quot;: { &quot;serve&quot;: &quot;vue-cli-service serve&quot;, &quot;build&quot;: &quot;vue-cli-service build&quot;, &quot;lint&quot;: &quot;vue-cli-service lint&quot;, &quot;lib&quot;: &quot;vue-cli-service build --target lib --name ths-vue ./components/index.ts&quot;}, –-target : 构建目标，默认为应用模式这里修改为 lib 启用库模式 –name : 输出文件名称 –-dest : 输出目录，默认 dist，这里没有设置 3.3 修改.npmignore1234567891011121314151617# 忽略目录examples/examples/node_modules/# 忽略指定文件*.map.browserslistrc.editorconfig.eslintrc.jsbabel.config.jspackage-lock.jsontsconfig.jsonyarn.lockvue.config.js# 编辑器缓存文件.idea.vscode 4 构建并发布*4.1 构建生成组件库： 1npm run lib 实现对 examples 中应用的访问： 1npm run serve 4.2 发布首先需要在 npm 官网上注册一个账号，通过: 1npm adduser 命令创建一个账户，或者在 npm 官网注册。 注册完成后在本地命令行中登录： 1npm login 输入用户名、密码、邮箱： 执行发布命令，发布到 npm： 1npm publish 如果以前改过 npm 的镜像地址，比如使用了淘宝镜像，就先改回来： 1npm config set registry http://registry.npmjs.org 5 新增组件* 在 components 文件夹下创建新组件命名的文件夹，其中包含新组件的单文件组件.vue 和一个导出文件 index.ts。 1234567import 新的组件名 from &quot;./新的单文件组件名.vue&quot;;新的组件名.install = (Vue) =&gt; { Vue.component(新的组件名.name, 新的组件名);};export default 新的组件名; 在 components 文件夹下的所有组件的入口文件 index.js 中添加 12345678// 在下方导入新增组件import 新的组件名 from &quot;./新的单文件组件名&quot;;// 存储组件列表const components = { // 在下方添加新增组件 新的组件名,}; 在 types 文件夹下创建新组件的 d.ts 文件 123import { TUIComponent } from './component';export declare class 新的组件名 extends TUIComponent { } 测试组件 在 examples 的 main.js 中导入组件，并 use。 待补充 在 App.vue 的模板中使用： 待补充 运行： 1npm run serve 6 使用组件库*ths-vue 是基于思路前端设计理念的 Vue UI 组件库，主要用于研发企业级前端产品。 特性 提炼自企业前端产品的交互语言和视觉风格。 开箱即用的高质量 Vue 组件。 支持环境 现代浏览器和 IE9 及以上（需要 polyfills） 支持服务端渲染 Electron IE/Edge Firefox Chrome Safari Opera ) Electron IE9, IE10, IE11, Edge last 2 versions last 2 versions last 2 versions last 2 versions last 2 versions 兼容性 ths-vue 支持所有的现代浏览器和 IE9+。 对于 IE 系列浏览器，需要提供 es5-shim 和 es6-shim 等 Polyfills 的支持。 如果你使用了 babel，强烈推荐使用 babel-polyfill 和 babel-plugin-transform-runtime 来替代以上两个 shim。不要同时使用 babel 和 shim 两种兼容方法。 安装使用 npm 或 yarn 安装推荐使用 npm 或 yarn 的方式进行开发，不仅可在开发环境轻松调试，也可放心地在生产环境打包部署使用，享受整个生态圈和工具链带来的诸多好处。 123npm install ths-vue --saveyarn add ths-vue 如果网络环境不佳，推荐使用 cnpm。 完整引入在 main.js 引入并注册： 12345import Tvue from &quot;ths-vue&quot;;import &quot;ths-vue/dist/ths-vue.css&quot;;Vue.use(Tvue); 在组件中使用： 1234567891011&lt;template&gt; &lt;HelloWorld&gt;&lt;/HelloWorld&gt;&lt;/template&gt;&lt;script&gt; export default { data () { return { } } }&lt;/script&gt; 按需引入使用 babel-plugin-import，在命令行中运行： 1npm i babel-plugin-import --save-dev 修改 babel.config.js： 12345678910111213presets: [ '@vue/cli-plugin-babel/preset', ],plugins: [ ['import', { libraryName: 'ths-vue', libraryDirectory: 'components', }, 'ths-vue', ], ], 在 main.ts 中： 123import { HelloWorld } from &quot;ths-vue&quot;;Vue.use(HelloWorld); 7 注意事项组件必须声明 name 属性，这个 name 就是组件的 HTML 标签。","link":"/2020/08/20/Vue%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91%E5%8F%8ANPM%E5%8F%91%E5%B8%83%EF%BC%88TS%E7%89%88%EF%BC%89/"},{"title":"CSS编码规范","text":"1、文件命名 采用 HTML 命名规则。 2、选择器 尽量少用通用选择器 *。 禁止使用 ID 选择器编写样式。 尽可能避免使用属性选择器（例如，[class^=”…”]）。属性选择器相较其他选择器对浏览器的性能消耗是巨大的。 属性选择器必须使用双引号。 3、属性的顺序 顺序：定位 &gt; 盒模型 &gt; 文字 &gt; 其他内部属性 &gt; 其他 CSS3 属性。 1234567891011121314定位属性z-index，position，float，top，right，bottom，left盒模型属性width，height，padding，margin，border文字属性font-\\*，line-height，text-align，text-decoration....其他内部属性overflow，opacity，cursor....其他 css3 属性animation，transition，transform.... 4、代码编写规范 统一使用两个空格进行代码缩进，使得各编辑器表现一致（各编辑器有相关配置）。 每个属性声明末尾都要加分号。 左括号与类名之间一个空格，冒号与属性值之间一个空格。 逗号分隔的取值，逗号之后一个空格。 每个选择器单独占一行。 颜色值 rgb() rgba() hsl() hsla() rect() 中不需有空格，且取值不要带有不必要的 0。 属性值十六进制数值能用简写的尽量用简写。 不要为 0 指明单位。 可简写的属性设置多值时，尽量使用简写语法。 可简写的属性设置单值时，尽量不使用简写语法。 尽量不要在 CSS 中使用!important。 url()中的路径不添加引号。 避免使用标签选择器编写样式。 123456789.fs,.fc { display: block; width: 50px; box-shadow: 1px 1px 1px #333, 2px 2px 2px #ccc; color: rgba(255,255,255,.5); background: #fff; margin: 0;} 5、浏览器私有前缀的写法 CSS3 浏览器私有前缀在前，标准前缀在后。 1234567.fs { -webkit-border-radius: 10px; -moz-border-radius: 10px; -o-border-radius: 10px; -ms-border-radius: 10px; border-radius: 10px;} 6、注释 注释内容第一个字符和最后一个字符都是一个空格字符，单独占一行。 12/* Comment Text */.fs{} 不同人编写的 css 应该加上对应的注释，注明页面说明、作者、日期等信息。 1234567891011/** * @description 说明 * @author 作者 * 修改者（多个人） * @date 2015-10-10 最后的修改时间 */ 7、重置标签的默认样式 因为不同浏览器对有些标签的默认值是不同的，如果不对 css 初始化往往会出现浏览器之间的页面显示差异，为了让各个浏览器的 CSS 样式有一个统一的基准，使 HTML 元素样式在跨浏览器时有一致性的效果，所以需要重置 css 的默认样式。（以下代码，在使用 fbi 创建项目时会自动生成） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* 清除默认样式 */* { -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box;}html,body { padding: 0; margin: 0; font-family: 'Microsoft yahei';}ul,ol,li,span,p,h1,h2,h3,h4,h5,h6,a,dl,dt,dd,input { padding: 0; margin: 0; list-style: none; text-decoration: none; font-weight: normal; font-style: normal; font-family: 'Microsoft yahei'; font-size: 14px;}a { cursor: pointer;}img { vertical-align: middle; border: 0;}","link":"/2020/08/28/CSS%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"},{"title":"HTML编码规范","text":"1、文件命名 文件名不得包含空格和特殊字符。 文件名统一使用小写字母(为了醒目，某些说明文件的文件名，可以使用大写字母，比如 README、LICENSE )。 文件名包含多个单词时，单词之间以中划线 ( - ) 分隔。 入口文件使用 index 命名（比如 index.html、index.asp、index.jsp）。 命名的原则是语义化，方便理解，见名知意。 外部插件建议放在 modules 目录里，组件建议放在 components 目录里，不要全都放到 js 文件夹中。 使用统一的自动化工具构建页面结构。 123npm install -g tfbifbi init 项目名称 2、DOCTYPE 声明 为了确保在每个浏览器中拥有一致的展现效果，HTML 文件必须加上 DOCTYPE 声明，并统一使用 HTML5 的文档声明。 1&lt;!DOCTYPE html&gt; 3、页面语言 LANG 强烈建议为 html 根元素指定 lang 属性，从而为文档设置正确的语言。这将有助于语音合成工具确定其所应该采用的发音，有助于翻译工具确定其翻译时所应遵守的规则等等。 1&lt;html lang=&quot;zh-cmn-Hans&quot;&gt; 4、文档编码 为了防止文档在不同浏览器下出现乱码的问题，统一只用 utf-8 编码。 1&lt;meta charset=&quot;UTF-8&quot;&gt; 5、命名风格 HTML 标签名、ID 名、类名、标签属性和大部分属性值统一用小写，用中划线链接。 ID 名是唯一的，一般写在最外层元素上，禁止使用 ID 写 css 样式。 对于引号的运用，必须使用双引号，禁止使用单引号。 避免过度任意的简写，.btn 代表 button，但是 .b 不能表达任何意思。 使用 .js-* 来标识行为，并且不要将这些 class 写到 CSS 文件中(加具体的事件名)。 嵌套标签建议基于最近的父 class 或规定关键字作为新 class 的前缀。 123&lt;div class=&quot;demo&quot;&gt; &lt;div class=&quot;demo-info&quot;&gt;&lt;/div&gt;&lt;/div&gt; 6、标签 每个标签都有自己的定义，HTML 中必须使用语义化标签，禁止一直使用一类标签。 HTML 中使用双闭合标签时标签必须闭合，使用单闭合标签时尾部不加斜杠。 行内元素不要嵌套块级元素。p 标签中是不能嵌套块级元素的，浏览器会解析为两个独立的标签。 使用 img 标签时，建议定义好图片的尺寸，在加载时可以预留指定空间，减少闪烁。 7、关于 JS 和 CSS 根据 HTML5 规范，在引入 CSS 和 JavaScript 文件时一般不需要指定 type 属性，因为 text/css 和 text/javascript 分别是它们的默认值。这一点在老旧浏览器上也是支持的。 引入 JS 时 script 标签如无特殊情况统一放在 body 结束标签的前面，引入 CSS 时 link 标签统一放在 head 结束标签的前面，因为浏览器生成 Dom 树的时候是一行一行读 HTML 代码的，link 标签放在最后页面会出现短暂无样式的效果，script 标签放在最后面就不会影响前面的页面的渲染。 原则上禁止在 HTML 中编写 JS 代码，禁止在 HTML 中编写内联样式。 8、注释 HTML 中必要时增加注释代码。 注释内容前后各一个空格字符，注释位于要注释代码的上面，单独占一行。 123&lt;!-- Comment Text --&gt;&lt;div&gt;...&lt;/div&gt; 9、代码格式化 统一使用两个空格进行代码缩进，使得各编辑器表现一致（各编辑器有相关配置）（浏览器的配置文件）。 嵌套元素必须缩进一次（两个空格）。 元素嵌套时，每个块状元素独立一行，内联元素可选。","link":"/2020/08/28/HTML%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"},{"title":"从零创建Cordova插件-入门","text":"l 介绍本文将细致讲解 cordova 插件的创建、编写、配置、发布，涉及 aar+jar+so、静态资源、四大组件等。 l 环境准备1.node 2.ionic 3.cordova 4.plugman plugman 是用于安装和卸载用于 Apache Cordova 项目的插件的命令行工具,安装 plugman 1npm install -g plugman 5.AndroidStudio l 一切都要从一个简单 cordova 插件开始l 创建 ionic 项目用于测试 cordova 的插件 1ionic start CordovaProject blank 此时 cordovaProject 下会生成如下结构 在添加 platforms 和 plugins 之后，可以在此目录下打包 1CordovaProject$ cordova build android l 创建插件创建一个最简单的 Toast 插件1plugins$ plugman create --name ThsToast --plugin_id cordova-plugin-ths-toast --plugin_version 1.0.0 创建插件的完整模版：为了方便在插件开发过程中进行测试，将插件创建在 cordovaPluginProject 项目目录下的 plugins 文件夹下 plugman platform add 创建 ThsToast 插件的平台基础代码进入具体的插件目录下，创建插件安卓和 iOS 平台基础代码 12cordova-plugin-ths-toast$ plugman platform add --platform_name androidcordova-plugin-ths-toast$ plugman platform add --platform_name ios 添加之后将在 cordova-plugin-ths-toast 目录下产生 android 和 ios 两个目录,生成的 java 文件内容如图所示 重命名 ThsToast 插件目录名称（可选）接着手动将 ThsToast 目录重命名为和上述 plugin_id 一样的值：cordova-plugin-ths-toast，命名方式和 cordova 插件命名规范保持一致，ths 是公司的统一标识，通常是英文字符串 重命名 ThsToast 插件目录下 android 目录 java 代码中的 package 包名和 api 方法名需要将默认的包名改为[反向域值].cordova.[插件 name]**，要注意的是，plugin.xml 中配置的 java 文件 target-dir 输出目录需要和这里包名目录匹配**，如plugin.xml 1&lt;source-file src=&quot;src/android/ThsToast.java&quot; target-dir=&quot;src/org/apache/cordova/thstoast&quot; /&gt; 注意：起名不要和安卓原生方法冲突了，比如这里 ThsToast 如果改成 Toast，就会和 android.widget.Toast 中的 Toast 类重名，主要是区分是系统的还是公司的插件 l 插件配置ThsToast 插件目录下的 plugin.xml 配置 js 调用方法名和资源文件输出路径添加完平台后，cordova-plugin-ths-toast 目录下的 plugin.xml 文件将添加如下内容修改 plugin.xml 文件内容如下 1234567891011121314151617181920212223242526272829&lt;?xml version='1.0' encoding='utf-8'?&gt;&lt;plugin id=&quot;cordova-plugin-ths-toast&quot; version=&quot;1.0.0&quot; xmlns=&quot;http://apache.org/cordova/ns/plugins/1.0&quot; xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;name&gt;Toast&lt;/name&gt; &lt;js-module name=&quot;ThsToast&quot; src=&quot;www/ThsToast.js&quot;&gt; &lt;!-- target修改, 通过window.ThsToast.show或ThsToast.show即可调用api --&gt; &lt;clobbers target=&quot;ThsToast&quot; /&gt; &lt;/js-module&gt; &lt;platform name=&quot;android&quot;&gt; &lt;config-file parent=&quot;/*&quot; target=&quot;res/xml/config.xml&quot;&gt; &lt;feature name=&quot;ThsToast&quot;&gt; &lt;!-- param value修改，[包名].[文件名] --&gt; &lt;param name=&quot;android-package&quot; value=&quot;cn.com.ths.thstoast.ThsToast&quot; /&gt; &lt;/feature&gt; &lt;/config-file&gt; &lt;config-file parent=&quot;/*&quot; target=&quot;AndroidManifest.xml&quot; /&gt; &lt;!-- target-dir修改，最终打包出的java文件完整目录路径 --&gt; &lt;source-file src=&quot;src/android/ThsToast.java&quot; target-dir=&quot;src/cn/com/ths/thstoast&quot; /&gt; &lt;/platform&gt; &lt;platform name=&quot;ios&quot;&gt; &lt;config-file parent=&quot;/*&quot; target=&quot;config.xml&quot;&gt; &lt;feature name=&quot;ThsToast&quot;&gt; &lt;param name=&quot;ios-package&quot; value=&quot;ThsToast&quot; /&gt; &lt;/feature&gt; &lt;/config-file&gt; &lt;source-file src=&quot;src/ios/ThsToast.m&quot; /&gt; &lt;/platform&gt;&lt;/plugin&gt; ThsToast 插件目录下的 www/xxx.js 修改 js api 对象和调用函数修改 exports 处理逻辑，增强可读性（可选) 暴露给 js 的 api 方法名通过 plugin.xml 配置www/xxx.js 中export 的 ThsToast在 plugin.xml 中是通过clobbers 的 target 值暴露给 js 调用的，如果 target 值改为 toast，通过 target.show 即可调用插件 api 1234&lt;js-module name=&quot;ThsToast&quot; src=&quot;www/ThsToast.js&quot;&gt; &lt;!-- 通过window.ThsToast.show或ThsToast.show即可调用api --&gt; &lt;clobbers target=&quot;ThsToast&quot; /&gt;&lt;/js-module&gt; exec 函数干了什么www/xxx.js 中的 exec 函数可以理解为 java 中暴露给 js 的回调方法，用于触发 java 的 excute 方法，该 js 函数传的’show’和[arg0]，success,error参数将会以action 和 args，callbackContext.success，callbackContext.error参数的形式传入 java 中的 excute 方法 1234@Override public boolean execute(String action, JSONArray args, CallbackContext callbackContext) throws JSONException { …… } l 在 ThsToast 插件根目录里写好 README，小盆友看了也会用1cordova-plugin-ths-toast$ touch README.md 一个简单模版 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889# cordova-plugin-ths-toast弹出提示框 cordova 插件## 支持平台Android## 安装插件|```# 通过 npm 安装插件cordova plugin add cordova-plugin-ths-toast# 通过 github 安装cordova plugin add https://github.com/THS-FE/cordova-plugin-ths-toast# 通过本地文件路径安装cordova plugin add 文件路径|```**说明： ionic 项目命令前加上 ionic，即 ionic cordova plugin xxxxx**参数说明：1. DEFAULT_DELAY 默认提示框延迟弹出的毫秒数## 配置文件修改在 config.xml 文件中 **platform name=&quot;android&quot;** 节点下添加以下配置|`xml &lt;preference name=&quot;DEFAULT_DELAY&quot; value=&quot;1000&quot;/&gt; |`## 使用方法显示提示框|```javascript/\\*\\*- 显示提示框- @param text 显示文字- @param success 成功的回调函数 \\*/ showToast(text, success) { try { ThsToast.show(text, success, err =&gt; { console.log('err', err); this.commUtilProvider.showToast('显示提示框失败'); }) } catch (err) { console.log(err); } }; |```隐藏提示框|```javascript/\\*\\*- 隐藏提示框- @param success 成功的回调函数 \\*/ hideToast(success) { try { ThsToast.hide(success, err =&gt; { console.log('err', err); this.commUtilProvider.showToast('隐藏提示框失败'); }) } catch (err) { console.log(err); } }; |```**说明：使用 ts 进行开发时，需要在文件上变声明下 declare const ThsToast;**|`typescript import { Component, OnInit, Input } from '@angular/core'; declare const ThsToast; @Component({ selector: 'app-explore-container', templateUrl: './explore-container.component.html', styleUrls: ['./explore-container.component.scss'], }) |`## 常见错误后续更新|``` l 给 ThsToast 插件加上 package.json，准备发布到 npm进入 ThsToast 插件根目录下 第一种方式：npm init 1cordova-plugin-ths-toast$ npm init 第二种方式：plugman createpackagejson（推荐） 1cordova-plugin-ths-toast$ plugman createpackagejson ./ 上面的命令都将创建一个 package.json 文件，但第二种方式相对于 npm init 的优点是会生成”cordova”和”keywords”两个属性。 “cordova”用于说明插件支持的平台，”keywords”规定可以在 cordova 官网通过关键字搜索到该 cordova 插件，”engines”表示插件依赖的各平台版本号，详细内容请参考cordova 创建插件 123456789101112131415161718192021222324{ &quot;name&quot;: &quot;cordova-plugin-ths-toast&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;cordova&quot;: { &quot;id&quot;: &quot;cordova-plugin-ths-toast&quot;, &quot;platforms&quot;: [&quot;android&quot;, &quot;ios&quot;] }, &quot;keywords&quot;: [ &quot;ecosystem:cordova&quot;, &quot;cordova-android&quot;, &quot;cordova-ios&quot;, &quot;toast&quot;, &quot;cordova-plugin-ths-toast&quot; ], &quot;engines&quot;: { &quot;cordovaDependencies&quot;: { &quot;1.0.0&quot;: { &quot;cordova-android&quot;: &quot;&gt;4.0.0&quot; }, &quot;&gt;1.0.0&quot;: { &quot;cordova-android&quot;: &quot;&gt;5.0.0&quot; } } }, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;} 注意：**”name”属性表示插件在 npm 仓库中的唯一 id，”cordova”中的”id”必须和 name 保持一致，因为要通过此 id 才能找到具体哪个插件的平台支持**， 比如安装时就是通过 name 的值在 npm 仓库中查找对应插件并安装： 1cordova plugin add cordova-plugin-ths-toast 这里可以搜索 keywords 中的插件 l 发布插件到 git上传到公司仓库: https://github.com/THS-FE 注意github 地址一定要发布到公司 git 仓库，不然无法修改和维护源代码 l 发布插件到 npm每次发布记得更新版本号，不然无法发布 12cordova-plugin-ths-toast$ npm login // 没有账号则需要到官网申请，登录过一次后就不用登了cordova-plugin-ths-toast$ npm publish l 安装插件1cordova plugin add cordova-plugin-ths-toast l 使用插件js 环境 1ThsToast.show(); ts 环境 12declare const ThsToast;ThsToast.show(); l 插件效果演示","link":"/2020/08/31/%E4%BB%8E%E9%9B%B6%E5%88%9B%E5%BB%BACordova%E6%8F%92%E4%BB%B6-%E5%85%A5%E9%97%A8/"},{"title":"JavaScript新特性","text":"1 前言我这里总结了一下 ES6+中，一些比较实用的新特性。我们日常开发应该尽快使用这些新特性，能极大地提高我们的开发效率。 我刚开始实习的时候，对 ES6 都不太怎么了解，工作后学习并渐渐运用起来，越用越爽，两个字：简洁方便高效。 提一句：只要用了 babel，所有的新特性请放心大胆地用。 2 你得尽快用上的“新特性” 为什么加引号，因为现在这些都不是多新的特性了，ES6 是 2015 年就出了，到现在已经 5 年了。 2.1 模板字符串模版字符串：用 `（反引号）标识，用 ${} 将变量括起来 old： 场景：通常我们在自定义一些 echarts 或者地图上添加东西时，我们常会拼接一些 html 代码 1var html = '&lt;div style=&quot;color: ' + color + ';&quot;&gt;' + str + &quot;&lt;div&gt;&quot;; 传统做法需要使用大量的“”（引号）和 + 来拼接才能得到我们需要的模版 new： 1let html = `&lt;div style=&quot;color: ${color} ;&quot;&gt; ${str} &lt;div&gt;`; ${} 里可以放任意的 JavaScript 表达式，也可以调用函数： 123456789const count = 8, price = 10;console.log(`加购一个后数量：${++count}, 总价：${count * price}`); // 加购一个后数量：9, 总价：90console.log(`输出个字符串：${&quot;cool&quot;}`); // 输出个字符串：coolfunction myLove() { return &quot;as you love!&quot;;}console.log(`I love ${myLove()}`); // I love as you love! 需要注意的几个问题： 当需要在字符串里使用反引号的时候，需要转义； 1console.log(`模版字符串：用 \\`（反引号）标识`); 如果${}中的变量不是字符串类型，那么会按照一般的规则转化为字符串； 12const obj = { a: 1, b: 2 };console.log(`a = ${obj}`); // a = [object Object] 模板字符串会保留所有的空格、缩进和换行； 12345let str = `I know , you know!`;console.log(str);// I know// , you know! 解决方案：使用\\解决换行符；使用+换行拼接；使用正则替换；使用变量替换； 1234567891011121314let str = `I know \\ , you know!`;console.log(str); // I know , you know!str = `I know ` + `, you know!`;console.log(str); // I know , you know!str = `I know , you know!`.replace(/\\s+/gm, &quot; &quot;);console.log(str); // I know , you know!const N = &quot;&quot;;str = `I know${N}, you know${N}, all we know!`;console.log(str); // I know, you know, all we know! 扩展了解： 实现原理（未验证）：通过正则匹配，替换原字符串中的变量。包括常见的{{}}, &lt;%=xx%&gt;等 12345function replace(str) { return str.replace(/\\$\\{([^}])\\}/g, function (matched, key) { return eval(key); });} 2.2 属性简写old： 一个属性名对应一个值 123456const pageNum = 0, pageSize = 10;const params = { pageNum: pageNum, pageSize: pageSize,}; new： 属性名和变量名保持一致，变量名尽量迎合属性名； 123456789101112const pageNum = 0, pageSize = 10, password = &quot;123123&quot;;const params = { pageNum, pageSize, password: encrypt(password), // 属性简写和键值对可以混写};// const params = {// pageNum: pageNum,// pageSize: pageSize// } question： 如果我们的需要的值不是一个单独变量，而是从某个对象取出属性 123456const pageNum = 0, pageSize = 10, user = {uid: 100000, password: '123123'};const params = { pageNum, pageSize, user.password ????} 答案：见 4.答案 2.3 方法属性old： 一个属性名对应一个值 1234567891011let math = { add: function (a, b) { return a + b; }, sub: function (a, b) { return a - b; }, multiply: function (a, b) { return a * b; },}; new： 自动识别方法名称作为属性名 1234567891011let math = { add(a, b) { return a + b; }, sub(a, b) { return a - b; }, multiply(a, b) { return a * b; },}; 取函数名为属性名称 微信小程序 page 结构： 1234567891011Page({ data: { isShowloading: true, }, onLoad(options) {}, onReady() {}, handleTap(event) {},});// 给page传入一个对象，这个对象的所有函数都可以进行属性名简写 question: 下面两个表达式都正确吗？ 1234567let obj1 = { fn1(){}.bind()}let obj2 = { fn2: function(){}.bind()} 2.4 箭头函数箭头函数表达方式：=&gt;，因为像个箭头，所以叫箭头函数。 old： 123var f = function (v) { return v;}; new： 1234567// 写法let f = (v) =&gt; v;// 完整写法let f = (v) =&gt; { return v;}; 如上，当函数只有一个形参时，=&gt;左侧可以省略()； 当函数返回值可以用一句简单表达式表示时，=&gt;右侧可以省略{}和return； 1234567let f = () =&gt; 5; // ()不可省略let sum = (num1, num2) =&gt; num1 + num2;//var sun = function(num1, num2){return num1 + num2;};this.httpUtil.get(&quot;xxxxxx.vm&quot;, params, true, (res) =&gt; { console.log(res);}); question: 以下会输出什么？ 12let getTempItem = () =&gt; { id: 's8309a82n', name: &quot;Temp&quot; };getTempItem(); 2.5 “你懂的”运算符Spread operator，这个中文名称有好几种说法（扩展运算符、延展操作符、展开运算符等等），而我给它起的名字就叫你懂的运算符。它表示方法前面见过了...，作用是可以将数组、字符串、对象等在语法层面上展开。 秘诀：给我“解压”到这里 “解压”数组 1234567const rgb = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];const colors = [...rgb]; // 巴啦啦魔仙变，给我把rgb解压到这个数组里// 结果： ['red', 'green', 'blue']const colorList = [&quot;yellow&quot;, ...rgb]; // ['yellow', 'red', 'green', 'blue']console.log([...colors, ...colorList]); // ???? “解压”对象 123456789let you = { name: &quot;DJ&quot;, age: 16,};you = { ...you, school: &quot;DLPU&quot;,};// {name: &quot;DJ&quot;, age: 16, school: &quot;DLPU&quot;} “解压”字符串 1234567let myCountry = 'China';console.log([...myCountry]); // [&quot;C&quot;, &quot;h&quot;, &quot;i&quot;, &quot;n&quot;, &quot;a&quot;]// 等同于：console.log(myCountry.split(''))cosnt resStr = {...myCountry};console.log(resStr); // {0: &quot;C&quot;, 1: &quot;h&quot;, 2: &quot;i&quot;, 3: &quot;n&quot;, 4: &quot;a&quot;}// 问题：怎么取值呢？ resStr[0] question: 以下分别会输出什么？ 123456789let obj = {a: 1, b: 2};console.log({a: 0, ...obj});????let arr = [2,3,4];console.log({...arr})????console.log([...obj]);???? 扩展了解：见下一章 2.6 解构赋值old: 获取对象中的值 123456789// res = {status: 200, data: {uid: 'ed9fa0', name: 'DJ', time: '1596808152'}}this.thsService.getLog().then((res) =&gt; { const status = res.status; const data = res.data; const name = res.data.name; const time = res.data.time; console.log(status, data, name, time);}); new: 123456789101112this.thsService.getLog().then(res=&gt;{ const { status, data } = res; const { status, data, data: { name, time } } = res; // console.log(status, data, name, time);})// 还可以这样写this.thsService.getLog().then({ status, data }=&gt;{ console.log(status, data);}) 数组： 123let arr = [1, 2, 3, 4];let [a, b, c] = arr; // a=1, b=2, c=3let [a, b, , d] = arr; // a=1, b=2, d=4 默认值： 12const { status = 500, data = null } = res;let [a = 0, b = 0, c = 0, d = 0, e = 0] = arr; 扩展了解： 剩余运算符（ES2018） 秘诀：“剩下的”都是我的 “剩下的”属性 1234let obj = { a: 1, b: 2, c: (_) =&gt; _ };let { b, ...rest } = obj; // rest说：b属性你拿走吧，剩下的全是我的b; // 2rest; // {a: 1, c: ƒ} “剩下的”参数 123456let restParam = (p1, p2, ...p3) =&gt; { // p3说：前两个参数你们拿走，剩下的都是我的了 console.log(p1, p2, p3);};restParam(1, 2, 3, 4, 5); // p1 = 1, p2 = 2, p3 = [3, 4, 5] 2.7 数组新方法 find(): any：返回找到满足条件的第一项，否则返回 undefined findIndex(): number：找到满足条件的一项的索引 includes(): boolean：是否包含一个值 在 ES6 之前，要判断一个数组中是否包含一个元素，是通过indexOf()返回不等于-1 ES6 之后，相继扩充一些方法： find( fn(item, [index], [arr]) ): 1234let arr = [{ id: 1, checked: true }, { id: 2 }, { id: 2 }, 3, 4, NaN];arr.find((item) =&gt; item.id === 1); // { id: 1, checked: true }arr.find((item) =&gt; Object.is(NaN, item)); // NaN find 会将每一个元素挨个去运行回调函数，找到了第一项之后就不会再执行了； findIndex( fn(item, [index], [arr]) ): 12arr.findIndex((item) =&gt; item.id === 1); // 0arr.findIndex((item) =&gt; Object.is(NaN, item)); // 5 includes(value, fromIdx): 123456789arr.includes(3); // truearr.includes(NaN); // truearr.includes({ id: 2 }); // falselet a1 = { id: 2 }, a2 = { id: 2 };a1 == a2; // falselet a = [a1, a2]; // [{id: 2}, {id: 2}]a.includes(a2); // true 字符串同样存在includes方法：'Made in China'.includes('o'), false some( fn(item, [index], [arr]) )：是否存在满足条件的一项，和 includes 是同样的作用。 区别（优缺点）：some传入的是回调函数，具有更强大的可操性；includes传入参数是具体的值，书写简便。 question: find()只能取出满足条件的一项，那如何取出数组中满足条件的所有项呢？ 12let arr = [{ id: 1, checked: true }, { id: 2 }, { id: 2 }, 3, 4, NaN];// ???? 扩展：数组所有方法参考手册 2.8 Promise、async/await 回调地狱：“无限”（大量）地使用嵌套回调函数，好像掉进了 18 层地狱 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 一个动画的回调地狱例子animate(ball1, 100, function () { animate(ball2, 200, function () { animate(ball3, 300, function () { animate(ball1, 200, function () { animate(ball3, 200, function () { animate(ball2, 180, function () { animate(ball2, 220, function () { animate(ball2, 200, function () { console.log(&quot;over&quot;); }) }) }) }) }) }) })});// promise优化后promiseAnimate(ball1, 500) .then(function () { return promiseAnimate(ball2, 200); }) .then(function () { return promiseAnimate(ball3, 300); }) .then(function () { return promiseAnimate(ball1, 200); }) .then(function () { return promiseAnimate(ball3, 200); }) .then(function () { return promiseAnimate(ball2, 180); }) .then(function () { return promiseAnimate(ball2, 220); }) .then(function () { return promiseAnimate(ball2, 200); })// async/await优化后async play() { await animate(ball1, 500); await animate(ball2, 200); await animate(ball3, 300); await animate(ball1, 200); await animate(ball4, 200); await animate(ball2, 180); await animate(ball2, 220); await animate(ball2, 200);} Promise: 基本用法： 12345678910111213141516171819202122232425262728293031function getUserData() { return new Promise((resolved, rejected) =&gt; { $.ajax({ type : &quot;get&quot;, url : &quot;api.com&quot;, success : res =&gt; { if(res.isSuccess) { resolved(res.data); }else { rejected({msg: '服务器错误', info: res.errmsg}); } }, error: err =&gt; { rejected({msg: '网络错误', info: err}); } }); })}getUserData().then(data =&gt; { console.log('success:', data);}).catch(err =&gt; { console.log(err.msg, err.info);})// 此外介绍一个方法，并行跑promise es2020有个新方法Promise.allSettledPromise.all([promise1, promise2, ...]).then(res =&gt; { console.log(res); // 由promise1,promise2正确执行结果组成的数组}).catch(err =&gt; { console.log(err);}) async/await： 是对 Promise 的优化，为 Promise 服务。一句话：用同步的风格写异步代码。 基础用法：https://patrick.js.org/post/1589841597 需要注意： async/await 就是一对“海尔兄弟”，缺一不可。async声明一个函数（函数返回会处理成一个 Promise），函数里面必须要有await，await 标识一个需要等一会（异步）的操作。函数内部使用了 await，那么该函数就必须用 async 声明。 await、return 和 return await 的陷阱：https://jakearchibald.com/2017/await-vs-return-vs-return-await/ 2.9 Modules模块化是 ES6 比较重要的特性，在此之前 JS 是不支持原生的模块化的，需要通过第三方库实现如 RequireJS。 了解更多模块化：JavaScript 模块化 模块化由export 和 import 组成，ES6 视一个文件为一个模块，文件内通过 export 对外暴露接口，其他文件通过 import 引入使用。 export：可导出变量、常量和函数 12345678910111213141516171819// utils/test.js// 单个导出export let name = 'Patrick Jun';export const pi = Math.PI;export function whoIAm() { console.log(&quot;I'm a FE coder!&quot;);}// 等同于（会将export作为一个对象导出）let name = 'Patrick Jun';const pi = Math.PI;const whoIAm = () =&gt; console.log(&quot;I'm a FE coder!&quot;);export { name, pi, whoIAm };// this is an object, so.export { name: name, PI: pi, iAm: whoIAm }; import：导入 123456// home.jsimport { name, pi, whoIAm } from &quot;./utils/test.js&quot;;console.log(name, pi);whoIAm();// Patrick Jun 3.141592653589793 main.js:2// I'm a FE coder! test.js:11 node 无法直接运行 module：https://nodejs.org/dist/latest-v10.x/docs/api/esm.html default：只能有一个 123456789101112// math.jsexport function add(a, b) { return a + b;}export function sub(a, b) { return a - b;}export default (a, b) =&gt; a * b;// main.jsimport mult, { add, sub } from &quot;./math&quot;; 3 你可以尝试的新特性3.1 对象新方法 Object.values(obj): 返回由对象中属性值组成的数组； Object.entries(obj): 返回对象的每个属性名和所对应的值组成的数组：[[key, value],[key, value]] 之前通过Object.keys()，可以获取到对象的所有的 key，而要获得所对应的值的时候： 123456let obj = { id: 1, value: &quot;123&quot;, data: { code: &quot;EC109&quot; } };Object.keys(obj); // [&quot;id&quot;, &quot;value&quot;, &quot;data&quot;]Object.keys(obj).forEach((key) =&gt; { console.log(obj[key]); // [1, &quot;123&quot;, {code: 'EC109'}]}); Object.values()：无需先获取键名，直接可以拿到所有值 1Object.values(obj); // [1, &quot;123&quot;, {code: 'EC109'}] Object.entries(): 123456Object.entries(obj).forEach(([key, value]) =&gt; { console.log(key + &quot;: &quot; + value);});// id: 1// value: 123// data: [object Object] 3.2 **指数操作符：类似数学的书写方式进行指数计算，可以看做是Math.pow()的简写 1let a = 7 ** 3; // a = 343，等同于 a = Math.pow(7, 3) 3.3 ??当我们查询某个属性时，经常会给没有该属性就设置一个默认的值，比如下面两种方式： 12let c = a ? a : b; // 方式1let c = a || b; // 方式2 这两种方式有个明显的弊端，它都会覆盖所有的假值，如(0, ‘’, false)，这些值可能是在某些情况下有效的输入。 空位合并操作符，用 ?? 表示。如果表达式在??的左侧运算符求值为 undefined 或 null，就返回其右侧默认值。 12let c = a ?? b;// 等价于let c = a !== undefined &amp;&amp; a !== null ? a : b; 3.4 padStart/padEnd用于在字符串开头或结尾添加填充字符串（ES2017） padStart(maxLength, [fillString])：从前面补充字符 padEnd(maxLength, [fillString])：从后面补充字符 1234567891011&quot;es8&quot;.padStart(2); // 'es8'&quot;es8&quot;.padStart(5); // ' es8'&quot;es8&quot;.padStart(6, &quot;woof&quot;); // 'wooes8'&quot;es8&quot;.padStart(14, &quot;wow&quot;); // 'wowwowwowwoes8'&quot;es8&quot;.padStart(7, &quot;0&quot;); // '0000es8'&quot;es8&quot;.padEnd(2); // 'es8'&quot;es8&quot;.padEnd(5); // 'es8 '&quot;es8&quot;.padEnd(6, &quot;woof&quot;); // 'es8woo'&quot;es8&quot;.padEnd(14, &quot;wow&quot;); // 'es8wowwowwowwo'&quot;es8&quot;.padEnd(7, &quot;6&quot;); // 'es86666' 应用场景： 1234567891011121314151617181920212223242526272829303132// 1.日期格式化const dt = new Date();console.log( `${dt.getFullYear()+''}-` +`${(dt.getMonth()+1+'').padStart(2, '0')}-` +`${(dt.getDate()+'').padStart(2, '0')}`);// 2020-08-07// 2.时间戳补位let timestamp = '1596808152';timestamp = +String(timestamp).padEnd(13, '0');// 1596808152000// 3.地区编码补位 省级编码2位，市级4位，区县6位，乡镇9位，村级12位。现在需要统一补充成12位/** * 格式化地区编码，按指定长度输出 * @param regionCode 地区编码 * @param length 需要的长度 */formateRegionCode(regionCode: string|number, length: number = 12): string { regionCode = String(regionCode); if(!regionCode || regionCode.length &lt; 2) { throw new Error('地区编码错误'); } if(length &lt; 2) { throw new Error('地区编码长度不能小于2'); } const tempCode = regionCode.split('').slice(0, length).join(''); return tempCode.length &lt; length ? tempCode.padEnd(length, '0') : tempCode;} 4 答案2.2 question: 1234567891011121314151617const pageNum = 0, pageSize = 10, user = { uid: 100000, password: &quot;123123&quot; };let params = { pageNum, pageSize, password: user.password, // 需给定属性名，user.password是无法将其识别成属性名};// 还可以这样let params = { pageNum, pageSize, ...user, // 2.5小节讲解};// {pageNum: 0, pageSize: 10, uid: 100000, password: &quot;123123&quot;}// 通过扩展符，可能会多出其他属性，如果多出来的属性对结果不影响，可以考虑这样做 2.3 question: obj1 错误，obj2 正确。简写方法的属性名总是变量本身作为字符串使用，bind 函数本身返回一个函数，从解析器角度来说，这个返回的函数叫什么名字并没有办法确定，而第二种写法，是确定好了fn2 2.4 question: 123Uncaught SyntaxError: Unexpected token ':'let getTempItem = id =&gt; ({ id, name: &quot;Temp&quot; }); 2.5 question: 123456{a: 1, b: 2}{0: 2, 1: 3, 2: 4} // result.0 ????VM37:1 Uncaught TypeError: obj is not iterable at &lt;anonymous&gt;:1:17 2.7 question: 1arr.filter((item) =&gt; item.id === 2); // [{id: 2}, {id: 2}] 5 参考资料 Modern JavaScript, 10 things you should be using, starting today - DEV 盘点 ES7、ES8、ES9、ES10 新特性 ES6，ES7，ES8，ES9，ES10 新特性一览 ES2020 新特性 种草 ES2020 新特性 异步 Promise 及 Async/Await 可能最完整入门攻略 刘哥金句：给别人讲述知识时可以发现自己掌握的是否牢固透彻，写的过程不断发现自己的不足，然后通过一些方式来解决问题，这也是一种学习过程；当然，给别人分享，也要从学习者的角度出发，考虑他们想要从你的分享中获得什么，还有就是你想表达些什么给他们。","link":"/2020/08/24/JavaScript%E6%96%B0%E7%89%B9%E6%80%A7/"},{"title":"Vue3.js模板项目创建","text":"基础环境 Vue CLI 版本为 v5.0.0-alpha.2 Node.js 版本为 v15.3.0 （官方建议是 10 以上版本，最低为 8.9） yarn 版本为 1.22.10 （推荐使用，用 NPM 也可以） 通过以下命令行查询对应版本号： 12345vue --version // @vue/cli 5.0.0-alpha.2node --v // v15.3.0yarn -v // 1.22.10 如发现版本不满足要求，可以分别通过： 运行以下命令行，更新 Vue CLI 至最新版本 1npm i -g @vue/cli@v5.0.0-alpha.2 前往 Node.js 下载最新版本的程序，并安装。 运行以下命令行，更新 yarn 至最新版本 1npm i -g yarn 项目创建Vue 默认会通过以前选择过的包管理工具 yarn 或 NPM 来安装依赖。想全局修改的话，可在命令行中运行: 1vue config --set packageManager yarn // 或 npm 推荐 yarn 也可在创建项目时动态指定当前项目的包管理工具： 1vue create vue3-starter -m yarn 勾选以下几项(单击图片可看大图): 依次选择如下内容： 最后会问是否要保存当前这个配置，按自己的意愿选择和命名。 成功后，运行如下命令行： 12cd vue3-starteryarn serve 在浏览器中打开 http://localhost:8080/ 看到页面就算完成了。 项目改造默认结构1234567891011121314151617181920212223242526├── public // 静态资源 该文件夹下的内容在构建时会直接拷贝到dist文件夹下│ ├── favicon.ico // 网站图标│ └── index.html // HTML模板页├── src // 主要工作目录│ ├── assets // 静态资源 会被webpack打包处理│ │ └── logo.png│ ├── components // 组件(dumb components，获取props，派发事件)│ │ └── HelloWorld.vue // 示例组件│ ├── router // 路由（统一使用懒加载）│ │ └── index.ts // 组装各路由并导出│ ├── store // 状态管理（可选）│ │ └── index.ts│ ├── views // 页面(smart components，可以访问store，路由，window)│ │ ├── About.vue // 关于│ │ └── Home.vue // 首页│ ├── App.vue // 根组件│ ├── main.ts // 入口文件（引入全局的样式和脚本，可安装插件、注册组件或指令等）│ └── shims-vue.d.ts // 帮助IDE识别 .vue文件├── .browserslistrc // 目标浏览器配置├── .editorconfig // 代码风格规范├── .eslintrc.js // eslint配置├── .gitignore // git提交忽略文件├── babel.config.js // babel配置├── package.json // 项目依赖、脚本├── README.md // 项目命令行说明└── tsconfig.json // TypeScript配置文件 内容改造安装依赖axiosaxios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。 1yarn add axios Normalize.cssNormalize.css 它使不同浏览器能更一致地呈现所有元素，并符合现代标准。 1yarn add normalize.css Element PlusElement Plus，是为一套基于 Vue 3.0 的桌面端组件库。 12yarn add element-plusyarn add babel-plugin-component -D // 为了按需打包 修改文件按照名称顺序，由上到下，由外到内。 修改 .editorconfig 中最后一行（现在屏幕都比较宽，100 个字符确实满足不了需求） 1max_line_length = 100; // 改为 max_line_length = 160 修改 .eslintrc.js 中的 rules （打包时配置 将 console 和 debug 全部删除，不需要做这个提示） 123456'no-console': process.env.NODE_ENV === 'production' ? 'warn' : 'off', // 修改为 'no-console': 'off','no-debugger': process.env.NODE_ENV === 'production' ? 'warn' : 'off', // 修改为 'no-debugger': 'off','import/prefer-default-export': 'off', // Composition Function 不一定需要默认导出'max-len': ['error', { code: 160 }], // 单行最大160个字符'multiline-comment-style': ['error', 'starred-block'], // 格式化注释 修改 babel.config.js 123456789101112module.exports = { presets: [&quot;@vue/cli-plugin-babel/preset&quot;], plugins: [ [ &quot;component&quot;, { libraryName: &quot;element-plus&quot;, // Element Plus 按需打包 styleLibraryName: &quot;theme-chalk&quot;, }, ], ],}; 添加 vue.config.js（定义自身的 WebPack 参数） 1234567891011121314151617181920212223242526272829/** * 判断是否是生产环境 * @returns {boolean} 是否是生产环境 */function isProd() { return process.env.NODE_ENV === &quot;production&quot;;}// 配置请求的基本API,当前开发模式配置的是淘宝的测试地址process.env.VUE_APP_BASE_API = isProd() ? &quot;&quot; : &quot;http://rap2api.taobao.org/app/mock/115307/user&quot;;module.exports = { publicPath: isProd() ? &quot;./&quot; : &quot;/&quot;, // 部署到生产环境时，按需修改前项为项目名称 productionSourceMap: false, // 不需要生产环境的 source map，减少构建时间 configureWebpack: (config) =&gt; { if (isProd()) { // 去除 console Object.assign( config.optimization.minimizer[0].options.terserOptions.compress, { drop_console: true, } ); } },}; 替换 public 下的 favicon.ico 为自己的网站图标 修改 public 下的 index.html 中的语言（设置为中文后，浏览器不会出现翻译提示） 1234&lt;html lang=&quot;&quot;&gt; // 改为 &lt;html lang=&quot;zh&quot;&gt;&lt;/html&gt;&lt;/html&gt; 在 src 下添加 hooks（所有钩子函数存放在此），services（请求后台接口的模块存放在此），utils（常用功能） 修改 src 下的 App.vue 为 app.vue (所有文件的命名统一使用 kebab-case 命名法)，删除大部分内容只保留 123&lt;template&gt; &lt;router-view /&gt;&lt;/template&gt; 修改 src 下的 main.ts 123456789101112import { createApp } from &quot;vue&quot;;import &quot;normalize.css&quot;; // CSS reset的替代方案import &quot;@/assets/styles/style.scss&quot;; // 引入全局样式import App from &quot;./app.vue&quot;;import router from &quot;./router&quot;;import store from &quot;./store&quot;;const app = createApp(App);app.use(store); // 按需使用状态管理app.use(router).mount(&quot;#app&quot;); 删除 src/assets 下 logo.png 文件，添加 fonts（字体）、icons（小图标）、images（大图片）、styles（CSS 样式）文件夹 在 src/assets/images 下 添加 common.scss（各项目通用样式） 和 style.css（当前应用全局样式） 12345678910111213141516171819202122232425262728293031// common.css/** ************************** 通用样式 ****************************** */html,body { height: 100%;}/** ****************** 修改type=number的样式 ****************** */input::-webkit-outer-spin-button,input::-webkit-inner-spin-button { -webkit-appearance: none;}input[type=&quot;number&quot;] { -moz-appearance: textfield;}/** ******************************************************** *//* 修改谷歌浏览器记住密码后input默认样式 */input:-webkit-autofill,textarea:-webkit-autofill,select:-webkit-autofill { -webkit-text-fill-color: #ededed !important; box-shadow: 0 0 0px 1000px transparent inset !important; background-color: transparent; background-image: none; transition: background-color 50000s ease-in-out 0s;}/** ******************************************************** */ 123// style.scss@import &quot;./common.scss&quot;; 删除 components 文件夹下 HelloWorld.vue 文件，添加 hooks.vue（添加一个使用 hooks 的例子） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;template&gt;&lt;div&gt; &lt;div class='title'&gt;{{myTitle}}&lt;/div&gt; &lt;button @click=&quot;handleCLick&quot;&gt;防抖测试&lt;/button&gt; &lt;div class='scroll-box' @scroll=&quot;handleScroll(throttleRef)&quot;&gt; {{throttleRef}}测试 &lt;div style=&quot;height: 200px&quot;&gt;&lt;/div&gt; &lt;div style=&quot;height: 200px&quot;&gt;&lt;/div&gt; &lt;div style=&quot;height: 200px&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import { ref, defineComponent } from 'vue';import { useDebounce } from '@/hooks/common/use-debounce';import { useThrottle } from '@/hooks/common/use-throttle';/** * hooks使用示例组件 */export default defineComponent({ name: 'Hooks', props: { title: String, }, setup(props) { const throttleRef = ref('节流'); const handleCLick = useDebounce((() =&gt; { console.log('防抖测试'); }), 500); const handleScroll = useThrottle(((message) =&gt; { console.log(`${message}测试`); }), 500); return { myTitle: props.title, throttleRef, handleCLick, handleScroll, }; },});&lt;/script&gt;&lt;style lang=&quot;scss&quot;&gt;.title{ text-align: center;}button{ margin-bottom: 8px;}.scroll-box{ height:300px; width:500px; background-color:rgb(209, 204, 204); overflow-y:scroll;}&lt;/style&gt; 在 src/hooks 下添加 common（各项目通用 hook 函数） 文件夹，添加 use-debounce.ts（防抖），use-throttle.ts（节流），use-router.ts（路由）三个常用 hook 1234567891011121314151617181920212223242526272829// use-debounce.ts/** * 防抖 在事件被触发一定时间后再执行回调，如果在这段事件内又被触发，则重新计时 * 使用场景： * 1、搜索框中，用户在不断输入值时，用防抖来节约请求资源 * 2、点击按钮时，用户误点击多次，用防抖来让其只触发一次 * 3、window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次 * @param fn 回调 * @param duration 时间间隔的阈值(单位：ms) 默认1000ms */export function useDebounce&lt;F extends (...args: unknown[]) =&gt; unknown&gt;( fn: F, duration = 1000): () =&gt; void { let timeoutId: ReturnType&lt;typeof setTimeout&gt; | undefined; const debounce = (...args: Parameters&lt;F&gt;) =&gt; { if (timeoutId) { clearTimeout(timeoutId); } timeoutId = setTimeout(() =&gt; { fn(...args); timeoutId = undefined; }, duration); }; return debounce;} 12345678910111213141516171819202122232425262728// use-throttle.ts/** * 节流 规定在一段时间内，只能触发一次函数。如果这段时间内触发多次函数，只有一次生效 * 使用场景： * 1、鼠标不断点击触发，mousedown(单位时间内只触发一次) * 2、监听滚动事件，比如是否滑到底部自动加载更多 * @param fn 回调 * @param duration 时间间隔的阈值(单位：ms) 默认500ms */export function useThrottle&lt;F extends (...args: unknown[]) =&gt; unknown&gt;( fn: F, duration = 1000): () =&gt; void { let timeoutId: ReturnType&lt;typeof setTimeout&gt; | undefined; const throttle = (...args: Parameters&lt;F&gt;) =&gt; { if (timeoutId) { return; } timeoutId = setTimeout(() =&gt; { fn(...args); timeoutId = undefined; }, duration); }; return throttle;} 123456789101112131415161718192021// use-router.tsimport { reactive, toRefs, watch, getCurrentInstance, Ref } from &quot;vue&quot;;import { Router } from &quot;vue-router&quot;;/** * 获取路由 * @returns 当前路由以及Router实例 */export function useRouter(): { route: Ref; router: Router } { const vm = getCurrentInstance(); const state = reactive({ route: vm?.proxy?.$route }); watch( () =&gt; vm?.proxy?.$route, (newValue) =&gt; { state.route = newValue; } ); return { ...toRefs(state), router: vm?.proxy?.$router as Router };} 在 src/router 下添加 home.ts 作为一个示例模块的路由 1234567891011import { RouteRecordRaw } from &quot;vue-router&quot;;const homeRoutes: Array&lt;RouteRecordRaw&gt; = [ { path: &quot;/home&quot;, name: &quot;home&quot;, component: () =&gt; import(&quot;@/views/home.vue&quot;), },];export default homeRoutes; 修改 src/router 下的 index.ts（让它能够自动加载 router 文件夹下的其它路由模块，以后只需要在 router 下添加像 home 一样的路由模块即可） 123456789101112131415161718192021222324252627282930313233import { createRouter, createWebHashHistory, RouteRecordRaw } from &quot;vue-router&quot;;import Login from &quot;../views/login.vue&quot;;// 首次必然要加载的路由const constRoutes: Array&lt;RouteRecordRaw&gt; = [ { path: &quot;/&quot;, name: &quot;Login&quot;, component: Login, },];// 所有路由let routes: Array&lt;RouteRecordRaw&gt; = [];// 自动添加router目录下的所有ts路由模块const files = require.context(&quot;./&quot;, false, /\\.ts$/);files.keys().forEach((route) =&gt; { // 如果是根目录的 index.js、 不做任何处理 if (route.startsWith(&quot;./index&quot;)) { return; } const routerModule = files(route); // 兼容 import export 和 require module.export 两种规范 ES modules commonjs routes = [...constRoutes, ...(routerModule.default || routerModule)];});const router = createRouter({ history: createWebHashHistory(), routes,});export default router; 在 src/services 下添加 user.ts（和后台接口交互的用户模块示例） 123456789101112131415161718192021222324import http from &quot;@/utils/http&quot;;import { AxiosResponse } from &quot;axios&quot;;// 使用接口定义登录接口返回的数据格式·export interface ILogin { accessToken: string; message: string;}// 添加API地址const API = { login: &quot;/login&quot;,};/** * 登录 * @param userInfo 用户信息 * @returns 验证结果 */export function login( userInfo: Record&lt;string, unknown&gt;): Promise&lt;AxiosResponse&lt;ILogin&gt;&gt; { return http.get&lt;ILogin&gt;(API.login, { data: userInfo });} 在 src/store 下添加 modules 文件夹，并在其中添加 user.ts（作为测试） 123456789101112131415161718192021222324252627282930313233343536import { ILogin, login } from &quot;@/services/user&quot;;// 用常量替代 mutation 事件类型，当前模块所有mutation一目了然const SET_ACCESSTOKEN = &quot;SET_ACCESSTOKEN&quot;;// stateconst userState = { accessToken: &quot;&quot;,};// getters// actionsconst actions = { async login( { commit }: { commit: (mutation: string, arg: string) =&gt; void }, userInfo: Record&lt;string, unknown&gt; ): Promise&lt;ILogin&gt; { const { data } = await login(userInfo); commit(SET_ACCESSTOKEN, data.accessToken); return data; },};// mutationsconst mutations = { [SET_ACCESSTOKEN](state: { accessToken: string }, accessToken: string): void { state.accessToken = accessToken; },};export default { state: userState, actions, mutations,}; 修改 src/store 下 index.ts（让其动态引入 modules 下的文件作为模块） 12345678910111213141516171819202122import { createStore } from &quot;vuex&quot;;interface IModule { [key: string]: { namespaced: boolean };}// 自动添加mudules下的所有ts模块const modules: IModule = {};const files = require.context(&quot;./modules&quot;, false, /\\.ts$/);files.keys().forEach((key) =&gt; { const moduleKey = key.replace(/(\\.\\/|\\.ts)/g, &quot;&quot;); modules[moduleKey] = files(key).default; modules[moduleKey].namespaced = true; // 让 mutations、getters、actions 也按照模块划分});// 无需使用模块或者是一些通用的状态写在下方export default createStore({ state: {}, mutations: {}, actions: {}, modules,}); 在 src/utils 下添加 http 文件夹，并在其中添加 index.ts 文件（封装 axios） 123456789101112131415161718192021222324252627282930313233343536import axios from &quot;axios&quot;;const http = axios.create({ baseURL: process.env.VUE_APP_BASE_API, // url = base url + request url // withCredentials: true, // 如跨域请求时要带上cookie,则设置为true timeout: 1000 * 5, // 请求超时时长 5秒});http.interceptors.request.use( (config) =&gt; { if (config.method === &quot;post&quot;) { // 按需添加内容 } return config; }, (error) =&gt; { console.log(error); return Promise.reject(error); });http.interceptors.response.use( (response) =&gt; { // 如果返回的状态不是200 就报错 按需修改 if (response.status &amp;&amp; response.status !== 200) { return Promise.reject(new Error(&quot;错误&quot;)); } return response; }, (error) =&gt; { console.log(error); return Promise.reject(error); });export default http; 删除 src/views 下的 About.vue 和 Home.vue，新建 login.vue 和 home.vue 123456789101112131415161718192021222324252627282930313233// login.vue&lt;template&gt; &lt;div&gt; &lt;el-button @click=&quot;handleLogin&quot;&gt;登录&lt;/el-button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import { defineComponent } from 'vue';import { ElButton } from 'element-plus';import { useRouter } from '@/hooks/common/use-router';import { useStore } from 'vuex';export default defineComponent({ name: 'Login', components: { ElButton }, setup() { const store = useStore(); const { router } = useRouter(); const handleLogin = async () =&gt; { const data = await store.dispatch('user/login', { userName: 'zqc', password: '18' }); // 派发事件，调用actions if (data.accessToken) { router.push('home'); } }; return { handleLogin, }; },});&lt;/script&gt; 改造后的结构1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768├── public // 静态资源 该文件夹下的内容在构建时会直接拷贝到dist文件夹下│ ├── favicon.ico // 网站图标│ ├── index.html // HTML模板页│ └── ...├── src // 主要工作目录│ ├── assets // 静态资源 会被webpack打包处理│ │ ├── fonts // 字体文件（可选）│ │ │ └── ...│ │ ├── icons // 图标（可选）│ │ │ └── ...│ │ ├── images // 图片（可选）│ │ │ ├── exception // exception（通用异常页面）模块使用到的图片│ │ │ │ └── ...│ │ │ ├── module-a // 此处要用模块命名（可选）│ │ │ │ └── ... // 该模块下使用到的图片│ │ │ └── ... // 通用的图片（小项目就不用分文件夹了）│ │ └── styles // 样式│ │ ├── common.scss // 常用样式（提供通用的）│ │ ├── style.scss // 全局样式，组装各样式并导出最终被 main.js 引入│ │ └── ...│ ├── components // 组件(dumb components，获取props，派发事件)│ │ ├── common // 不同项目中的通用组件（可选）│ │ │ └── ...│ │ ├── module-a // 此处要用模块命名（可选）│ │ │ └── ... // 该模块下的组件│ │ └── ... // 当前项目中的通用组件│ ├── hooks // 钩子│ │ ├── common // 不同项目中的通用hooks│ │ │ ├── use-debounce.ts // 防抖hook│ │ │ ├── use-router.ts // 路由hook│ │ │ ├── use-throttle.ts // 节流hook│ │ │ └── ...│ │ └── ... // 本项目中通用的hooks│ ├── layouts // 布局（可选）│ │ └── ...│ ├── plugins // vue插件（如：Element,vuetify,antd）（可选）│ │ ├── index.ts // 组装各插件并导出│ │ └── ...│ ├── router // 路由（除必然要加载的以外，统一使用懒加载）│ │ ├── index.ts // 组装各路由并导出│ │ └── ...│ ├── services // 接口请求│ │ ├── module-a .ts // 各业务模块所有包含的请求和数据处理，此处要用模块命名│ │ └── ...│ ├── store // 状态管理（可选）│ │ ├── modules // 各模块│ │ │ └── ... // 尽量和views中的模块对应上│ │ ├── index.ts // 组装模块并导出│ ├── utils // 工具类│ │ ├── http // aixos封装│ │ │ └── index.ts│ │ └── ...│ ├── views // 页面(smart components，可以访问store，路由，window)│ │ ├── module-a.vue // 用模块命名,如该模块下页面较多，可建以模块为名称的文件夹，在其中创建多个页面│ │ │ └── ...│ │ └── ...│ ├── app.vue // 根组件│ ├── main.ts // 入口文件（引入全局的样式和脚本，可安装插件、注册组件或指令等）│ └── shims-vue.d.ts // 帮助IDE识别 .vue文件├── .browserslistrc // 目标浏览器配置├── .editorconfig // 代码风格规范├── .eslintrc.js // eslint配置├── .gitignore // git提交忽略文件├── babel.config.js // babel配置├── package.json // 项目依赖、脚本├── README.md // 项目命令行说明├── tsconfig.json // TypeScript配置文件└── vue.config.js // 自定义webpack配置","link":"/2020/09/14/Vue3-js%E6%A8%A1%E6%9D%BF%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/"},{"title":"if-else逻辑判断优化","text":"前言为什么要优化if else逻辑判断呢？我们应该如何去优化它呢？优化它有什么意义呢？ 在分享之前我们先看一段代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// 贷款申请操作的处理function check() { // 是否输入正确用户名 if (this.checkUsername(this.username)) { // 是否输入正确身份证号 if (this.checkIdCard(this.idCard)) { // 请输入正确的电话号码 if (this.checkTel(this.tel)) { // 担保人是本人 if (this.dbr === &quot;担保人是本人&quot;) { // 是否存在身份证正面 if (document.querySelector(&quot;.sfzzm img&quot;)) { console.log(&quot;存在身份证正面&quot;); // 是否存在身份证反面 if (document.querySelector(&quot;.sfzfm img&quot;)) { console.log(&quot;存在身份证反面&quot;); // 是否存在学历证书 if (document.querySelector(&quot;.xlzs img&quot;)) { console.log(&quot;存在学历证书&quot;); if (this.ydxy) { this.tijiaoIsShow = false; } } else { Toast(&quot;请上传学历证书&quot;); this.tijiaoIsShow = true; } } else { Toast(&quot;请上传身份证反面&quot;); } } else { Toast(&quot;请上传身份证正面&quot;); } } else if (this.dbr == &quot;担保人不是本人&quot;) { if (this.checkUsername(this.dbrname)) { if (this.checkIdCard(this.dbridCard)) { if (this.checkTel(this.dbrzyzh)) { if (document.querySelector(&quot;.sfzzm img&quot;)) { console.log(&quot;存在身份证正面&quot;); if (document.querySelector(&quot;.sfzfm img&quot;)) { console.log(&quot;存在身份证反面&quot;); if (document.querySelector(&quot;.xlzs img&quot;)) { console.log(&quot;存在学历证书&quot;); this.tijiaoIsShow = false; } else { Toast(&quot;请上传学历证书&quot;); } } else { Toast(&quot;请上传身份证反面&quot;); } } else { Toast(&quot;请上传身份证正面&quot;); } } else { Toast(&quot;请输入担保人展业证号&quot;); } } else { Toast(&quot;请输入担保人身份证号&quot;); } } else { Toast(&quot;请输入担保人姓名&quot;); } } else { Toast(&quot;请选择担保人是否为本人&quot;); } } else { Toast(&quot;请输入正确的电话号码&quot;); } } else { Toast(&quot;请输入正确的身份证号&quot;); } } else { Toast(&quot;请输入正确的姓名&quot;); }} 看完这样一个代码后，相信大家和我的心情是一样的： 因为我们每次维护时要记住好几个逻辑判断分支，才能知道到底什么情况下才能得到那个结果，这种代码的可读性和可维护性自然就比较低了。 箭头式代码。 12345678910// ...................// ...................// ...................// ...................// ...................// ...................// ...................// ...................// ...................// ................... 那我这次分享的目的就是通过优化某种场景下的if else语句，使得优化后的代码看着比较清爽，从而提高代码的可读性和可维护性。 那接下来我就带大家了解一下具体场景下的if else优化方法有哪些，先从简单的场景入手。 单个 if 语句优化策略需求：当条件为真时打印出日志内容 优化前 12345678let flag = true;if (flag) { log();}function log() { console.log(&quot;如果flag值为真的时候打印这段文字&quot;);} 优化后 123456let flag = true;flag &amp;&amp; log();function log() { console.log(&quot;如果flag值为真的时候打印这段文字&quot;);} 好处：代码在一行很清晰，简洁，好读。 单个 if else 语句优化策略提前 return需求：执行登录操作，如果用户名和密码输入框为空，那么我们就提示用户”用户名和密码不能为空”类似信息；如果都不为空，那我们就执行登录的操作。 优化前 12345678let user = &quot;silu&quot;;let password = &quot;solution&quot;;if (user &amp;&amp; password) { // 执行登录操作} else { return &quot;用户名和密码不能为空&quot;;} 优化后：排非策略，先排除为 false 的情形，通过后再执行为 true 时的业务逻辑 1234567let user = &quot;silu&quot;;let password = &quot;solution&quot;;if (!user || !password) { return &quot;用户名和密码不能为空&quot;;}// 执行登录操作 好处：可以干掉else，减少代码分支，提高代码的可维护性和可阅读性。 使用条件三目运算符使用场景：在不影响可读性的情况下，处理if else分支下简短的返回值、单个简短赋值语句、调用单个相应函数时，建议使用三目运算符。 示例一：if else分支下简短返回值 优化前： 1234567function demo(flag) { if (flag) { return &quot;true&quot;; } else { return &quot;false&quot;; }} 优化后 123function demo(falg) { return flag ? &quot;true&quot; : &quot;false&quot;;} 示例二：if else分支下简短赋值 优化前： 12345678function demo(flag) { let val = &quot;&quot;; if (flag) { val = &quot;true&quot;; } else { val = &quot;false&quot;; }} 优化后： 123function demo(flag) { let val = flag ? &quot;true&quot; : &quot;false&quot;;} 示例三：if else分支下调用单个函数 优化前： 1234567function demo(flag) { if (flag) { success(); } else { fail(); }} 优化后 123function demo(flag) { flag ? success() : fail();} 好处：在以上场景中，使用条件三目运算符相比if else来说，语句在一行中书写，代码非常精炼，执行效率更高 。 多个 if else 嵌套优化策略 需求：后端大哥说了，给你返回的数据里面如果有 userInfo字段，并且userInfo下面有hobby字段并且有值就显示 hobby里面的内容，否则页面 hobby这一块不显示 12345678910let result = { status: 200, msg: &quot;success&quot;, data: { userInfo: { name: &quot;doudou&quot;, hobby: [&quot;吃饭&quot;, &quot;睡觉&quot;, &quot;打豆豆&quot;], }, },}; 一般写法：“金字塔一样的if else嵌套” 1234567891011121314151617if (result.data) { if (result.data.userInfo) { if (Array.isArray(result.data.userInfo.hobby)) { if (result.data.userInfo.hobby.length) { // 进行业务逻辑操作 } else { return &quot;hobby字段为空&quot;; } } else { return &quot;hobby字段不是一个数组&quot;; } } else { return &quot;userInfo字段不存在&quot;; }} else { return &quot;data字段不存在&quot;;} 但if else一般不建议嵌套超过三层，如果一段代码存在过多的if else嵌套，代码的可读性就会急速下降，后期维护难度也大大提高。所以，我们写这种代码时都应该尽量避免过多的if else嵌套。下面我就开始分享几个可以减少if else嵌套的方法。 第一种优化 123456if (!result.data) return &quot;data字段不存在&quot;;if (!result.data.userInfo) return &quot;userInfo字段不存在&quot;;if (!Array.isArray(result.data.userInfo.boddy)) return &quot;hobby字段不是一个数组&quot;;if (result.data.userInfo.hobby.length) { // 进行业务逻辑操作} 遵循的一般规则是，当发现无效条件时，提前返回。 好处：对于多层的 if 嵌套，使用此方法，代码看起来更简洁，可读性高，增强了代码的可维护性。 第二种优化 适合严谨又懒的前端 12345678try { // 有可能出现错误的代码写在这里 if (result.data.userInfo.hobby.length) { // 进行业务逻辑操作 }} catch (error) { // 出错后的处理写在这里} 采取的try catch策略 如果try中的代码没有出错，则程序正常运行 try 中的内容后，不会执行catch中的内容， 如果try中的代码一但出错，程序立即跳入catch中去执行代码，那么try中代码出错后的程序就不再执行了. 第三种优化 使用可选链（optional chaining)：我们都知道如果我们对一个空值进行属性读取的时候，程序会抛出异常。就像上面那个例子，在多级嵌套的对象中取属性值的时候更容易出现这个问题。那么我们为了保证程序的健壮性，就需要确保对象不为空时再读取下一级的值。 1234// 可选链优化if (result?.data?.userInfo?.hobby?.length) { // 进行业务逻辑操作} 再也不用为了解决容错而写过多重复代码了， 操作符 *?.* 会检查操作符左边的值是否是空值。如果是 null 或 undefined，这个表达式就终止然后返回 undefined。否则，这个表达式继续执行检查。 可选链操作符( ?. )，当尝试访问可能不存在的对象属性时，可选链操作符将会使表达式更短、更简明 。 多个 else if 分支优化策略需求: 有多个按钮，点击按钮执行相应业务逻辑操作。 按钮点击后根据按钮的不同type分别做两件事，第一、打印出对应日志，第二、跳转到对应的页面。 1234567891011121314151617181920212223242526/** * 按钮点击事件 * @param { string } type // 1女装2男装3童装4美妆5箱包 */const onButtonClick = (type) =&gt; { if (type === &quot;1&quot;) { showLog(&quot;女装&quot;); jumpTo(&quot;womenPage&quot;); } else if (type === &quot;2&quot;) { showLog(&quot;男装&quot;); jumpTo(&quot;menPage&quot;); } else if (type === &quot;3&quot;) { showLog(&quot;童装&quot;); jumpTo(&quot;childPage&quot;); } else if (type === &quot;4&quot;) { showLog(&quot;美妆&quot;); jumpTo(&quot;makeupPage&quot;); } else if (type === &quot;5&quot;) { showLog(&quot;箱包&quot;); jumpTo(&quot;bagPage&quot;); } else { showLog(&quot;推荐好物&quot;); jumpTo(&quot;recommendPage&quot;); }}; 多数新人在工作中常用 switch case 进行改写。 12345678910111213141516171819202122232425262728293031/** * 按钮点击事件 * @param { string } type // 1女装2男装3童装4美妆5箱包 */const onButtonClick = (type) =&gt; { switch (type) { case &quot;1&quot;: showLog(&quot;女装&quot;); jumpTo(&quot;womenPage&quot;); break; case &quot;2&quot;: showLog(&quot;男装&quot;); jumpTo(&quot;menPage&quot;); break; case &quot;3&quot;: showLog(&quot;童装&quot;); jumpTo(&quot;childPage&quot;); break; case &quot;4&quot;: showLog(&quot;美妆&quot;); jumpTo(&quot;makeupPage&quot;); break; case &quot;5&quot;: showLog(&quot;箱包&quot;); jumpTo(&quot;bagPage&quot;); break; default: showLog(&quot;推荐好物&quot;); jumpTo(&quot;recommendPage&quot;); }}; 注：不要忘记在每个case语句后放一个 break，case 语句只是指明了想要执行代码的起点，并没有指明终点，如果没有在case语句中添加break语句，没有明确的中断流程，在每次条件判断后都会执行下次判断条件，可能会造成逻辑混乱。 使用 switch case 后的语句的确比if else看着清晰易读了些，但是当需求增多后代码看起来还是那么的臃肿，似乎并没有从根本上解决问题，和if else的写法对比也不是很明显的提高。 那接下来我们就换种方法,借助对象的{key，value}结构优化 1234567891011121314151617181920const actions = { 1: [&quot;女装&quot;, &quot;womenPage&quot;], 2: [&quot;男装&quot;, &quot;menPage&quot;], 3: [&quot;童装&quot;, &quot;childPage&quot;], 4: [&quot;美妆&quot;, &quot;makeupPage&quot;], 5: [&quot;箱包&quot;, &quot;bagPage&quot;], default: [&quot;推荐好物&quot;, &quot;recommendPage&quot;],};/** * 按钮点击事件 * @param { string } type // 1女装2男装3童装4美妆5箱包 */function onButtonClick(type) { let action = actions[type] || actions[&quot;default&quot;]; // 打印日志 showLog(action[0]); // 跳转页面 jumpTo(action[1]);} 借助对象结构的这种写法，把判断条件作为对象的属性名，处理逻辑要传入的参数作为对象的属性值，在执行按钮点击事件时通过查询对象中的键，获取到键对应的值，然后执行对应的处理逻辑。这种写法非常的适合一元条件判断的情况。 问：那除了借助对象结构来实现优化，还有其它方法吗？ 答：我们还可以借助 ES6 中的 Map 数据结构来优化 ； Map 对象保存键值对。任何类型值(对象或者原始值) 都可以作为一个键或一个值。 123456789101112131415161718const actions = new Map([ [&quot;1&quot;, [&quot;女装&quot;, &quot;womenPage&quot;]], [&quot;2&quot;, [&quot;男装&quot;, &quot;menPage&quot;]], [&quot;3&quot;, [&quot;童装&quot;, &quot;childPage&quot;]], [&quot;4&quot;, [&quot;美妆&quot;, &quot;makeupPage&quot;]], [&quot;5&quot;, [&quot;箱包&quot;, &quot;bagPage&quot;]], [&quot;default&quot;, [&quot;推荐好物&quot;, &quot;recommendPage&quot;]],]);/** * 按钮点击事件 * @param { string } type // 1女装2男装3童装4美妆5箱包 */function onButtonClick(type) { let action = actions.get(type) || actions.get(&quot;default&quot;); showLog(action[0]); jumpTo(action[1]);} 上面用到了 es6 里的 Map 对象。Map 对象和 Object 对象的区别: 一个 Object 的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值。 Map 中的键值是有序的（FIFO 原则），而添加到对象中的键则不是。 Map 的键值对个数可以从 size 属性获取，而 Object 的键值对个数只能手动计算。 如果我们把问题再升级一下，在点击按钮时不仅要判断 type，还要判断用户的身份——男用户 or 女用户。 123456789101112131415161718192021222324252627282930313233343536/** * 按钮点击事件 * @param { string } type // 1女装2男装3童装4美妆5箱包 * @param { string } sex // 男用户or女用户 */function onButtonClick(type, sex) { if (sex === &quot;women&quot;) { if (type === &quot;1&quot;) { // do something } else if (type === &quot;2&quot;) { // do something } else if (type === &quot;3&quot;) { // do something } else if (type === &quot;4&quot;) { // do something } else if (type === &quot;5&quot;) { // do something } else { // do something } } else if (sex === &quot;men&quot;) { if (type === &quot;1&quot;) { // do something } else if (type === &quot;2&quot;) { // do something } else if (type === &quot;3&quot;) { // do something } else if (type === &quot;4&quot;) { // do something } else if (type === &quot;5&quot;) { // do something } else { // do something } }} 从上方示例代码中可以看出，如果判断条件变为二元条件判断时，if else 的数量就增加到一元判断条件的二倍，代码看着更臃肿了。那么对于二元的条件判断我们应该怎么去优化它们呢？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778const actions = new Map([ [ &quot;women_1&quot;, () =&gt; { /* do something */ }, ], [ &quot;women_2&quot;, () =&gt; { /* do something */ }, ], [ &quot;women_3&quot;, () =&gt; { /* do something */ }, ], [ &quot;women_4&quot;, () =&gt; { /* do something */ }, ], [ &quot;women_5&quot;, () =&gt; { /* do something */ }, ], [ &quot;men_1&quot;, () =&gt; { /* do something */ }, ], [ &quot;men_2&quot;, () =&gt; { /* do something */ }, ], [ &quot;men_3&quot;, () =&gt; { /* do something */ }, ], [ &quot;men_4&quot;, () =&gt; { /* do something */ }, ], [ &quot;men_5&quot;, () =&gt; { /* do something */ }, ], [ &quot;default&quot;, () =&gt; { /* do something */ }, ],]);/** * 按钮点击事件 * @param { string } type // 1女装2男装3童装4美妆5箱包 * @param { string } sex // 男用户or女用户 */function onButtonClick(type, sex) { let action = actions.get(`$(sex)_$(type)`) || actions.get(&quot;default&quot;); action.call(this);} 上面这种处理思想是，把条件判断拼接成字符串作为键，每个分支下的处理逻辑作为值，在使用时传入参数使用 Map 查询，这种方法非常适合于二元或多元条件判断。 如果你不喜欢把查询条件拼接为字符串使用，这还有一种方法，把查询条件作为对象，借助 Map 数据结构实现。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394const actions = new Map([ [ { sex: &quot;women&quot;, type: &quot;1&quot; }, () =&gt; { /* do something */ }, ], [ { sex: &quot;women&quot;, type: &quot;2&quot; }, () =&gt; { /* do something */ }, ], [ { sex: &quot;women&quot;, type: &quot;3&quot; }, () =&gt; { /* do something */ }, ], [ { sex: &quot;women&quot;, type: &quot;4&quot; }, () =&gt; { /* do something */ }, ], [ { sex: &quot;women&quot;, type: &quot;5&quot; }, () =&gt; { /* do something */ }, ], [ { sex: &quot;men&quot;, type: &quot;1&quot; }, () =&gt; { /* do something */ }, ], [ { sex: &quot;men&quot;, type: &quot;2&quot; }, () =&gt; { /* do something */ }, ], [ { sex: &quot;men&quot;, type: &quot;3&quot; }, () =&gt; { /* do something */ }, ], [ { sex: &quot;men&quot;, type: &quot;4&quot; }, () =&gt; { /* do something */ }, ], [ { sex: &quot;men&quot;, type: &quot;5&quot; }, () =&gt; { /* do something */ }, ], [ &quot;default&quot;, () =&gt; { /* do something */ }, ],]);/** * 按钮点击事件 * @param { string } type // 1女装2男装3童装4美妆5箱包 * @param { string } sex // 男用户or女用户 */function onButtonClick(type, sex) { // 根据条件使用filter查询 let action = [...actions].filter( ([key, value]) =&gt; key.sex === sex &amp;&amp; key.type === type ); action.forEach(([key, value]) =&gt; value.call(this));}/** * 按钮点击事件 * @param { string } type // 1女装2男装3童装4美妆5箱包 * @param { string } sex // 男用户or女用户 */function onButtonClick(type, sex) { // 根据条件使用find查询 let action = [...actions].find( ([key, value]) =&gt; key.sex === sex &amp;&amp; key.type === type ); action[1].call(this);} 上方在执行按钮点击事件时，根据条件查询相应执行逻辑时，提供了filter和find两种查询方式，个人觉得使用filter更为正式，使用find更容易阅读，当然你也可以使用其它方法啦~ 从这里我们就看出了使用 Map 相对于 Object 存在的优势了，Map 数据结构可以以任意类型的值作为 key。 假如在 women 情况下，type 为 1,2,3,4 时的处理逻辑都一样该怎么写呢？ 123456789101112131415161718192021222324252627282930313233const actions = new Map([ [ { sex: &quot;women&quot;, type: &quot;1&quot; }, () =&gt; { /* 执行A逻辑 */ }, ], [ { sex: &quot;women&quot;, type: &quot;2&quot; }, () =&gt; { /* 执行A逻辑 */ }, ], [ { sex: &quot;women&quot;, type: &quot;3&quot; }, () =&gt; { /* 执行A逻辑 */ }, ], [ { sex: &quot;women&quot;, type: &quot;4&quot; }, () =&gt; { /* 执行A逻辑 */ }, ], [ { sex: &quot;women&quot;, type: &quot;5&quot; }, () =&gt; { /* 执行B逻辑 */ }, ], // ……]); 这样写的话 Map 里面就会显得比较臃肿，具体的执行逻辑处理过程都放在了 Map 里面。好点的写法可以是这样子。 1234567891011121314const logicA = () =&gt; { /* 执行A逻辑 */};const logicB = () =&gt; { /* 执行B逻辑 */};const actions = new Map([ [{ sex: &quot;women&quot;, type: &quot;1&quot; }, logicA], [{ sex: &quot;women&quot;, type: &quot;2&quot; }, logicA], [{ sex: &quot;women&quot;, type: &quot;3&quot; }, logicA], [{ sex: &quot;women&quot;, type: &quot;4&quot; }, logicA], [{ sex: &quot;women&quot;, type: &quot;5&quot; }, logicB], // ……]); 上面的写法虽然 Map 中结构清晰了，日常需求的话可以这么写也是没什么问题的。但是，如果以后增加需求，women 条件下 type 为 6、7、8、10、11……的逻辑处理都是一样的。那么我们还要像上方那样的写法在 Map 中一一增加同样的执行逻辑吗？ 显然，这样的话会变得比较繁琐，那么我们还有其它办法来应对这种情况吗？ 12345678910111213function actions() { const logicA = () =&gt; { /* 执行A逻辑 */ }; const logicB = () =&gt; { /* 执行B逻辑 */ }; const action = new Map([ [/^women_[1-4]$/, logicA], [/^women_5$/, logicB], // …… ]);} 利用正则进行判断条件匹配后，代码又清爽了许多。并且这里使用 Map 后的优势就更加的明显了，符合正则的条件的公共逻辑都会执行。 总结下这部分的内容： 一元条件判断：存到 Object 中。 一元条件判断：存到 Map 中。 二元或多元判断：将判断条件拼接成字符串存到 Object 中。 二元或多元判断：将判断条件拼接成字符串存到 Map 中。 多元判断时：将判断条件写成 Object 存到 Map 中。 多元判断时：将判断条件写成正则存到 Map 中。 使用数组新特性优化逻辑判断在工作中，巧妙的使用 ES6 中提供的数组新特性，也可以达到轻松优化逻辑判断的效果。 使用 includes 优化代码逻辑需求：判断animal是否属于cute类型。 当我们遇到多条件判断时，本能的写下以下代码。 1234567891011const cuteAnimal = [&quot;dog&quot;, &quot;cat&quot;, &quot;bird&quot;, &quot;panda&quot;];function animalJudge(animal) { if ( animal === &quot;dog&quot; || animal === &quot;cat&quot; || animal === &quot;bird&quot; || animal === &quot;panda&quot; ) { console.log(&quot;可爱的小动物&quot;); }} 但是当cuteAnimal的种类多达十几种或者是更多的时候，我们就只能通过这种||的形式去维护吗？ 这时候我们可以试着使用includes方法 1234567const cuteAnimal = [&quot;dog&quot;, &quot;cat&quot;, &quot;bird&quot;, &quot;panda&quot;];function animalJudge(animal) { if (cuteAnimal.includes(animal)) { console.log(&quot;可爱的小动物&quot;); }} 这个时候后期维护的话，增加动物类型时只需要在cuteAnimal数组中增加，当类型数量多时，代码看起来还是很简洁，不像上面使用很多||那么杂乱 使用 every 优化代码逻辑需求：判断animals数组中的动物是否都属于cute类型 every：判断数组的每一项是否都满足条件，都满足条件返回true，否则返回false 1234567891011121314151617181920212223242526const animals = [ { name: &quot;dog&quot;, type: &quot;cute&quot;, }, { name: &quot;cat&quot;, type: &quot;cute&quot;, }, { name: &quot;elephant&quot;, type: &quot;tall&quot;, },];function type() { let isAllCute = true; // 判断条件：animals中的动物是否都是cute类型 for (let animal of animals) { if (!isAllCute) break; isAllRed = animal.type === &quot;cute&quot;; } console.log(isAllCute); // false} 使用every方法，更容易处理上面的判断逻辑 123456789101112131415161718192021const animals = [ { name: &quot;dog&quot;, type: &quot;cute&quot;, }, { name: &quot;cat&quot;, type: &quot;cute&quot;, }, { name: &quot;elephant&quot;, type: &quot;tall&quot;, },];function animals() { // 判断条件：animals中的动物是否都是cute类型 const isAllCute = animals.every((animal) =&gt; animal.type === &quot;cute&quot;); console.log(isAllCute); // false} 使用 some 方法优化代码逻辑需求：判断animals中的动物是否存在有tall类型的。 some()是对数组中每一项运行给定函数，如果有一项符合条件，则返回 true，都不符合条件返回 false。 123456789101112131415161718192021const animals = [ { name: &quot;dog&quot;, type: &quot;cute&quot;, }, { name: &quot;cat&quot;, type: &quot;cute&quot;, }, { name: &quot;elephant&quot;, type: &quot;tall&quot;, },];function animals() { // 判断条件：animals中的动物是否含有tall类型 const isHasTall = animals.some((animal) =&gt; animal.type === &quot;tall&quot;); console.log(isHasTall); // true} 默认值优化优化前 12345function request(options) { let method = options.method ? options.method : &quot;GET&quot;; let data = options.data ? options.data : {}; //...} 优化后 12345function request(options) { let method = options.method || &quot;GET&quot;; let data = options.data || {}; //...} 基于 ES6 优化后 123456// 解析解构和默认参数搭配使用function request({ method, data } = { method: &quot;GET&quot;, data: {} }) { //... console.log(method); // GET console.log(data); // {}} 使用策略模式优化分支逻辑需求：咱马上要过国庆节啦，得打折清仓呀，有的商品 5 折，有的 7 折，有的 9 折~ 优化前 123456789101112131415161718192021222324252627function percent50(price) { // 五折的算法}function percent70(price) { // 七折的算法}function percent90(price) { // 九折的算法}function calculatePrice(price) { if (五折的商品) { return percent50(price); } if (七折的商品) { return percent50(price); } if (九折的商品) { return percent50(price); }}calculatePrice(price); 写到这里需求又来了，那以后的中秋节、元旦、情人节、元宵节……都要促销呀！再来个满 300 减 50，满 500 减 80，vip 用户满 500-150 上不封顶！对于这种越来越多的需求，还要深入函数内部一一增加if分支吗？ 以上写法的缺点： calculatePrice函数比较庞大，包含了很多if else语句 如果再增加更多相似需求，必须要深入到calculatePrice函数内部实现，违反了开放封闭原则。 使用策略模式优化策略模式(Strategy Pattern)：定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。 策略模式是一种对象行为型模式。 这里的算法其实就是业务逻辑，为了更形象，干脆将其理解为一个函数。其实这个定义的基本意思就是说，根据策略选择要执行的函数，而每一个策略都会有一个标识名，可以称为key。而策略名对应的函数，可以称为value，其实就是使用key寻找value，然后执行vlaue的过程。也就是说，根据条件去执行相应的业务逻辑，从这层意思上理解，就是if else要干的事。 使用策略模式优化后： 使用思路：定义一个对象封装不同的行为，提供选择接口，在不同条件下调用相应的行为。 12345678910111213141516171819202122232425262728293031323334// 策略类let strategy = { // 5折 percent50(price) { return price * 0.5; }, // 7折 percent70(price) { return price * 0.7; }, // 9折 percent90(price) { return price * 0.9; }, // 满300-50 fullReduce50(price) { // 执行满300-50的业务逻辑 }, // 满300-80 fullReduce80(price) { // 执行满300-80的业务逻辑 }, // vip用户五折 vip50(price) { // vip用户五折的业务逻辑 },};// 调用策略类中的方法// 环境类function calculatePrice(strategyName, price) { return strategy[strategyName] &amp;&amp; strategy[strategyName](price);}console.log(calculatePrice(&quot;percent50&quot;, 100)); // 50 使用策略类优化后，后期再增加需求时，我们就不需要再深入到calculatePrice函数内部增加分支了，只需要在strategy策略类中增加相应的算法就可以啦！这样的代码是不是在后期更好维护呢！！！ 上面例子中： 策略类 是指strategy对象，保存了所有的策略名对应的方法。 环境类 是用接收策略名和其它参数，然后调用对应的策略方法。 好处： 有效的避免了多重条件选择语句。 策略模式提供了对开放-封闭原则的完美支持，将算法独立封装在 strategy 中，使得这些算法易于切换、易于理解、易于扩展。 总结 更少的嵌套，尽早return 。 倾向于使用对象或使用 map 结构来优化if else，而不是 Switch语句 。 多重判断时使用Array.includes 。 对 所有/部分 判断使用 Array.every &amp; Array.some 。 使用默认参数和解构 。 当一个项目中需要大量算法，大量匹配模式时可以考虑使用策略模式。 感想 让我们感到快乐和幸福的方法，无非是全身心的投入到我们稍微努力一下就能完成的事情中去。是这样的，太难的事情我们很难去完成最终丧失信心，而简单的事情又不能勾起我们的兴趣，只有像这种看似比较难，但是稍微努力就能完成的事情，才能给我们带来很大的快乐。","link":"/2020/09/30/if-else%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD%E4%BC%98%E5%8C%96/"},{"title":"函数式编程范式","text":"注：本文部分代码涉及到一些 JavaScript 新特性，需要提前了解一下：JavaScript 新特性 讲解视频：https://www.bilibili.com/video/BV1vV411a7kH/ 1 函数式编程范式1.1 定义函数式编程（Functional Programming: FP）是一种编程范式（指计算机中编程中的典范模式或方法，就是一种思维方式），属于结构化编程，用于描述数据（函数）之间的映射关系。 特别需要注意的是，函数式编程中的函数不是指程序中的函数（方法），而是数学中的函数（映射关系），如：y = f(x)，指x和y之间的关系。 常见的编程范式有：过程化（命令式）编程、面向对象编程、声明式编程等。 过程化编程：最原始的传统编程，将问题抽象为一系列步骤，然后通过编程方式将这些步骤转换为程序指令集，这些指令集按照一定顺序排列。人们把支持过程化编程范式的编程语言称为过程化编程语言，常见的有机器语言、汇编语言、BASIC、C、FORTRAN 等。过程化语言特别适合解决线性（或者说按部就班）的算法问题。 面向对象编程：将待解决问题抽象为面向对象的程序中的对象，利用封装使每个对象都拥有个体的身份。程序就是成堆的对象，彼此通过信息的传递，请求其它对象进行工作。面向对象包括三个基本概念：封装性、继承性、多态性。常见的面向对象语言有 Java、C、C++、JavaScript。 声明式编程：以数据结构的形式来表达程序执行的逻辑。它的主要思想是告诉计算机应该做什么，但不指定具体要怎么做。SQL 语句就是最明显的一种声明式编程的例子，我们只需要定义好该如何处理数据，不需要指定具体实现，就可以查询到我们需要的数据。 现代编程语言的发展趋势是支持多种范式，如 C#、Java 8+、Kotlin、ES6+。 编程范式和设计模式的区别： 编程范式：是指从事软件工程的一类典型的编程风格（此概念好比“战略”），体现编写程序的人如何看待程序设计的“哲学观”； 程序设计模式：设计模式是软件设计中常见问题的典型解决方案（此概念好比“战术”），是解决一系列实际问题的“方法学”。 1.2 特点 代码简洁：函数式编程使用了大量的函数，减少了代码的重复； 接近自然语言，易于理解： 123let result = （1 + 2）* 3 - 4; // 普通表达式let result = subtract(multiply(add(1, 2), 3), 4); // 函数式编程 函数是“第一等公民”：函数与其他数据类型一样，处于平等地位，可以赋值给其它变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值； 闭包和高阶函数：函数式编程会使用较多的闭包和高阶函数； 没有“副作用”，方便与代码管理和单元测试：副作用 指函数内部与外部互动(最典型的情况，就是修改全局变量量的 值)，产⽣运算以外的其他结果。函数式编程强调没有”副作用”，意味着函数要保持独立，所有功能就是返回一个新的值，没有其他⾏为，尤其是不得修改外部变量的值； 引用透明：函数的运行不依赖于外部变量或”状态”，只依赖于输入的参数，任何时候只要参数相同，引用函数所得到的返回值总是相同的。 1.3 基本概念① 函数式编程的思维方式： 把现实世界的事物和事物之间的联系（映射关系）抽象到程序世界（对运算过程进行抽象） 12// 比如买单价为0.5元的白菜，买了两斤，需要支付多少块钱（白菜与货币的联系）let money = multiply(0.5, 2); // 即两斤白菜 -&gt; 1元（money） ② 程序的本质： 根据输入通过某种运算获得相应的输出，程序开发过程中会涉及很多有输入和输出的函数。 ③ 函数y = f(x)： x → f(映射) → y 图 1 从 x 到 y 的函数关系 图 2 从 x 到 y 不是函数关系 ④ 纯函数：相同的输入始终要得到相同的输出 ⑤ 函数式编程是用来描述数据（函数）之间的映射 1.4 学习指南函数式编程范式只是一种对程序编程思维的一种概论，而具体的实现则通过柯里化（第 5 章）、函数组合（第 6 章）、函子等来实现。 在学习如何实现前，需要先了解三个小知识点：头等函数（第 2 章），闭包（第 3 章），纯函数（第 4 章）。 2 头等函数2.1 函数是一等公民函数是一等公民？通俗来讲在某些编程语言中，函数是不能够： 函数可以存储在变量中 函数可以作为参数（2.2.1） 函数可以作为返回值（2.2.2） JavaScript 对待不同的数据结构具有同等级别的支持，函数可以享受以上几种待遇，所以在 JavaScript 中，函数是一等公民。 函数可以存储在变量中： 123456789101112131415161718192021// 把函数赋值给变量const fn = () =&gt; { console.log(&quot;2.1 函数可以存储在变量中&quot;);};fn();// 属性赋值示例const objController = { getKeys(obj) { // ES6属性简写，等同于getKeys: getKeys(obj) return Object.keys(obj); },};// 优化：上面代码中getKeys方法和内部调用Object.keys方法的参数和返回值一样，所以可以改写成下面const objController = { getKeys: Object.keys,};console.log(objController);const my = { name: &quot;Patrick Jun&quot;, constellation: &quot;Virgo&quot; };console.log(objController.getKeys(my)); 2.2 高阶函数如果一个函数以下面任一方式使用，那么这个函数就可以称为高阶函数。 参数是一个函数 返回值是一个函数 Patrick Jun：可以操作函数的函数就是高阶函数。这就跟高数里的求导（二阶及以上的求导称之为高阶求导）一样，可以对已导函数的求导就是高阶求导。 2.2.1 函数作为参数将函数作为参数最常见的就是咱们经常用的回调函数。 1234567891011121314151617181920212223// 遍历（模拟数组的forEach方法）function forEach(arr, fn) { for (let i = 0; i &lt; arr.length; i++) { fn(arr[i], i); // 将每一项传入回调fn处理 }}// 筛选，返回符合条件的元素组成的新数组function filter(arr, fn) { const results = []; for (const item of arr) { if (fn(item)) { results.push(item); } } return results;}const colors = [&quot;#FF0000&quot;, &quot;#00FF00&quot;, &quot;blue&quot;];forEach(colors, (item, index) =&gt; { console.log(index + 1, item);});console.log(filter(colors, (item) =&gt; item.length === 7)); 2.2.2 函数作为返回值123456789101112131415161718192021222324252627function makeFn() { const msg = &quot;hello function&quot;; return function () { console.log(msg); };}const fn = makeFn(); // makeFn()执行后返回一个匿名函数，赋值给fnfn();// makeFn()()// 模拟lodash中的once函数 对一个函数只执行一次的函数(例如支付,不管用户点击多少次按钮，都只执行一次)function once(func) { let done = false; // 定义一个状态done，判断是否已执行支付 return function () { if (!done) { done = true; // 更改闭包作用域中的done为已支付 func.apply(this, arguments); } };}const pay = once((money) =&gt; { // 传入一个函数，通过输出模拟支付过程和结果 console.log(`支付${money}元`);});pay(20); // 支付20元pay(30);pay(40); 2.2.3 使用高阶函数意义 抽象可以帮我们屏蔽细节，只需要关注我们的目标 比如前面的例子：不用在乎如何遍历，只需要关注我们怎么出处理数据。不用在乎用户会不会多次点击，只需要关注如何处理支付后的流程。 高阶函数用来抽象通用的问题 比如前面抽象遍历问题 2.2.4 常用高阶函数模拟 map 通过指定函数处理数组的每个元素，并返回处理后的数组。 1234567891011function map(arr, fn) { const res = []; for (const val of arr) { res.push(fn(val)); // 将回调fn()处理好的元素存入新数组 } return res;}let arr = [1, 2, 3, 4, 5];arr = map(arr, (item) =&gt; item * item);console.log(arr); //[ 1, 4, 9, 16, 25 ] every 用于检测数组所有元素是否都符合指定条件 12345678910111213141516171819function every(arr, fn) { let res = true; // 定义一个flag for (const val of arr) { res = fn(val); // fn判断 if (!res) { // 只要有一个元素不满足，就结束循环 break; } } return res;}const arr1 = [1, 2, 3, 4, 5];const arr2 = [4, 5, 6, 7];const res1 = every(arr1, (item) =&gt; item &gt; 3);console.log(res1); // falseconst res2 = every(arr2, (item) =&gt; item &gt; 3);console.log(res2); // true some 判断数组中是否至少有一个元素满足条件 12345678910111213141516171819function some(arr, fn) { let res = false; // 定义一个flag for (const val of arr) { res = fn(val); // fn判断 if (res) { // 只要有一个元素满足，就结束循环 break; } } return res;}const arr1 = [1, 2, 3, 4, 5];const arr2 = [1, 3, 5, 7];const res1 = some(arr1, (item) =&gt; item % 2 === 0);console.log(res1); // trueconst res2 = some(arr2, (item) =&gt; item % 2 === 0);console.log(res2); // false find 返回数组中满足提供的测试函数的第一个元素的值，如果未找到，则返回 undefined 12345678910111213141516function find(arr, fn) { for (const item of arr) { if (fn(item)) { // 找到满足条件的第一个元素 return item; } } return undefined; // 未找到返回undefined}const arr1 = [1, 2, 3, 4, 5];const res1 = find(arr1, (item) =&gt; item % 2 === 0);console.log(res1); // 2const res2 = find(arr1, (item) =&gt; item === 8);console.log(res2); // undefined findIndex 找到满足条件的第一个元素，返回其位置，如果未找到，则返回-1 12345678910111213141516function findIndex(arr, fn) { for (let i = 0; i &lt; arr.length; i++) { if (fn(arr[i])) { // 找到满足条件的第一个元素位置 return i; } } return -1; // 未找到返回-1}const arr1 = [1, 2, 3, 4, 5];const res1 = findIndex(arr1, (item) =&gt; item % 2 === 0);console.log(res1); // 1const res2 = findIndex(arr1, (item) =&gt; item === 8);console.log(res2); // -1 3 闭包3.1 定义函数和其周围的状态的引用捆绑在一起形成的闭包。 可以在另一个作用域中调用一个函数内部的函数并访问到该函数的作用域中的成员； 闭包的本质：函数在执行的时候会放到一个执行栈上，当函数执行完毕后会从执行栈上删除，但是堆上作用域成员因为被外部引用而不能被释放，因此内部函数依然可以访问到作用域的成员； 特性： 函数嵌套函数（高阶函数） 函数内部可以引用函数外部的参数和变量 参数和变量不会被垃圾回收机制回收 3.2 案例123456789101112131415161718192021222324252627function makePower(power) { return function (number) { return number ** power; // number为底数，power为指数 };}// 平方：number**2const power2 = makePower(2);// 立方：number**3const power3 = makePower(3);console.log(power2(5));console.log(power2(2));console.log(power3(4));function makeSalary(base) { return function (performance) { return base + performance; };}// 底层打工人const level1 = makeSalary(1000);// 高级打工人const level2 = makeSalary(10000);console.log(level1(100)); // 1100console.log(level1(120)); // 1120console.log(level2(30000)); // 40000 打开 Chrome 开发者工具 &gt; Sources ： Call Stack(函数调用栈) Scope(作用域) ： Global(var 全局) 、 Local(局部) 、 Closure(闭包) 、 Script(let 作用域) 仅看一看演示一下，具体细节之后专门分享 ^_^ 12345678910111213// 查看函数栈和闭包作用域成员的访问function makeSalary() { let base = 1000; return function (performance) { // debugger; base += 1; return base + performance; };}const sallary = makeSalary();console.log(sallary(100));console.log(sallary(200)); 4 纯函数4.1 概念相同的输入永远会等到相同的输出，没有任何可观察的副作用 slice 和 splice 分别：纯函数和不纯函数 slice 返回数组中的指定部分，不会改变原数组 splice 对数组进行操作返回该数组，会改变原数组 12345678910111213141516171819// 纯函数 slice(start, end)const numbers = [1, 2, 3, 4, 5];console.log(numbers.slice(0, 3)); // [ 1, 2, 3 ]console.log(numbers.slice(0, 3)); // [ 1, 2, 3 ]console.log(numbers.slice(0, 3)); // [ 1, 2, 3 ]// 不纯函数 splice(index, howmany, ...items)console.log(numbers.splice(0, 3)); // [ 1, 2, 3 ]console.log(numbers.splice(0, 3)); // [ 4, 5 ]console.log(numbers.splice(0, 3)); // []// 最简单的纯函数示例function getSum(a, b) { return a + b;}console.log(getSum(1, 2)); // 3console.log(getSum(1, 2)); // 3console.log(getSum(1, 2)); // 3 4.2 lodash官网：lodashlodash 是一个纯函数的功能库，提供了对数组、数字、对象、字符串、函数等操作的一些方法。 123456789101112131415const _ = require(&quot;lodash&quot;);const arr = [&quot;Tom&quot;, &quot;Jon&quot;, &quot;Kate&quot;];console.log(_.first(arr));console.log(_.last(arr));console.log(_.toUpper(_.last(arr)));console.log(_.reverse(arr));console.log(_.first(arr));_.each(arr, (item, index) =&gt; { console.log(item, index);});const value = [];_.isEmpty(value); // 判断一个value 是否是empty(null,[],{}....) 4.3 纯函数的好处 可缓存：因为纯函数相同的输入永远会等到相同的输出，所以可以把纯函数结果缓存 12345678910111213141516171819202122232425262728// 记忆函数const _ = require(&quot;lodash&quot;);function getArea(r) { console.log(`执行getArea计算，r = ${r}`); return Math.PI * r * r;}// 这里使用lodash中的记忆函数const getAreaWithMemory = _.memoize(getArea);console.log(getAreaWithMemory(4));console.log(getAreaWithMemory(4)); // 不会再次计算console.log(getAreaWithMemory(5));// js模拟 memoize 方法的实现function memoize(f) { const cache = {}; return function () { const key = JSON.stringify(arguments); cache[key] = cache[key] || f.apply(f, arguments); return cache[key]; };}const getAreaWithMemory = memoize(getArea);console.log(getAreaWithMemory(4));console.log(getAreaWithMemory(4));console.log(getAreaWithMemory(5)); 可测试：纯函数让测试更加方便，对单元化测试很友好 并行处理：在多线程环境下并行操作共享的内存数据很可能会出现意外情况，纯函数不需要访问共享的内存数据，所以在并行环境下可以任意运行纯函数（Web Worker） 4.4 副作用纯函数：指相同的输入永远会得到相同的输出，而且没有可观察的副作用，而副作用让一个函数变的不纯，纯函数根据相同的输入返回相同的输出，如果函数依赖于外部的状态就无法保证输出相同，就会带来副作用。 1234567891011// 不纯的函数let min = 18;function checkAge(age) { return age &gt;= min; // 依赖外部的min状态}// 纯函数function checkAge2(age) { let min = 18; // 硬编码，可通过闭包或者柯里化解决 return age &gt;= min;} 副作用的来源： 配置文件 数据库 获取用户的输入： 所有的外部交互都有可能带来副作用，副作用也会使方法通用性下降、不适合扩展，同时副作用会给程序中带来安全隐患给程序员带来不确定性，但是副作用不可能完全禁止，尽可能控制他们在可控范围内发生。 12345678910111213141516171819// 有副作用let result = 0;function sum() { const a = $(&quot;.input-1&quot;).val(); const b = $(&quot;.input-2&quot;).val(); result = a + b;}// &lt;button onclick=&quot;sum()&quot;&gt;求和&lt;/button&gt;// 避免副作用function sum(a, b) { return a + b;}$(&quot;button&quot;).bind(&quot;click&quot;, () =&gt; { const a = $(&quot;.input-1&quot;).val(); const b = $(&quot;.input-2&quot;).val(); result = sum(a, b);});// &lt;button&gt;求和&lt;/button&gt; 5 柯里化柯里化（curry：咖喱）可以把多元函数转化成一元函数 当一个函数有多个参数的时候，先传递一部分参数调用它（这部分参数以后永远不变） 然后返回一个新的函数接受剩余的参数，直达参数接收完毕才返回结果 5.1 柯里化示例(问题回顾)解决上面硬编码问题： 1234567// 普通纯函数的方式解决function checkAge(age, min) { return age &gt;= min;}console.log(checkAge(20, 18)); // trueconsole.log(checkAge(17, 18)); // falseconsole.log(checkAge(24, 22)); // true 上面代码可以发现当基准值时18时，18是重复的 使用之前所学的闭包处理 1234567891011121314// 闭包的方式解决（简单的柯里化）function checkAge(min) { return function (age) { return age &gt;= min; };}const checkAge18 = checkAge(18);const checkAge22 = checkAge(22);console.log(checkAge18(17)); // falseconsole.log(checkAge18(20)); // trueconsole.log(checkAge22(20)); // falseconsole.log(checkAge22(30)); // true 使用 ES6 改造上面checkAge函数： 1let checkAge = (min) =&gt; (age) =&gt; age &gt;= min; 5.2 lodash.curry(fn) _.curry(fn) 文档：https://www.lodashjs.com/docs/lodash.curry 功能：创建一个函数，该函数接受 fn 的参数。如果 fn 所需的参数都被提供则执行 fn 并返回结果，否则继续返回该函数并等待接收剩余的参数。 需要注意：传参先后顺序不能变 1234567891011const _ = require(&quot;lodash&quot;);function getSum(a, b, c) { return a + b + c;}const curried = _.curry(getSum);console.log(curried(2, 3, 4)); // 9console.log(curried(2)(3)(4)); // 9console.log(curried(2)(3, 4)); // 9console.log(curried(2, 3)(4)); // 9 案例 1234567891011121314151617181920212223242526const _ = require(&quot;lodash&quot;);const match = _.curry((reg, str) =&gt; { return str.match(reg);});// 匹配所有数字const hasSpace = match(/\\s+/g);// 匹配所有空白字符const hasNumber = match(/\\d+/g);console.log(hasSpace(&quot;helloword&quot;)); // nullconsole.log(hasNumber(&quot;123213 123&quot;)); // [&quot;123213&quot;, &quot;123&quot;]console.log(hasNumber(&quot;helloword&quot;)); // null// 再扩展：筛选数组中指定条件的元素const filter = _.curry((func, array) =&gt; { return array.filter(func);});console.log(filter(hasSpace, [&quot;Patrick Jun&quot;, &quot;Patrick_Jun&quot;])); // [&quot;Patrick Jun&quot;]// 分步使用 = filter(hasSpace)(['Patrick Jun', 'Patrick_Jun'])const findSpace = filter(hasSpace);console.log(findSpace([&quot;Patrick Jun&quot;, &quot;Patrick_Jun&quot;])); // [&quot;Patrick Jun&quot;] 模拟 lodash 中的 curry 方法 小知识点：fn = (a, b, c, d, e) =&gt; {};，那么fn.length = 5; 1234567891011121314151617181920function curry(func) { return function curriedFn(...args) { // 判断形参和实参的个数 if (args.length &lt; func.length) { return function () { // 将...args与...arguments拼接传递给curriedFn return curriedFn(...args, ...arguments); }; } return func(...args); };}function getSum(a, b, c) { return a + b + c;}const curried = curry(getSum);console.log(curried(2, 3)(4)); // 9console.log(curried(2)(3, 4)); // 9 图解步骤： 5.3 总结 柯里化可以让我们给一个函数传递较少的参数得到一个已经记住了某些固定参数的新函数 这是一种对函数参数的“缓存”（闭包） 让函数变的更灵活，让函数的粒度更小 可以把多元函数转换成一元函数，可以组合使用函数产生强大的功能 6 函数组合6.1 概念函数组合(compose)：如果一个函数要经过多个函数处理才能得到最终值，这个时候可以把中间过程的函数合并成一个函数。 函数就像是数据的管道，函数组合就是把这些管道连接起来，让数据穿过多个管道形成最终结果 函数组合默认是从右到左执行 函数组合后只接受一个参数 123456789101112131415161718// 函数组合演示function reverse(array) { return array.reverse();}function first(array) { return array[0];}function compose(f, g) { return function (value) { return f(g(value)); };}const last = compose(first, reverse);console.log(last([1, 2, 3, 4])); // 4 6.2 lodash 组合函数lodash 中组合函数flow()或者flowRight()，他们都可以组合多个函数 flow和flowRight会创建一个函数，返回结果是调用提供函数的结果。提供函数会连续调用，每个提供函数传入的参数都是前一个函数返回的结果。 flow()是从左到右运行 flowRight()是从右到左运行，使用的更多一些 123456789const _ = require(&quot;lodash&quot;);const reverse = (arr) =&gt; arr.reverse();const first = (arr) =&gt; arr[0];const toUpper = (s) =&gt; s.toUpperCase();const f = _.flowRight(toUpper, first, reverse);console.log(f([&quot;one&quot;, &quot;two&quot;, &quot;three&quot;])); // ??? 模拟lodash中的flowRight()方法： 数组中的reduce() ：对数组中的每个元素执行一个由您提供的 reducer 函数(升序执行)，将其结果汇总为单个返回值。 12345678910function compose(...args) { return function (val) { return args.reverse().reduce((acc, fn) =&gt; { return fn(acc); }, val); };}// ES6// const compose = (...args) =&gt; (val) =&gt; args.reverse().reduce((acc, fn) =&gt; fn(acc), val); 图解步骤： 6.3 结合律函数的组合要满足结合律。 例如compose(f,g,h)，我们既可以先把f和g组合在一起，还可以先把g和h组合： 123456789101112console.log(compose(compose(f, g), h) == compose(f, compose(g, h))); //trueconsole.log(compose(f, g, h) == compose(f, compose(g, h))); //trueconst _ = require(&quot;lodash&quot;);// 下面三种写法结果运行一样const f = _.flowRight(_.flowRight(_.toUpper, _.first), _.reverse); // 前两个组合const f1 = _.flowRight(_.toUpper, _.flowRight(_.first, _.reverse)); // 后两个组合const f2 = _.flowRight(_.toUpper, _.first, _.reverse); // 不组合console.log(f([&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]) === f1([&quot;one&quot;, &quot;two&quot;, &quot;three&quot;])); // trueconsole.log(f([&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]) === f2([&quot;one&quot;, &quot;two&quot;, &quot;three&quot;])); // trueconsole.log(f1([&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]) === f2([&quot;one&quot;, &quot;two&quot;, &quot;three&quot;])); // true 6.4 实战题目：将NEVER SAY DIE 转换为 never-say-die; 思路：小写，分割，join 'NEVER SAY DIE'.toLowerCase().split(' ').join('-'); 分析： 123456789101112131415161718192021222324252627282930313233const _ = require(&quot;lodash&quot;);// 第一步：_.toLower()// 第二步：_.split()// 因为我们需要传入str变量，所以str放在最后面传入，以下同理const split = _.curry((symbol, str) =&gt; _.split(str, symbol));// 第三步：._joinconst join = _.curry((symbol, array) =&gt; _.join(array, symbol));// log用来检测数据管道中，哪部分值有错误const log = (v) =&gt; { console.log(v); // 继续返回值给下一个fn return v;};const f = _.flowRight(join(&quot;-&quot;), log, split(&quot; &quot;), log, _.toLower);console.log(f(&quot;NEVER SAY DIE&quot;)); // never-say-die// // 考虑到数据管道很长的情况，如果多次log，打印的数据不够直观，于是改造log// const _ = require('lodash');// const trace = _.curry((tag, v) =&gt; {// console.log(tag, v);// return v;// });// const split = _.curry((symbol, str) =&gt; _.split(str, symbol));// const join = _.curry((symbol, arr) =&gt; _.join(arr, symbol));// const f = _.flowRight(join('-'), trace('after split：'), split(' '), trace('after toLower：'), _.toLower);// console.log(f('NEVER SAY DIE')); 7 总结 函数式编程是一种强调以函数使用为主的软件开发风格； 纯函数指没有副作用的函数，相同的输入有相同的输出； 在函数式编程里面，将多个不同函数组合是一个非常非常非常重要的思想； 函数式编程将函数视为积木，通过一些高阶函数来提高代码的模块化和可重用性。 理解：柯里化是”因式分解“，将参数分解开；函数组合是”结合律“，函数可以组合使用。 进阶内容：lodash/fp、函子；（笔者还没学明白呢，敬请期待） 参考文章： 概念定义特点：https://juejin.im/post/6858129115598635015 函数式编程讲解：https://juejin.im/post/6844903743117361165 函数式编程讲解：https://juejin.im/post/6844903655397654535 拉勾教育大前端训练营笔记： https://zhuanlan.zhihu.com/p/162839608 what are “first class objects”：https://stackoverflow.com/questions/245192/what-are-first-class-objects","link":"/2020/10/13/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/"},{"title":"从零创建Cordova插件-进阶","text":"l cordova 开发进阶 l 开发进阶之插件配置 活动12345&lt;platform name=&quot;android&quot;&gt; &lt;config-file target=&quot;AndroidManifest.xml&quot; parent=&quot;/manifest/application&quot;&gt; &lt;activity android:name=&quot;cn.com.ths.thstoast.MyActivity&quot;/&gt; &lt;/config-file&gt;&lt;/platform&gt; 广播静态注册 12345678910&lt;platform name=&quot;android&quot;&gt; &lt;!-- 自定义的广播接收器 --&gt; &lt;receiver android:name=&quot;cn.com.ths.thstoast.MyBroadcastReceiver&quot; android:enabled=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;!-- 飞行模式开/关广播 --&gt; &lt;action android:name=&quot;android.intent.action.AIRPLANE_MODE&quot; /&gt; &lt;category android:name=&quot;$PACKAGE_NAME&quot; /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt;&lt;/platform&gt; 服务123456&lt;platform name=&quot;android&quot;&gt; &lt;service android:name=&quot;cn.com.ths.thstoast.MyService&quot; android:enabled=&quot;true&quot; android:exported=&quot;true&quot; /&gt;&lt;/platform&gt; 内容提供者1234567891011&lt;platform name=&quot;android&quot;&gt; &lt;!-- 访问其他应用的内容需要配置应用读写权限 --&gt; &lt;uses-permission android:name=&quot;android.permission.READ_CALENDAR&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_CALENDAR&quot;/&gt; &lt;!-- 如果不是上面Calendar这种系统provider(android.provider.*)，则需要注册 --&gt; &lt;provider android:name=&quot;org.apache.cordova.provider.TestContentProvider&quot; android:authorities=&quot;org.apache.cordova.provider.testprovider&quot; android:exported=&quot;false&quot; /&gt;&lt;/platform&gt; jar+aar+so 配置jar 配置123&lt;platform name=&quot;android&quot;&gt; &lt;lib-file src=&quot;src/android/libs/jpush-android-3.0.1.jar&quot; /&gt;&lt;/platform&gt; so 配置so 路径so 是在 NDK 平台开发的，NDK 是用来给安卓手机开发软件用的，但是和 SDK 不同的是它用的是 C 语言，而 SDK 用的是 Java 语言。NDK 开发的软件在安卓的环境里是直接运行的，一般只能在特定的 CPU 指令集的机器上运行。 so 配置通常配置在 libs 目录下 so plugin.xml 配置，注意输出路径子目录也要改123456&lt;source-file src=&quot;src/android/libs/armeabi/libjcore110.so&quot; target-dir=&quot;libs/armeabi&quot; /&gt; &lt;source-file src=&quot;src/android/libs/armeabi-v7a/libjcore110.so&quot; target-dir=&quot;libs/armeabi-v7a&quot; /&gt; &lt;source-file src=&quot;src/android/libs/arm64-v8a/libjcore110.so&quot; target-dir=&quot;libs/arm64-v8a&quot; /&gt; &lt;source-file src=&quot;src/android/libs/x86/libjcore110.so&quot; target-dir=&quot;libs/x86&quot; /&gt; &lt;source-file src=&quot;src/android/libs/x86_64/libjcore110.so&quot; target-dir=&quot;libs/x86_64&quot; /&gt;&lt;/source-file&gt; aar 配置aar 文件配置aar 和 jar 类似，但是他包含了所有资源，class 以及 res 资源文件，aar 和 gradle 通常放在 libs 下 gradle 配置gradle 中要在 repositories 中配置 flatDir，dependencies 中配置 compile 的 aar 包 123456789101112repositories{ jcenter() flatDir{ dirs 'libs' }}dependencies { compile 'com.android.support:appcompat-v7:23.1.0' compile(name:'ijkplayer-java-debug', ext:'aar') compile(name:'giraffeplayer-debug', ext:'aar')} aar plugin.xml12345 &lt;platform name=&quot;android&quot;&gt; &lt;framework src=&quot;src/android/libs/giraffeplayer-build.gradle&quot; custom=&quot;true&quot; type=&quot;gradleReference&quot; /&gt; &lt;resource-file src=&quot;src/android/libs/giraffeplayer-debug.aar&quot; target=&quot;libs/giraffeplayer-debug.aar&quot; /&gt; &lt;resource-file src=&quot;src/android/libs/ijkplayer-java-debug.aar&quot; target=&quot;libs/ijkplayer-java-debug.aar&quot; /&gt;&lt;/platform&gt; 静态资源和 java 文件静态资源路径静态资源规定放在 src/android/res 目录下 静态资源输出目录配置 通过 resource-file 和 source-file 配置当前路径和输出路径，静态资源默认路径是 src/android/res/xxx, 输出路径是 res/xxx12345678910111213&lt;platform name=&quot;android&quot;&gt; &lt;source-file src=&quot;src/android/res/drawable-hdpi/jpush_richpush_btn_selector.xml&quot; target-dir=&quot;res/drawable&quot; /&gt; &lt;source-file src=&quot;src/android/res/drawable-hdpi/jpush_richpush_progressbar.xml&quot; target-dir=&quot;res/drawable&quot; /&gt; &lt;source-file src=&quot;src/android/res/drawable-hdpi/jpush_ic_richpush_actionbar_back.png&quot; target-dir=&quot;res/drawable-hdpi&quot; /&gt; &lt;source-file src=&quot;src/android/res/drawable-hdpi/jpush_ic_richpush_actionbar_divider.png&quot; target-dir=&quot;res/drawable-hdpi&quot; /&gt; &lt;source-file src=&quot;src/android/res/layout/jpush_popwin_layout.xml&quot; target-dir=&quot;res/layout&quot; /&gt; &lt;source-file src=&quot;src/android/res/layout/jpush_webview_layout.xml&quot; target-dir=&quot;res/layout&quot; /&gt; &lt;source-file src=&quot;src/android/res/layout/test_notification_layout.xml&quot; target-dir=&quot;res/layout&quot; /&gt; &lt;source-file src=&quot;src/android/res/values/jpush_style.xml&quot; target-dir=&quot;res/values&quot; /&gt;&lt;/platform&gt; java 文件路径java 文件通常放在 src/android 目录下 java 文件输出目录配置 默认路径是 src/android/Xxx.java 输出目录是 src/包/名/字/，注意 target-dir 是目录路径，target 才是文件路径1234&lt;platform name=&quot;android&quot;&gt; &lt;source-file src=&quot;src/android/MyReceiver.java&quot; target-dir=&quot;src/cn/jpush/phonegap&quot; /&gt; &lt;source-file src=&quot;src/android/JPushPlugin.java&quot; target-dir=&quot;src/cn/jpush/phonegap&quot; /&gt;&lt;/platform&gt; meta-data拿一个分享插件举例做示范 plugin.xml：配置 preference，用于接收用户传参 variable 的值，config-file 中配置 meta-data, 保存参数键值信息用于给 java 类调用。 1234567891011&lt;preference name=&quot;WEIXIN_APP_ID&quot; /&gt;&lt;platform name=&quot;android&quot;&gt; &lt;preference name=&quot;WEIXIN_APP_ID&quot; value=&quot;WEIXIN_APP_ID&quot; /&gt; &lt;!-- 友盟 AK --&gt; &lt;meta-data android:name=&quot;WEIXIN_APP_ID&quot; android:value=&quot;WEIXIN_APP_ID&quot; &gt; &lt;/meta-data&gt;&lt;/platform&gt; 权限当需要使用系统的某个功能时，一定要加上权限询问配置，所有的权限在这查看 1234567891011&lt;platform name=&quot;android&quot;&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_LOCATION_EXTRA_COMMANDS&quot; /&gt;&lt;/platform&gt; l 开发进阶之插件实现 开启活动简单来说，活动相当于 angular 的 page，vue 的 vue，是一个可包含组件（fragment）的 ui 页面。 开启普通活动12345678910111213141516171819202122232425// 应用上下文Context context = cordova.getActivity().getApplicationContext();String pkgName = context.getPackageName();// 打开app应用Intent intent = context .getPackageManager() .getLaunchIntentForPackage(pkgName);// 打开XxxActivity// Intent intent=new Intent(cordova.getActivity(), XxxActivity.class);// 打开应用必须要加 CATEGORY_LAUNCHERintent.addCategory(Intent.CATEGORY_LAUNCHER);intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_SINGLE_TOP);// 启动应用context.startActivity(intent);// 启动活动// cordova.getActivity().startActivity(intent);// 启动有返回值的活动// cordova.startActivityForResult((CordovaPlugin) this, intent, 0); 本插件中开启活动代码 1234567891011public class ThsToast extends CordovaPlugin { private static final String TAG = &quot;ThsToast&quot;; @Override public boolean execute(String action, JSONArray args, CallbackContext callbackContext) throws JSONException { Log.d(TAG, &quot;start execute!&quot;); // 启动活动 Intent intent = new Intent(cordova.getActivity(), MyActivity.class); cordova.getActivity().startActivity(intent); }} 启动活动演示： 打开第三方 Android SDK 活动 如:百度地图 uri12345678// 如果有百度地图 uri详情：http://lbsyun.baidu.com/index.php?title=uri/api/androidIntent intent = Intent.parseUri(&quot;intent://map/direction?&quot; + &quot;origin=&quot;+options.getOrigin4Baidu() + &quot;&amp;destination=&quot;+options.getDestination4Baidu() + &quot;&amp;mode=&quot;+options.getModel4Baidu() + &quot;&amp;coord_type=wgs84&amp;referer=Autohome|GasStation#Intent;scheme=bdapp;package=com.baidu.BaiduMap;end&quot;,0);cordova.getActivity().startActivity(intent); 使用广播广播其实就是一个在 app 范围内的事件推送和接受中心，类似于 iframe 的 postMessage。 在 cordova 项目中使用和原生广播没有区别，一般静态广播用在插件比较多，如果是动态广播，则需要在 activity 中通过 registerReceiver 注册 12345678910111213public class ThsToast extends CordovaPlugin { private static final String TAG = &quot;ThsToast&quot;; @Override public boolean execute(String action, JSONArray args, CallbackContext callbackContext) throws JSONException { Log.d(TAG, &quot;start execute!&quot;); // 动态注册广播： MyBroadcastReceiver myReceiver = new MyBroadcastReceiver(); IntentFilter itFilter = new IntentFilter(); itFilter.addAction(&quot;android.intent.action.AIRPLANE_MODE&quot;); cordova.getContext().registerReceiver(myReceiver, itFilter); }} android/MyBroadcastReceiver.java 1234567891011public class MyBroadcastReceiver extends BroadcastReceiver { private String ACTION_BOOT = &quot;android.intent.action.AIRPLANE_MODE&quot;; @Override public void onReceive(Context context, Intent intent) { String action = intent.getAction(); if (ACTION_BOOT.equals(action)) { Toast.makeText(context, &quot;切换飞行模式！&quot;, Toast.LENGTH_SHORT).show(); } }} 广播效果演示： 使用服务服务可以同步或执行一些小任务、小进程，甚至对其他进程的 ui 页面做操作，可类比 angular 的 service 服务。 和原生 Service 一样的用法 12345678910public class ThsToast extends CordovaPlugin { private static final String TAG = &quot;ThsToast&quot;; @Override public boolean execute(String action, JSONArray args, CallbackContext callbackContext) throws JSONException { Log.d(TAG, &quot;start execute!&quot;); // 启动服务 cordova.getContext().startService(new Intent(cordova.getActivity(), MyService.class)); }} 使用内容提供者内容提供者其实是一个手机系统范围的 API 调度中心，比如可以读取和修改通讯录和相册的内容。 使用 jar+aar+so使用 jarjar 包可以理解为 api 的集合，解压后全部是编译好的 class，但是不包含资源文件，可以直接使用使用其中的类。jar 包路径通常位于 libs 目录下查看依赖的 api 源文件 使用 so通常在 jar 中使用 使用 aar例如跳转 activity 使用 meta-data保存用户添加插件时传入的参数键值对象 meta-data 在 java 中获取参数对象Plugin.java：通过 cordova.getActivity().getPackageManager().getApplicationInfo(cordova.getActivity().getPackageName(), PackageManager.GET_META_DATA)获取参数存储的对象 appInfo，再通过 appInfo.metaData.getType(key)取得参数 value，getType 有 getString、getInt…… meta-data 如何传参传入插件参数有两种办法， 1.用 cordova 安装时利用–variable key=value 传入 1cordova plugin add cordova-plugin-share --variable WEIXIN_APP_ID=xxx --variable WEIXIN_APP_SECRET=xxx 2.添加插件完成后，在项目的 config.xml 中手动添加，cordova build 后生效 1234&lt;plugin name=&quot;cordova-plugin-share&quot; spec=&quot;1.0.0&quot;&gt; &lt;variable name=&quot;WEIXIN_APP_ID&quot; value=&quot;xxx&quot; /&gt; &lt;!--...--&gt;&lt;/plugin&gt; 使用权限1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import android.Manifest;public static final String WRITE = Manifest.permission.WRITE_EXTERNAL_STORAGE;public static final String READ = Manifest.permission.READ_EXTERNAL_STORAGE;public static final int REQ_CODE = 0;@Overridepublic boolean execute(String action, JSONArray args, CallbackContext callbackContext) throws JSONException { if (action.equals(&quot;show&quot;)) { this.args = args; this.callbackContext = callbackContext; if (cordova.hasPermission(READ) &amp;&amp; cordova.hasPermission(WRITE)) { // 有权限则跳转活动 this.launchActivity(); } else { // 若没有权限则请求 this.getPermission(); } return true; } return false;}/*** 请求权限**/protected void getPermission() { cordova.requestPermissions(this, REQ_CODE, new String[]{WRITE, READ});}@Overridepublic void onRequestPermissionResult(int requestCode, String[] permissions, int[] grantResults) throws JSONException { for (int r : grantResults) { if (r == PackageManager.PERMISSION_DENIED) { this.callbackContext.sendPluginResult(new PluginResult(PluginResult.Status.ERROR, PERMISSION_DENIED_ERROR)); return; } } switch (requestCode) { case REQ_CODE: launchActivity(); break; }} 使用生命周期和常用钩子excute：执行插件方法调用插件执行方法。第一个参数 action 是调用的方法名，第二个参数 args 是传入的参数数组，第三个参数 CallbackContext 是传入的回调函数上下文，可以通过 callbackContext.success(message)和 callbackContext.error(errorMessage)传入回调参数; 123@Overridepublic boolean execute(String action, JSONArray args, CallbackContext callbackContext) throws JSONException {} initialize：初始化在插件构造函数执行和字段初始化之后调用，此时尚未执行 excute 方法。 12@Overridepublic void initialize (CordovaInterface cordova, CordovaWebView webView) {} pluginInitialize：无参初始化在插件构造函数执行和字段初始化之后调用，没有参数，此时尚未执行 excute 方法，pluginInitialize 不支持 cordova 3.0-3.5 。 12@Overrideprotected void pluginInitialize() {} 插件初始化到执行的过程执行顺序如下，依次是 initialize、pluginInitialize、execute： 1232020-09-03 00:20:34.928 19307-19435/com.ths.exam.lilin D/ThsToast: start initialize!2020-09-03 00:20:34.928 19307-19435/com.ths.exam.lilin D/ThsToast: start pluginInitialize!2020-09-03 00:20:34.929 19307-19435/com.ths.exam.lilin D/ThsToast: start execute! onStart：活动开始周期活动正在被启动，已经可见，但是还没位于前台。 12@Overridepublic void onStart() {} onResume：活动恢复周期活动位于前台，并且可以与用户交互了。 12345678910/** * 当活动将开始与用户互动时调用。 * * @param multitasking 表示是否为应用程序打开了多任务 */@Overridepublic void onResume(boolean multitasking) { super.onResume(multitasking); // deviceready();} onPause：活动暂停周期活动处于正在停止的状态，通常当要离开这活动的时候会被调用。接下去 onStop()马上会被调用，如果是弹出一个对话框，那么 onStop 不会被调用。 123456789/** * 在系统即将开始恢复上一个活动时调用 * * @param multitasking 表示是否为应用程序打开了多任务 */@Overridepublic void onPause(boolean multitasking) { super.onPause(multitasking);} onStop：活动停止周期活动即将停止，活动完全不可见。 1234567/** * 活动停止前调用 */@Overridepublic void onStop() { super.onStop();} onReset：活动重置周期这个方法表示活动正在重新启动，活动由停止状态恢复为运行状态，通常由上一个活动返回到这个活动时，这个活动会调用此方法。 12345/** * 当视图导航时调用 */@Overridepublic void onReset() {} onActivityResult：返回活动数据当从另一个活动返回到当前活动时，当前活动中的 onActivityResult 可接收刚才活动的返回数据。 1234@Overridepublic void onActivityResult(int requestCode, int resultCode, Intent intent) { super.onActivityResult(requestCode, resultCode, intent);} onDestroy：活动销毁周期活动完全销毁前调用，可以在这做一些资源释放的操作。 1234567/** * 活动销毁前调用 */@Overridepublic void onDestroy() { // deviceready = false;} l 总结本文从创建一个简单的 cordova 自定义插件，到四大组件的配置和使用，以及如何导入和使用 jar、aar、so、静态资源方面做了详细讲解，最后归纳了常用的生命周期和回调方法。看到这，我们应该已经具备独立创建和改写插件的基本能力，剩下的就只有自己多看多用 cordova-plugin，实践出真知，若有总结不到位或者遗漏的地方，还请各位朋友多多指出，共同交流完善！如果这篇文章对前端或其他方向的你有所帮助或者启发，记得点个赞哦亲：） l 下载文中演示的插件1cordova plugin add cordova-plugin-ths-toast","link":"/2020/10/14/%E4%BB%8E%E9%9B%B6%E5%88%9B%E5%BB%BACordova%E6%8F%92%E4%BB%B6-%E8%BF%9B%E9%98%B6/"},{"title":"原型链详解","text":"原型链详解一、什么是原型链1994 年，网景公司（Netscape）发布了 Navigator 浏览器 0.9 版后，意识到 Web 需要变得更加动态。该公司的创始人马克·安德森（Marc Andreessen）认为 HTML 需要一种“胶水语言”，Web 设计人员和兼职程序员可以轻松地使用它们来组装诸如图像和插件之类的组件，这些代码可以直接在网页中编写。 1995 年，该公司招募了 Brendan Eich，其目标是创建一个脚本语言将补充 Java，并且应具有相似的语法。艾克（Eich）在 1995 年 5 月的 10 天内就发明了一个。尽管该语言是以 Mocha 的名称开发的，但该语言在 1995 年 9 月首次发布于 Netscape Navigator 2.0 的 Beta 版本中时正式被称为 LiveScript，但当它于 12 月在 Netscape Navigator 2.0 beta 3 中进行部署时被重新命名为 JavaScript。 Javascript 和基于类的语言（Java、C#）不同，它参考了 Self 语言（一种基于原型的面向对象程序设计语言），通过原型来实现继承（方法或属性的共享），确切地说是委托。 当在某个对象上的方法或属性不存在时，会在它的原型上去查找，如还不存在就会去它原型的原型上查找，这样形成一条链路就是原型链。 可以理解为下文要提到的 person.proto.proto.proto… 二、JS 创建对象的三种方式有人说 JS 一切皆对象，是错误的！原始值就不是。那么对象如何创建呢？ 2.1 使用 new 加 函数创建对象12345var person = new Object();person.name = &quot;lili&quot;;person.sayHello = function () { console.log(&quot;Hello!&quot;);}; 2.2 使用字面量创建对象123456var person = {​ name: 'lili',​ sayHello: function () {​ console.log('Hello!')​ } } 注：var person = {} 等同于 var person = new Object()。 2.3 使用 Object.create()方法创建对象123456789var person = {​ name: 'lili',​ sayHello: function () {​ console.log('Hello!')​ } } var me = Object.create(person); me.name = 'wangwang'; Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__，即： me.__proto__=== person。 三、构造函数3.1 构造函数是什么？通过 new 函数名来实例化对象的函数叫构造函数。 任何的函数都可以作为构造函数。 之所以有构造函数与普通函数之分，主要从功能上进行区别的，构造函数的主要功能为初始化对象,特点是和 new 一起使用。构造函数可以为初始化的对象添加属性和方法。 下面我们从例子看下构造函数。 123function Person() {}var person1 = new Person();var person2 = new Person(); 上面的 person1 和 person2 都是通过 Person 函数实例化出来的。这个 Person 函数就是当前 person1 和 person2 的构造函数。对象上的 constructor 属性可以指明这个对象的构造函数是什么。 12person1.constructor === Person; // trueperson2.constructor === Person; // true 对于上面的 Person 函数来说，本身也是一个对象，那么这个对象是如何实例化出来的呢? 它的 constructor 又指向谁呢? 那就要说到创建函数对象的方法。 123456function foo() { console.log(&quot;你好&quot;);}var foo1 = new Function('console.log(&quot;你好2&quot;)');foo();foo1(); Person 函数是由 JS 内置函数 Function 函数实例化，Person.constructor === Function。而 Function 本身还是个构造函数，它的 constructor 是本身。 3.2constructor 属性在哪里当你打开编辑器，按我上面的例子去打印上面的例子中的 person1，查看它的 constructor 属性，会发现看不见 constructor 属性呢？打印如下： 为什么呢，明明可以访问到啊（person2.constructor === Person），这个问题先留着，接着往下看。 四、prototype 是什么，有什么用呢4.1prototype 的意义上面的通过 new 创建实例的方法中我们如何做到共享属性和方法呢？ 比如，所有的实例都具有黑色头发这个属性，都有可以说话这个方法，那么我们通过上面的方法创建实例，如何添加这个属性和方法呢。代码如下： 1234567891011function Person() {}var person1 = new Person();var person2 = new Person();person1.hairColor = &quot;black&quot;;person2.hairColor = &quot;black&quot;;person1.sayHello = function () { console.log(&quot;Hello!&quot;);};person2.sayHello = function () { console.log(&quot;Hello!&quot;);}; 如果，我现在要修改，所有这些实例的对象的头发都是红色，怎么办？又去每个对象都修改为红色？代码冗余。有人说，那我可以把属性的复制放在构造函数中完成，比如： 123456function Person() { this.hairColor = &quot;balck&quot;; this.sayHello = function () { console.log(&quot;Hello!&quot;); };} 没有问题。那么我再提另一个问题，假如这些人都共享居所，或者资金，比如北京有一套房。那么，如果其中有一个人赚了一套房，这些人是可以共享的，那么上面的方法如何做到呢？ 同时，每次实例化都要为属性和方法开辟新的内存空间,那如果实例多个对象的话，非常浪费内存空间。 那么基于上面的问题，就需要说到 prototype 属性，给构造函数设置一个 prototype 属性。这个属性是一个对象，所有实例对象需要共享的属性和方法，都放在这个对象里面。代码示例如下： 1234567function Person() {}Person.prototype.hairColor = &quot;back&quot;;Person.prototype.sayHello = function () { console.log(&quot;Hello!&quot;);};var person1 = new Person();var person2 = new Person(); 用上面的方法，可以解决内存浪费问题，所有共享属性和方法都放在 prototype 中，只需要开辟其相对应的内存，同时也能实现数据共享和继承。那么 Function 作为 Person 函数的构造函数，是不是也应该有个 prototype 属性，存放 Person 函数可以从 Function 那里共享的属性和方法呢。 上面已经说了 prototype 的作用，所有函数都可以是构造函数，所以，所有函数都具有 prototype 属性，里边可存放所有可供其实例继承的共享属性和方法。 总结：1.所有函数都具有 prototype 属性。2.prototype 存放了实例的共享属性和方法。3.prototype 是一个对象，有的人称它为显式原型。 4.2constructor 的真正位置那么说到这里，我们解决下 3 留下的问题，为什么实例打印的时候没有显示它的 constructor 这个属性呢。假如每个实例都给赋值了一个 constructor 属性，类似于我们 3 中说的那样，那是不是就遇到了我们 3 说的问题呢，会不断开辟内存去存放，浪费内存，所以，同理，实例的 constructor 存放在这个实例的构造函数的 prototype 中共享。 五、__proto__是什么，有什么用？5.1 [[Prototype]]属性我们上面说到了 prototype 存放了共享的属性和方法，那么我们的实例是如何继承这些共享的属性和方法。我们自然会想到在每个实例对象内部创建一个属性等于自己的原型（构造函数上的 prototype）。是不是就可以通过对象去获取到共享的属性和方法了呢？（及 person1.这个属性 === Person.prototype，又因为 Person.prototype 里存放了 hairColor 属性，所以，通过 person1.这个属性.hairColor 就可以获取这个共享的 hairColor 的值是多少。） [[Prototype]]就是所说的这个对象属性，指向同构造函数上的 prototype，也是这个实例真正意义上的原型对象，这个属性是内部隐藏属性，不对外提供访问，所以我们通过 对象.[[Prototype]] 无法查看和修改原型上的属性和方法。 那么说到这里，结合前面说到问题，是不是有人会问， 既然对象.[[Prototype]]=== 构造函数.prototype。那我是不是只要获取到构造函数的 prototype，就可以查看原型对象和修改原型对象呢。没错，是的，只要你知道这个对象的构造函数。那你可能接着问，那还不简单，前面不是说了嘛，对象.constructor === 对象的构造函数。那我是不是就可以通过对象.constructor 找到对象的构造函数呢。那么，我们接着往下看。 5.2 constructor 不可信修改上面相关列子，如果定义一个 Dog 函数，Dog 函数共享的头发颜色是红色， person1.constructor = Dog,那么这个时候 person1 的 hairColor 颜色是什么呢。代码如下 12345678910111213function Person() {}Person.prototype.hairColor = &quot;back&quot;;Person.prototype.sayHello = function () { console.log(&quot;Hello!&quot;);};var person1 = new Person();var person2 = new Person();function Dog() {}person1.constructor = Dog;Dog.prototype.hairColor = &quot;red&quot;; // 在Dog.prototype上定义hairColor属性console.log(person1.constructor); // Dogconsole.log(person2.constructor); // Personconsole.log(person1.hairColor); // balck 所以从上面的例子可以看出 person1.constructor 是 Dog，但是头发颜色是 balck 而不是 red，所以通过 constructor 去获取实例的构造函数，然后获取共享属性（hairColor）的方法不可取。 那我想获取到原型对象，查看共享的属性和方法，以及实现修改共享的属性和方法咋办啊？ [[Prototype]]属性我又得不到。接着往下看。 5.3 __proto__为了实现上面我们说的问题，后来许多浏览器厂商实现了 __proto__属性 ，（最开始是火狐浏览器提供的__proto__）暴露了对象的[[Prototype]]。__proto__指向了[[Prototype]]，我们就可以通过对象.__proto__得到对象原型对象上的属性和方法，同样也可以去修改。 对象.[[Prototype]] = 创建自己的构造函数内部的 prototype（原型对象） 对象.__proto__= 对象.[[Prototype]] 对象.__proto__ = 创建自己的构造函数内部的 prototype（原型对象） 注意：__proto__在 ES6 以前不是 JS 标准，是浏览器给提供的。由于越来越流行，运用广泛，在 es6 规范中被标准化为传统功能，以确保 Web 浏览器的兼容性。它已被不推荐使用, 现在更推荐使用 Object.getPrototypeOf，Object.setPrototypeOf。 那么，上面的图中 Function 函数也是一个对象，它的__proto__指向了什么呢？我们说了对象.__proto__ = 对象的构造函数.prototype。由于上面讲到过的，那么 Function 的构造函数是其本身，所以 Function.__proto__ === Function.prototype。 六、原型模式 JavaScript 中除了基础类型外的数据类型，都是对象（引用类型）。但是由于其没有类（class，ES6 引入了 class，但其只是语法糖）的概念，如何将所有对象联系起来就成立一个问题，于是就有了原型和原型链的概念。 所有的引用类型（数组、对象、函数）都有一个 __proto__属性(隐式原型属性），本质是个对象。 所有的函数，都有一个 prototype(显式原型）属性，存放了其实例可共享的属性和方法。 对象的__proto__等于实例这个对象的构造函数的 prototype。 Object.prototype 没有 __proto__，这也是原型链的终点。 上面总结了下原型链的基本知识，下面我们通过例子详细说明。 七、通过例子详细说明原型链的查找7.1 原型链上查找某个对象是否具有某个属性所谓的原型链上去查找，其实就是通过对象的__proto__去查找。（这个链可以理解为用__proto__去连接） 1.先查看实例上是否具有该属性。及对象.属性是否有值有就找到了。 2.如果 1 中没找到，就去实例的原型对象（proto ）找有没有该属性。及**对象.__proto__**上是否有值 。 3.如果 2 中没找到，就对象.__proto__.__proto__**找有没有该属性。一直通过.__proto__链接下去，直到终点。** 我们下面通过详细的例子说明原型链的查找，找下这个人的头发是什么颜色。 7.2 例子 11234567function Person(name) { this.name = name;}var person1 = new Person(&quot;lili&quot;);person1.hairColor = &quot;red&quot;;console.log(person1);console.log(person1.hairColor); person1 被 Person 构造函数实例化，我们给这个 person1 加了属性 hairColor，这个时候 person1 上具有 hairColor 的（person1.hairColor = ‘red’），就是我们后来给他赋值的颜色，红色。打印如下： 7.3 例子 212345678function Person(name) { this.name = name;}Person.prototype.hairColor = &quot;black&quot;;var person1 = new Person(&quot;lili&quot;);console.log(person1);console.dir(Person);console.log(person1.hairColor); 第一步：person1 被构造函数实例化的时候，是否初始化了 hairColor 的值呢。我们可以从上面的代码中看见，构造函数只初始化了一个属性 name 的值，所以 personOne 没有 hairColor 这个值。打印如下图： 第二步：这个对象是否有像例子 1 中（person1.hairColor = ‘red’），给实例对象赋值。显然也没有。对象实例上没有找到 hairColor 这个属性。 第三步：找这个对象的原型对象及 person1.__proto__是否有 hairColor 的值； person1.__proto__ === person1 的构造函数.prototype 及 Person.prototype； Person.prototype 有没有 hairColor 这个属性呢？看代码 Person.prototype.hairColor = ‘black’，是有的，黑色，原型链查找结束。所以我们知道了 person1 的原型的头发是黑色的，所以 person1 继承这个头发的颜色，也是黑色的。如下图： 所以 person1.hairColor === ‘black’； 那么有个问题，原型链不断向上查找的头是哪里呢？ 我们再看个例子，去掉上个例子中 Person.prototype.hairColor = ‘black’，如下： 7.4 例子 31234567function Person(name) { this.name = name;}var person1 = new Person(&quot;lili&quot;);console.log(person1);console.dir(Person);console.log(person1.hairColor); 还是查找 person1.hairColor 的值。 第一步：如上个例子的第一步，不细说了。 第二步：如上个例子第二步，不细说了。 第三步：如上个例子第三步，这个时候我们发现，Person.prototype 也没有 hairColor 的值。 及 person1.proto上也没找到 hairColor 的值。 第四步：（1）查找 person1.__proto__.__proto__，那么 person1.__proto__.__proto__是什么呢？ （2）第三步中我们知道了 person1.__proto__=== Person.prototype，person1.__proto__.__proto__ === Person.prototype.__proto__。 （3）那么 Person.prototype 是什么呢？是 Person 函数的原型，本身是个对象，那么对象.__proto__=== 对象的构造函数的 prototype，那这个对象的构造函数是什么呢，是 JS 的内置 Object 函数实例化的。所以上面的问题就变成 Person.prototype.__proto__=== Object.prototype。查找 Object 函数的 prototype 上是否有 hairColor 属性吗？显然也没有。继续查找。 第四步：查找 person1.__proto__.__proto__.__proto__，及 Object.prototype 的__proto__，而 Object.prototype 是没有__proto__，所以到此结束。 八、JS 的内置函数8.1Array ​ Array.prototype // [] ​ Array.__proto__ // Function.prototype Array.__proto__.__proto__ {}.__proto__ === Object.prototype 8.2 Object ​ Objecy.prototype // {} ​ Objecy.__proto__ // Function.prototype 8.3Function ​ Function.prototype // ƒ () ​ Function.__proto__ // Function.prototype 8.4String ​ String.prototype // 空字符串 ​ String.__proto__ // Function.prototype 就这些呢，其他自己看吧。 九、实战9.1 题 1123456789101112131415 function A() {} function B(a) { this.a = a; } function C(a) { if (a) { ​ this.a = a; } } A.prototype.a = 1; B.prototype.a = 1; C.prototype.a = 1;​ console.log(new A().a);​ console.log(new B().a); console.log(new C(2).a); 9.2 题 2123456789101112131415161718var F = function () {};Object.prototype.a = function () { console.log(&quot;a()&quot;);};Function.prototype.b = function () { console.log(&quot;b()&quot;);};var f = new F();F.a();F.b();f.a();f.b();console.log(new A().a);console.log(new B().a);console.log(new C(2).a); 答案：a() b() a() f.b is not a function 参考文章：https://juejin.im/post/6844903837623386126#heading-4","link":"/2020/10/19/%E5%8E%9F%E5%9E%8B%E9%93%BE%E8%AF%A6%E8%A7%A3/"},{"title":"HTTP协议演变","text":"简介HTTP（HyperText Transfer Protocol）是万维网（World Wide Web）的基础协议。自 Tim Berners-Lee 博士和他的团队在 1989-1991 年间创造出它以来，HTTP 已经发生了太多的变化，在保持协议简单性的同时，不断扩展其灵活性。如今，HTTP 已经从一个只在实验室之间交换文件的早期协议进化到了可以传输图片，高分辨率视频和 3D 效果的现代复杂互联网协议。 1 HTTP/0.9最初版本的 HTTP 协议并没有版本号，后来它的版本号被定位在 0.9 以区分以后的版本。 HTTP/0.9 极其简单：请求由单行指令构成，以唯一可用方法 GET 开头，其后跟目标资源的路径（一旦连接到服务器，协议、服务器、端口号这些都不是必须的）。 GET /mypage.html 响应也极其简单的：只包含响应文档本身。 123&lt;HTML&gt;这是一个非常简单的HTML页面&lt;/HTML&gt; 跟后来的版本不同，HTTP/0.9 的响应内容并不包含 HTTP 头，这意味着只有 HTML 文件可以传送，无法传输其他类型的文件；也没有状态码或错误代码：一旦出现问题，一个特殊的包含问题描述信息的 HTML 文件将被发回，供人们查看。 2 HTTP/1.01996 年 11 月，一份新文档（RFC 1945）被发表出来，文档 RFC 1945 定义了 HTTP/1.0，但它是狭义的，并不是官方标准。新增了一下主要内容： 具备了传输除纯文本 HTML 文件以外其他类型文档的能力 引入了 HTTP 头的概念，无论是对于请求还是响应，允许传输元数据，使协议变得非常灵活，更具扩展性。 其次，除了 GET 命令，还引入了 POST 命令和 HEAD 命令，丰富了浏览器与服务器的互动手段。 状态码会在响应开始时发送，使浏览器能了解请求执行成功或失败，并相应调整行为协议版本信息现在会随着每个请求发送（HTTP/1.0 被追加到了 GET 行）。 2.1 请求格式1234567891011GET /mypage.html HTTP/1.0User-Agent: NCSA_Mosaic/2.0 (Windows 3.1)200 OKDate: Tue, 15 Nov 1994 08:12:31 GMTServer: CERN/3.0 libwww/2.17Content-Type: text/html&lt;HTML&gt;一个包含图片的页面 &lt;IMG SRC=&quot;/myimage.gif&quot;&gt;&lt;/HTML&gt; 接下来是第二个连接，请求获取图片： 12345678GET /myimage.gif HTTP/1.0User-Agent: NCSA_Mosaic/2.0 (Windows 3.1)200 OKDate: Tue, 15 Nov 1994 08:12:32 GMTServer: CERN/3.0 libwww/2.17Content-Type: text/gif(这里是图片内容) 第一行是请求命令，必须在尾部添加协议版本（HTTP/1.0）。后面就是多行头信息，描述客户端的情况。回应的格式是”头信息 + 一个空行（\\r\\n） + 数据”。其中，头信息第一行是”协议版本 + 状态码（status code） + 状态描述”。 2.2 头信息中一些字段说明2.2.1 Content-Type 字段关于字符的编码，1.0 版规定，头信息必须是 ASCII 码，后面的数据可以是任何格式。因此，服务器回应的时候，必须告诉客户端，数据是什么格式，这就是 Content-Type 字段的作用。下边常见 Content-Type 字段的值： 123456text/htmltext/cssimage/pngimage/gifapplication/javascriptapplication/octet-stream 这些数据类型总称为 MIME type，MIME type 还可以在尾部使用分号，添加参数。 Content-Type: text/html; charset=utf-8 客户端请求的时候也可以使用 Accept 声明自己接收的数据格式 accept: */* 2.2.2 Content-Encoding 字段由于传输的数据可能比较大，一次可以将数据压缩后进行传输。Content-Encoding 字段就是说明数据压缩的方法。 123content-encoding: gzipContent-Encoding: compressContent-Encoding: deflate 客户端在请求时，使用 Accept-Encoding 字段说明自己可以接受哪些压缩方法。 Accept-Encoding: gzip, deflate 2.3 缺点HTTP/1.0 版的主要缺点是，每个 TCP 连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。TCP 连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）。所以，HTTP 1.0 版本的性能比较差。随着网页加载的外部资源越来越多，这个问题就愈发突出了。为了解决这个问题，有些浏览器在请求时，用了一个非标准的 Connection 字段。 Connection: keep-alive 这个字段要求服务器不要关闭 TCP 连接，以便其他请求复用。服务器同样回应这个字段。 Connection: keep-alive 一个可以复用的 TCP 连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段，不同实现的行为可能不一致，因此不是根本的解决办法。 3 HTTP/1.11997 年 1 月，HTTP/1.1 版本发布，只比 1.0 版本晚了半年。它进一步完善了 HTTP 协议，一直用到了 20 年后的今天，直到现在还是最流行的版本。 3.1 持久连接1.1 版的最大变化，就是引入了持久连接（persistent connection），即 TCP 连接默认不关闭，可以被多个请求复用，不用声明 Connection: keep-alive。 客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送 Connection: close，明确要求服务器关闭 TCP 连接。 目前，对于同一个域名，大多数浏览器允许同时建立 6 个持久连接。 3.2 管道机制1.1 版还引入了管道机制（pipelining），即在同一个 TCP 连接里面，客户端可以同时发送多个请求。这样就进一步改进了 HTTP 协议的效率。 举例来说，客户端需要请求两个资源。以前的做法是，在同一个 TCP 连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求。管道机制则是允许浏览器同时发出 A 请求和 B 请求，但是服务器还是按照顺序，先回应 A 请求，完成后再回应 B 请求。 3.3 Content-Length 字段一个 TCP 连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的。这就是 Content-length 字段的作用，声明本次回应的数据长度。 Content-Length：3495 上面代码告诉浏览器，本次回应的长度是 3495 个字节，后面的字节就属于下一个回应了。 在 1.0 版中，Content-Length 字段不是必需的，因为浏览器发现服务器关闭了 TCP 连接，就表明收到的数据包已经全了。 3.4 分块传输编码使用 Content-Length 字段的前提条件是，服务器发送回应之前，必须知道回应的数据长度。 对于一些很耗时的动态操作来说，这意味着，服务器要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，采用”流模式”（stream）取代”缓存模式”（buffer）。 因此，1.1 版规定可以不使用 Content-Length 字段，而使用”分块传输编码”（chunked transfer encoding）。只要请求或回应的头信息有 Transfer-Encoding 字段，就表明回应将由数量未定的数据块组成。 Transfer-Encoding: chunked 每个非空的数据块之前，会有一个 16 进制的数值，表示这个块的长度。最后是一个大小为 0 的块，就表示本次回应的数据发送完了。下面是一个例子。 1234567891011121314151617HTTP/1.1 200 OKContent-Type: text/plainTransfer-Encoding: chunked25This is the data in the first chunk1Cand this is the second one3con8sequence0 3.5 其他功能1.1 版还新增了许多动词方法 PUT、PATCH、HEAD、 OPTIONS、DELETE 。另外，客户端请求的头信息新增了 HOST 字段，用来指定服务器的域名。 Host: www.example.com 有了 HOST 字段，就可以将请求发往同一台服务器上的不同网站，为虚拟主机的兴起打下了基础。 3.6 缺点虽然 1.1 版允许复用 TCP 连接，但是同一个 TCP 连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为”队头堵塞”（Head-of-line blocking）。 为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久连接。这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入 CSS 代码、域名分片（domain sharding）等等。如果 HTTP 协议设计得更好一些，这些额外的工作是可以避免的。 4 SPDY 协议2009 年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP/1.1 效率不高的问题。这个协议在 Chrome 浏览器上证明可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 之中得到继承。 5 HTTP/22015 年，HTTP/2 发布。它不叫 HTTP/2.0，是因为标准委员会不打算再发布子版本了，下一个新版本将是 HTTP/3。RFC 7540 定义了 HTTP/2 的协议规范和细节。 在开放互联网上 HTTP 2.0 将只用于 https://网址，而 http://网址将继续使用HTTP/1，目的是在开放互联网上增加使用加密技术，以提供强有力的保护去遏制主动攻击 。 5.1 http2 优势5.1.1 二进制协议HTTP/1.1 版的头信息肯定是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”（frame）：头信息帧和数据帧。 二进制协议的一个好处是，可以定义额外的帧。HTTP/2 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。 5.1.2 多工（多路复用）HTTP/2 复用 TCP 连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”。 举例来说，在一个 TCP 连接里面，服务器同时收到了 A 请求和 B 请求，于是先回应 A 请求，结果发现处理过程非常耗时，于是就发送 A 请求已经处理好的部分， 接着回应 B 请求，完成后，再发送 A 请求剩下的部分。 这样双向的、实时的通信，就叫做多工（Multiplexing）。 5.1.3 数据流因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。 HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流 ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID 一律为奇数，服务器发出的，ID 为偶数。 数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM 帧），取消这个数据流。1.1 版取消数据流的唯一方法，就是关闭 TCP 连接。这就是说，HTTP/2 可以取消某一次请求，同时保证 TCP 连接还打开着，可以被其他请求使用。 客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。 5.1.4 头信息压缩HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。 HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。 5.1.5 服务器推送HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。 常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析 HTML 源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预测到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。 6 HTTP 与 HTTPS由于 http/2 是完全使用 https 协议的，需要了解下 http 和 https 的区别。HTTPS 协议可以理解为 HTTP 协议的升级，就是在 HTTP 的基础上增加了数据加密。在数据进行传输之前，对数据进行加密，然后再发送到服务器。这样，就算数据被第三者所截获，但是由于数据是加密的，所以你的个人信息仍然是安全的。这就是 HTTP 和 HTTPS 的最大区别。 6.1 SSL/TLS互联网的通信安全，建立在 SSL/TLS 协议之上，SSL“安全套接层”协议，TLS“安全传输层”协议，都属于是加密协议，在其网络数据传输中起到保护隐私和数据的完整性。保证该网络传输的信息不会被未经授权的元素拦截或修改，从而确保只有合法的发送者和接收者才能完全访问并传输信息。 SSL :（Secure Socket Layer，安全套接字层），位于可靠的面向连接的网络层协议和应用层协议之间的一种协议层。SSL 通过互相认证、使用数字签名确保完整性、使用加密确保私密性，以实现客户端和服务器之间的安全通讯。该协议由两层组成：SSL 记录协议和 SSL 握手协议。 TLS :（Transport Layer Security，传输层安全协议），用于两个应用程序之间提供保密性和数据完整性。该协议由两层组成：TLS 记录协议和 TLS 握手协议。 6.2 作用不使用 SSL/TLS 的 HTTP 通信，就是不加密的通信。所有信息明文传播，带来了三大风险。 窃听风险（eavesdropping）：第三方可以获知通信内容。 篡改风险（tampering）：第三方可以修改通信内容。 冒充风险（pretending）：第三方可以冒充他人身份参与通信。 SSL/TLS 协议是为了解决这三大风险而设计的，希望达到： 所有信息都是加密传播，第三方无法窃听。 具有校验机制，一旦被篡改，通信双方会立刻发现。 配备身份证书，防止身份被冒充。 互联网是开放环境，通信双方都是未知身份，这为协议的设计带来了很大的难度。而且，协议还必须能够经受所有匪夷所思的攻击，这使得 SSL/TLS 协议变得异常复杂。 6.3 历史互联网加密通信协议的历史，几乎与互联网一样长。 1994 年，NetScape 公司设计了 SSL 协议（Secure Sockets Layer）的 1.0 版，但是未发布。 1995 年，NetScape 公司发布 SSL 2.0 版，很快发现有严重漏洞。 1996 年，SSL 3.0 版问世，得到大规模应用。 1999 年，互联网标准化组织 ISOC 接替 NetScape 公司，发布了 SSL 的升级版 TLS 1.0 版。 2006 年和 2008 年，TLS 进行了两次升级，分别为 TLS 1.1 版和 TLS 1.2 版。最新的变动是 2011 年 TLS 1.2 的修订版。 目前，应用最广泛的是 TLS 1.0，接下来是 SSL 3.0。但是，主流浏览器都已经实现了 TLS 1.2 的支持。TLS 1.0 通常被标示为 SSL 3.1，TLS 1.1 为 SSL 3.2，TLS 1.2 为 SSL 3.3。 6.4 基本的运行过程SSL/TLS 协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。 但是，这里有两个问题。 （1）如何保证公钥不被篡改？解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。（2）公钥加密计算量太大，如何减少耗用的时间？解决方法：每一次对话（session），客户端和服务器端都生成一个”对话密钥”（session key），用它来加密信息。由于”对话密钥”是对称加密，所以运算速度非常快，而服务器公钥只用于加密”对话密钥”本身，这样就减少了加密运算的消耗时间。 因此，SSL/TLS 协议的基本过程是这样的： （1） 客户端向服务器端索要并验证公钥。（2） 双方协商生成”对话密钥”。（3） 双方采用”对话密钥”进行加密通信。 上面过程的前两步，又称为”握手阶段”（handshake）。 6.5 握手阶段的详细过程 “握手阶段”涉及四次通信，我们一个个来看。需要注意的是，”握手阶段”的所有通信都是明文的。 6.5.1 客户端发出请求（ClientHello）首先，客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做 ClientHello 请求。在这一步，客户端主要向服务器提供以下信息。 （1） 支持的协议版本，比如 TLS 1.0 版。（2） 一个客户端生成的随机数，稍后用于生成”对话密钥”。（3） 支持的加密方法，比如 RSA 公钥加密。（4） 支持的压缩方法。 这里需要注意的是，客户端发送的信息之中不包括服务器的域名。也就是说，理论上服务器只能包含一个网站，否则会分不清应该向客户端提供哪一个网站的数字证书。这就是为什么通常一台服务器只能有一张数字证书的原因。对于虚拟主机的用户来说，这当然很不方便。2006 年，TLS 协议加入了一个 Server Name Indication 扩展，允许客户端向服务器提供它所请求的域名。 6.5.2 服务器回应（SeverHello）服务器收到客户端请求后，向客户端发出回应，这叫做 SeverHello。服务器的回应包含以下内容。 （1） 确认使用的加密通信协议版本，比如 TLS 1.0 版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。（2） 一个服务器生成的随机数，稍后用于生成”对话密钥”。（3） 确认使用的加密方法，比如 RSA 公钥加密。（4） 服务器证书。 除了上面这些信息，如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供”客户端证书”。比如，金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供 USB 密钥，里面就包含了一张客户端证书。 6.5.3 客户端回应客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。 如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息。 （1） 一个随机数。该随机数用服务器公钥加密，防止被窃听。（2） 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。（3） 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的 hash 值，用来供服务器校验。 上面第一项的随机数，是整个握手阶段出现的第三个随机数，又称”pre-master key”。有了它以后，客户端和服务器就同时有了三个随机数，接着双方就用事先商定的加密方法，各自生成本次会话所用的同一把”会话密钥”。 此外，如果前一步，服务器要求客户端证书，客户端会在这一步发送证书及相关信息。 6.5.4 服务器的最后回应服务器收到客户端的第三个随机数 pre-master key 之后，计算生成本次会话所用的”会话密钥”。然后，向客户端最后发送下面信息。 （1）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的 hash 值，用来供客户端校验。 至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用”会话密钥”加密内容。","link":"/2020/10/21/HTTP%E5%8D%8F%E8%AE%AE%E6%BC%94%E5%8F%98/"},{"title":"Nest.js-基本概念介绍","text":"Nest.js1 什么是 nest.jsNest.js是用于构建高效且可伸缩的服务端应用程序的渐进式 Node.js 框架。 2 nestjs 的优点 完美的支持typescript，因此可以使用日益繁荣的ts生态工具 兼容 express 中间件，因为express是最早出现的轻量级的node server端框架，nest.js能够利用所有express的中间件，使其生态完善 层层处理，一定程度上可以约束代码，比如何时使用中间件、何时需要使用guards守卫等 依赖注入以及模块化的思想，提供了完整的mvc的链路，使得代码结构清晰，便于维护 3 概念3.1 控制器 Controller(接收数据，返回响应)客户端的请求最终交给那个函数或者模块处理都需要通过预先处理，直接处理客户端请求（路由、方法等）的模块我们称之为控制器。 控制器的目的是接收应用的特定请求 路由机制控制哪个控制器接收哪些请求 每个控制器有多个路由 不同的路由可以执行不同的操作 3.2 提供者 Provider几乎所有的东西都可以被认为是提供者 - service, repository, factory, helper 等等。他们都可以通过 constructor 注入依赖关系，也就是说，他们可以创建各种关系。但事实上，提供者不过是一个用@Injectable() 装饰器注解的简单类。 3.2.1 什么是依赖注入？ 依赖注入（_Dependency Injection_，简称DI） 是实现 控制反转（_Inversion of Control_，缩写为**IoC**） 的一种常见方式。 3.2.2 什么是控制反转？ 控制反转，是面向对象编程中的一种设计原则，可以用来降低计算机代码之间的耦合度。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象。 把有依赖关系的类放到容器中，解析出这些类的实例，就是依赖注入。目的是实现类的解耦。 实例：Class A 中用到了 Class B 的对象 b，一般情况下，需要在 A 的代码中显式的 new 一个 B 的对象。采用依赖注入技术之后，A 的代码只需要定义一个私有的 B 对象，不需要直接 new 来获得这个对象，而是通过相关的容器控制程序来将 B 对象在外部 new 出来并注入到 A 类里的引用中。 举例（摘抄）：假设你是一个想开公司的富二代，开公司首先需要一间办公室。那么你不用自己去买，你只需要在你的清单列表上写上办公室这么一项，那么，你老爸已经派人给你安排好了办公室，这间办公室长什么样？多大？在哪里？是租的？还是买的？你根本不知道，你也不需要知道。 现在你又在清单上写了需要 80 台办公电脑，你老爸又给你安排好了 80 台， 你自己并不需要关心这些电脑是什么配置，买什么样的 CPU 性价比更高，只要他们是能办公的电脑就行了。那么你的老爸就是所谓的 IoC 容器，你在编写 Company 这个 class 的时候，你内部用到的 Office、Computers 对象不需要你自己导入和实例化，你只需要在 Company 这个类的 Constructor （构造函数） 中声明你需要的对象，IoC 容器会帮你把所依赖的对象实例注入进去。 Nest 就是建立在依赖注入这种设计模式之上的，所以它在框架内部封装了一个 IoC 容器来管理所有的依赖关系。 3.3 模块 Module模块是具有 @Module() 装饰器的类。 @Module() 装饰器提供了元数据，Nest 用它来组织应用程序结构。 每个 Nest 应用程序至少有一个模块，即根模块。根模块是 Nest 开始安排应用程序树的地方。事实上，根模块可能是应用程序中唯一的模块，特别是当应用程序很小时，但是对于大型程序来说这是没有意义的。在大多数情况下，您将拥有多个模块，每个模块都有一组紧密相关的功能。 @module() 装饰器接受一个描述模块属性的对象： providers controllers imports exports 3.3.1 模块声明与配置 @Module()装饰的类为模块类，该装饰器的典型用法如下： 1234567@Module({ providers: [UserService], controllers: [UserController], imports: [OrderModule], exports: [UserService],})export class UserModule {} 3.3.2 参数说明 proviers 服务提供者列表，本模块可用，可以自动注入 controllers 控制器列表，本模块可用，用来绑定路由访问 imports 本模块导入的模块，如果需要使用到其他模块的服务提供者，此处必须导入其他模块 exports 本模块导出的服务提供者，只有在此处定义的服务提供者才能在其他模块使用 3.3.3 模块化有以下优点 业务低耦合、边界清晰、便于排查错误、便于维护。 3.4 中间件 Middleware中间件是在路由处理程序 之前 调用的函数。 中间件函数可以访问请求和响应对象，以及应用程序请求响应周期中的 next() 中间件函数。 next() 中间件函数通常由名为 next 的变量表示。 中间，是客户端和路由处理的中间，我们前面提到路由交给了控制器处理，如果我们想请求在到达控制器之前或者在响应发送给客户端之前对request和 response 做一些处理，就可以使用中间件，在中间件定义的过程中，有一个很重要的函数——next()，他决定了请求-响应的循环系统。 中间件函数可以执行以下任务: 执行任何代码。 对请求和响应对象进行更改。 结束请求-响应周期。 调用堆栈中的下一个中间件函数。 如果当前的中间件函数没有结束请求-响应周期, 它必须调用 next() 将控制传递给下一个中间件函数。否则, 请求将被挂起。 Nest 中间件可以是一个函数，也可以是一个带有 @Injectable() 装饰器的类。 3.5 异常过滤器 Filter内置的异常层负责处理整个应用程序中的所有抛出的异常。当捕获到未处理的异常时，最终用户将收到友好的响应。 当你的项目中出现了异常，而代码中却没有处理，那么这个异常就会到 Nestjs 内建的异常处理层，我们通过预定义异常处理过滤器，就能将异常更友好地响应给前端。 当异常无法识别时 (既不是 HttpException 也不是继承的类 HttpException ) , 用户将收到以下 JSON 响应: 1234{ &quot;statusCode&quot;: 500, &quot;message&quot;: &quot;Internal server error&quot;} 3.6 管道 Pipe管道就是一个实现了 PipeTransform 接口并用 @Injectable() 装饰器修饰的类。 管道的作用简单来说就是，可以将输入的数据处理过后输出。 转换：将输入数据转换为所需的输出 验证：验证输入的内容是否满足预先定义的规则，当数据不正确时可能会抛出异常 把参数转化成十进制的整型数字 12345678910@Injectable()export class ParseIntPipe implements PipeTransform&lt;string, number&gt; { transform(value: string, metadata: ArgumentMetadata): number { const val = parseInt(value, 10); if (isNaN(val)) { throw new BadRequestException(&quot;Validation failed&quot;); } return val; }} 对于 get 请求中的参数 id，调用 new ParseIntPipe 方法来将 id 参数转化成十进制的整数。 1234@Get(':id')async findOne(@Param('id', new ParseIntPipe()) id) { return await this.catsService.findOne(id);} 3.7 守卫 Guard应用中有些请求处理不是对所有前来请求的用户完全开放的，只有具有指定身份的人才能请求某些接口，负责这一职责的功能模块称之为守卫。 Guards守卫的作用是决定一个请求是否应该被处理函数接受并处理，也可以在middleware中间件中来做请求的接受与否的处理，与middleware相比，Guards可以获得更加详细的关于请求的执行上下文信息。 举例：我们的房子为什么需要钥匙？因为我们不允许外人进入我们的房间。 通常 Guards 守卫层，位于 middleware 之后，管道之前（请求正式被处理函数处理之前）。一般使用看守器来做接口权限的验证，比如验证请求是否包含 token 或者 token 是否过期。 123456789101112import { Injectable, CanActivate, ExecutionContext } from &quot;@nestjs/common&quot;;import { Observable } from &quot;rxjs&quot;;@Injectable()export class AuthGuard implements CanActivate { canActivate( context: ExecutionContext ): boolean | Promise&lt;boolean&gt; | Observable&lt;boolean&gt; { const request = context.switchToHttp().getRequest(); return validateRequest(request); }} 1234567export interface ArgumentsHost { getArgs&lt;T extends Array&lt;any&gt; = any[]&gt;(): T; getArgByIndex&lt;T = any&gt;(index: number): T; switchToRpc(): RpcArgumentsHost; switchToHttp(): HttpArgumentsHost; switchToWs(): WsArgumentsHost;} 1234export interface ExecutionContext extends ArgumentsHost { getClass&lt;T = any&gt;(): Type&lt;T&gt;; getHandler(): Function;} 3.8 拦截器 interceptor拦截器就是使用 @Injectable 修饰并且实现了 NestInterceptor 接口的类。 拦截器可以简单理解为关卡，它可以给每一个需要执行的函数绑定，拦截器将在该函数执行前或者执行后运行。可以转换函数执行后返回的结果等。 拦截器具有一系列有用的功能，这些功能受面向切面编程（**AOP**）技术的启发。它们可以： 在函数执行之前/之后绑定额外的逻辑 转换从函数返回的结果 转换从函数抛出的异常 重写函数 举例：所有接口返回的数据结构处理。具体看项目代码 interceptors 拦截器在函数执行前或者执行后可以运行，如果在执行后运行，可以拦截函数执行的返回结果，修改参数等。* 3.9 装饰器装饰器是一种特殊类型的声明，本质上就是一个方法，可以注入到类、方法、属性、参数上，扩展其功能。 通过装饰器，可以方便的修饰类，以及类的方法，类的属性等，装饰器可分为以下几种： 类的装饰器 类方法的装饰器 类函数参数的装饰器 类的属性的装饰器 举例：查看项目代码 main.ts 页面 3.10 路由控制器的目的是接收应用程序的特定请求。基于路由机制来实现请求的分发。通常，每个控制器具有多个路由，并且不同的路由可以执行不同的动作。 为了创建一个基本的控制器，我们使用类和装饰器。装饰器将类与所需的元数据相关联，并使 Nest 能够创建路由映射（将请求绑定到相应的控制器）。 3.10.1 路由指向 打开 src 下的 main.ts，应该会看到下列代码： { NestFactory } from '@nestjs/core';1234567import { AppModule } from './app.module';async function bootstrap() { const app = await NestFactory.create(AppModule); await app.listen(3000);}bootstrap(); await NestFactory.create(AppModule)表示使用 Nest 的工厂函数创建了 AppModule。 await app.listen(3000) 表示监听的是 3000 端口，可以自定义。http://localhost:3000/thsapp/疑问：thsapp 哪里来的？输出的结果是哪里来的？ 3.10.2 全局路由前缀 12345678910// src/main.tsimport { NestFactory } from '@nestjs/core';import { AppModule } from './app.module';async function bootstrap() { const app = await NestFactory.create(AppModule); app.setGlobalPrefix('thsapp'); // 全局路由前缀 await app.listen(3000);}bootstrap(); http://localhost:3000/thsapp/user2疑问：user2 哪里来的？输出的结果是哪里来的？ 3.10.3 局部路由前缀 12345678910111213141516import {Controller, Get} from '@nestjs/common';@Controller('user')export class User2Controller { // http://localhost:3000/thsapp/user @Get() async getUserInfo() { return '我是用户信息'; } // http://localhost:3000/thsapp/user/info // @Get('info') // async getUserInfo() { // return '获取用户信息'; // }} 12345678910111213// src/app.controller.tsimport { Controller, Get } from '@nestjs/common';import { AppService } from './app.services';@Controller()export class AppController { constructor(private readonly appService: AppService) {} @Get() getHello(): string { return this.appService.getHello(); }} 123456789// src/app.service.tsimport { Injectable } from '@nestjs/common';@Injectable()export class AppService { getHello(): string { return 'Hello World!'; }} 3.10.4 AOP（Aspect Oriented Programming） 面向切面编程，是通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术。在运行时，动态地将代码切入到类的指定方法、指定位置上。 我们管切入到指定类指定方法的代码片段称为切面，而切入到哪些类、哪些方法则叫切入点。有了AOP，我们就可以把几个类共有的代码，抽取到一个切片中，等到需要时再切入对象中去，从而改变其原有的行为。 优点： 降低业务逻辑各部分之间的耦合度 提高程序的可重用性 提高了开发的效率 提高代码的灵活性和可扩展性 将日志记录，性能统计，安全控制，事务处理，异常处理等代码从业务逻辑代码中划分出来，通过对这些行为的分离，我们希望可以将它们独立到非指导业务逻辑的方法中，进而改变这些行为的时候不影响业务逻辑的代码。 4 层级关系 5 装饰器补充知识点在 ES5 中，对象中的每个属性都有一个特性值来描述这个属性的特点，他们分别是：configurable: 属性是否能被delete删除，当值为false时，其他特性值也不能被改变，默认值为trueenumerable： 属性是否能被枚举，也就是是否能被for in循环遍历。默认为truewritable: 是否能修改属性值。默认为truevalue：具体的属性值是多少，默认为undefinedget：当我们通过person.name访问name的属性值时，get将被调用。该方法可以自定义返回的具体值是多少。get默认值为undefinedset：当我们通过person.name = 'Jake'设置 name 属性值时，set方法将被调用，该方法可以自定义设置值的具体方式，set默认值为undefined需要注意的是，不能同时设置value，writeable与get set。我们可以通过Object.defineProperty(操作单个)与Object.defineProperties（操作多个）来修改这些特性值。 123var person = { name: &quot;Lily&quot;,}; 123456789// 三个参数分别为 target, key, descriptor(特性值的描述对象)Object.defineProperty(person, &quot;name&quot;, { value: &quot;Lucy&quot;,});// 新增Object.defineProperty(person, &quot;age&quot;, { value: 20,}); 123456function nameDecorator(target, key, descriptor) { descriptor.value = () =&gt; { return &quot;Tom&quot;; }; return descriptor;} 函数nameDecorator的定义会重写被他装饰的属性(getName)。方法的三个参数与Object.defineProperty一一对应，分别指当前的对象Person，被作用的属性getName，以及属性特性值的描述对象descriptor。函数最后必须返回descriptor。 123456789101112class Person { constructor() { this.name = &quot;Lily&quot;; } @nameDecorator getName() { return this.name; }}let p1 = new Person();console.log(p1.getName()); @nameDecorator，就是装饰器语法自定义函数nameDecorator的参数中，target，就是装饰的对象Person，key就是被装饰的具体方法getName。 项目开发流程上面进行了一些基本概念的介绍，相信你已经对 nest 有了一定的认识，下面将会对项目开发的流程做一下详细的介绍。 1 环境准备node.js: 11.13.0+npm: 6.7.0+nestjs: 6.0.0mongodb 安装 MongoDBWindows: https://docs.qq.com/doc/DWG1TZkRnZ0pyT2Rn?tdsourcetag=s_macqq_aiomsg&amp;jumpuin=5682206Mac: https://sevenlet.github.io/mongodb/ 2 开始1npm i tfbi -g 1fbi init 项目名 nest-starter 1npm i 12345678# development$ npm run start# watch mode$ npm run start:dev# production mode$ npm run start:prod 3 目录介绍https://github.com/THS-FE/nest-starter 4 开始编写代码4.1 配置、连接数据库123456789101112131415161718192021import { Module } from &quot;@nestjs/common&quot;;import { AppController } from &quot;./app.controller&quot;;import { AppService } from &quot;./app.service&quot;;import { MongooseModule } from &quot;@nestjs/mongoose&quot;;@Module({ imports: [ MongooseModule.forRoot( &quot;mongodb://localhost/nest-blog&quot;, // uri { // options useNewUrlParser: true, } ), ], controllers: [AppController], providers: [AppService],})export class AppModule {} forRoot() 方法来完成与数据库的连接 4.2 创建数据库 Schema、接口 interface、DTO 数据库 schema： 这是一种数据组织，它是定义数据库需要存储的数据结构和类型的蓝图。 接口 interface：TypeScript 接口用于类型检查。它可以用来定义在应用中传递的数据的类型。 数据传输对象 DTO： 这个对象定义了数据是以何种形式通过网络发送的以及如何在进程之间进行传输的。 4.21 创建 schemasrc/schemas/user.schema.ts 12345678import * as mongoose from &quot;mongoose&quot;;export const UserSchema = new mongoose.Schema({ userName: String, password: String, realName: String, token: String,}); 4.22 创建 interfacesrc/interfaces/user.interface.ts 1234567export interface User { userName: string; // 用户名 password?: string; // 密码 realName?: string; // 真实姓名 token?: string; salt?: string;} 4.23 创建 DTO（data transform object 数据传输对象）src/modules/user/dtos/LoginDto.dto.ts 12345678910111213141516171819import { MinLength, IsNotEmpty } from &quot;class-validator&quot;;import { ApiProperty, ApiPropertyOptional } from &quot;@nestjs/swagger&quot;;import { User } from &quot;src/interfaces/user.interface&quot;;export class LoginDto implements User { @IsNotEmpty({ message: &quot;不能为空&quot; }) @ApiProperty({ description: &quot;用户名&quot;, example: &quot;zhangjx&quot; }) userName: string; // 字段——用户名 @MinLength(6, { message: &quot;长度不能小于6&quot;, }) @ApiProperty({ description: &quot;密码&quot;, example: &quot;123456&quot; }) password: string; // 字段——密码 @IsNotEmpty({ message: &quot;不能为空&quot; }) @ApiPropertyOptional({ description: &quot;用户名&quot;, example: &quot;张金秀&quot; }) realName: string; // 字段——真实姓名} 4.3 nest-cli 创建文件指令使用 nest-cli 提供的指令可以快速创建文件，语法如下： 1nest g [文件类型] [文件名] [文件目录（src目录下）] 4.31 创建模块 Module1nest g module user modules 1234import { Module } from &quot;@nestjs/common&quot;;@Module({})export class UserModule {} 自动在根模块引入 4.32 创建控制器 Controller1nest g controller user2 modules 1234import { Controller } from &quot;@nestjs/common&quot;;@Controller(&quot;user2&quot;)export class User2Controller {} 自动在模块内引入 4.33 创建服务 Services1nest g service user2 modules 1234import { Injectable } from &quot;@nestjs/common&quot;;@Injectable()export class User2Service {} 自动在模块内引入 4.34 中间件1nest g middleware logger middleware 4.35 拦截器1nest g interceptor transform interceptor 4.36 过滤器1nest g filter any-exception filters 1nest g filter http-exception filters 4.37 管道1nest g pipe validation pipes 5 Swagger UI查看接口文档http://localhost:3000/api-doc","link":"/2020/10/23/Nest-js-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D/"},{"title":"从零开始搭建前端项目开发环境","text":"1 写在最前为何大多数人觉得搭建一个前端项目的开发环境很困难。首先，一个完整的开发环境需要依赖多个工具，每个工具又有不计其数的配置项，想要全部理解需要花费大量的时间。其次，一些官方文档中文翻译滞后，而且结构组织的也不是很好，没有从一个具体的项目出发讲解如何配置，只看 API 没有什么针对性。最后，好多国内相关博客要么没有标注工具的版本，导致按照步骤进行配置时会发现自己下载的和讲述的某些地方会不一致；要么只讲如何配置，不讲配置的原因，导致大家仍是云里雾里。不过所幸，大部分 CLI 实现了脚手架的功能，帮助快速生成项目，而不用了解工具的具体配置。 但是，作文里总会有个转折不是。当我们需要自己独立去创建一个项目的时候…该怎么办哖，Don’t be afraid，I’m here. 接下来会先介绍一下几个常用工具（Babel 7.13.0，Browserslist 4.16.6, ESLint 7.26.0, EditorConfig）的核心概念、安装和配置，最后会结合 TypeScript + SASS + webpack5 的项目来说如何将它们整合起来形成一个完整的前端项目开发环境。 Here we go. 2 Babel (7.13.0)Babel 是一个 Javascript 编译器。主要用于将 ECMAScript 2015+ 版本的代码转换为向后兼容(backwards compatible)的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其它环境(如：node)中。 2.1 安装123npm i -D @babel/core @babel/cli @babel/preset-envnpm i -D core-js 运行此命令之前要先初始化项目，新建项目文件夹 xxx , 在该文件夹下 运行： 1npm init 尽量不要一路回车，建议按实际内容来。 2.1.1 @babel/core主要用于将源代码(JS\\TS)解析为 AST(抽象语法树)。 2.1.2 @babel/cli用于从命令行编译文件。 2.1.3 @babel/preset-env预设环境。源代码解析成 AST 后，还需要进行转换和生成，这是由插件来做的。@babel/preset-env(预设环境)是常用预设和插件的集合（babel-preset-es2015，babel-preset-es2016，babel-preset-es2017，babel-preset-latest，babel-preset-node5, babel-preset-es2015-node 等，@babel/preset-env 不支持 stage-x 插件）。 最初每年 EcmaScript 标准更新，都需要使用者手动添加最新年份的预设才能进行新语法的转换: 12345&quot;presets&quot;: [ &quot;es2015&quot;, &quot;es2016&quot;, &quot;es2017&quot; ], 后来改成了 babel-preset-latest，意思为最新的预设（包含了以往所有年份），不用每年都需要手动添加一把。最终 latest 也被废弃，变成了目前的 preset-env。开发人员可以在代码中直接书写已经正式发布的特性。不过，当 ES 更新时，肯定还需要更新一下 @babel/preset-env。 2.1.4 core-jsBabel 默认只转换新的 JavaScript 语法，如： 类、箭头函数、扩展运算（spread），而不转换新的 API ，如：Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise 等全局对象，以及一些定义在全局对象上的方法（如：Object.assign）。不转码的 API 详细清单可以查看 definitions.js 文件。 core-js 提供了 es5、es6+的 polyfills(填充物，用于实现浏览器并不支持的原生 API 的代码，它将一个新的 API 引入到一个旧的环境中，仅靠旧环境中已有的技术手段实现)，包括promises, symbols, collections, iterators, typed arrays等等。 这里不得不提一下该库和它的俄罗斯作者。该库一周的下载量比大家熟知的 Angular、 React、Vue 加一起的下载量还要多的多。就这样的一个库谁能想到它的作者竟然需要在命令行里 looking for a good job，后来该作者又因为骑摩托车撞死一人，伤一人，被判入狱 18 个月, 现在应该已经处于服刑期间了… @babel/polyfill 已废弃。 2.2 配置可以在三类文件中对 Babel 进行配置，在项目的根目录中创建 babel.config.*、.babelrc.* (* 可为 空，json, js, cjs 或 mjs) ，或在 package.json 中添加。 如果扩展名为 json，那一般的内容是： 1234{ &quot;presets&quot;: [...], &quot;plugins&quot;: [...]} 如果扩展名为 js，则内容为： 1234const presets = [ ... ];const plugins = [ ... ];module.exports = { presets, plugins }; 在 package.json 中： 123456789{ &quot;name&quot;: &quot;my-package&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;babel&quot;: { &quot;presets&quot;: [ ... ], &quot;plugins&quot;: [ ... ], }} 我们一般使用 babel.config.js 作为配置文件，因为在 JS 中可以写注释，方便理解（JSON 不方便）。其它工具的配置文件能采用 js 做扩展名的也尽量使用 .js。 在项目文件夹下创建 src 目录，新建 index.js。编写内容： 12345const userInfo = new Map();userInfo.set('name', '天下布武');userInfo.set('age', 18);console.log(Object.entries(userInfo)); 在 package.json 中添加： 123&quot;scripts&quot;: { &quot;build&quot;: &quot;./node_modules/.bin/babel src/index.js --out-dir dist&quot;}, 2.2.1 @babel/preset-env最简设置如下(不建议，转换后会多出很多冗余代码，至少要配置一个 targets)： 123module.exports = { presets: [['@babel/preset-env']],}; 在命令行中运行： 1npm run build 就能在新生成的 dist 文件夹中看到 编译后的 index.js ： 可以看到之前的 const 被转译成了 var。 下面对两个常用参数进行说明： 2.2.1.1 targets设置编译代码的目标平台，可以是浏览器也可以是 node 环境。如不设置，会将所有 ES6+的代码编译为 ES5-。建议设置，这样可以按目标平台来决定是否进行转换，以避免增加不必要的补丁，减少打包后的代码体积。 常见设置如下： 12345678910module.exports = { presets: [ [ '@babel/preset-env', { targets: '&gt; 1%, last 2 versions, ie &gt; 8', }, ], ],}; 以上配置的意思是要兼容全球范围内使用量大于 1%的浏览器和它们最新的两个版本，加上 IE 9-11。这里既可以指定浏览器的版本，也可以通过查询的方式来确定要支持的浏览器。详情见Browserslist这一章节。 若设置 targets: ‘&gt; 10%’ , 再运行一次 npm run build ，因为大于 10% 的浏览器只有谷歌，它是支持 const 的, 因此编译结果几乎原封未动： 建议使用 .browserslistrc 文件来定义 targets，这样其它工具(Autoprefixer、PostCSS、Stylelint 等)也能通过该配置获取到目标浏览器，从而做有针对性的处理。 2.2.1.2 useBuiltIns是否内置兼容。如果设置，就可以不用在 HTML 中引入 polyfill 的 JS 文件来处理浏览器的兼容性问题了。常见设置如下： 1234567891011module.exports = { presets: [ [ '@babel/preset-env', { useBuiltIns: 'usage', corejs: 3, }, ], ],}; 可选值包括：”usage” | “entry” | false。 false：默认值，即不引入 polyfills，不做浏览器兼容。 entry：根据配置的浏览器，引入这些浏览器不兼容的 polyfill。这个是在文件中已经明确写了 import “core-js” 或其中具体某个模块（如：import “core-js/es/array”）的情况下，babel 会根据 browserslist 自动添加指定浏览器不兼容的该模块下的所有 polyfill，无论当前代码是否需要。 usage：会根据配置的浏览器以及代码中用到的 API 自动添加 polyfill，实现了按需引入。一般使用这个配置。 只有当 useBuiltIns 的值为 entry 或 usage 时，”corejs” 这个选项才会起作用。这里如无特殊情况尽量指定 core-js 的版本为 3（默认为 2）, 因为它有很多 2 没有的新特性： “corejs”: 3。 这里运行 npm run build, 运行结果为： 可以看出它在全局作用域下添加了 Map 变量，同时在 Object 原型中添加了 entries 方法。 babel 默认转出的是模块规范为 commonJS，只能在 Node 环境中使用，如果想在浏览器环境中使用，一般有两种方式：1、 结合 rollup2、 结合 webpack我们一般使用 第二种方式，参看最后 webpack 实例。 2.2.2 @babel/plugin-transform-runtime对于一般应用开发来说，直接使用上述的 polyfill 方案是比较方便的，但如果是开发工具、库的话，这种方案未必适合(由上图可以看出，polyfill 是添加自定义全局对象 或向对象的 prototype 上添加方法实现的)。使用 @babel/plugin-transform-runtime 这个插件就可以解决这个问题。 安装： 1npm i -D @babel/plugin-transform-runtime @babel/runtime-corejs3 配置： 1234567891011module.exports = { presets: [['@babel/preset-env']], plugins: [ [ '@babel/plugin-transform-runtime', { corejs: 3, }, ], ],}; 该插件无法读取 preset-env 的 targets 或者是 browserlist 中的目标平台参数，因此不会根据目标平台来决定是否进行转换和注入 polyfills，而是全转换和注入所有。以后可能会在 useBuiltIns 中增加一个参数 “runtime” 来代替该插件。可参见：https://github.com/babel/babel/issues/10133 再运行 npm run build，得到： 凡是 require 进来的模块都直接赋值给普通变量，不会对 Map 、 Object 等全局变量造成影响。 注：这里的和上边所有提到的“编译”一词更准确的说法应该是“转译（Transpile）”。 3 Browserslist (4.11.1)Browserslist 是一个能够在不同的前端工具间共享目标浏览器的配置。看配置就知道当前项目支持的浏览器有哪些。它使用 Can I Use 的数据做查询。 在项目中添加 Browserslist，常用有两种方式(不能同时在 .browserslistrc 和 package.json 中配置，否则使用 Babel 转译的时候会报错)： 在项目的根目录下添加 .browserslistrc 文件 123&gt; 1%last 2 versionsie &gt; 8 在 package.json 文件中增加 browserslist 节点 123456789101112{ &quot;private&quot;: true, &quot;dependencies&quot;: { }, &quot;browserslist&quot;: [ &quot;last 2 version&quot;, &quot;&gt; 1%&quot;, &quot;ie &gt; 8&quot; ]} 查询结果可通过 https://browserl.ist/ 来查看。 运行命令行： 1npx browserslist 可查看当前项目目标浏览器列表。如果只是在 babel.config.* 文件中配置了 target 是检测不出来的（会优先使用），因此建议使用 单独的 .browserslistrc 来设置。 4 ESLint (7.26.0)是一个可以查找并且修复 JavaScript(TypeScript)中错误的工具，目的是为了保证代码风格统一，避免出错。 4.1 概念4.1.1 extends（扩展）扩展里填的内容是包含了一系列规则的配置文件。这个一般不需要自己定义，因为有很多现成的：如 ESLint 自身的 eslint:recommended、eslint:all 和社区的 google、airbnb。 配置的模块名(npm 的包名)要为 eslint-config-xxx，在配置中可缩写为 xxx。 例： 4.1.2 plugins（插件）extends 中是对 eslint 现有规则的一系列预设（开启或关闭），而 plugins 不仅可以定义预设，也可以自定义规则（比如自己创建一个 no-console2，区别于 ESLint 的 no-console），甚至可对不是 JavaScript 类型的文件（如 *ts，*.md，*.vue）扩展自己的规则。 插件的模块名一般为 eslint-plugin-xxx，在配置中可缩写为 xxx。 例： 4.1.3 rules（规则）直接配置已有规则的开启、关闭。比如强制在 JavaScript 中使用单引号（”quotes”: [2, “single”]）。规则定义中参数的设置说明： “off” 或 0：关闭规则 “warn” 或 1：警告，不会影响程序执行 “error” 或 2：错误，程序不能执行 4.2 安装4.2.1 针对 JavaScript1npm i -D eslint eslint-config-airbnb-base eslint-plugin-import 4.2.1.1 eslint-config-airbnb-base包含了 airbnb 最基础（不包含 React 相关）的 JS 编码风格规则。 4.2.1.2 eslint-plugin-import上边的插件依赖这个。😛 4.2.2 针对 TypeScript1npm i -D eslint eslint-config-airbnb-typescript eslint-plugin-import @typescript-eslint/eslint-plugin 4.2.2.1eslint-config-airbnb-typescriptAirbnb 风格的 TypeScript 支持。它将一些常见配置都加了进去，省下了好多工作量。ps. 这是一个匈牙利布达佩斯技术和经济大学的学生做的，想想自己的大学生活都在做啥… 该插件包含了@typescript-eslint/parser（TypeScript 解析器），它调用@typescript-eslint/typescript-estree（通过在给定的源代码上调用 TypeScript 编译器，就是 npm i typescript -D 安装的那个，以产生 TypeScript AST，然后将该 AST 转换为 ESLint 期望的格式）。ESlint 默认的解析器叫 espree。 4.2.2.2 @typescript-eslint/eslint-plugin与 @typescript-eslint/parser 结合使用时，运行 TypeScript 的分析规则。 4.3 配置可使用 .eslintrc.( 可为 空，js, yaml, yml, json）或在 package.json 中配置，这里使用 .eslintrc.js 来进行配置。 一个项目中在不同的文件夹下可以有多个 .eslintrc. 配置文件，这样可以约束不同文件夹下的文件使用不同的风格，这一点和 editorConfig 一样。 4.3.1 针对 JavaScript一般配置如下： 12345678910111213141516171819module.exports = { root: true, // 意思是到头啦，不要再向上找了 env: { // 代码将会在哪些环境中运行。每个环境都附带了一组特定的预定义全局变量，如 browser 中有 window，document等，添加后可以直接在代码中使用，而不报错。 browser: true, node: true, es2020: true, }, extends: 'airbnb-base', // 使用airbnb风格 parserOptions: { ecmaVersion: 2020, // 启用ES2020的语法 }, rules: { 'no-console': process.env.NODE_ENV === 'production' ? 'warn' : 'off', // 只在打包时强制不使用console 'no-debugger': process.env.NODE_ENV === 'production' ? 'warn' : 'off', // 只在打包时强制不使用debugger 'max-len': ['error', { code: 160 }], // 单行最大160个字符 'multiline-comment-style': ['error', 'starred-block'], // 格式化注释 },}; 4.3.2 针对 TypeScript一般设置如下： 1234567891011121314151617181920212223module.exports = { root: true, // 意思是到头啦，不要再向上找了 env: { // 代码将会在哪些环境中运行。每个环境都附带了一组特定的预定义全局变量，如 browser 中有 window，document等，添加后可以直接在代码中使用，而不报错。 browser: true, node: true, }, extends: [ 'airbnb-typescript/base', // 使用airbnb风格 'plugin:@typescript-eslint/eslint-recommended', 'plugin:@typescript-eslint/recommended', 'plugin:@typescript-eslint/recommended-requiring-type-checking', ], parserOptions: { project: './tsconfig.json', // 要在tsconfig中设置编译的版本 }, rules: { 'no-console': process.env.NODE_ENV === 'production' ? 'warn' : 'off', // 只在打包时强制不使用console 'no-debugger': process.env.NODE_ENV === 'production' ? 'warn' : 'off', // 只在打包时强制不使用debugger 'max-len': ['error', { code: 160 }], // 单行最大160个字符 'multiline-comment-style': ['error', 'starred-block'], // 格式化注释 },}; 最后要在 VS Code 中安装 ESLint 插件，配置相关参数，使之能够在文件保存时自动修复格式错误；WebStrom 中则需设置允许 ESLint（最新的 2020.1.1 版本中也能够在文件保存时自动修复错误）。 5 stylelint5 EditorConfig帮助在不同的编辑器或 IDE 上从事同一项目的多个开发人员保持一致的编码样式。 一个项目里可以有多个.editorconfig 分别放置在不同的文件夹中，当 VS Code 这类编辑器打开一个文件时，它会检查这个文件所在目录和它的父级文件夹（直到项目根目录或者是是某个文件夹中的 .editorconfig 里标识了 root = true 才会停止)中是否存在 .editorconfig。被打开的文件格式会以距当前文件最近的 .editorconfig 中的内容为准。 一般配置如下： 12345678910111213141516# 告诉编辑器这是最顶层的（不要再向上找了） EditorConfig 文件root = true[*]charset = utf-8 # 设置编码为utf-8indent_style = space # 缩进方式为空格indent_size = 2 # 缩进大小为2个字符end_of_line = lf # 换行符，可选&quot;lf&quot;、&quot;cr&quot;、&quot;crlf&quot;trim_trailing_whitespace = true # 删除行尾空格insert_final_newline = true # 始终在文件末尾插入一个新行max_line_length = 160 # 单行最大字符数 160[*.md]insert_final_newline = falsetrim_trailing_whitespace = false 6 webpack (5.37.0)webpack 是用于现代 JavaScript 应用程序的静态模块打包器。当 webpack 处理应用程序时，它会在内部构建一个依赖关系图，该图映射项目所需的每个模块最终会生成一个或多个包。 6.1 概念6.1.1 moduleswebpack 中，无论是 JS 、CSS 还是图片等，总之一切皆模块。 有点像 RxJS，一切皆数据流。模块间依赖的表述有很多种方式，如：import，require，define，@import，url(…), &lt;img src=…&gt; 等等。 6.1.2 Entry &amp; Output入口指示 webpack 应该使用哪个模块开始构建其内部依赖关系图。默认为： ./src/index.js。 出口告诉 webpack 在何处发出它创建的包文件以及如何命名这些文件。默认为： ./dist/main.js 6.1.3 Loaderswebpack 默认只能解析 JavaScript 和 JSON，可以通过添加 Loaders 来处理其他类型的文件。 6.1.4 Plugins可以利用插件来执行更广泛的任务，例如打包优化，资产管理和环境变量的注入。 6.1.5 Mode分 development、production、none 三种，每种都会对应一系列默认配置。 6.2 实战接下来以初始化一个 TypeScript + SCSS 项目为例，介绍下 webpack5 的配置流程。 在开始之前先说下，为何没用 ts-loader 和 TSLint： 由于 TSLint 的性能不如 ESLint，再加上有很多热门的社区（React Hooks、Vue），都是通过 ESLint 来构建规则，因此，TypeScript 团队决定专注支持 ESLint。 Babel7 虽然不支持 TS 类型检查，但已经支持转译。 构建需要安装的插件、工具太多，能少一个就少一个，一个编译器既能支持 JS，又能支持 TS，为何不用。因此，感觉 ts-loader 的生命也不会太长了… Node 环境要求至少为：10.13.0。 6.2.1 初始化项目1npm init 在命令行中填入项目相关信息，不建议一路回车… 6.2.2 安装 webpackwebpack 是最新的 webpack5。 1npm i -D webpack webpack-cli 如果需要一个 web 服务器做调试和热更新，则需安装： 1npm i -D webpack-dev-server 6.2.3 创建 .editorconfig统一编码样式。 12345678910111213141516# 告诉编辑器这是最顶层的（不要再向上找了） EditorConfig 文件root = true[*]charset = utf-8 # 设置编码为utf-8indent_style = space # 缩进方式为空格indent_size = 2 # 缩进大小为2个字符end_of_line = lf # 换行符，可选&quot;lf&quot;、&quot;cr&quot;、&quot;crlf&quot;trim_trailing_whitespace = true # 删除行尾空格insert_final_newline = true # 始终在文件末尾插入一个新行max_line_length = 160 # 单行最大字符数 160[*.md]insert_final_newline = falsetrim_trailing_whitespace = false 6.2.4 安装 TypeScript 编译器并配置安装编译器的目的是为了配合 ESLint 做代码检查和自动修复。 1npm i -D typescript 在项目根目录下创建 tsconfig.json，其中可定义入口文件以及编译的参数，用于将 TypeScript 转译为 JavaScript。 一定要设置，否则在 IDE 做语法校验的时候，新 JavaScript API（如： Object.fromEntries ）会报错。 12345678{ &quot;compilerOptions&quot;: { &quot;lib&quot;: [ &quot;ESNext&quot;, &quot;DOM&quot; ] }} ESNext 指的是 TypeScript 支持的最新版本的 ES。它会随着 ES 版本的更新而自动更新，一劳永逸。DOM 类型定义，允许在 TS 中直接写 window，document。 6.2.5 安装 ESLint 并配置1npm i -D eslint eslint-config-airbnb-typescript eslint-plugin-import @typescript-eslint/eslint-plugin .eslintrc.js 1234567891011121314151617181920212223module.exports = { root: true, // 这个配置同 editorConfig，意思是不要找了 env: { // 代码将会在哪些环境中运行。每个环境都附带了一组特定的预定义全局变量，如 browser 中有 window，document等，添加后可以直接在代码中使用，而不报错。 browser: true, node: true, }, extends: [ 'airbnb-typescript/base', // 使用airbnb风格 'plugin:@typescript-eslint/eslint-recommended', 'plugin:@typescript-eslint/recommended', 'plugin:@typescript-eslint/recommended-requiring-type-checking', ], parserOptions: { project: './tsconfig.json', // 要在tsconfig中设置编译的版本 }, rules: { 'no-console': process.env.NODE_ENV === 'production' ? 'warn' : 'off', // 只在打包时强制不使用console 'no-debugger': process.env.NODE_ENV === 'production' ? 'warn' : 'off', // 只在打包时强制不使用debugger 'max-len': ['error', { code: 160 }], // 单行最大160个字符 'multiline-comment-style': ['error', 'starred-block'], // 格式化注释 },}; 6.2.6 创建 .gitignore提交 Git 服务器时，忽略的文件列表。使用 SVN 的就不需要这个了。 1234567891011121314151617181920212223.DS_Storenode_modules/dist# local env files.env.local.env.*.local# Log filesnpm-debug.log*yarn-debug.log*yarn-error.log*# Editor directories and files.idea.vscode*.suo*.ntvs**.njsproj*.sln*.sw?.git 6.2.7 创建 .browserslistrc这里设置兼容 IE11。当前项目如果是作为库使用的话，该设置不会起作用。详情见：babel-plugin-transform-runtime 1234&gt; 1%last 2 versionsnot ie &lt; 11 6.2.8 安装 webpack loaders所有 Loaders 都在 webpack.config.js 文件中的 module 节点中进行添加。 6.2.8.1 转译6.2.8.1.1 babel-loader 及相关webpack 本身只能打包（模块合并）而没有转译的能力，TS 转译成 JS 用的是 Babel ，并没有使用 TypeScript 编译器。 123npm i -D babel-loadernpm i -D @babel/core @babel/preset-env @babel/preset-typescript core-js babel.config.js： 123456789101112module.exports = { presets: [ [ '@babel/preset-env', { useBuiltIns: 'usage', corejs: 3, }, ], '@babel/preset-typescript', ],}; webpack.config.js 片段: 12345678910module: { rules: [ // 使用 babel-loader 解析 ts, js, tsx, jsx 文件. { test: /\\.(ts|js)x?$/, // 匹配扩展名为 .ts,.js,.tsx.jsx 的文件 use: 'babel-loader', // 使用 babel-loader 来进行解析 exclude: /node_modules/, // 排除 node_modules 文件下的文件 }, ];} 更多配置可见下方完整的配置。 当前项目将要作为库的话，还得安装： 1npm i -D @babel/plugin-transform-runtime @babel/runtime-corejs3 同时 babel.config.js 中的配置改成下面这个： 1234567891011module.exports = { presets: ['@babel/preset-env', '@babel/preset-typescript'], plugins: [ [ '@babel/plugin-transform-runtime', { corejs: 3, }, ], ],}; 6.2.8.2 样式6.2.8.2.1 sass-loader加载 SASS/SCSS 文件 并将其编译为 CSS。 1npm i -D sass-loader node-sass sass-loader 要求要安装 Dart Sass 或者是 Node Sass。弄过 NPM 下载下来的这两者只是个编译器。据说前者在 node 环境中性能比后者要差，因此一般都会使用 node-sass。 webpack.config.js 一般配置如下： 123456789101112131415// 执行顺序：从右到左 { test: /\\.s[ac]ss$/i, use: [ // 从字符串中创建style标签到HTML的Header中 'style-loader', // 转换CSS为字符串 'css-loader', // 给CSS添加前缀以适应各浏览器 'postcss-loader', // 编译 Sass 到 CSS 'sass-loader', ], }, 6.2.8.2.2 postcss-loaderPostCSS是 CSS 语法转换的工具。它提供 API 来对 CSS 文件进行分析和修改它的规则。利用其插件 autoprefixer ，可以给 CSS 添加目标浏览器（Browserslist 中定义的）前缀。 1234-moz- /* 火狐等使用Mozilla浏览器引擎的浏览器 */-webkit- /* Safari, 谷歌浏览器等使用Webkit引擎的浏览器 */-o- /* Opera浏览器(早期) */-ms- /* Internet Explorer */ 1npm i -D postcss-loader autoprefixer 创建 postcss.config.js, 定义 PostCSS 的插件为 autoprefixer： 12345module.exports = { plugins: { autoprefixer: {}, },}; 6.2.8.2.3 css-loader加载 CSS 文件，并以 JS 模块（CSS 样式以字符串的形式封装在其中）的形式返回。 如果只使用 css-loader，解析出的 CSS 内容都在打包后的 js 代码中，没有任何作用。 只有配合 style-loader 或 mini-css-extract-plugin 等，引用的样式才会起作用。 1npm i -D css-loader 6.2.8.2.4 style-loader将 CSS 样式注入到 DOM 中。默认是在&lt;header&gt;最后添加&lt;style&gt;，这是通过生成 JS 方法动态添加的。 1npm i -D style-loader 一般这样配置： 12345{ test: /\\.css$/, use: ['style-loader', 'css-loader', 'postcss-loader'],}, 6.2.8.3 文件6.2.8.3.1 url-loader将小于一个限制大小的文件转换为base64 URIs。超过限制的，会默认使用 file-loader 来做处理。所以这里一定要把 file-loader 也安装上。 1npm i -D url-loader file-loader 6.2.8.3.2 file-loader生成文件到输出的文件夹中，并返回相对路径 URL 。 1npm i -D file-loader 6.2.9 安装 webpack plugins6.2.9.1 HTMLWebpackPlugin会生成一个 HTML5 文件，其中 body 中会加入所有 webpack 打包出来的内容。 1npm i -D html-webpack-plugin 6.2.9.2 clean-webpack-plugin移除或清空构建出的文件夹。 1npm i -D clean-webpack-plugin 6.2.9.3 mini-css-extract-plugin将 CSS 提取到单独的 CSS 文件中。 1npm i -D mini-css-extract-plugin 一般的配置如下： 1234567891011121314151617181920212223242526272829303132const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;); module: { rules: [ ... { test: /\\.s[ac]ss$/i, use: [ // 提取到单独的CSS文件 MiniCssExtractPlugin.loader, // 转换 CSS 到 CommonJS 'css-loader', // 给 CSS 添加前缀以适应各浏览器 'postcss-loader', // 编译 Sass 到 CSS 'sass-loader', ], }, ], },plugins: [ ...js new MiniCssExtractPlugin({ filename: 'css/[name].css', chunkFilename: 'css/[id].css', }),], 6.2.9.4 webpack-bundle-analyzer可视化 webpack 输出文件的大小。 1npm i -D webpack-bundle-analyzer 12345const { BundleAnalyzerPlugin } = require('webpack-bundle-analyzer');module.exports = { plugins: [new BundleAnalyzerPlugin()],}; 6.2.10 创建 webpack.config.js配置 webPack 来处理 TypeScript。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172const { CleanWebpackPlugin } = require('clean-webpack-plugin');const HtmlWebpackPlugin = require('html-webpack-plugin');const MiniCssExtractPlugin = require('mini-css-extract-plugin');const path = require('path');const config = { entry: './src/index.ts', // 入口文件 externals: { // cesium: 'Cesium', }, module: { rules: [ // 使用 babel-loader 解析 ts, js, tsx, jsx 文件. { test: /\\.(ts|js)x?$/, use: 'babel-loader', exclude: /node_modules/, }, // 执行顺序：从右到左 { test: /\\.s[ac]ss$/i, use: [ // 提取到单独的CSS文件 MiniCssExtractPlugin.loader, // 转换 CSS 到 CommonJS 'css-loader', // 给 CSS 添加前缀以适应各浏览器 'postcss-loader', // 编译 Sass 到 CSS 'sass-loader', ], }, // 使用 url-loader 将小于 4KB 图片 转换为 base64 URIs { test: /\\.(png|jpe?g|gif|webp)$/i, use: [ { loader: 'url-loader', options: { name: 'images/[name].[hash:8].[ext]', limit: 4096, esModule: false, }, }, ], }, ], }, resolve: { extensions: ['.ts', '.tsx', '.js', '.jsx', '.json'], // 按顺序解析以上扩展名的文件(必须添加，否则通过import进来的文件无法解析。import时可不写扩展名 默认值为 ['.wasm', '.mjs', '.js', '.json'] }, output: { filename: 'bundle.js', path: path.resolve(__dirname, 'dist'), }, plugins: [ new CleanWebpackPlugin(), new HtmlWebpackPlugin({ template: 'public/index.html', title: 'TypeScript-Webpack-starter', }), new MiniCssExtractPlugin({ filename: 'css/[name].css', chunkFilename: 'css/[id].css', }), ],};module.exports = (env, argv) =&gt; { if (argv.mode === 'development') { config.devtool = 'source-map'; // 导出SourceMap供调试 } if (argv.mode === 'production') { } return config;}; 某些开源项目会在项目的根目录下创建一个 build 文件夹，将 webpack 的配置拆分为 base(存放公用配置)、dev(开发环境特有的配置)、prod(生产环境特有的配置)，利用合并插件将 dev 或 prod 和 base 合并。个人认为其拆分的思想没有问题，但如果配置项没达到一定规模(500 行以上?)可以不用这么麻烦。如上方配置所示：只使用 webpack.config.js ，先添加公用配置(一个对象)，然后通过判断当前是开发还是生产模式，补充相应配置。 6.2.11 添加脚本package.json 12345 &quot;scripts&quot;: { &quot;serve&quot;: &quot;npx webpack serve --mode=development --open&quot;, &quot;dev&quot;: &quot;npx webpack serve --mode=development --open&quot;, &quot;build&quot;: &quot;npx webpack --mode production&quot; }, 6.2.12 形成项目结构创建 libs、public、src 文件夹 12345678910111213141516171819├── libs // 第三方库├── public│ ├── index.html├── src│ ├── assets // 资源│ │ ├── images // 图片│ │ ├── styles // 样式文件 scss、less、css│ └── index.ts├── .browserslistrc├── .editorconfig├── .eslintrc.js├── .gitignore├── babel.config.js├── package.json├── postcss.config.js├── README.md├── tsconfig.json└── webpack.config.js 其中 index.html 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-cmn-Hans&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot; /&gt; &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;noscript&gt; &lt;strong &gt;We're sorry but &lt;%= htmlWebpackPlugin.options.title %&gt; doesn't work properly without JavaScript enabled. Please enable it to continue.&lt;/strong &gt; &lt;/noscript &gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 6.2.13 源码地址https://github.com/THS-FE/typescript-webpack-starter 7 备注7.1 为什么好多配置文件的后缀是 rc [Unix: from runcom files on the CTSS system 1962-63, via the startup script /etc/rc] Script file containing startup instructions for an application program (or an entire operating system), usually a text file containing commands of the sort that might have been invoked manually once the system was running but are to be executed automatically each time the system starts up. rc 代表短语 runcom （运行命令），unix 的爷爷 CTSS 系统中的脚本文件，里边包含了应用或者整个系统启动时要执行的命令。 现在更通用的含义可能是 runtime configration，即应用运行时的配置。 参考：https://stackoverflow.com/questions/11030552/what-does-rc-mean-in-dot-files https://unix.stackexchange.com/questions/3467/what-does-rc-in-bashrc-stand-for","link":"/2020/05/21/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"},{"title":"前端开发必须掌握的基本概念","text":"编译型(compiled) VS 解释型(interpreted)计算机语言通常分为三类：即机器语言，汇编语言和高级语言 机器语言（machine language）（1）概念：机器语言是用二进制代码(0 和 1)表示的、计算机能直接识别和执行的一种机器指令的集合。它是计算机的设计者通过计算机的硬件结构赋予计算机的操作功能。 （2）特点：不同种类的计算机其机器语言是不兼容的，按某种计算机的机器指令编制的程序不能在另一种计算机上执行。在现今，除了计算机生产厂家的专业人员外，绝大多数程序员已经不再学习机器语言。 （3) 示例 图 1 机器语言 （4）指令集架构 又称指令集或指令集体系（英语：Instruction SetArchitecture，缩写为 ISA），是计算机体系结构中与程序设计有关的部分，包含了基本数据类型，指令集，寄存器，寻址模式，存储体系，中断，异常处理以及外部 I/O。指令集架构包含一系列的 opcode 即操作码（机器语言），以及由特定处理器执行的基本命令。 计算机微处理器的指令集架构（Instruction Set Architecture）常见的有两种： 精简指令集运算（Reduced Instruction SetComputing，RISC）：该指令集较为简单，每个指令的运行时间较短，完成的操作也简单，指令的执行性能较佳；但是要做复杂的事情，就需要由多个指令配合完成。当前有 UNIX、Linux、MacOS 以及包括 iOS、Android、WindowsPhone、WindowsRT 等在内的大多数移动操作系统运行在精简指令集的处理器上。 复杂指令集运算（Complex Instruction SetComputing，CISC）：与 RISC 不同的是，CISC 在指令集的每个小指令可以执行一些较低级的硬件操作，指令数目多而且复杂，每条指令的长度不同。因为指令执行较为复杂，所以每条指令花费的时间较长，但每个指令可以处理的工作较为丰富。常见的 CISC 指令集的 CPU 有 AMD、intel、VIA 等 X86 架构的 CPU。当前 x86 架构微处理器如 Intel 的 Pentium/Celeron/Xeon 与 AMD 的 Athlon/Duron/Sempron；以及其 64 位扩展系统的 x86-64 架构的 Intel64 的 Intel Core/Core2/Pentium/Xeon 与 AMD64 的 Phenom II/Phenom/Athlon64/Opteron/Ryzen/EPYC 都属于复杂指令集。主要针对的操作系统是微软的 Windows 和苹果公司的 OSX。另外 Linux，一些 UNIX 等，都可以运行在 x86（复杂指令集）架构的微处理器。 参考：https://www.processon.com/view/link/5dad48c8e4b0e4339303ebe2 汇编语言（assembly language） 概念：是用与代码指令实际含义相近的英文缩写词、字母和数字等符号来取代指令代码的一种符号语言（汇编语言亦称符号语言）。所以说,汇编语言是一种用助记符表示的仍然面向机器的计算机语言。 特点：机器语言和汇编语言都是面向硬件(CPU)的语言，语言对机器过分依赖。在不同的设备中，汇编语言对应着不同的机器语言指令集。一种汇编语言专用于某种计算机系统结构，而不像许多高级语言，可以在不同系统平台之间移植。使用汇编语言编写的源代码，然后通过相应的汇编程序将它们转换成可执行的机器代码。这一过程被称为汇编过程。 （3）示例：如用 ADD 表示运算符号“＋”的机器代码 图 2 汇编语言 高级语言（High-level programming language）（1）概念：高级编程语言是高度封装了的编程语言。它是以人类的日常语言为基础的一种编程语言，使用一般人易于接受的文字来表示，有较高的可读性，以方便对电脑认知较浅的人亦可以大概明白其内容。由于早期电脑业的发展主要在美国，因此一般的高级语言都是以英语为蓝本。 （2）示例：现在开发人员使用的大部分都是高级语言，如 Java、JavaScript、Python 等等 （3）特点：高级语言是面向用户的语言。无论何种机型的计算机,只要配备上相应的高级语言的编译或解释程序,则用该高级语言编写的程序就可以通用 编译型语言和解释型语言分类依据根据高级程序语言的运行方式不同，分为两种：编译型语言和解释型语言 根本区别：把高级语言编译成机器语言，执行这个编译过程的时机不同，即运行方式不同 概念（1）编译型语言 在程序运行之前：使用针对特定 CPU 体系的编译器，将源代码（高级程序语言编写的代码）一次性的编译成目标代码（机器语言编写的代码）（源代码——机器码）； 程序运行时，直接运行编译好的目标代码； 再次运行时，可直接使用上一次编译好的机器码，不需要重新编译。 (2) 解释型语言 程序运行时：即边编译边运行，每编译一行程序（高级语言——机器语言），就立刻运行，然后再编译下一行，再运行，如此不停地进行下去； 再次运行时，需要重新进行编译。 （3）比较 图 3 高级语言执行过程 用解释器来运行程序会比直接运行编译过的机器代码来得慢，但是相对的这个解释的行为会比编译再运行来得快。这在程序开发的雏型化阶段和只是撰写试验性的代码时尤其来得重要，因为这个“编辑-解释-调试”的循环通常比“编辑-编译-运行-调试”的循环来得省时许多。所以解释型语言可以达到较快的开发速度，编译型语言可以达到较快的运行进度之间。 常用语言分类编译型语言：C、C++ 解释型语言：JavaScript、Python、MATLAB、TypeScript 总结编译型与解释型，两者各有利弊。 Java 语言虽然比较接近解释型语言的特征，但在执行之前已经预先进行一次预编译，生成的代码是介于机器码和 Java 源代码之间的中介代码，运行的时候则由 JVM（Java 的虚拟机平台，可视为解释器）解释执行。它既保留了源代码的高抽象、可移植的特点，又已经完成了对源代码的大部分预编译工作，所以执行起来比“纯解释型”程序要快许多。 既然编译型与解释型各有优缺点又相互对立，所以一批后来诞生的语言都有把两者折衷起来的趋势。总之，随着设计技术与硬件的不断发展，编译型与解释型两种方式的界限正在不断变得模糊。 其他概念【源程序】又叫源码，用非机器语言书写好的符号程序称源程序 【目标程序】指源程序经编译后可直接被不同 CPU 架构运行的机器码集合 图 4 编译器 图 5 解释器 转自：*https://blog.csdn.net/qq_41026740/article/details/96009765* https://www.cnblogs.com/clemente/p/10413618.html 静态类型(Static Typing) VS 动态类型(Dyn amic Typing)分类标准编程语言里会有类型检查的机制，类型检查的目的是避免程序发生一些未预料到的错误。 编程语言按照类型检查可以分为两大类：静态类型和动态类型。二者的根本区别在于：进行类型检查的时机，类型检查可以理解为：确定变量的类型，并实行类型的约束操作（类型转换） 概念 静态类型 在运行前进行数据类型检查的语言，即静态类型语言中，变量的类型必须先声明，即在创建的那一刻就已经确定好变量的类型 动态类型 在程序运行时才做数据类型检查的语言，即动态类型语言中，声明变量时无需指定类型，第一次将某类型的数据赋值给变量，在内部会将数据类型记录下来，成为该变量的类型 【注意】静态类型在编译型语言中较为普遍，动态类型在解释型语言中较为普遍，但不是绝对的，如 TypeScript 是解释型语言，静态类型语言 讨论静态类型在程序运行前，就能可靠地发现类型错误。因此通常能增进最终程序的可靠性。然而，有多少的类型错误发生，以及有多少比例的类型错误能被静态类型所捕捉，目前对此仍有争论。静态类型的拥护者认为，当程序通过类型检查时，它才有更高的可靠性。但是动态类型的拥护者指出，大部分软件证明，两者在可靠性上并没有多大差别。 常用语言分类静态类型语言：Java、C、C++、TypeScript 动态类型语言：JavaScript、Python 【补充】前端最常用见的 10 个错误中，有 7 个是类型错误，ts 它是静态类型语言。在没运行的时候，IDE 就帮我们做类型检查了，能减少错误，所以前端开发就这方面而言 ts 优于 js。 转自：https://www.jianshu.com/p/bc492fcbf18f 强类型(Strong Typing) VS 弱类型(Weak Typing)分类标准按编程语言对类型检查的严格程度的强弱之分：分为强类型定义语言和弱类型定义语言 概念 强类型语言 一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了 2、弱类型语言 对于变量类型的检查比较宽松，容忍隐式类型转换这种事情的发生，包括相关类型之间隐式转换和不相关类型之隐式间转换 常用语言分类强类型语言：Python、Java、C# 弱类型语言：JavaScript、TypeScript 【注意点】“这门语言是不是动态语言”与“这门语言是否类型安全”之间是完全没有联系的 例如： Python 是动态语言，是强类型定义语言（类型安全的语言） JavaScript 是动态语言，是弱类型定义语言（类型不安全的语言） JAVA 是静态语言，是强类型定义语言（类型安全的语言） 对强弱类型的深入理解虽然对这两个词是这样定义的，但是在技术含义上这两个术语尚未达成共识。相比之下，静态类型化意味着程序在执行之前就经过检查，程序可能在启动前被拒绝。动态类型化意味着在执行过程中会检查值的类型，而类型错误的操作可能会导致程序停止运行或在运行时发出错误信号。静态类型化的主要原因是要排除可能具有此类“动态类型错误”的程序。 强类型通常意味着类型系统中没有漏洞，而弱类型意味着类型系统可以被破坏。但是 C 语言，在编译时对语言进行类型检查（静态类型），但是仍然存在很多漏洞。几乎可以将任何类型的值转换为相同大小的另一类型，特别是可以自由地转换指针类型。 所以不同的人对“强”和“弱”两个程度副词的理解和定义是不同的。所以避免使用这两个词对语言做区分。 转自：https://blog.csdn.net/m0_37828249/article/details/87971474 集成开发环境(IDE(IntegratedDevelopmentEnvironment)) VS 编辑器(Editor)概念1、编辑器 就是基于对一个文件、一个视频、一串数字等进行编辑或者再次编辑的工具。一般是为了文件、视频或者字符有更好的体现功能才进行的编辑，总的来说大概就是修改与编写的意思，可编写代码，也可编写文字，编辑图片等。常见的编辑器有文本编辑器、网页编辑器、源程序编辑器、图像编辑器，声音编辑器，视频编辑器等 示例：Notepad++等 2、IDE 集成开发环境（IDE，Integrated Development Environment）,是用于提供程序开发环境的应用程序，一般包括代码编辑器、编译器、调试器和图形用户界面等工具。集成了代码编写功能、分析功能、编译功能、调试功能等一体化的开发软件服务套。所有具备这一特性的软件或者软件套（组）都可以叫集成开发环境。编译器、编辑器、调试器都可以属于 IDE，如微软的 VisualStudio 系列，Borland 的 C++Builder、Delphi 系列等。该程序可以独立运行，也可以和其它程序并用。IDE 多被用于开发 HTML 应用软件。 简单说，就是集成了编辑器、编译器以及链接器等众多功能的一个集成开发环境。 示例：Visual Studio 系列、webstorm 等(vs code 加上它一大堆插件) 转自：https://blog.csdn.net/pointer_5/article/details/94242888 语法糖(Syntactic sugar) VS 语法盐(syntactic salt)概念 语法糖 语法糖是在不改变其所在位置的语法结构的前提下，实现了运行时等价。可以简单理解为，加糖后的代码编译后跟加糖前一模一样，只是更方便程序员使用，让程序更加简洁，有更高的可读性 示例：ES6 的箭头函数、解构赋值等 2、语法盐 语法盐是指那些为避免容易犯的语法错误加上的额外语法限制。这些特性强迫程序员做出一些基本不用于描述程序行为，而是用来证明他们知道自己在做什么的额外举动。 示例： 类型检查 有人建议在用 end if, end while 等代替现在的统一的 end C++ 通过引入 static_cast、reinterpret_cast、const_cast 和 dynamic_cast 这四种转换来强迫程序员多敲键盘，从而令他们少用转换 C#在 switch 语法中的 case 标记代码块内，如果没有 goto、return、throw 跳离语法，一定得加上 break 语法 如果非常仔细、小心，这些语法盐可能就是多余的 转自：https://segmentfault.com/a/1190000010159725 重复发明轮子(Reinvent the wheel)来源我们都知道轮子应该是圆的最省力，但是当我们的祖先不知道什么形状最省力的情况下，就可能会发明出三角轮、四边轮、五边轮等等。当大家都知道圆形的轮子是最省力的，是最好的形状之后，再发明其他形状的轮子就没有什么意义了。当大家都知道圆形的轮子是最省力的、是最好的形状之后，如何改进现有的圆形轮子，才是最重要的。 为什么是轮子因为轮子是人类历史上最伟大的发明之一。轮子是人类的早期发明物之一。早期的轮子，是光滑的圆木，人们借助于这些圆木在地面上移动物体。历史上没有记录表明轮子是在什么年代、由谁发明的。然而，当“第一个发明者”把轮子安装在轴上时，人们就开始利用轮子把物体从一个地方移动到另一个地方。人们发现，在公元前 2000 年埃及古文物中，便有了轮子；古代中国文明也有发明使用轮子的记载和考古发现。 尽管轮子如此强烈地吸引着人类，可是人们却花费了几个世纪的时间来建造使用轮子的机器，而且大约有 400 多年，轮子的基本形状一直没有变化。 概念 概念 是指前人已经指明了方向，我们需要了解之前轮子的原理和利弊，加以改进或修改，使它更好或者满足自己新的需求。 2、示例 Linus 在上大学的时候，他觉得老师教学用的操作系统 Minix 不够好用，于是就自己写了一个操作系统来代替，这东西就叫 Linux,市场份额占到了服务器市场的一半甚至更多在与其他人开发 Linux 的过程中，他们一直使用的版本控制系统 Bitkeeper 终止了授权，而 Torvalds 觉得其他的版本控制系统太蠢了，于是花了一周又自己写了一个东西，叫做 Git。于是这个东西又占到了版本控制系统市场的七成甚至八成以上的份额。 脚手架(Scaffolding)概念在计算中使用的脚手架指的是两种技术之一： 第一种是与某些 MVC 框架中的数据库访问相关的代码生成技术; 第二种是由各种工具支持的项目生成技术。 “脚手架”是一种元编程的方法，用于构建基于数据库的应用。许多 MVC 框架都有运用这种思想。程序员编写一份 specification（规格说明书），来描述怎样去使用数据库；而由（脚手架的）编译器来根据这份 specification 生成相应的代码，进行增、删、改、查数据库的操作。我们把这种模式称为”脚手架”，在脚手架上面去更高效的建造出强大的应用。 前端开发中脚手架的作用是创建项目的初始文件，本质是方案的封装。前端工程体系的功能涵盖范围广，封装的方案类型多，对应的配置项也非常复杂。而且，大多数前端工程体系的开发者并不是一线的业务开发者。对于业务开发者来说，这套工程体系就是一个黑盒，他们不需要了解其中的复杂原理，只需要知道如何配置即可。所以业务开发者的需求就是快速开发快速配置，并且生成的配置项跟项目要对应，既要满足项目的功能需求，又不能有“混淆视听”的冗余功能。 CLI(command-line interface)CLI 为 command-line interface 的缩写，意为：命令行界面，是脚手架的实现方式之一。VueCLI 是一个 Vue.js快速开发的完整系统（或者俗称为：命令行工具），它所具有的一项功能是：快速搭建繁杂的单页面应用。 vue 的 clivue 是一套渐进式（就是你需要什么就用什么，不需要什么就可以不用，强制你遵守的规则很少），自底向上增量开发（就是根据系统和硬件编写出基层的基本需求代码，再慢慢增加模块），由于他要求遵守的规则较少，你可以引不同自己需要的东西，就需要配合 webpack 打包工具把引入的不同模块的东西打包 webpack 是一个工具，俗称打包工具，就是把所以浏览器不能识别的东西如（less，scss）等转换为浏览器可以识别的语言如（css），因为 vue 中需要引入大量的各种各样的模块所以很依赖 webpack 。在 webpack 看来 一切皆模块。 cli 他能快速生成 webpack 打包结构，就跟‘！’可以动态生成 html 框架一样。 转自：https://blog.csdn.net/pojpoj/article/details/100737194 银弹(Silver Bullet)来源 在古老的传说里，狼人是不死的。想要杀死狼人有几种方法： １.像杀死吸血鬼那样用木桩钉住狼人的心脏； ２.将月光遮住 ３.用银子做的子弹射穿透狼人的心脏或头 当然现实中是没有狼人的。但现实中确实有银弹这个东西。而其意义也类似于能杀死狼人的最好办法。现实中的狼人可以是一个棘手的项目，或者一件不可能的事。而“银弹”就是指能解决这些事的方法，或者技术手段。如果看过《人月神话》，那一定对银弹这个词并不陌生。不过在 IT 行业中，只有张嘴不办事的人会去幻想银弹技术。《没有银弹》（NoSilver Bullet）是 IBM 大型电脑之父佛瑞德·布鲁克斯（FredBrooks）在 1987 年所发表的一篇关于软体工程的经典论文。该论述中强调由于软体的复杂性本质，而使真正的银弹并不存在；所谓的没有银弹是指没有任何一项技术或方法可使软件工程的生产力在十年内提高十倍。 概念本意是指万金油、万能药、一个完美的解决方案。在软件开发中，银弹是指使得使生产率、可靠性或简洁性获得数量级上的进步。但是软件开发本身具备复杂性，不可见性，可变性，随着计算机历史的发展，软件开发次要困难从很大程度上已经得到解决，但从某种程度上来说，无论怎么发展，软件本身具有的复杂性都没有从根本上得到解决。 转自：*https://www.zhihu.com/question/20829469* https://www.zhihu.com/question/20829469/answer/16319016 Shim VS polyfill概念 shim shim 一般指一些做兼容性的库,用来弥补旧浏览器对新特性支持的不足。它将一个新的 API 引入到一个旧的环境中,而且仅靠旧环境中已有的手段实现，即把不同 API 封装成一种。 polyfill 一个 polyfill 就是一个用在浏览器 API 上的 shim，也是·对浏览器的不足做补充。但是它的做法是先检查当前浏览器是否支持某个 API,如果不支持的话就加载对应的 polyfill.然后新旧浏览器就都可以使用这个 API 了 示例：旧浏览器不支持 ES6 的 Array.prototype.find 方法,我们想要在项目中使用Array.prototype.find, Shim：function arrayFind() { if (Array.prototype.find) {// … } else {// … }} Polyfill：if (!Array.prototype.find) { Array.prototype.find = function() {// …}} 转自：https://www.jianshu.com/p/26d34cebf6be?utm_source=oschina-app 库 (library) VS 框架(framework)概念1、库 库是一系列预先定义好的数据结构和函数(对于面向对象语言来说，是类)的集合，提供给开发者使用，程序员通过使用这些数据结构和函数实现功能。库没有控制权，控制权在使用者手中，在库中查询需要的功能在自己的应用中使用。 2、框架 框架也是一系列预先定义好的数据结构和函数，一般用于作为一个软件的骨架，会基于自身的特点向用户提供一套相当于叫完整的解决方案，而且控制权的在框架本身，使用者要找框架所规定的某种规范进行开发。 本质区别 框架与库之间最本质区别在于控制权：you call libs, frameworks callyou（控制反转） 联系和区别二者联系紧密，他们以聚合的形式让我们在所要开发的应用中使用，在框架中我们完全可以自由的使用库，同时也可以没有框架的基础之上使用库，使用库的控制权始终在我们的手中，但是使用框架时候就必须按照它的规范来进行模块化的开发。 图 6 库和框架的关系 图 7 应用、库和框架的关系 转自：*https://www.jianshu.com/p/60100985dd7f* 方法(method ) VS 函数(function)函数属于整个文件, 方法属于某一个对象，函数可以直接调用,方法必须用对象或者类来调用 URL VS URI VS URN概念1、URI：Uniform Resource Identifier，统一资源标识符 URI 是以某种统一的（标准化的）方式标识资源的简单字符串，一般由三部分组成： （1）访问资源的命名机制。 （2）存放资源的主机名。 （3）资源自身的名称，由路径表示 2、URL：Uniform Resource Locator，统一资源定位符 URL 是 Internet 上用来描述信息资源的字符串，主要用在各种 WWW 客户程序和服务器程序上。采用 URL 可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。 URL 的格式由下列三部分组成： （1）协议（或称为服务方式）； （2）存有该资源的主机 IP 地址（有时也包括端口号）； （3）主机资源的具体地址。如目录和文件名等。 第一部分和第二部分之间用”：//”符号隔开，第二部分和第三部分用”/”符号隔开。第一部分和第二部分是不可缺少的，第三部分有时可以省略。 URN：Uniform Resource Name，统一资源名称 URN 是用特定命名空间的名字标识资源 联系和区别 联系 URL 和 URN 都是 URI 的一种，URI 的范畴位于体系的顶层，URL 和 URN 的范畴位于体系的底层。这种排列显示 URL 和 URN 都是 URI 的子范畴。 图 8 三者的关系 不同 URI 指的是一个资源,URL 是用地址定位一个资源，URN 是用名称定位一个资源 转自：https://www.cnblogs.com/wxlzhizu/archive/2010/06/04/1751517.html localStorage VS sessionStorage概念localStorage 和 sessionStorage 一样都是用来存储客户端临时信息的对象，他们均只能存储字符串类型的对象（虽然规范中可以存储其他原生类型的对象，但是目前为止没有浏览器对其进行实现） 异同点 相同点 存储大小都是 5MB 都保存在客户端，不与服务端交互通信 只能存储字符串类型，对于复杂的对象可以使用 ECMAScript 提供的 JSON 对象的 stringify 和 parse 来处理 不同点 生命周期不同 localStorage 生命周期是永久，关闭页面或浏览器之后 localStorage 存储的数据也不会丢失，除非用户显式地在浏览器提供的 UI 上清除 localStorage 信息，否则这些信息将永远存在 sessionStorage 生命周期为当前窗口或标签页，一旦窗口或标签页被永久关闭了，那么所有通过 sessionStorage 存储的数据也就被清空了 数据共享机制 不同浏览器无法共享 localStorage 或 sessionStorage 中的信息。 相同浏览器的不同页面间可以共享相同的 localStorage（页面属于相同域名和端口） 不同页面或标签页间无法共享 sessionStorage 的信息。这里需要注意的是，页面及标签页仅指顶级窗口，如果一个标签页包含多个 iframe 标签且他们属于同源页面，那么他们之间是可以共享 sessionStorage 的。 转自：https://www.cnblogs.com/vickylinj/p/10883256.html 向前兼容(Foreward Compatibility) VS 向后兼容(Backward Compatibility)概念 兼容包括：硬件兼容性和软件兼容性 Forward 意思是向前进，指未来，向前兼容是站在旧版本的立场讨论未来版本的兼容性问题。在计算机中指在较低档计算机上编写的程序，可以在同一系列的较高档计算机上运行，或者在某一平台的较低版本环境中编写的程序可以在较高版本的环境中运行，都称为向上兼容，前者是硬件兼容，而后者是软件兼容。向上兼容具有非常重要的意义，一些大型软件的开发，工作量极大，如这些软件都能做到兼容，则无需在其它机器上重新开发，就可节省庞大的人力和物力。 Backward 意思是向后退，指过去，站在新版本的立场讨论过去版本的兼容性问题。在计算机中指在一个程序或者类库更新到较新的版本后，旧的版本程序创建的文档或系统仍能被正常操作或使用，或在旧版本的类库的基础上开发的程序仍能正常编译运行的情况。例如较高档的计算机或较高版本的软件平台可以运行较为低档计算机或早期的软件平台所开发的程序。向下兼容可以使用户在进行软件或硬件升级时，厂商不必为新设备或新平台从头开始编制应用程序，以前的程序在新的环境中任然有效。 转自：https://blog.csdn.net/wangxufa/java/article/details/72846362 正向代理(Forward proxy) VS 反向代理(Reverse proxy) 网络代理分为正向代理和反向代理。 正向代理（1）概念 当客户端无法访问外部资源的时候，可以通过一个正向代理去间接地访问，所以客户端需要配置代理服务器的 ip。 正向代理是一个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须设置正向代理服务器，当然前提是要知道正向代理服务器的 IP 地址，还有代理程序的端口。 图 9 正向代理 （2）举例 我是一个用户，我访问不了某网站，但是我能访问一个代理服务器，这个代理服务器呢,他能访问那个我不能访问的网站，于是我先连上代理服务器,告诉他我需要那个无法访问网站的内容，代理服务器去取回来,然后返回给我。从网站的角度，只在代理服务器来取内容的时候有一次记录，有时候并不知道是用户的请求，也隐藏了用户的资料，这取决于代理告不告诉网站。 图 10 反向代理 作用 访问原来无法访问的资源，如 google 可以做缓存，加速访问资源 对客户端访问授权，上网进行认证 代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息 反向代理 概念 反向代理实际运行方式是指以代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个服务器。客户端是感知不到代理的存在的，反向代理对外都是透明的，访问者者并不知道自己访问的是一个代理。因为客户端不需要任何配置就可以访问。 作用 保证内网的安全，可以使用反向代理提供 WAF 功能，阻止 web 攻击大型网站，通常将反向代理作为公网访问地址，Web 服务器是内网 负载均衡，通过反向代理服务器来优化网站的负载 转自：https://www.jianshu.com/p/a1c35f5d27f7 ES6 VS ES2015ECMAScript 和 JavaScript 的关系ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现。 JavaScript 是 Netscape 创造的并交给了国际标准化组织 ECMA，之所以不叫做 JavaScript 由于商标的问题，java 是 sun 公司的商标，根据授权协议只有 Netscape 公司可以合法使用 JavaScript 这个名字，另外就是为了体现 JavaScript 的标准的制定者不是 ECMA 所以取名为 ECMAScript ECMAScript 的历史ECMAScript 1.0 是 1997 年发布的，接下来的两年，连续发布了 ECMAScript 2.0（1998年 6 月）和 ECMAScript 3.0（1999 年 12 月）。3.0版是一个巨大的成功，在业界得到广泛支持，成为通行标准，奠定了 JavaScript语言的基本语法，以后的版本完全继承。直到今天，初学者一开始学习JavaScript，其实就是在学 3.0 版的语法。 2000 年，ECMAScript 4.0 开始酝酿。这个版本最后没有通过，但是它的大部分内容被 ES6继承了。因此，ES6 制定的起点其实是 2000 年。 为什么 ES4 没有通过呢？因为这个版本太激进了，对 ES3做了彻底升级，导致标准委员会的一些成员不愿意接受。2008 年 7月，由于对于下一个版本应该包括哪些功能，各方分歧太大，争论过于激烈，ECMA开会决定，中止 ECMAScript 4.0 的开发，将其中涉及现有功能改善的一小部分，发布为ECMAScript3.1，而将其他激进的设想扩大范围，放入以后的版本，由于会议的气氛，该版本的项目代号起名为Harmony（和谐）。会后不久，ECMAScript 3.1 就改名为 ECMAScript 5。 ES6 与 ECMAScript 2015 的关系ES6 是 ECMA 的为 JavaScript 制定的第 6 个版本的标准，标准委员会最终决定，标准在每年的 6月份正式发布一次，作为当年的正式版本。ECMAscript 2015是在 2015 年 6 月份发布的 ES6 的第一个版本。依次类推 ECMAscript 2016 是 ES7、 ECMAscript2017 是 ES8……，最新的是 ECMAscript 2019，即 ES10 转自：https://es6.ruanyifeng.com/#docs/intro 进程(process) VS 线程(thread)进程和线程是操作系统的基本概念 概念进程：是执行中一段程序，即一旦程序被载入到内存中并准备执行，它就是一个进程。进程是表示资源分配的的基本概念，又是调度运行的基本单位，是系统中的并发执行的单位。 线程：单个进程中执行中每个任务就是一个线程。线程是进程中执行运算的最小单位。 从 CPU 运行的角度理解CPU+RAM+各种资源（比如显卡，光驱，键盘等等外设）构成我们的电脑，但是电脑的运行，实际就是 CPU 和相关寄存器以及 RAM 之间的事情。 执行一段程序代码，实现一个功能的过程是：当得到 CPU 的时候，相关的资源必须也已经就位，然后 CPU 开始执行。这里除了 CPU 以外所有的就构成了这个程序的执行环境，也就是我们所定义的程序上下文。当这个程序执行完了，或者分配给他的 CPU 执行时间用完了，那它就要被切换出去，等待下一次得到 CPU。在被切换出去的最后一步工作就是保存程序上下文，因为这个是下次他得到 CPU 的运行环境，必须保存。 所以计算机工作的过程是：先加载程序 A 的上下文，然后开始执行 A，保存程序 A 的上下文，调入下一个要执行的程序 B 的程序上下文，然后开始执行 B,保存程序 B 的上下文。 进程和线程就是这样的背景出来的，两个名词是对应的 CPU 时间段的描述。进程就是包换上下文切换的程序执行时间总和，即 CPU 加载上下文、CPU 执行、CPU 保存上下文之和。进程的颗粒度太大，每次都要有上下的调入，保存，调出。如果我们把进程比喻为一个运行在电脑上的软件，那么一个软件的执行不可能是一条逻辑执行的，必定有多个分支和多个程序段，就好比要实现程序 A，实际分成a，b，c 等多个块组合而成。那么这里具体的执行就可能变成：程序 A 得到 CPU，然后 CPU 加载上下文，开始执行程序 A 的 a 小段，然后执行 A 的 b 小段，然后再执行 A 的 c 小段，最后 CPU 保存 A 的上下文。这里 a，b，c 的执行是共享了 A 的上下文，CPU 在执行的时候没有进行上下文切换的。这里的 a，b，c 就是线程，也就是说线程是共享了进程的上下文环境，的更为细小的 CPU 时间段。 二者关系（1）根本区别：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位 （2）资源开销：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。 （3）包含关系：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。 （4）内存分配：同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的 （5）影响关系：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。 （6）执行过程：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行 转自：https://blog.csdn.net/ThinkWon/java/article/details/102021274 https://blog.csdn.net/ThinkWon/article/details/102021274 参考：http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html 形参（parameter） VS 实参 (argument)概念1、实参 全称为”实际参数”，是在调用时传递给函数的参数。实参可以是常量、变量、表达式、函数等 2、形参 全称为”形式参数”由于它不是实际存在变量，所以又称虚拟变量。是在定义函数名和函数体的时候使用的参数,目的是用来接收调用该函数时传入的参数 VR（Virtual Reality）VS AR（Augmented Reality） VS MR（Mixed Reality）概念1、VR（虚拟现实） 是指利用计算机技术模拟产生一个为用户提供视觉、听觉、触觉等感官模拟的三度空间虚拟世界，用户借助特殊的输入/输出设备，与虚拟世界进行自然的交互。用户进行位置移动时，电脑可以通过运算，将精确的三维世界视频传回产生临场感，令用户及时、无限制地观察该空间内的事物，如身临其境一般。 简单地说，VR 看到的图像全是计算机模拟出来的，都是虚假的 2、AR（增强现实） 是一种实时计算摄影机影像位置及角度，并辅以相应图像的技术。这种技术可以通过全息投影，在镜片的显示屏幕中将虚拟世界与现实世界叠加，操作者可以通过设备互动。 AR 是将虚拟信息加在真实环境中，来增强真实环境，因此看到的图像是半真半假，如 Faceu 激萌特效相机 APP，这款 APP 会自动识别人脸，并在人脸上叠加动态贴图和道具，从而创造出卖萌搞笑效果的照片，例如加兔子耳朵、加彩虹特效 3、MR（混合现实） 指的是结合真实和虚拟世界创造了新的环境和可视化三维世界，物理实体和数字对象共存、并实时相互作用，以用来模拟真实物体，是虚拟现实技术的进一步发展。 MR 是将真实世界和虚拟世界混合在一起，可以说它呈现的图像令人真假难辨 三者关系VR 概念最小，AR 概念包含了 VR，MR 概念最大，包含了 VR 和 AR AR 和 MR 的辨别虚拟物体与真实物体是不是被肉眼分离出来，如果不能被肉眼分离的就是 MR，可以的就是 AR。例如之前提到的 Faceu 激萌特效相机 APP 以及不少 AR 应用一眼就可以知道哪些是真的，哪些是假的。而 MR 直接向视网膜投射整个 4 维光场，所以用户看到的物体和看真实的物体，从数学上是没有区别的。 转自：*https://www.sohu.com/a/203516748_100033040* yarn VS npm二者都是 JS 依赖包管理工具，Yarn 是由 Facebook，google，Exponent 和 Tilde制作的一种新的 JavaScript 软件包管理器。可以在官方公告上看到，其目的是解决团队在npm 面临的问题，即安装包不够快、有安全隐患，npm 允许安装包执行代码。 npm 的问题 npm install 的时候非常慢，删除 node_modules，重新 install 的时候依旧如此； 同一个项目，安装的时候无法保持一致性。由于 package.json 文件中版本号的特点，下面三个版本号在安装的时候代表不同的含义。 图 11 npm 版本控制 “5.0.3”表示安装指定的 5.0.3 版本，“～ 5.0.3”表示安装 5.0.X 中最新的版本，“^5.0.3”表示安装 5.X.X 中最新的版本。这就会导致同一个项目，由于安装的版本不一致出现 bug。 安装的时候，包会在同一时间下载和安装，中途某个时候，一个包抛出了一个错误，但是 npm 会继续下载和安装包。因为 npm 会把所有的日志输出到终端，有关错误包的错误信息就会在一大堆 npm 打印的警告中丢失掉，使得不太容易注意到实际发生的错误。 yarn 的优点1、速度快，速度快主要来自以下两个方面： （1）并行安装：无论 npm 还是 Yarn 在执行包的安装时，都会执行一系列任务。npm是按照队列执行每个 package，也就是说必须要等到当前 package安装完成之后，才能继续后面的安装。而 Yarn 是同步执行所有任务，提高了性能。 （2）离线模式：如果之前已经安装过一个软件包，用 Yarn 再次安装时之间从缓存中获取，就不用像 npm 那样再从网络下载了。 2、安装版本统一 为了防止拉取到不同的版本，Yarn 有一个锁定文件 (lock file)记录了被确切安装上的模块的版本号。每次只要新增了一个模块，Yarn就会创建（或更新）yarn.lock这个文件。这么做就保证了，每一次拉取同一个项目依赖时，使用的都是一样的模块版本。 3、更简洁的输出 npm 的输出信息比较冗长。在执行 npm install &lt;package&gt;的时候，命令行里会不断地打印出所有被安装上的依赖。相比之下，Yarn简洁太多：默认情况下，结合了emoji 直观且直接地打印出必要的信息，也提供了一些命令供开发者查询额外的安装信息。 转自：https://www.jianshu.com/p/254794d5e741 K VS P（Progressive）我们在下载电影时，通常有标清、高清、全高清甚至超高清的源，再细心一点我们会发现它们分别又叫 480p、720p、1080p…，那么这些数字背后意味着什么，K 和 p 又分别代表什么含义？ 概念 P 是 Progressive,逐行的意思，P 是逐行扫描，表示的是“视频像素的总行数”，几 P 就是纵向有多少行像素，例如，1080p 就是纵向有 1080 行像素，1080x1080（1:1），1440x1080（1.33），1920x1080（1.78），2581x1080（2.39），3840x1080（3.56）等都是 1080P K 表示的是“视频像素的总列数”， “几 K”的原始定义是：横向大约有几个 1024 列像素，1K 就是 1024，2K 就是 2048，4K 就是 4096，以此类推。但在电视领域，这些“几 K”都被加上了一个固定分辨率标准，比如 2K 是 2560x1440，4K 是 3840x2160，大家平时所说的这些所谓标准，都是 16：9 的电视标准（TV Standard） K”和“P”能否同时出现？要想准确描述一个屏幕或视频的分辨率，这两者必须同时出现，否则就会出现歧义 电视标准仅仅只在电视领域或日常生活中 16:9 的视频和显示器比例中适用，一旦脱离了电视领域，或者屏幕及视频比例不再是 16：9，该规则即作废，定义一个视频有几 K 的方法只有一个：横向像素数有几个 1024，定义一个视频有几 P 的方法也只有一个：纵向有多少行像素 4K（超高清）、1080P（全高清）、720P（超清）、480P（高清） 转自：https://www.bilibili.com/read/cv2889564/","link":"/2020/05/21/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%BF%85%E9%A1%BB%E6%8E%8C%E6%8F%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"title":"跨域解决","text":"什么导致了跨域跨域首先，网络是没有绝对安全可言的，但是，我们又需要使用浏览器来访问网络，所以浏览器能存在的安全基础就是有相对较高的安全性，提升了别人做坏事的成本。 Same-origin policy(同源策略,以下简写为 CORS)就是浏览器安全的一个重要部分。 同源策略是一个重要的安全策略，它用于限制一个源(Origin)的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。 同源策略的目的有两个： 对系统用户：保证用户信息的安全，防止恶意的网站窃取数据。 对开发人员：约束网站使用的资源尽可能是同源可控或者信任的资源，减少问题的可能性，从而来增强网站的安全性。 真实案例（仅限演示例子使用）：在登录腾讯文档后，打开一个文档，在控制台调用下面的代码，将会给一个好友分配该文档的编辑权限。 123456789$.ajax({ type: &quot;post&quot;, url: &quot;https://docs.qq.com/cgi-bin/redirect/300000000/ep/api/setpadinfo?localPadId=BYtWkVVnlVCW&amp;type=1&amp;ver=2&amp;route_ip=&amp;room_route_ip=&amp;get_vip_info=1&quot;, data: &quot;corp_id=&amp;data=%7B%22policy%22%3A1%2C%22addmemlist%22%3A%5B%7B%22uintype%22%3A0%2C%22uin%22%3A2803621806%2C%22work_id%22%3A%22%22%2C%22info%22%3A2%2C%22new%22%3A1%7D%5D%2C%22submemlist%22%3A%5B%5D%7D&amp;message=%7B%22seq%22%3A%2272bcde05-6052-44f2-be8c-b6454a3e6716%22%2C%22action%22%3A1%7D&amp;xsrf=ac8bd23b7c50fa4b&amp;dataType=0&quot;, success: function (data) { console.log(data); }, error: function (err) {},}); 退出账号后，调用相同代码，不能给相同好友分配该文档的编辑权限。并报下面的错误。 123cgicode: 11000;msg: &quot;no correct p_uin or p_skey or uid or uid_key in cookie [errcode:11000:0]&quot;;retcode: 11000; 由报错可以看出，出现问题是因为 cookie 中缺少相关信息，导致服务端认证失败。 在其他网站的控制台调用相同代码会报如下错误： 1Access to XMLHttpRequest at 'https://docs.qq.com/cgi-bin/redirect/300000000/ep/api/setpadinfo?localPadId=BYtWkVVnlVCW&amp;type=1&amp;ver=2&amp;route_ip=&amp;room_route_ip=&amp;get_vip_info=1' from origin 'https://fanyi.baidu.com' has been blocked by CORS policy: 、No 'Access-Control-Allow-Origin' header is present on the requested resource. 现在根据上面的情况试想在没有同源策略的情况下：在你登陆腾讯文档后，再打开一个其他源的网站，调用上面的代码，也是会成功给好友分配编辑权限的。进而联想到在一个第三方网站掌握腾讯文档的接口信息规则后，就可以假冒你对你的账号进行任意操作，这是十分可怕的。 那么怎么判断是同一个源呢，它的定义是什么呢？ 同源的定义：如果两个 URL 的协议、主机 和 端口 (如果有指定的话) 都相同的话，则这两个 URL 是同源。这个方案也被称为“协议/主机/端口元组”。 注： 只有浏览器才会有跨域问题，因为只有浏览器才有同源策略。 恶意文档：可能导致推栈缓冲区溢出，从而在电脑中执行一些代码的文件，一般指病毒或者木马的运行程序。 跨域示例下表给出了与 URL：http://store.company.com/dir/page.html 的源进行对比的示例: URL 结果 原因 http://store.company.com/dir2/other.html 同源 只有路径不同 http://store.company.com/dir/inner/another.html 同源 只有路径不同 https://store.company.com/secure.html 失败 协议不同 http://store.company.com:81/dir/etc.html 失败 端口不同 ( http: 默认端口是 80;https: 默认端口是 443) http://news.company.com/dir/other.html 失败 主机不同 注：域名和 IP 指向一样，但是还是会引起跨域的。例如：http://www.ths.com.cn/和http://223.223.179.206/都指向同一个地方 限制范围随着互联网的发展，”同源策略”越来越严格。目前，如果非同源，共有三种行为受到限制。 Cookie、LocalStorage、SessionStorage 和 IndexDB 无法读取。 脚本 API 访问。 AJAX 请求不能发送。 常见跨域错误缺少可跨域响应头 关键字： No ‘Access-Control-Allow-Origin’ header （Access-Control-Allow-Origin 翻译：允许访问的源）注：客户端发送的叫请求，服务器端返回的叫响应生动例子：客户端向服务器借钱是请求，服务器不给钱是对客户端的响应 允许跨域的值重复 关键字： The ‘Access-Control-Allow-Origin’ header contains multiple values ‘*, *‘, but only one is allowed。 （”允许访问的源“响应头包含重复的两个*号，但是只有一个是允许的）原因： 多次代理的时候配置的允许跨域的值有重复的。 不允许访问其他域的对象或者数据存储（cookie 等） 关键字：block a frame with origin form accessing a cross-origin frame （访问了一个跨域的源） 解决跨域跨域网络访问（Cross-origin network access）因为跨域产生的原因是两个资源不在同一个域，所以有四种解决的办法： 把两个资源放到同一个域中 服务器允许资源跨域共享(CORS) 浏览器插件 利用一些不受同源策略影响的标签实现（script） 把两个资源放到同一个域中 反向代理：通过 nginx 把多个资源代理到一块 参考 nginx 说明文档注： 在能操作文件的情况下，不建议多次代理，因为这样会导致网络传输变慢，影响系统的流畅性。 正向代理：通过同域的接口返回其他域的资源 注： 反向代理：访问自定义的接口来返回其他接口的资源，通过自定义接口已经不能分出真实资源来自哪里。 正向代理：由代理服务器去请求资源并返回给你，访问还是原来的真实网址。 不管是正向代理还是反向代理，都是由服务器端去进行访问的，所以要保证在服务器端能访问到真实地址。 服务器允许资源跨域共享 Tomcat 在 Tomcat 根目录 –&gt; conf –&gt; web.xml 的 web-app 节点下加入如下代码。 1234567891011121314&lt;filter&gt; &lt;filter-name&gt;CorsFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.catalina.filters.CorsFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;cors.allowed.origins&lt;/param-name&gt; &lt;param-value&gt;*&lt;/param-value&gt; &lt;!-- 当指定部分可跨域时，使用下面代码配置指定域 --&gt; &lt;!-- &lt;param-value&gt;http://127.0.0.1:10229&lt;/param-value&gt; --&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CorsFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 注: Tomcat 配置修改后必须重启 Tomcat 才会生效。 Nginx在 Nginx 的根目录 –&gt; conf –&gt; nginx.conf 文件适当写入下述代码。 全局可跨域 12345# 在 server 节点下添加以下语句add_header Access-Control-Allow-Origin *;add_header 'Access-Control-Allow-Credentials' 'true';add_header Access-Control-Allow-Methods 'GET,POST';add_header Access-Control-Allow-Headers 'Content-Type,*'; 指定接口可跨域 12345678# 在指定的 location 节点下添加，示例如下：location /tomcat/ { proxy_pass http://localhost:8090/; add_header Access-Control-Allow-Origin *; add_header 'Access-Control-Allow-Credentials' 'true'; add_header Access-Control-Allow-Methods 'GET,POST'; add_header Access-Control-Allow-Headers 'Content-Type,*';} 注： Nginx 配置修改后必须重启才会生效。 同时添加全局可跨域和指定接口可跨域时，访问指定接口会产生可跨域响应头重复的问题，可使用指定接口代理，因此不推荐使用全局可跨域。 注意localtion的匹配规则 当配置指定域可跨域时，可把*换为具体的域名或者 IP，多个之间用逗号隔开。 多次代理设置具体相同的域也是会报允许跨域的值重复错误 多次代理设置域时，http:127.0.0.1:10229/ === http:127.0.0.1:10229 补：location 和 proxy_pass 易混淆点 location (后面两点为 URL 访问的相关知识补充) location 后面带不带/ 都是一样的 如果 URL 的格式为http://my.suyp.com/或者http://127.0.0.1:10229/，**尾部有没有/都不会造成重定向**。因为这种情况下，浏览器请求时会在后面默认加上/。可以这样理解，没有请求是访问的http://my.suyp.com,都是访问的http://my.suyp.com/,所以没有重定向。 如果 URL 的格式为http:127.0.1:10229/node/。尾部如果缺少/将导致重定向。因为根据约定，URL 尾部的/表示目录，没有/表示文件。所以访问/node/时，服务器会自动去该目录下找对应的默认文件或者返回该目录的文件列表。如果访问/node的话，服务器会先去找node文件，找不到的话会将node当成目录重定向到/node/，去该目录下找默认文件或者返回该目录的文件列表。 proxy_pass假设下面四种情况分别用 http://192.168.1.1/proxy/test.html 进行访问。 - 1234location /proxy/ { proxy_pass http://127.0.0.1:10229/;}# 代理到URL：http://127.0.0.1:10229/test.html - 1234location /proxy/ { proxy_pass http://127.0.0.1:10229; # （相对于第一种，最后少一个 / ）}# 代理到URL：http://127.0.0.1:10229/test.html - 1234location /proxy/ { proxy_pass http://127.0.0.1:10229/aaa/;}# 代理到URL：http://127.0.0.1:10229/aaa/test.html - 1234location /proxy/ { proxy_pass http://127.0.0.1:10229/aaa; # （相对于第三种，最后少一个 / ）}# 代理到URL：http://127.0.0.1:10229/aaatest.html 理解： 如果最后有/，就是把 URL 以location路由切割，把后面的部分放到代理地址的后面，如果没有，就是把路由加上后面的部分放到代理地址的后面。（注意: http://127.0.0.1===http://127.0.0.1/）。 推荐配置代理的写法： 123456789location /proxy/ { proxy_pass http://127.0.0.1/;}location /proxy/ { proxy_pass http://127.0.0.1/aaa/;}# location 的路由最后也加上/# proxy_pass 的最后也加上/# 好处：访问的地址和真实地址在/proxy/之后是完全一样的，便于理解记忆 Node 全局可跨域 123456789app.all(&quot;*&quot;, (req, res, next) =&gt; { // 设置允许跨域的域名，*代表允许任意域名跨域 res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); // 允许的header类型 res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;content-type&quot;); // 跨域允许的请求方式 res.header(&quot;Access-Control-Allow-Methods&quot;, &quot;DELETE,PUT,POST,GET,OPTIONS&quot;); next();}); 指定接口可跨域 12345678app.get(&quot;/node&quot;, (req, res) =&gt; { // 设置允许跨域的域名，*代表允许任意域名跨域 res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); // 允许的header类型 res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;content-type&quot;); // 跨域允许的请求方式 res.header(&quot;Access-Control-Allow-Methods&quot;, &quot;DELETE,PUT,POST,GET,OPTIONS&quot;);}); 注：因为 Node 的路由是由上到下匹配的，有符合的默认就不继续向下匹配了 + 指定全局可跨域时，一定要先写app.all + 在app.all 中，一定要加next(), 来让路由继续向下匹配 浏览器插件在 chrome 网上商店中搜索 Allow CORS: Access-Control-Allow-Origin 插件安装，在需要的时候运行即可。 利用一些不受同源策略影响的标签JSONPJSONP 是服务器与客户端跨源通信的一种方法。最大特点就是简单适用，老式浏览器全部支持，服务器不用做任何改造。 理论基础：Web 页面上调用 js 文件时是不受否跨域的影响（不仅如此，凡是拥有”src”这个属性的标签都拥有跨域的能力，比如&lt;script&gt;、&lt;img&gt;、&lt;iframe&gt;）。 因为 JSONP 是利用script标签的特性来实现跨域的，所以不支持post请求。 基本思想：在远程服务器上设法把数据装进 js 格式的文件里，供客户端调用和进一步处理。 首先，网页动态插入&lt;script&gt;元素，由它向跨源网址发出请求。 1234567891011121314151617function addScriptTag(src) { var script = document.createElement(&quot;script&quot;); script.setAttribute(&quot;type&quot;, &quot;text/javascript&quot;); script.src = src; document.body.appendChild(script);}window.onload = function () { // 这里使用一个文本来模拟jsonp服务端返回的最终数据格式 // 文本内容：jsonpExe({&quot;data&quot;:&quot;我是jsonp的数据&quot;}); addScriptTag(&quot;http://localhost:1000/jsonp.txt?callback=jsonpExe&quot;);};function jsonpExe(param) { // jsonp方式传回来的数据本身就是json对象 alert(JSON.stringify(param));} 上面代码通过动态添加&lt;script&gt;元素，向服务器localhost:1000发出请求。注意，该请求的查询字符串有一个callback参数，用来指定回调函数的名字，这对于 JSONP 是必需的。 服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。 1jsonpExe({ data: &quot;我是jsonp的数据&quot; }); 由于&lt;script&gt;元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了foo函数，该函数就会立即调用。作为参数的 JSON 数据被视为 JavaScript 对象，而不是字符串，因此避免了使用JSON.parse的步骤。 或者使用 AJAX 调用，示例如下： 12345678910111213141516function getJSONPData() { $.ajax({ type: &quot;get&quot;, url: &quot;http://localhost:1000/jsonp.txt&quot;, dataType: &quot;jsonp&quot;, // 一定要使用 jsonp 类型 success: function (data) { console.log(data); }, error: function (err) {}, });}function jsonpExe(param) { // jsonp方式传回来的数据本身就是json对象 alert(JSON.stringify(param));} 表单提交数据不受同源策略的影响 表单提交: 123456789101112131415&lt;!-- 成功 --&gt;&lt;form action=&quot;http://localhost:10229/setUserInfo&quot; method=&quot;post&quot;&gt; &lt;p&gt; &lt;label&gt;用户名：&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;user&quot; /&gt; &lt;/p&gt; &lt;p&gt; &lt;label&gt;密&amp;nbsp;&amp;nbsp;&amp;nbsp;码：&lt;/label&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&quot;submit&quot; name=&quot;&quot; value=&quot;提交1&quot;&gt; &lt;input type=&quot;reset&quot; name=&quot;&quot; value=&quot;重置1&quot;&gt; &lt;/p&gt;&lt;/form&gt; ajax 请求： 12345678910111213// err 跨域$.ajax({ type: &quot;post&quot;, url: &quot;http://localhost:10229/setUserInfo&quot;, data: { user: &quot;suyp&quot;, }, success: function (data) { console.log(data); $(&quot;.txt-erea&quot;).text(data); }, error: function (err) {},}); 发散一下思维：虽然form标签只能发送数据，但是没有跨域问题，所以在只需要发送消息的时候也可以使用form来进行单方面通信。 Canvas 中的跨域问题受影响的方法如下： getImageData()：返回一个ImageData对象，用来描述 canvas 区域隐含的像素数据 toBlob()：创造Blob对象，用以展示 canvas 上的图片；这个图片文件可以被缓存或保存到本地，由用户代理端自行决定。如不特别指明，图片的类型默认为 image/png，分辨率为96dpi。 toDataURL() ：返回一个包含图片展示的 data URI 。可以使用 type 参数其类型，默认为 PNG 格式。图片的分辨率为96dpi。 下面以toDataURL()为例。 在使用Canvas绘制不同域的图片然后转为Base64时，会有跨域问题。但是，不影响 Canvas 绘制展示图片。 1234567891011121314151617&lt;body&gt; &lt;canvas id=&quot;myCanvas&quot; width=&quot;1920&quot; height=&quot;1080&quot; style=&quot;border: 2px solid grey&quot;&gt;当前浏览器不支持canvas&lt;/canvas&gt;&lt;/body&gt;&lt;script&gt; var canvas = document.getElementById(&quot;myCanvas&quot;) var context = canvas.getContext(&quot;2d&quot;) var img = new Image() // img.src = './img/思路logo紫.png'; // 同源图片 img.src = 'http://localhost:8090/CORS/思路logo蓝.png'; // 不同源图片 //图片加载完后，将其显示在canvas中 img.onload = function() { context.drawImage(this, 0, 0, 1920, 1080) // 改变图片大小到1080*980 // toDataURL是向canvas转为Base64的一个方法 console.log(canvas.toDataURL('image/png')); }&lt;/script&gt; 报错： 解决方式： 设置图片的crossOrigin = 'anonymous',来让toDataURL方法不因跨域报错 设置图片可跨域二者缺一不可。 1234567891011121314151617&lt;body&gt;&lt;canvas id=&quot;myCanvas&quot; width=&quot;1920&quot; height=&quot;1080&quot; style=&quot;border: 2px solid grey&quot;&gt;当前浏览器不支持canvas&lt;/canvas&gt;&lt;/body&gt;&lt;script&gt;var canvas = document.getElementById(&quot;myCanvas&quot;)var context = canvas.getContext(&quot;2d&quot;)var img = new Image()img.src = 'http://localhost:8090/CORS/思路logo蓝.png'; // 不同源图片img.crossOrigin = 'anonymous';//图片加载完后，将其显示在canvas中img.onload = function() { context.drawImage(this, 0, 0, 1920, 1080) // 改变图片大小到1080*980 // toDataURL是向canvas转为Base64的一个方法 console.log(canvas.toDataURL('image/png'));}&lt;/script&gt; 不允许 IFrame 被嵌入在响应头中有这么一个配置项 X-Frame-Options来标识一个页面是否可以被其他页面嵌入。可选值： deny：表示该页面不允许在 frame 中展示，即便是在相同域名的页面中嵌套也不允许。 sameorigin：表示该页面可以在相同域名页面的 frame 中展示。 allow-from uri：表示该页面可以在指定来源的 frame 中展示。（uri 为指定源的地址） 配置： Tomcat在 Tomcat 根目录 –&gt; conf –&gt; web.xml 的 web-app 节点下加入如下代码。 1234567891011121314151617 &lt;!-- 配置页面是否能被其他页面展示 --&gt;&lt;filter&gt; &lt;filter-name&gt;httpHeaderSecurity&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.catalina.filters.HttpHeaderSecurityFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;antiClickJackingOption&lt;/param-name&gt; &lt;!-- 配置的具体值 --&gt; &lt;param-value&gt;sameorigin&lt;/param-value&gt; &lt;/init-param&gt; &lt;async-supported&gt;true&lt;/async-supported&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;httpHeaderSecurity&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt; &lt;dispatcher&gt;FORWARD&lt;/dispatcher&gt;&lt;/filter-mapping&gt; 12345678910111213141516171819202122 &lt;!-- 配置页面是否能被其他页面展示 --&gt;&lt;filter&gt; &lt;filter-name&gt;httpHeaderSecurity&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.catalina.filters.HttpHeaderSecurityFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;antiClickJackingOption&lt;/param-name&gt; &lt;!-- 配置的具体值 --&gt; &lt;param-value&gt;allow-from&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 当指定部分域可展示时，使用下面代码配置指定域 --&gt; &lt;init-param&gt; &lt;param-name&gt;antiClickJackingUri&lt;/param-name&gt; &lt;param-value&gt;http://127.0.0.1:10229&lt;/param-value&gt; &lt;/init-param&gt; &lt;async-supported&gt;true&lt;/async-supported&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;httpHeaderSecurity&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt; &lt;dispatcher&gt;FORWARD&lt;/dispatcher&gt;&lt;/filter-mapping&gt; 注：目前测试指定域可嵌入无效，错误如下： 1testIframe.html:1 Invalid 'X-Frame-Options' header encountered when loading 'http://localhost:8090/CORS/testIframe.html': 'ALLOW-FROM http://127.0.0.1:10229' is not a recognized directive. The header will be ignored. Nginx配置 nginx 发送 X-Frame-Options 响应头，把下面这行添加到 ‘http’, ‘server’ 或者 ‘location’ 的配置中: add_header X-Frame-Options sameorigin always;add_header X-Frame-Options deny always;add_header X-Frame-Options allow-from 'http://127.0.0.1,http://127.0.0.2' always;小结：跨域网络访问推荐做法： 在能随意操作文件的情况优先把资源分类放到一起，这样既不会有跨域请求问题，也方便管理。 不行的话，使用 Nginx 代理。 跨域数据存储访问（Cross-origin data storage access）使用域名document.domain 属性中存入的是主机信息，并且可以设置为当前域或者当前域的父域。如果将其设置为其当前域的父域，则这个较短的父域将用于后续源检查。另外，任何对 document.domain 的赋值操作，包括 document.domain = document.domain 都会导致端口号被重写为 null。因此 company.com:8080 不能仅通过设置 document.domain = “company.com” 来与 company.com 通信。必须在他们双方中都进行赋值，以确保端口号都为 null 。 由于以上的情况，我们可以在多个只有二级域名不同的网页进行以下操作。 注： 域名 域名分类 CookieCookie 是服务器写入浏览器的一小段信息，只有同源的网页才能共享。但是，两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置 document.domain共享 Cookie。 举例来说，A 网页是**http://w1.example.com/a.html，B 网页是http://w2.example.com/b.html**，那么只要设置相同的 document.domain，两个网页就可以共享 Cookie。 1document.domain = &quot;example.com&quot;; 现在，A 网页通过脚本设置一个 Cookie。 1document.cookie = &quot;test1=hello&quot;; B 网页就可以读到这个 Cookie。 1var allCookie = document.cookie; 另外，服务器也可以在设置 Cookie 的时候，指定 Cookie 的所属域名为一级域名，这样二级域名和三级域名不用做任何设置，都可以读取这个 Cookie。 DOM如果两个窗口一级域名相同，只是二级域名不同，那么设置上一节介绍的 document.domain属性，就可以规避同源策略，拿到 DOM。 父页面： 1234window.onload = function () { document.domain = &quot;suyp.com&quot;; document.cookie = &quot;username=suyp&quot;;}; 子页面： 1234567891011121314151617181920window.onload = function () { document.domain = &quot;suyp.com&quot;;};// 这里请求时，会带上父页面的cookie: document.cookie = 'username=suyp';function getData() { $.ajax({ type: &quot;get&quot;, url: &quot;http://localhost:10229/node&quot;, // 默认情况下，标准的跨域请求是不会发送cookie的 xhrFields: { withCredentials: true, }, success: function (data) { console.log(data); // $('.txt-erea').text(data); }, error: function (err) {}, });} Node 服务端： 123456789101112131415161718192021222324252627// 在开启服务的代码基础上新加如下代码const express = require(&quot;express&quot;);const app = express();const cookieParser = require(&quot;cookie-parser&quot;);app.use(cookieParser());app.get(&quot;/node&quot;, (req, res) =&gt; { // 使用cookie时不能设置域为 * res.header(&quot;Access-Control-Allow-Origin&quot;, req.headers.origin); // 允许的header类型 res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;content-type&quot;); // 跨域允许的请求方式 res.header(&quot;Access-Control-Allow-Methods&quot;, &quot;DELETE,PUT,POST,GET,OPTIONS&quot;); // 要设置允许客户端携带验证信息 res.header(&quot;Access-Control-Allow-Credentials&quot;, true); console.log(&quot;cookie信息&quot;); console.log(req.cookies); res.end(&quot;&quot;);});/** * 开启监听 */app.listen(port, function () { console.log(&quot;ok&quot;);}); 注： 同源 ajax 请求是可以自动携带 cookie 的 而非同源需要客户端和服务端都做处理： 客户端需要对 xhr 对象设置 withCredentials:true 服务端需要设置响应头 access-control-allow-credentials:true 同时必须指明 access-control-allow-origin 为服务方的 origin， 不能为* 新增属性：Chrome 51 开始，浏览器的 Cookie 新增加了一个SameSite属性，用来防止 CSRF 攻击和用户追踪。可选值： StrictStrict最为严格，完全禁止第三方 Cookie，跨站点时，任何情况下都不会发送 Cookie。换言之，只有当前网页的 URL 与请求目标一致，才会带上 Cookie。 LaxLax规则稍稍放宽，大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外。 NoneNone相当于忽略该属性。不过，前提是必须同时设置 Secure 属性（Cookie 只能通过 HTTPS 协议发送），否则无效。 相关东西，后面补充。 小结：跨域数据存储访问推荐做法： 把文件放在一起或者使用 Nginx 代理到一起 （推荐） 如果使用的域名可以考虑设置document.domain属性 完全不同源，可以考虑通过跨域通信的方式传递相关参数 跨域脚本 API 访问（Cross-origin script API access）如果两个网页不同源，就无法拿到对方的 DOM。典型的例子是iframe窗口和window.open方法打开的窗口，它们与父窗口无法通信。 比如，父窗口运行下面的命令，如果 iframe 窗口不是同源，就会报错。 12document.getElementById(&quot;myIFrame&quot;).contentWindow.document;// Uncaught DOMException: Blocked a frame with origin &quot;http://127.0.0.1:5500&quot; from accessing a cross-origin frame. 上面命令中，父窗口想获取子窗口的 DOM，因为跨源导致报错。 反之亦然，子窗口获取主窗口的 DOM 也会报错。 12window.parent.document.body;// Uncaught DOMException: Blocked a frame with origin &quot;http://localhost:1000&quot; from accessing a cross-origin frame. 对于完全不同源的网站，目前有四种方法，可以解决跨域窗口的通信问题。 片段标识符（fragment identifier） window.name 跨文档通信 API（Cross-document messaging） WebSocket 片段标识符片段标识符（fragment identifier）指的是，URL 的#号后面的部分，比如http://example.com/x.html#fragment的#fragment。如果只是改变片段标识符，页面不会重新刷新。也可以叫做锚点, 用作页面定位. 父窗口可以把信息，写入子窗口的片段标识符。 12345var srcStr = document.getElementsByClassName(&quot;iframe&quot;)[0].src.split(&quot;#&quot;)[0] + &quot;#&quot; + encodeURI(value);$(&quot;.iframe&quot;).attr(&quot;src&quot;, srcStr); 子窗口通过监听 hashchange 事件得到通知。 123456window.onhashchange = checkMessage;function checkMessage() { var message = window.location.hash; // ...} 同样的，子窗口也可以改变父窗口的片段标识符。 1parent.location.href = target + &quot;#&quot; + hash; 注意：如果修改后的 hash 值和原来的一样，不会进片段标识符改变的监听 window.name浏览器窗口有window.name属性。这个属性的最大特点是，无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页可以读取它。 父窗口先打开一个子窗口，载入一个不同源的网页，该网页将信息写入 window.name 属性。 1window.name = '{&quot;name&quot;: &quot;lisi&quot;}'; 接着，子窗口跳回一个与主窗口同域的网址。 12// 把子页面的window.location 设置为域和父页面同源的window.location = &quot;http://127.0.0.1:5500/windowName/testWN.html&quot;; 然后，主窗口就可以读取子窗口的 window.name 了。 1var data = document.getElementById(&quot;myFrame&quot;).contentWindow.name; 这种方法的优点是，window.name容量很大，可以放置非常长的字符串；代码实现： 12345678910111213141516171819var state = 0;(iframe = document.createElement(&quot;iframe&quot;)), (loadfn = function () { if (state === 1) { var data = iframe.contentWindow.name; // 读取数据 alert(data); // 你好，我是子页面的window.name， 携带了一些数据 } else if (state === 0) { state = 1; iframe.contentWindow.location = &quot;http://127.0.0.1:10229/page/windowName/null.html&quot;; // 设置的代理文件 } });iframe.src = &quot;http://localhost:1000/windowname-nginx.html&quot;;if (iframe.attachEvent) { iframe.attachEvent(&quot;onload&quot;, loadfn);} else { iframe.onload = loadfn;}document.body.appendChild(iframe); window.postMessage上面两种方法都属于破解，HTML5 为了解决这个问题，引入了一个全新的 API：跨文档通信 API（Cross-document messaging）。 这个 API 为 window 对象新增了一个方法 window.postMessage，允许跨窗口通信，不论这两个窗口是否同源，只要你能获取到目标对象的 window 对象。 举例来说，父窗口http://aaa.com向子窗口http://bbb.com发消息，调用postMessage方法就可以了。 12var popup = window.open(&quot;http://aaa.com&quot;, &quot;title&quot;);popup.postMessage(&quot;Hello World!&quot;, &quot;http://aaa.com&quot;); postMessage方法的第一个参数是具体的信息内容，第二个参数是接收消息的窗口的源（origin），即”协议 + 域名 + 端口”。也可以设为*，表示不限制域名，向所有窗口发送. 子窗口向父窗口发送消息的写法类似。 1window.opener.postMessage(&quot;Nice to see you&quot;, &quot;http://bbb.com&quot;); 注：window.opener 属性是一个可读可写的属性，可返回对创建该窗口的 Window 对象的引用。 父窗口和子窗口都可以通过message事件，监听对方的消息。 1234567window.addEventListener( &quot;message&quot;, function (e) { console.log(e.data); }, false); 下面的例子是，子窗口通过event.source属性引用父窗口，然后发送消息。 1234window.addEventListener(&quot;message&quot;, receiveMessage);function receiveMessage(event) { event.source.postMessage(&quot;Nice to see you!&quot;, &quot;*&quot;);} event.origin属性可以过滤不是发给本窗口的消息。 123456789window.addEventListener(&quot;message&quot;, receiveMessage);function receiveMessage(event) { if (event.origin !== &quot;http://bbb.com&quot;) return; if (event.data === &quot;Hello World&quot;) { event.source.postMessage(&quot;Hello&quot;, event.origin); } else { console.log(event.data); }} message 事件的事件对象 event，提供以下三个属性。 event.source：发送消息的窗口 event.origin: 消息发向的网址 event.data: 消息内容 下面的例子是，子窗口通过event.source属性引用父窗口，然后发送消息。 1234window.addEventListener(&quot;message&quot;, receiveMessage);function receiveMessage(event) { event.source.postMessage(&quot;Nice to see you!&quot;, &quot;*&quot;);} event.origin属性可以过滤不是发给本窗口的消息。 123456789window.addEventListener(&quot;message&quot;, receiveMessage);function receiveMessage(event) { if (event.origin !== &quot;http://bbb.com&quot;) return; if (event.data === &quot;Hello World&quot;) { event.source.postMessage(&quot;Hello&quot;, event.origin); } else { console.log(event.data); }} 通过 window.postMessage，读写其他窗口的 LocalStorage 或者 SessionStorage 也成为了可能。 下面是一个例子，主窗口写入iframe子窗口的localStorage。 1234567window.onmessage = function (e) { if (e.origin !== &quot;http://bbb.com&quot;) { return; } var payload = JSON.parse(e.data); localStorage.setItem(payload.key, JSON.stringify(payload.data));}; 上面代码中，子窗口将父窗口发来的消息，写入自己的LocalStorage。 父窗口发送消息的代码如下。 123456var win = document.getElementsByTagName(&quot;iframe&quot;)[0].contentWindow;var obj = { name: &quot;Jack&quot; };win.postMessage( JSON.stringify({ key: &quot;storage&quot;, data: obj }), &quot;http://bbb.com&quot;); 加强版的子窗口接收消息的代码如下。 1234567891011121314151617window.onmessage = function (e) { if (e.origin !== &quot;http://bbb.com&quot;) return; var payload = JSON.parse(e.data); switch (payload.method) { case &quot;set&quot;: localStorage.setItem(payload.key, JSON.stringify(payload.data)); break; case &quot;get&quot;: var parent = window.parent; var data = localStorage.getItem(payload.key); parent.postMessage(data, &quot;http://aaa.com&quot;); break; case &quot;remove&quot;: localStorage.removeItem(payload.key); break; }}; 加强版的父窗口发送消息代码如下。 1234567891011121314var win = document.getElementsByTagName(&quot;iframe&quot;)[0].contentWindow;var obj = { name: &quot;Jack&quot; };// 存入对象win.postMessage( JSON.stringify({ key: &quot;storage&quot;, method: &quot;set&quot;, data: obj }), &quot;http://bbb.com&quot;);// 读取对象win.postMessage(JSON.stringify({ key: &quot;storage&quot;, method: &quot;get&quot; }), &quot;*&quot;);window.onmessage = function (e) { if (e.origin != &quot;http://aaa.com&quot;) return; // &quot;Jack&quot; console.log(JSON.parse(e.data).name);}; SessionStorage 同理。 WebSocketWebSocket 是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源策略，只要服务器支持，就可以通过它进行跨源通信。 下面是一个例子，浏览器发出的 WebSocket 请求的头信息（摘自维基百科）。 12345678GET /chat HTTP/1.1Host: server.example.comUpgrade: websocketConnection: UpgradeSec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==Sec-WebSocket-Protocol: chat, superchatSec-WebSocket-Version: 13Origin: http://example.com 上面代码中，有一个字段是Origin，表示该请求的请求源（origin），即发自哪个域名。 正是因为有了Origin这个字段，所以 WebSocket 才没有实行同源策略。因为服务器可以根据这个字段，判断是否许可本次通信。如果该域名在白名单内，服务器就会做出如下回应。 12345HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=Sec-WebSocket-Protocol: chat 示例： Node 服务端: 1234567891011121314151617181920212223242526272829303132const WebSocket = require(&quot;ws&quot;);// websocket服务的端口const wsport = 3006;var wss = new WebSocket.Server({ port: wsport, path: &quot;/ws&quot;,});let webSocketServer = wss.on(&quot;connection&quot;, function connection(ws) { console.log(&quot;ws连接&quot;); ws.isAlive = true; ws.on(&quot;pong&quot;, heartbeat); ws.on(&quot;message&quot;, function incoming(message) { message = JSON.parse(message); sendAllMessage(webSocketServer, message); });});// 广播消息function sendAllMessage(server, message) { server.clients.forEach((ws) =&gt; { ws.send(JSON.stringify(message)); });}// 定时每30s发送ping监测连接是否中断const interval = setInterval(function ping() { wss.clients.forEach(function each(ws) { if (ws.isAlive === false) return ws.terminate(); ws.isAlive = false; ws.ping(); });}, 30000); 页面 1： 12345678910111213141516171819202122232425var ws = new WebSocket(&quot;ws://localhost:3006/ws&quot;, &quot;suyp&quot;);ws.onopen = function (param) { console.log(&quot;WebSocket连接成功！&quot;); ws.onmessage = function (param) { console.log(&quot;这是WebSocket接收的消息 --- &quot; + param.data); // 接收消息这里推荐写try catch 来捕捉错误，因为消息有可能不是JSON格式 try { var message = JSON.parse(param.data); } catch (e) { console.log(e); } if (message) { switch (message.key) { case &quot;closeInfoWindow&quot;: console.log(&quot;弹窗已关闭&quot;); break; default: break; } } }; ws.onclose = function () { console.log(&quot;ws关闭了&quot;); };}; 页面 2 1234567891011// 向父页面发送消息,来关闭弹窗function closeInfowWindow2() { if (ws) { ws.send( JSON.stringify({ key: &quot;closeInfoWindow&quot;, msg: &quot;&quot;, }) ); }} 小结跨域脚本 API 访问推荐做法： Nginx 代理到一起 （最好） 使用 postMessaget 通信 （挺好） 参考资料 什么是 JSONP — HansExploration JSONP — 百度百科 浏览器同源策略及其规避方法 — 阮一峰 WebSocket 教程 — 阮一峰 X-Frame-Options — MDN SameSite — MDN","link":"/2020/08/27/%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3/"},{"title":"Vue.js2最佳实践(持续更新至Vue.js3出来😁)","text":"1 写在开头文档较长，可按需耐心反复阅读。其中带（官）的是直接引用了 Vue 官方的风格指南。针对 Vue 性能优化相关内容，单独在内容后进行了标注，可通过搜索“性能优化”四个字查找。 2 Vue.js2 模板工程说明2.1 目的封装常用功能和配置，规范代码编写，保证输出的一致性，方便前端人员在此基础上快速开发新项目的业务模块。 2.2 下载模板项目（Boilerplate）分为 JavaScript 和 TypeScript 两个版本。 JS： git clone https://github.com/THS-FE/vue2-starter-js.git TS： git clone https://github.com/THS-FE/vue2-starter-ts.git 2.3 目录结构该目录结构适合中大型项目，如果是小型项目，可对目录或模块进行适当删减（尤其是后面有可选标识的）。 2.3.1 JavaScript 版123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869├── public // 静态资源 该文件夹下的内容在构建时会直接拷贝到dist文件夹下 ├── favicon.ico // 网站图标 ├── index.html // HTML模板页│ └── ...├── src // 主要的工作目录 ├── assets // 静态资源 会经过webpack打包处理 ├── fonts // 字体文件（可选） └── ... ├── images // 图片 ├── error // error（通用出错页面）模块 └── ... // 使用到的图片 ├── module-a // 用模块命名（可选） └── ... // 该模块下使用到的图片 └── ... // 通用的图片（小项目就不用分文件夹了） └── styles // 样式 ├── common.scss // 常用样式（提供通用的） ├── element-variables.scss // 自定义element样式 ├── global.scss // 全局样式 ├── style.scss // 组装各样式并导出，最终被 main.js 引入 └── ... ├── components // 组件(dumb components，获取props，派发事件) ├── common └── ... // 不同项目中的通用组件 ├── module-a // 用模块命名（可选） └── ... // 该模块下的组件 └── ... // 当前项目中的通用组件 ├── directives // 指令（可选） └── ... // 自定义指令 ├── layouts // 布局（可选） └── ... ├── plugins // vue插件（如：Element，vuetify） ├── element.js // Element按需加载 ├── index.js // 插件的入口文件，组装各插件并导出 └── ... // 自定义插件 ├── router // 路由（统一使用懒加载） ├── index.js // 路由的入口文件，组装各路由并导出 └── ... ├── services // 接口请求 ├── config.js // 常量 ├── index.js // 服务调用的入口文件，组装各模块请求方法并导出 └── ... ├── store // 状态管理（可选） ├── modules // 各模块 └── ... // 命名尽量和views中的模块对应上 ├── actions.js // 根级别的 action ├── getters.js // 根级别的 getter ├── index.js // 状态管理的入口文件，组装各模块并导出 ├── mutation-types.js // mutation事件类型定义 └── mutations.js // 根级别的 mutation ├── utils // 工具类 ├── config.js // 常量 ├── common.js // 常用功能（通用的） ├── request.js // HTTP请求封装 ├── validator.js // 表单验证 └── ... ├── views // 页面(smart components，可以访问store，路由，window) ├── exception // 通用异常页面 ├── not-found.vue // 404页面 └── unauthorized.vue // 403页面 ├── module-a.vue // 用模块命名,如该模块下页面较多，可建以模块为名称的文件夹，在其中创建多个页面 └── ... ├── app.vue // 根组件 └── main.js // 入口文件（引入全局的样式和脚本，可安装插件、注册组件或指令等）├── .browserslistrc // 目标浏览器配置├── .editorconfig // 代码风格规范，如：缩进├── .eslintrc.js // eslint配置├── babel.config.js // babel配置├── package.json // 项目依赖、脚本└── vue.config.js // webpack打包配置 在创建该项目时，没有添加 PWA、单元测试和端到端测试。原因：PWA 并没有普及，没多少人会使用；各类测试对于需求经常变化的项目来说就是个累赘，测试用例还没有写完，需求变了… 对项目相关工具配置项不了解的，可参看 《从零开始搭建前端项目开发环境》 2.3.2 TypeScript 版因 Vue3.0 取消了基于类的组件（class based component），使用 functional based component+hooks(也就是 Composition API)，为了降低学习成本，在使用脚手架创建项目时，没有启用 vue-class-component。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273├── public // 静态资源 该文件夹下的内容在构建时会直接拷贝到dist文件夹下 ├── favicon.ico // 网站图标 ├── index.html // HTML模板页│ └── ...├── src // 主要工作目录 ├── assets // 静态资源 会被webpack打包处理 ├── fonts // 字体文件（可选） └── ... ├── images // 图片 ├── exception // exception（通用异常页面）模块使用到的图片 └── ... ├── module-a // 此处要用模块命名（可选） └── ... // 该模块下使用到的图片 └── ... // 通用的图片（小项目就不用分文件夹了） └── styles // 样式 ├── common.scss // 常用样式（提供通用的） ├── element-variables.scss // 自定义element样式 ├── global.scss // 全局样式 ├── style.scss // 组装各样式并导出最终被 main.js 引入 └── ... ├── components // 组件(dumb components，获取props，派发事件) ├── common └── ... // 通用组件 ├── module-a // 此处要用模块命名（可选） └── ... // 该模块下的组件 └── ... // 当前项目中的通用组件 ├── directives // 指令（可选） └── ... // 自定义指令 ├── layouts // 布局（可选） └── ... ├── plugins // vue插件（如：Element，vuetify） ├── element.ts // Element按需加载 ├── index.ts // 组装各插件并导出 └── ... ├── router // 路由（统一使用懒加载） ├── index.ts // 组装各路由并导出 └── ... ├── services // 接口请求 ├── config.ts // 常量 ├── index.ts // 组装各请求并导出 └── ... ├── store // 状态管理（可选） ├── modules // 各模块 └── ... // 尽量和views中的模块对应上 ├── actions.ts // 根级别的 action ├── getters.js // 根级别的 getter ├── index.ts // 组装模块并导出 ├── mutation-types.ts // mutation事件类型定义 └── mutations.ts // 根级别的 mutation ├── utils // 工具类 ├── config.ts // 常量 ├── common.ts // 常用功能（提供通用的） ├── request.ts // HTTP请求 ├── validator.ts // 表单验证 └── ... ├── views // 页面(smart components，可以访问store，路由，window) ├── exception // 通用异常展示页面 ├── NotFound.vue // 404页面 └── Unauthorized.vue // 401页面 ├── module-a.vue // 用模块命名,如该模块下页面较多，可建以模块为名称的文件夹，在其中创建多个页面 └── ... ├── app.vue // 根组件 ├── main.ts // 入口文件（引入全局的样式和脚本，可安装插件、注册组件或指令等） ├── shims-tsx.d.ts // 允许使用tsx的文件，用于编写jsx风格的ts代码 └── shims-vue.d.ts // 帮助IDE识别 .vue文件├── .browserslistrc // 目标浏览器配置├── .editorconfig // 代码风格规范├── .eslintrc.js // eslint配置├── babel.config.js // babel配置├── package.json // 项目依赖、脚本├── postcss.config.js// postcss配置├── tsconfig.json // TypeScript配置文件└── vue.config.js // webpack打包配置 2.4 配置变更以下内容均已在模板项目里添加，这里只是做个说明。 2.4.1 新增依赖2.4.1.1 Normalize.css 6.2k为默认的 HTML 元素样式上提供了跨浏览器的高度一致性。相比于传统的 CSS reset，Normalize.css 是一种现代的、为 HTML5 准备的优质替代方案。 安装： npm i normalize.css -S 已在 main.js 文件中引入： import 'normalize.css'; 2.4.1.2 moment 239.1kDay.js 6.3k是一个轻量的处理时间和日期的 JavaScript 库，和 Moment.js 的 API 设计保持完全一样，用于解析、检验、操作、以及显示日期。 安装： npm i dayjs -S 可在任何需要的文件中引入： 1234import dayjs from &quot;dayjs&quot;;import &quot;dayjs/locale/zh-cn&quot;;dayjs.locale(&quot;zh-cn&quot;); // 使用中文 2.4.1.3 Element 637.7k一套为开发者、设计师和产品经理准备的基于 Vue2.0 的桌面端组件库。 安装： npm i element-ui -S 已在 plugins/index.js 文件中引入： 1234import ElementUI from &quot;element-ui&quot;;import &quot;@/assets/styles/element-variables.scss&quot;;Vue.use(ElementUI); 项目中已改成按需加载。 2.4.1.4 axios 12.9k是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。 安装： npm i axios -S 已在 utils/request.js 文件中引入： import axios from 'axios'; 2.4.1.5 vue-event-proxy 1.79kb让 Vue.js 支持全局事件的库。 通过增加前缀实现全局事件，能在不同组件间进行数据通信 组件销毁自动移除注册的事件 安装： npm i vue-event-proxy -S 已在 plugins/index.js 文件中引入： 123import EventBus from &quot;vue-event-proxy&quot;;Vue.use(EventBus); TS 版需要同时在 shims-vue.d.ts 文件中添加模块申明： declare module 'vue-event-proxy' 在非父子组件间使用（相当于事件总线）： 12345// 发布this.$emit(&quot;global:你的事件名字&quot;);// 监听this.$on(&quot;global:你的事件名字&quot;, () =&gt; {}); 如不加 global: 前缀，则和平时使用的方式一致。 2.4.2 新增功能2.4.2.1 request定义拦截器对 HTTP 请求配置做统一处理。 已写在 utils/request.js 文件中，需按实际项目需要进行修改： 12345678910111213141516171819202122232425262728293031323334353637import axios from &quot;axios&quot;;const service = axios.create({ baseURL: process.env.VUE_APP_BASE_API, // url = base url + request url // withCredentials: true, // 如跨域请求时要带上cookie,则设置为true timeout: 5000, // 请求超时时长});service.interceptors.request.use( (config) =&gt; { // 按需添加内容 // eslint-disable-next-line no-empty if (config.method === &quot;post&quot;) { } return config; }, (error) =&gt; { console.log(error); return Promise.reject(error); });service.interceptors.response.use( (response) =&gt; { // 如果返回的状态不是200 就报错 按需修改 if (response.status &amp;&amp; response.status !== 200) { return Promise.reject(new Error(&quot;Error&quot;)); } return response; }, (error) =&gt; { console.log(error); return Promise.reject(error); });export default service; 如果使用同一个服务地址，那么还需要在 vue.config.js 中要修改： // 设置 HTTP 请求的 base url，需修改 12// 设置HTTP请求的base url，需修改process.env.VUE_APP_BASE_API = isProd() ? &quot;这里要修改成实际的地址&quot; : &quot;&quot;; 2.4.2.2 导航守卫通过跳转或取消的方式守卫导航。 已写在 router/index.js 文件中，需按实际项目需要进行修改： 1234567891011121314router.beforeEach((to, from, next) =&gt; { // 如果登录的时候设置过; if (localStorage.getItem(&quot;token&quot;) != null) { next(); } else { // 如果没有设置这个值为空,说明没有登录，导向登录页 // eslint-disable-next-line no-lonely-if if (to.name === &quot;login&quot;) { next(); } else { next({ path: &quot;/login&quot; }); } }}); 2.4.2.3 路由拆分按模块拆分成不同的路由文件，方便多人协作同步开发，互不影响。 可在 router/index.js 文件中添加： 1234567891011121314151617181920212223import homeRoutes from './home'; // 引入首页模块的路由// routes 需要定义类型let routes: RouteConfig[] = [{ path: '/', redirect: '/login',},{ path: '/login', name: 'login', component: Login,},...];routes = [...routes, ...homeRoutes]; // 合并它模块的路由const router = new Router({ mode: 'history', base: process.env.BASE_URL, routes,}); 2.4.2.4 store 拆分如果项目非常大状态就会有很多，如不进行分类处理，所有的状态和对状态的处理都放一个文件里面，代码会很臃肿，不利于后期的维护。 在 store/index.js 文件中： 12345678910111213141516import mutations from &quot;./mutations&quot;;import actions from &quot;./actions&quot;;import getters from &quot;./getters&quot;;import user from &quot;./modules/user&quot;;const state = {};export default new Vuex.Store({ state, getters, actions, mutations, modules: { user, },}); 2.4.2.5 Vue Composition API方便以后平滑过渡到 Vue.js3.0。 安装： npm i @vue/composition-api -S 已在 plugins/index.js 文件中引入： 123import VueCompositionApi from &quot;@vue/composition-api&quot;;Vue.use(VueCompositionApi); 2.4.2.6 主题切换使用 CSS Variables 2.4.3 配置新增2.4.3.1 vue.config.js为了不改变默认配置，在 configureWebpack 中通过 Object.assign 的方式合并配置，这种方式只会对配置进行新增、修改，而不会过多地改变默认配置。 2.4.3.1.1 去除 console1234// 去除 consoleObject.assign(config.optimization.minimizer[0].options.terserOptions.compress, { drop_console: true,}); 2.4.3.1.2 分离第三方库123456789// 单独将 elementUI 拆包Object.assign(config.optimization.splitChunks.cacheGroups, { elementUI: { name: &quot;chunk-elementUI&quot;, priority: 20, // 权重要大于 vendors 和 app 不然会被打包进 vendors 或者 app test: /[\\\\/]node_modules[\\\\/]element-ui[\\\\/]/, chunks: &quot;all&quot;, },}); 2.4.3.2 Element 按需加载 (性能优化 1)安装： npm install babel-plugin-component -D 修改 babel.config.js： 12345678910111213module.exports = { presets: [&quot;@vue/cli-plugin-babel/preset&quot;], // element按需加载 plugins: [ [ &quot;component&quot;, { libraryName: &quot;element-ui&quot;, styleLibraryName: &quot;theme-chalk&quot;, }, ], ],}; 2.5 安装运行在项目所在文件夹下运行命令行安装依赖： npm install 如果 NPM 下载慢的话，可使用以下命令： npm install --registry=https://registry.npm.taobao.org 项目启动： npm run serve 项目打包： npm run build 3 命名3.1 组件尽量将组件放在对应目录所属模块的文件夹之下，若只有一个文件的则直接放在 components 或 views 目录下，如：login，home。 组件名尽量为名词，开头的单词就是所属模块的名字。 3.1.1（官）使用两个或以上单词根组件 App 以及 &lt;transition&gt;、&lt;component&gt; 之类的 Vue 内置组件除外。这样做可以避免跟现有的以及未来的 HTML 元素相冲突，因为所有的 HTML 元素名称都是单个单词的。 Bad 123Vue.component(&quot;todo&quot;, { // ...}); 1234export default { name: &quot;Todo&quot;, // ...}; Good 123Vue.component(&quot;todo-item&quot;, { // ...}); 1234export default { name: &quot;TodoItem&quot;, // ...}; 常用的结尾单词有 123456789***-detail.vue***-edit.vue***-list.vue***-info.vue***-report.vue 3.1.2（官）使用PascalCase 或kebab-case 命名组件文件单词大写开头对于代码编辑器的自动补全最为友好。 Bad 12components/|- mycomponent.vue 12components/|- myComponent.vue Good 123components/|- my-component.vue 3.1.3（官）JS/JSX 中的组件名应该始终使用 PascalCase 进行命名在 JavaScript 中，PascalCase 是类和构造函数 (本质上任何可以产生多份不同实例的东西) 的命名约定。Vue 组件也有多份实例，所以同样使用 PascalCase 是有意义的。额外的好处是，在 JSX (和模板) 里使用 PascalCase 使得代码的读者更容易分辨 Vue 组件和 HTML 元素。 然而，对于只通过 Vue.component 定义全局组件的应用来说，推荐 kebab-case 作为替代。原因是： 全局组件很少被 JavaScript 引用，所以遵守 JavaScript 的命名约定意义不大。 这些应用往往包含许多 DOM 内的模板，这种情况下是必须使用 kebab-case 的。 Bad 123Vue.component(&quot;myComponent&quot;, { // ...}); 1import myComponent from &quot;./MyComponent.vue&quot;; 1234export default { name: &quot;myComponent&quot;, // ...}; 1234export default { name: &quot;my-component&quot;, // ...}; Good 123Vue.component(&quot;MyComponent&quot;, { // ...}); 123Vue.component(&quot;my-component&quot;, { // ...}); 1import MyComponent from &quot;./MyComponent.vue&quot;; 1234export default { name: &quot;MyComponent&quot;, // ...}; 3.1.4（官）和父组件紧密耦合的子组件应该以父组件名作为前缀命名可以试着通过在其父组件命名的目录中嵌套子组件以解决这个问题。比如： 123456components/|- TodoList/ |- Item/ |- index.vue |- Button.vue |- index.vue 或： 123456components/|- TodoList/ |- Item/ |- Button.vue |- Item.vue|- TodoList.vue 但是这种方式并不推荐，因为这会导致： 许多文件的名字相同，使得在编辑器中快速切换文件变得困难。 过多嵌套的子目录增加了在编辑器侧边栏中浏览组件所花的时间。 Bad 1234components/|- TodoList.vue|- TodoItem.vue|- TodoButton.vue 123components/|- SearchSidebar.vue|- NavigationForSearchSidebar.vue Good 1234components/|- TodoList.vue|- TodoListItem.vue|- TodoListItemButton.vue 123components/|- SearchSidebar.vue|- SearchSidebarNavigation.vue 3.1.5（官）以高级别的(通常是一般化描述的) 单词开头，以描述性的修饰词结尾比如对于一个带搜索表单的应用来说，它可能包含这样的组件： 1234567components/|- ClearSearchButton.vue|- ExcludeFromSearchInput.vue|- LaunchOnStartupCheckbox.vue|- RunSearchButton.vue|- SearchInput.vue|- TermsCheckbox.vue 很难看出来哪些组件是针对搜索的。现根据规则给组件重新命名： 1234567components/|- SearchButtonClear.vue|- SearchButtonRun.vue|- SearchInputExcludeGlob.vue|- SearchInputQuery.vue|- SettingsCheckboxLaunchOnStartup.vue|- SettingsCheckboxTerms.vue 因为编辑器通常会按字母顺序组织文件，所以现在组件之间的重要关系一目了然。 若换成多级目录的方式，把所有的搜索组件放到“search”目录，把所有的设置组件放到“settings”目录。只推荐在非常大型 (如有 100+ 个组件) 的应用下才考虑这么做，因为： 在多级目录间找来找去，要比在单个 components 目录下滚动查找花费更多的精力。 存在组件重名 (比如存在多个 ButtonDelete 组件) 的时候在编辑器里更难快速定位。 让重构变得更难，为一个移动了的组件更新相关引用时，查找/替换通常并不高效。 Bad 1234567components/|- ClearSearchButton.vue|- ExcludeFromSearchInput.vue|- LaunchOnStartupCheckbox.vue|- RunSearchButton.vue|- SearchInput.vue|- TermsCheckbox.vue Good 1234567components/|- SearchButtonClear.vue|- SearchButtonRun.vue|- SearchInputQuery.vue|- SearchInputExcludeGlob.vue|- SettingsCheckboxTerms.vue|- SettingsCheckboxLaunchOnStartup.vue 3.1.6（官）使用完整单词而不是缩写编辑器中的自动补全已经让书写长命名的代价非常之低了，而其带来的明确性却是非常宝贵的。不常用的缩写尤其应该避免。 Bad 123components/|- SdSettings.vue|- UProfOpts.vue Good 123components/|- StudentDashboardSettings.vue|- UserProfileOptions.vue 3.1.7（官）基础组件(也就是展示类的、无逻辑的或无状态的组件) 应该全部以一个特定的前缀开头，比如 Base 当在编辑器中以字母顺序排序时，应用的基础组件会全部列在一起，这样更容易识别。 因为组件名应该始终是多个单词，所以这样做可以避免在包裹简单组件时随意选择前缀 (比如 MyButton、VueButton)。 因为这些组件会被频繁使用，所以可能想把它们放到全局而不是在各处分别导入它们。 Bad 1234components/|- MyButton.vue|- VueTable.vue|- Icon.vue Good 1234components/|- BaseButton.vue|- BaseTable.vue|- BaseIcon.vue 3.1.8（官）单个活跃实例的组件应该以 The 前缀命名，以示其唯一性这不意味着组件只可用于一个单页面，而是每个页面只使用一次。这些组件永远不接受任何 prop，因为它们是为应用定制的，而不是它们在应用中的上下文。如果发现有必要添加 prop，那就表明这实际上是一个可复用的组件，只是目前在每个页面里只使用一次。 Bad 123components/|- Heading.vue|- MySidebar.vue Good 123components/|- TheHeading.vue|- TheSidebar.vue 3.2 Prop3.2.1（官）应该始终使用 camelCase，而在模板和 JSX 中应该始终使用 kebab-case我们单纯的遵循每个语言的约定。在 JavaScript 中更自然的是 camelCase。而在 HTML 中则是 kebab-case。 Bad 123props: { 'greeting-text': String} 1&lt;WelcomeMessage greetingText=&quot;hi&quot; /&gt; Good 123props: { greetingText: String;} 1&lt;WelcomeMessage greeting-text=&quot;hi&quot; /&gt; 3.3 method3.3.1 要是动宾短语Bad go、nextPage、show、open、login Good jumpPage、openCarInfoDialog 尽量使用常用单词开头： set、get、open、close、jump 3.3.2 使用 camelCase 进行命名Bad get_list_data、getlistData Good getListData 3.4 事件3.4.1（官）使用 kebab-case 进行命名无论是 camelCase 或 PascalCase 的命名，都能被监听到，但 DOM 模板中使用会感觉怪怪的。 3.4.2 以动词或是名词结尾如：upload-success、upload-error 、 dropzone-upload-success、dropzone-upload-error。 3.5 文件夹3.5.1 尽量是小写的单个名词有复数结构时，要采用复数命名法。例：scripts, styles, images。 3.5.2 如不是单个，则使用 kebab-case 进行命名使用 kebab-case 命名的文件夹比 camelCase 命名的文件夹看起来更清晰，可参考 node_modules 文件夹里的内容。 Bad 123errorPage;ErrorPage; Good 1error - page; 3.6 文件3.6.1 *.js 文件命名规范统一使用 kebab-case 风格 3.6.2 *.ts 文件命名规范统一使用 kebab-case 风格 3.6.3 *.scss 文件命名规范统一使用 kebab-case 命名风格 3.6.4 其它文件命名规范统一使用 kebab-case 命名风格 4 一般约束4.1（官）顶级 App 组件和布局组件中的样式可以是全局的，但是其它所有组件都应该是有作用域的这条规则只和单文件组件有关。不一定要使用 scoped 特性。设置作用域也可以通过 CSS Modules，那是一个基于 class 的类似 BEM 的策略，当然也可以使用其它的库或约定。 Bad 123456789&lt;template&gt; &lt;button class=&quot;btn btn-close&quot;&gt;X&lt;/button&gt;&lt;/template&gt;&lt;style&gt;.btn-close { background-color: red;}&lt;/style&gt; Good 123456789101112131415&lt;template&gt; &lt;button class=&quot;button button-close&quot;&gt;X&lt;/button&gt;&lt;/template&gt;&lt;!-- 使用 `scoped` 特性 --&gt;&lt;style scoped&gt;.button { border: none; border-radius: 2px;}.button-close { background-color: red;}&lt;/style&gt; 123456789101112131415&lt;template&gt; &lt;button :class=&quot;[$style.button, $style.buttonClose]&quot;&gt;X&lt;/button&gt;&lt;/template&gt;&lt;!-- 使用 CSS Modules --&gt;&lt;style module&gt;.button { border: none; border-radius: 2px;}.buttonClose { background-color: red;}&lt;/style&gt; 123456789101112131415&lt;template&gt; &lt;button class=&quot;c-Button c-Button--close&quot;&gt;X&lt;/button&gt;&lt;/template&gt;&lt;!-- 使用 BEM 约定 --&gt;&lt;style&gt;.c-Button { border: none; border-radius: 2px;}.c-Button--close { background-color: red;}&lt;/style&gt; 4.2（官）始终为插件、混入等不考虑作为对外公共 API 的自定义私有属性使用 $_ 前缀。并附带一个命名空间以回避和其它作者的冲突Vue 使用 _前缀来定义其自身的私有属性，所以使用相同的前缀 (比如_update) 有覆写实例属性的风险。即便检查确认 Vue 当前版本没有用到这个属性名，也不能保证和将来的版本没有冲突。 对于 $ 前缀来说，其在 Vue 生态系统中的目的是暴露给用户的一个特殊的实例属性，所以把它用于私有属性并不合适。 不过，推荐把这两个前缀结合为 $_，作为一个用户定义的私有属性的约定，以确保不会和 Vue 自身相冲突。。 Bad 12345678var myGreatMixin = { // ... methods: { update: function () { // ... }, },}; 12345678var myGreatMixin = { // ... methods: { _update: function () { // ... }, },}; 12345678var myGreatMixin = { // ... methods: { $update: function () { // ... }, },}; Good 12345678var myGreatMixin = { // ... methods: { $_myGreatMixin_update: function () { // ... }, },}; 12345678910111213141516// 甚至更好！var myGreatMixin = { // ... methods: { publicMethod() { // ... myPrivateFunction(); }, },};function myPrivateFunction() { // ...}export default myGreatMixin; 4.3（官）在单文件组件、字符串模板和 JSX 中没有内容的组件应该是自闭合的——但在 DOM 模板里永远不要这样做自闭合组件表示它们不仅没有内容，而且刻意没有内容。其不同之处就好像书上的一页白纸对比贴有&quot;本页有意留白&quot;标签的白纸。而且没有了额外的闭合标签，代码也更简洁。 不幸的是，HTML 并不支持自闭合的自定义元素——只有官方的&quot;空&quot;元素。所以上述策略仅适用于进入 DOM 之前 Vue 的模板编译器能够触达的地方，然后再产出符合 DOM 规范的 HTML。 Bad 12&lt;!-- 在单文件组件、字符串模板和 JSX 中 --&gt;&lt;MyComponent&gt;&lt;/MyComponent&gt; 12&lt;!-- 在 DOM 模板中 --&gt;&lt;my-component/&gt; Good 12&lt;!-- 在单文件组件、字符串模板和 JSX 中 --&gt;&lt;MyComponent/&gt; 12&lt;!-- 在 DOM 模板中 --&gt;&lt;my-component&gt;&lt;/my-component&gt; 4.4（官）组件的 data 必须是一个函数当在组件中使用 data 属性的时候 (除了 new Vue 外的任何地方)，它的值必须是返回一个对象的函数。 当 data 的值是一个对象时，它会在这个组件的所有实例之间共享。若希望每个组件实例都管理其自己的数据。为了做到这一点，每个实例必须生成一个独立的数据对象。在 JavaScript 中，在一个函数中返回这个对象就可以了。 Bad 12345Vue.component(&quot;some-comp&quot;, { data: { foo: &quot;bar&quot;, },}); 12345export default { data: { foo: &quot;bar&quot;, },}; Good 1234567Vue.component(&quot;some-comp&quot;, { data: function () { return { foo: &quot;bar&quot;, }; },}); 12345678910// In a .vue file 尽量使用简写export default { data () { // 可以在这里写很多的前置数据操作 ... return { foo: 'bar' } }} 1234567// 在一个 Vue 的根实例上直接使用对象是可以的，// 因为只存在一个这样的实例。new Vue({ data: { foo: &quot;bar&quot;, },}); 4.5（官）Prop 定义要详细：类型、必填、验证细致的 prop定义有两个好处： 它们写明了组件的 API，所以很容易看懂组件的用法； 在开发环境下，如果向一个组件提供格式不正确的 prop，Vue 将会告警，以帮助你捕获潜在的错误来源。 Bad 123Vue.component({ props: [&quot;status&quot;],}); Good 123456789Vue.component({ props: { status: { type: String, required: true, validator: (value) =&gt; ['syncing', 'synced', 'error'].includes(value); } }}) 4.6（官）尽量使用指令缩写，而且要么都用要么都不用用 : 表示 v-bind: 、用 @ 表示 v-on: 和用 # 表示 v-slot。 Bad 1234&lt;input v-bind:value=&quot;newTodoText&quot; :placeholder=&quot;newTodoInstructions&quot;&gt; 1234&lt;input v-on:input=&quot;onInput&quot; @focus=&quot;onFocus&quot;&gt; 1234567&lt;template v-slot:header&gt; &lt;h1&gt;Here might be a page title&lt;/h1&gt;&lt;/template&gt;&lt;template #footer&gt; &lt;p&gt;Here's some contact info&lt;/p&gt;&lt;/template&gt; Good 1234&lt;input :value=&quot;newTodoText&quot; :placeholder=&quot;newTodoInstructions&quot;&gt; 1234&lt;input v-bind:value=&quot;newTodoText&quot; v-bind:placeholder=&quot;newTodoInstructions&quot;&gt; 1234&lt;input @input=&quot;onInput&quot; @focus=&quot;onFocus&quot;&gt; 1234&lt;input v-on:input=&quot;onInput&quot; v-on:focus=&quot;onFocus&quot;&gt; 1234567&lt;template v-slot:header&gt; &lt;h1&gt;Here might be a page title&lt;/h1&gt;&lt;/template&gt;&lt;template v-slot:footer&gt; &lt;p&gt;Here's some contact info&lt;/p&gt;&lt;/template&gt; 1234567&lt;template #header&gt; &lt;h1&gt;Here might be a page title&lt;/h1&gt;&lt;/template&gt;&lt;template #footer&gt; &lt;p&gt;Here's some contact info&lt;/p&gt;&lt;/template&gt; 4.7（官）应该优先通过 Vuex 管理全局状态，而不是通过 this.$root 或一个全局事件总线通过 this.$root 和/或全局事件总线管理状态在很多简单的情况下都是很方便的，但是并不适用于绝大多数的应用。Vuex 提供的不仅是一个管理状态的中心区域，还是组织、追踪和调试状态变更的好工具。 Bad 1234567891011121314151617// main.jsnew Vue({ data: { todos: [], }, created: function () { this.$on(&quot;remove-todo&quot;, this.removeTodo); }, methods: { removeTodo: function (todo) { var todoIdToRemove = todo.id; this.todos = this.todos.filter(function (todo) { return todo.id !== todoIdToRemove; }); }, },}); Good 12345678910111213141516// store/modules/todos.jsexport default { state: { list: [], }, mutations: { REMOVE_TODO(state, todoId) { state.list = state.list.filter((todo) =&gt; todo.id !== todoId); }, }, actions: { removeTodo({ commit, state }, todo) { commit(&quot;REMOVE_TODO&quot;, todo.id); }, },}; 1234567891011121314151617181920212223&lt;!-- TodoItem.vue --&gt;&lt;template&gt; &lt;span&gt; {{ todo.text }} &lt;button @click=&quot;removeTodo(todo)&quot;&gt; X &lt;/button&gt; &lt;/span&gt;&lt;/template&gt;&lt;script&gt;import { mapActions } from 'vuex'export default { props: { todo: { type: Object, required: true } }, methods: mapActions(['removeTodo'])}&lt;/script&gt; 4.8（官）简单逻辑可在模板中使用表达式，中等逻辑操作使用 computed ，复杂或需调用异步方法时使用 watch模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。例如： 123&lt;div id=&quot;example&quot;&gt; {{ message.split('').reverse().join('') }}&lt;/div&gt; 在这个地方，模板不再是简单的声明式逻辑。你必须看一段时间才能意识到，这里是想要显示变量 message 的翻转字符串。当你想要在模板中多次引用此处的翻转字符串时，就会更加难以处理。所以，对于任何复杂逻辑，你都应当使用计算属性。 1234&lt;div id=&quot;example&quot;&gt; &lt;p&gt;Original message: &quot;{{ message }}&quot;&lt;/p&gt; &lt;p&gt;Computed reversed message: &quot;{{ reversedMessage }}&quot;&lt;/p&gt;&lt;/div&gt; 12345678910111213var vm = new Vue({ el: &quot;#example&quot;, data: { message: &quot;Hello&quot;, }, computed: { // 计算属性的 getter reversedMessage: function () { // `this` 指向 vm 实例 return this.message.split(&quot;&quot;).reverse().join(&quot;&quot;); }, },}); 虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么 Vue 通过 watch 选项提供了一个更通用的方法，来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。 123456789101112131415161718192021222324252627282930313233&lt;script&gt;var watchExampleVM = new Vue({ el: '#watch-example', data: { question: '', answer: 'I cannot give you an answer until you ask a question!' }, watch: { // 如果 `question` 发生改变，这个函数就会运行 question: function (newQuestion, oldQuestion) { this.answer = 'Waiting for you to stop typing...'this.debouncedGetAnswer() } }, created: function () { // `_.debounce` 是一个通过 Lodash 限制操作频率的函数。// 在这个例子中，我们希望限制访问 yesno.wtf/api 的频率// AJAX 请求直到用户输入完毕才会发出。想要了解更多关于// `_.debounce` 函数 (及其近亲 `_.throttle`) 的知识，// 请参考：https://lodash.com/docs#debouncethis.debouncedGetAnswer = _.debounce(this.getAnswer, 500) }, methods: { getAnswer: function () { if (this.question.indexOf('?') === -1) { this.answer = 'Questions usually contain a question mark. ;-)'return } this.answer = 'Thinking...'var vm = this axios.get('https://yesno.wtf/api') .then(function (response) { vm.answer = _.capitalize(response.data.answer) }) .catch(function (error) { vm.answer = 'Error! Could not reach the API. ' + error }) } }})&lt;/script&gt; 4.9 生命周期函数调用规则 5 编程思想5.1（官）组件模板应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法复杂表达式会让模板变得不那么声明式。应该尽量描述应该出现的是什么，而非如何计算那个值。而且计算属性和方法使得代码可以重用。Bad 12345678910{ { fullName .split(&quot; &quot;) .map(function (word) { return word[0].toUpperCase() + word.slice(1); }) .join(&quot; &quot;); }} Good 12&lt;!-- 在模板中 --&gt;{{ normalizedFullName }} 12345678// 复杂表达式已经移入一个计算属性computed: { normalizedFullName: function () { return this.fullName.split(' ').map(function (word) { return word[0].toUpperCase() + word.slice(1) }).join(' ') }} 5.2（官）应该优先通过 prop 和事件进行父子组件之间的通信，而不是 this.$parent 或改变 prop一个理想的 Vue 应用是 prop 向下传递，事件向上传递的。遵循这一约定会让组件更易于理解。访问组件之外的上下文违反了基于模块开发的第一原则。因此应该尽量避免使用 this.$parent。 组件必须相互保持独立，Vue 组件也是。如果组件需要访问其父层的上下文就违反了该原则。 如果一个组件需要访问其父组件的上下文，那么该组件将不能在其它上下文中复用。 在有些情况下，可能需要对一个 prop 进行&quot;双向绑定&quot;。不幸的是，真正的双向绑定会带来维护上的问题，因为子组件可以修改父组件，且在父组件和子组件都没有明显的改动来源，推荐以 update:myPropName 的模式触发事件取而代之。在子组件中通过.sync/emit模式来改变父组件传入的 Props 的值。 Bad 1234567891011121314151617181920212223Vue.component(&quot;TodoItem&quot;, { props: { todo: { type: Object, required: true, }, }, methods: { removeTodo() { var vm = this; vm.$parent.todos = vm.$parent.todos.filter(function (todo) { return todo.id !== vm.todo.id; }); }, }, template: ` &lt;span&gt; {{ todo.text }} &lt;button @click=&quot;removeTodo&quot;&gt; X &lt;/button&gt; &lt;/span&gt; `,}); Good 123456789101112131415161718192021222324// parent template&lt;todo-item :todo.sync=&quot;todoObj&quot;&gt;// childVue.component('TodoItem', { props: { todo: { type: Object, required: true } }, methods: { removeTodo: (newFoo) =&gt; { this.$emit('update:todo', newTodoObj); } }， template: ` &lt;span&gt; {{ todo.text }} &lt;button @click=&quot;removeTodo&quot;&gt; X &lt;/button&gt; &lt;/span&gt; `}) 5.3 谨慎使用 this.$refsVue.js 支持通过 ref 属性来访问其它组件和 HTML 元素。并通过 this.$refs 可以得到组件或 HTML 元素的上下文。在大多数情况下，通过 this.$refs 来访问其它组件的上下文是可以避免的。在使用的的时候你需要注意避免调用了不恰当的组件 API，所以应该尽量避免使用 this.$refs。 当遇到 props 和 events 难以实现的功能时，通过 this.$refs 来实现。 当需要操作 DOM 无法通过指令来做的时候可使用 this.$ref 而不是 JQuery、document.getElement*、document.queryElement。 Good 12345678&lt;!-- 推荐，并未使用 this.$refs --&gt;&lt;range :max=&quot;max&quot; :min=&quot;min&quot; @current-value=&quot;currentValue&quot; :step=&quot;1&quot;&gt;&lt;/range&gt; 123456789101112131415161718192021222324252627282930313233343536373839&lt;!-- 使用 this.$refs 的适用情况--&gt;&lt;modal ref=&quot;basicModal&quot;&gt; &lt;h4&gt;Basic Modal&lt;/h4&gt; &lt;button class=&quot;primary&quot; @click=&quot;$refs.basicModal.hide()&quot; &gt;Close &lt;/button&gt;&lt;/modal&gt;&lt;button @click=&quot;$refs.basicModal.open()&quot; &gt;Open modal&lt;/button&gt;&lt;!-- Modal component --&gt;&lt;template&gt; &lt;div v-show=&quot;active&quot;&gt; &lt;!-- ... --&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { // ... data() { return { active: false, }; }, methods: { open() { this.active = true; }, hide() { this.active = false; }, }, // ...};&lt;/script&gt; 5.4 按照一定的结构顺序来组织组件 导出一个清晰、组织有序的组件，使得代码易于阅读和理解。同时也便于标准化。 按首字母排序 properties、data、computed、watches 和 methods 使得这些对象内的属性便于查找。 合理组织，使得组件易于阅读。（name; extends; props, data 和 computed; components; watch 和 methods; lifecycle methods 等）。 使用 name 属性。借助于 vue devtools 可以让你更方便的测试。 合理的 CSS 结构，如 BEM。 使用单文件 .vue 文件格式来组件代码。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;template&gt; &lt;div class=&quot;Ranger__Wrapper&quot;&gt; &lt;!-- ... --&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default { // 不要忘记 name 属性 name: 'RangeSlider', // 使用组件 mixins 共享通用功能 mixins: [], // 使用其它组件 components: {}, // 组成新的组件 extends: {}, // 指令 directives: {}, // 组件属性、变量 props: { bar: {}, // 按字母顺序 foo: {}, fooBar: {}, }, // 变量 data() { return {} }, // 方法 computed: {}, watch: {}, methods: {}, // 生命周期函数（按顺序） ... beforeCreate() {}, created () {}, mounted() {} ... };&lt;/script&gt;&lt;style scoped&gt; .Ranger__Wrapper { &lt;!-- ... --&gt; }&lt;/style&gt; 5.5 接口调用流程未使用状态管理时： 在 services 文件夹下按模块添加方法，该方法包括调用接口以及返回数据的处理。（方便复用） 在单文件组件中调用上述方法。 使用状态管理时： 在 services 文件夹下按模块添加方法，该方法包括调用接口以及返回数据的处理。（方便复用） 在 store 的 actions 中调用上述方法，commit 到 mutation，mutation 改变 state 的值。 在单文件组件中调用 actions 中的方法。 5.6 每个分类都只有一个入口（如：router、store、plugins 等分类下）即每个文件夹下都会有一个 index.js/ts, 目的是对外隔离，当引入该分类下的文件时，不用按每个 JS 模块路径引入，否则调整单个模块位置需要修改依赖它的所有模块。 5.7 每个分类内部模块互相引用时，使用相对路径; 分类之间模块引用时，使用绝对路径相对路径目的是对外隔离，不和分类外的路径产生关系，同时方便分类复用。如 plugins 文件夹下的 index 文件。 12// Elementimport &quot;./element&quot;; 绝对路径目的是从语义上区分模块是否是同一分类，分类路径发生改变时一次性全局替换。如在 main.js 中引入 plugins。 1import &quot;@/plugins&quot;; // 按需引入插件 vue 组件、assets 等其它各模块的引用路径，类似如下，用&quot;@&quot;直接引用 src 目录下的，而不是使用相对路径。 12import AjaxTree from &quot;@/components/tree/ajax-tree&quot;;import VmTable from &quot;@/components/table/vm-table&quot;; css 的文件引用路径如下，用&quot;~@&quot;替换之前的&quot;../../&quot;： 1234&lt;style lang=&quot;scss&quot;&gt; @import &quot;~@/assets/styles/common.scss&quot;; @import &quot;~@/assets/styles/table.scss&quot;;&lt;/style&gt; 5.8 组件封装组件分为 dumb component（普通组件，一般是 components 里的一个单文件组件） 和 smart component（容器组件，一般是 views 里的一个单文件组件）两种。 普通组件尽量只通过 props 接收容器组件传来的数据，向父组件派发消息，而不做其它任何主动调取数据等工作。 6 性能优化6.1（官）总是用 key 配合 v-for (性能优化 2)在组件上总是必须用 key 配合 v-for，以便维护内部组件及其子树的状态。 同时，Key 不要为 index，尽量是一个唯一值，因为数据发生变化时，index 可能不变。 Bad 12345&lt;ul&gt; &lt;li v-for=&quot;todo in todos&quot;&gt; {{ todo.text }} &lt;/li&gt;&lt;/ul&gt; Good 12345678&lt;ul&gt; &lt;li v-for=&quot;todo in todos&quot; :key=&quot;todo.id&quot; &gt; {{ todo.text }} &lt;/li&gt;&lt;/ul&gt; 6.2（官）永远不要把 v-if 和 v-for 同时用在同一个元素上 (性能优化 3)一般在两种常见的情况下会倾向于这样做： 为了过滤一个列表中的项目 (比如 v-for=&quot;user in users&quot; v-if=&quot;user.isActive&quot;)。在这种情形下，请将 users 替换为一个计算属性 (比如 activeUsers)，让其返回过滤后的列表。会获得如下好处： 过滤后的列表只会在 users 数组发生相关变化时才被重新运算，过滤更高效。 使用 v-for=&quot;user in activeUsers&quot; 之后，在渲染的时候只遍历活跃用户，渲染更高效。 解耦渲染层的逻辑，可维护性 (对逻辑的更改和扩展) 更强。 为了避免渲染本应该被隐藏的列表 (比如 v-for=&quot;user in users&quot; v-if=&quot;shouldShowUsers&quot;)。这种情形下，请将 v-if 移动至容器元素上 (比如 ul, ol)。 通过将 v-if 移动到容器元素，不会再对列表中的每个用户检查 shouldShowUsers。取而代之的是，只检查它一次，且不会在 shouldShowUsers 为否的时候运算 v-for。 Bad 123456789&lt;ul&gt; &lt;li v-for=&quot;user in users&quot; v-if=&quot;user.isActive&quot; :key=&quot;user.id&quot; &gt; {{ user.name }} &lt;/li&gt;&lt;/ul&gt; 123456789&lt;ul&gt; &lt;li v-for=&quot;user in users&quot; v-if=&quot;shouldShowUsers&quot; :key=&quot;user.id&quot; &gt; {{ user.name }} &lt;/li&gt;&lt;/ul&gt; Good 12345678910111213141516&lt;ul&gt; &lt;li v-for=&quot;user in activeUsers&quot; :key=&quot;user.id&quot; &gt; {{ user.name }} &lt;/li&gt;&lt;/ul&gt;computed: { activeUsers: function () { return this.users.filter(function (user) { return user.isActive }) }} 12345678&lt;ul v-if=&quot;shouldShowUsers&quot;&gt; &lt;li v-for=&quot;user in users&quot; :key=&quot;user.id&quot; &gt; {{ user.name }} &lt;/li&gt;&lt;/ul&gt; 6.3 组件销毁时及时清除事件监听、定时器等 (性能优化 4)一般在 created 或 mounted 生命周期函数中添加 事件总线和 window 上的事件监听或定时器，在 beforeDestroy 或 destroyed 中，添加以上三类事件的移除方法。 12345678910111213created() { this.$eventHub.$on('logged-in', this.getCurrentUser);},beforeDestroy() { this.$eventHub.$off('logged-in');},methods: { getCurrentUser(){ ... }} 12345678910111213mounted() { window.addEventListener('scroll', this.scrollhandle);},beforeDestroy() { window.removeEventListener('scroll', this.scrollhandle);},methods: { scrollhandle(event) { ... },}, 1234567mounted() { this.interVal = setInterval(callback,millisec,args);},beforeDestroy() { clearInterval(this.interVal);} 6.4 通过 ES6 动态导入的方式引入异步组件 (性能优化 5)在平时的开发工作中，为了减少首屏代码体积，往往会把一些非首屏的组件设计成异步组件，按需加载。 基于路由 123456789101112131415161718192021import Vue from &quot;vue&quot;;import Router from &quot;vue-router&quot;;import Home from &quot;../views/Home.vue&quot;;Vue.use(Router);export default new Router({ routes: [ { path: &quot;/&quot;, name: &quot;home&quot;, component: Home, }, { path: &quot;/about&quot;, name: &quot;about&quot;, // route level code-splitting // this generates a separate chunk (about.[hash].js) for this route // which is lazy-loaded when the route is visited. component: () =&gt; import(/* webpackChunkName: &quot;about&quot; */ &quot;../views/About.vue&quot;), }, ],}); 本地注册 1234567891011121314&lt;!-- App.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;message&gt;&lt;/message&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { components: { Message: () =&gt; import(&quot;./Message&quot;) }};&lt;/script&gt; 6.5 VueX 状态管理6.5.1 不要过度使用 Store (性能优化 6)把所有逻辑移到 Store 中会导致更多的性能开销和不必要的复杂性。 在严格模式下，无论何时发生了状态变更且不是由 mutation 函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。 开启严格模式： 1234const store = new Vuex.Store({ // ... strict: process.env.NODE_ENV !== &quot;production&quot;,}); 不要在发布环境下启用严格模式！严格模式会深度监测状态树来检测不合规的状态变更——请确保在发布环境下关闭严格模式，以避免性能损失。 6.5.2 State6.5.2.1 将数组转化为对象进行存储 (性能优化 7)即使从接口中返回的数据就是对象数组的形式，并且视图需要将其显示为使用 v-for 指令映射的数组，也应考虑将其作为对象放在存储中。 可以轻松地使用 ES6+内置的 Object.keys，Object.values 和 Object.entries 方法从任何对象中获取数组，但反之则有些复杂。 作为一种算法，通过键从对象中检索到的内容的时间复杂度为 O(1)，如果使用搜索或过滤器来查找相同的数据，则是 O(n)。 Bad 1234const initialState = { partnersList: [], // array of all partners currentPartner: {}, // current partner object.}; Good 1234const initialState = { partnersList: {}, // object with all partners keyed by ID currentPartnerId: ``, // a string contining the ID of the current partner.}; 6.5.3 Getter6.5.3.1 需要包含一些逻辑如果要访问子属性，通过 mapState。 Bad 123getters: { getProducts: state =&gt; state.products,} Good 123getters: { getFeaturedProducts: state =&gt; state.products.filter(p =&gt; p.isFeatured),} 6.6 数据冻结 (性能优化 8)如果有一个巨大的数组或 Object，并且确信数据不会修改，使用 Object.freeze() 可以让 Vue 不会给对象加上 getter/setter,性能会大幅提升。 在组件中： 123456789export default { data: () =&gt; ({ users: {}, }), async created() { const users = await axios.get(&quot;/api/users&quot;); this.users = Object.freeze(users); },}; 在 store 中： 1234567const mutations = { setUsers(state, users) { state.users = Object.freeze(users); // 也可以做修改 // state.users = Object.freeze([...state.users, user]); },}; 如果是嵌套对象，则使用深度冻结，也就是遍历对象，用下方的 deepFreeze 替换上边写的 Object.freeze。 123456789101112131415161718192021/** * 深度冻结对象 * @param target 要冻结的嵌套对象 */function deepFreeze(target) { Object.freeze(target); Object.getOwnPropertyNames(target).forEach((prop) =&gt; { if ( target.hasOwnProperty(prop) &amp;&amp; target[prop] !== null &amp;&amp; (typeof target[prop] === &quot;object&quot; || typeof target[prop] === &quot;function&quot;) &amp;&amp; !Object.isFrozen(target[prop]) ) { deepFreeze(target[prop]); } }); return target;} 6.7 图片压缩 (性能优化 9)使用 image-webpack-loader 对图片进行压缩。安装： 1npm i -D image-webpack-loader 在 vue.config.js 中 添加配置： 12345678910111213module.exports = { configureWebpack: (config) =&gt; { // 压缩图片 config.module.rules.push({ test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, use: [ { loader: &quot;image-webpack-loader&quot;, }, ], }); },}; 6.8 使用 KeepAlive 按需缓存路由页面 (性能优化 10)123&lt;keep-alive include=&quot;要缓存的组件名称,要缓存的组件名称&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt; 6.9 使用 CDN 或者引入其它服务器上的文件地址实现对静态资源并行请求 (性能优化 11)浏览器针对每个域名能创建的最大 TCP 连接数是有限制的（谷歌浏览器 6 个），通过将静态资源放在不同的域中可以增加并行请求数。 6.10 GZip (性能优化 12)使用 Nginx 进行动态压缩，具体请看 Nginx 相关的文档（待补充）。 7 其它7.1 静态分析使用 ESLint 作为代码静态分析工具，遵从 Airbnb+自定义风格。 7.2 常用插件Vue-Awesome-Swiper：基于 Swiper4、适用于 Vue 的轮播组件。 Vue-Lazyload：图片懒加载。 (性能优化 13) vue-svg-icon：可定义 svg 图标的颜色。 7.3 常用工具Octotree：GitHub 可视化代码树插件。 npm-check-updates：更新 package.json 中的所有依赖到最新版本。 7.4 资源一张思维导图辅助你深入了解Vue | Vue-Router | Vuex 源码架构 8 写在最后看过一篇文章，觉得观点挺好的，就直接拿来用了。 Best Practice ：最佳实践。Wikipedia 上对其解释为：A best practice is a method or technique that has been generally accepted as superior to any alternatives because it produbces results that are superior to those achieved by other means or because it has become a standard way of doing things. (最佳实践是一种：因其产生的结果优于其它选择下的结果，或其已经成为一种做事的标准，从而被普遍认可优于任何替代方案的方法或技术。) 最佳实践本身是美好的存在，犹如夜空中的一轮明月，照亮黑暗中的方向，指引着摸索前行的凡人。 但凡事有度，子曰：&quot;过犹不及。&quot; 首先，最佳实践容易带来思想包袱，让人无法专注于解决问题本身。 总是希望采用最好的技术方法，不愿意在不正确的做法上浪费时间，导致瞻前顾后，甚至裹足不前。此时的最佳实践，已然成为了一种毒药，一旦偏离了问题本身这个出发点，就会不知不觉走进&quot;宏大构想&quot;的思维陷阱。把简单的问题复杂化，阻碍了迈出第一步，直到能规划出&quot;包罗万象&quot;的解决方案后才肯动手，拖延症就这样来了，时间却走了。 其次，对最佳实践的执念容易让人钻牛角尖，将目标的重心带偏。 过度关注实施过程是否符合标准化，忽视了项目中其它重要的东西，比如用户体验，比如实际需求。 再次，工程师思维，沉迷于奇技淫巧中无法自拔。 比如性能优化。&quot;优秀的程序员应该榨干每一字节内存&quot;，听起来很熟悉，不是吗？但经济学上来讲，边际效应决定了一次项目中，越优化性价比越低。有一个很容易被忽略的事实：硬件其实比程序员要便宜。 再比如对设计模式的崇拜。设计模式当然是好东西，但如果像强迫症一样使用它们，坚持用上它们才是正确的编程，就会导致按图索骥，强行让问题去适应设计模式，而不是让解决方案针对问题，这就本末倒置了。 最后，一个项目的开发顺利与否，并不在于技术选型是否为最佳实践。 工作数年，大小项目经历若干，慢慢体会到，一个项目的开发顺利与否，并不在于技术选型是否为最佳实践，更多的时候，取决于开发方案和技术储备之间的平衡。做项目毕竟是要讲方案落地的，如果最佳实践中的技术成本，超出了开发者的落实能力，那就是坑，这时盲从最佳实践无异于挖坟。如果是一个人的项目，抽时间恶补一通，兴许能填填坑，这取决于 IQ。但要是一个团队，那就不是什么 IQ，EQ，QQ 的问题了，这中间产生的学习成本，集体培训成本，反复沟通成本，大量的初级错误，千奇百怪的代码，互相冲突引发的焦躁情绪等等。这些负面的东西如果不能妥善的处理，足以抵消掉最佳实践带来的好处。别忘了，deadline 正在迫近。 当尘埃落定，蓦然回首，最佳实践很可能没你想象中那么重要。它更多的是一种精神层面的求道，并非物质世界的必要。 全篇能全部看下来，觉得自己基础扎实，想在前端道路上有进一步发展的请加微信： zapzqc只要你肯努力，这里将会为你提供充足的发展空间。","link":"/2020/04/29/Vue-js2%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"},{"title":"Storybook的基本使用指南","text":"1 什么是 Storybook让我们来看看 Storybook 的官网咋说的： ”Build bulletproof UI components faster” ——更快地创建一个坚不可摧的 UI 组件库。 “Storybook is an open source tool for developing UI components in isolation for React,Vue, Angular, and more. It makes building stunning UIs organized and efficient.”——故事书是一个开源的工具，用于独立开发 React、Vue、Angular 等的 UI 组件。它能有组织且高效地构建 UI 组件。 简而言之，Storybook 是一个开源的项目，该项目已经为我们搭好了架子，我们只需要在该架子的基础上添砖加瓦，就能够将所有 UI 组件集成在一个项目中，展示和分类组件，提供组件全面的示例，并进行组件测试。 每一个 UI 组件的示例就是一个 story 。所有的示例的集合，就是 Storybook 了。 2 Storybook 的开发流程一般在开发完成一个 UI 组件之后，如果你想让其他人查看并复用你的 UI 组件，就可以进行 story 的开发了。当前的开发流程如下图所示： 未来我们还会走另一种开发流程，Storybook 项目将作为 vue-component-ts 的一部分，直接导入 vue-component-ts 中的 UI 组件。所以未来我们会省去在 npm 上注册插件的这一步，而改为导入组件库中的 UI 组件。 3 Storybook 的文件目录1234567891011121314151617│ .eslintrc.js│ babel.config.js│ package.json│├─.Storybook│ main.js // 配置Storybook的行为信息，还可以在次配置webpack、babel信息。│ manager.js // 设置插件的行为信息，比如修改插件主题色。│├─src│ ├─components // 若不使用组件注册的方式来引用UI组件，还可以将UI组件放在该文件夹下，然后在story中引用。│ │ └─t-button.vue // UI组件源码│ ││ └─stories // 所有的UI组件示例都会放在该文件夹下│ └─charts.stories.js // 这是一个关于charts组件的stories，里面包含了多个charts的story│└─static // 静态目录，放置静态文件 └─mds // 存放有关于story介绍的markdown文档 注意：修改 main.js 后要想使其生效，需要重启项目。 4 快速构建一个 Storybook4.1 编写一个最基本的 story一个组件可以编写多个 story 。编写一个组件的 story 有两种方式，一种是 CSF 方式，另一种是 StoriesOf 方式。由于 StoriesOf 是新出的写法，在实践的过程中会存在一些问题，所以还是比较推荐 CSF 方式 首先，我们需要新建一个 xxx.stories.js 文件，或者新建一个文件夹，里面包含着该 UI 组件的所有，每个 UI 组件的 story 都写在这里面。 4.1.1 CSF（ Component Story Format ）方式123456789101112131415const TVue = require('ths-vue');// 控制页面如何绘制出你的story，以及如何提供插件使用的信息export default { title: ‘echarts/xx’}// 柱状统计图就相当于一个story了，所有有关于该story的参数在配置项中配置export const 柱状统计图 = () =&gt; ({ props: {…}, data (){…}, components: {thsBarChart: TVue.thsBarChart.thsBarChart}, template: ` &lt;ths-bar-chart :basic=&quot;basic“ :options=&quot;options&quot;&gt;&lt;/ths-bar-chart&gt; `}) export default 的常用参数介绍: 12345678import md from '../../static/mds/thsBarChart.md';export default: {title: ‘大标题|文件夹/组件名’, // story所在文件目录的定义，可以控制左侧菜单栏的显示// story的参数可以用于在story或stories的层次上为各种插件提供配置parameters: { notes: md, // notes是一个插件}} 4.1.2 StoriesOf 方式12345678910import { storiesOf } from &quot;@storybook/vue&quot;;import TButton from &quot;../components/t-button.vue&quot;;storiesOf(&quot;PC|统计图&quot;, module).add(&quot;柱图&quot;, () =&gt; ({ components: { TButton }, props: { color: &quot;#FF0000&quot;, label: &quot;确定&quot;, }, template: '&lt;t-button :color=&quot;color&quot; &gt;{{label}}&lt;/t-button&gt;',})); 注：两种方式不建议写在同一个 story 里。 4.2 Storybook 插件的安装与配置 npm i –D 插件名 以 addon-knobs 插件为例在 .storybook/main.js 中 module.exports 导出的对象中添加以下内容： 1addons: [&quot;@storybook/addon-knobs&quot;]; 在 story 中引用该插件就 OK 了： 1import { color, text, boolean } from &quot;@storybook/addon-knobs&quot;; 4.3 常用插件的使用4.3.1 Storybook 插件之 KnobsKnobs 可以用于设置组件传入的参数信息，并实时更新，查看效果（不会改变组件的源码）。 使用方法（这是一段关键代码，props 为一个 story 的其中一个配置参数）： 123456789101112import { object } from '@storybook/addon-knobs';props:{ basic: { default: object( '基础配置', { width: '100%', height: '240', backgroundColor: '#fff', }, ), }, 效果： 修改 width 、height 、backgroundColor 参数就可以在界面上给组件传参啦~ 4.3.2 Storybook 插件之 notesNotes 可以用于读取指定的 markdown 文档，展示组件的配置参数的类型、含义，介绍组件的配置方式和安装方式等信息。 使用方法： 123456import md from &quot;../../static/mds/thsBarChart.md&quot;;export default { parameters: { notes: md, },}; 这样就能将 markdown 文档引入到故事中显示了~ 友情链接： Storybook 官网链接 Storybook 使用示例：http://182.48.115.106:8090/svn/Products/前端开发1.0/工程/代码/思路组件库/Vue/storybook 5 md 示例一个组件主要要介绍的内容有：组件功能简介、组件引用配置示例（即组件源码）和组件配置项说明。以 thsBarChart 组件为例，列举了该组件的 markdown 文档该具备哪些内容： 5.1 组件功能简介用 vue + echars 实现的柱状统计图，可以选择性地显示多个系列的数据。鼠标 hover 上某段数据能够显示该段数据上所有系列的数据信息。 5.2 组件引用配置示例在 main.js 中： 123import Vue from &quot;vue&quot;;import { thsBarChart } from &quot;ths-vue&quot;;Vue.use(thsBarChart); 在 xxx.vue 文件中： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223&lt;template&gt; &lt;ths-bar-chart :basic=&quot;basic&quot; :options=&quot;options&quot; :nameAlias=&quot;nameAlias&quot; :valueAlias=&quot;valueAlias&quot; :data=&quot;data&quot; &gt;&lt;/ths-bar-chart&gt;&lt;/template&gt;&lt;script&gt;export default { data() { return { basic: { width: &quot;100%&quot;, height: &quot;240&quot;, backgroundColor: &quot;#fff&quot;, }, options: { color: [ &quot;#538FFF&quot;, &quot;#FFBF27&quot;, &quot;#FC807A&quot;, &quot;#7BD25F&quot;, &quot;#BE90EA&quot;, &quot;#FF9F37&quot;, ], tooltip: { show: true, backgroundColor: &quot;#fff&quot;, textStyle: { color: &quot;#333&quot;, fontSize: &quot;12&quot;, fontFamily: &quot;PF&quot;, fontWeight: &quot;normal&quot;, }, }, title: { show: false, text: &quot;这是标题&quot;, textStyle: { color: &quot;#666&quot;, fontSize: &quot;16&quot;, fontFamily: &quot;PF&quot;, fontWeight: &quot;bold&quot;, }, left: &quot;center&quot;, }, legend: { padding: [0, 0, 0, 50], show: true, left: &quot;center&quot;, top: 20, orient: &quot;horizontal&quot;, textStyle: { color: &quot;#666&quot;, fontSize: &quot;12&quot;, fontFamily: &quot;PF&quot;, fontWeight: &quot;normal&quot;, }, data: [&quot;示例&quot;, &quot;示例2&quot;], }, grid: { left: 40, right: 30, top: 50, bottom: 40, }, xAxis: { show: true, name: &quot;&quot;, nameTextStyle: { color: &quot;#666&quot;, fontSize: &quot;12&quot;, fontFamily: &quot;PF&quot;, fontWeight: &quot;normal&quot;, }, nameGap: 10, boundaryGap: true, axisLine: { show: true, lineStyle: { color: &quot;#eee&quot;, width: 1, type: &quot;solid&quot;, }, }, axisTick: { show: false, }, splitLine: { show: false, lineStyle: { color: &quot;#eee&quot;, width: 1, type: &quot;solid&quot;, }, }, axisLabel: { show: true, interval: 0, color: &quot;#666&quot;, rotate: 0, fontFamily: &quot;PF&quot;, fontSize: &quot;12&quot;, }, data: [&quot;周一&quot;, &quot;周二&quot;, &quot;周三&quot;, &quot;周四&quot;, &quot;周五&quot;, &quot;周六&quot;, &quot;周日&quot;], }, yAxis: { show: true, name: &quot;单位&quot;, nameTextStyle: { color: &quot;#666&quot;, fontSize: &quot;12&quot;, fontFamily: &quot;PF&quot;, fontWeight: &quot;normal&quot;, }, nameGap: 10, inverse: false, boundaryGap: false, splitNumber: 15, axisLine: { show: true, lineStyle: { color: &quot;#eee&quot;, width: 1, type: &quot;solid&quot;, }, }, axisTick: { show: false, }, splitLine: { show: true, lineStyle: { color: &quot;#eee&quot;, width: 1, type: &quot;dashed&quot;, }, }, axisLabel: { show: true, interval: 0, color: &quot;#666&quot;, rotate: 0, fontFamily: &quot;PF&quot;, fontSize: &quot;12&quot;, }, }, series: [ { name: &quot;示例&quot;, label: { show: false, position: &quot;top&quot;, distance: 5, color: &quot;#666&quot;, fontFamily: &quot;PF&quot;, fontSize: &quot;12&quot;, }, barColor: &quot;&quot;, barWidth: 4, borderColor: &quot;rgba(0,0,0,0)&quot;, borderWidth: 2, backgroundColor: &quot;&quot;, data: [120, 132, 101, 134, 90, 230, 210], stack: &quot;示例2&quot;, }, { name: &quot;示例2&quot;, label: { show: false, position: &quot;top&quot;, distance: 5, color: &quot;#666&quot;, fontFamily: &quot;PF&quot;, fontSize: &quot;12&quot;, }, barColor: &quot;&quot;, barWidth: 4, borderColor: &quot;rgba(0,0,0,0)&quot;, borderWidth: 2, backgroundColor: &quot;&quot;, data: [12, 13, 10, 13, 9, 23, 21], }, { name: &quot;示例3&quot;, label: { show: false, position: &quot;top&quot;, distance: 5, color: &quot;#666&quot;, fontFamily: &quot;PF&quot;, fontSize: &quot;12&quot;, }, barColor: &quot;&quot;, barWidth: 4, borderColor: &quot;rgba(0,0,0,0)&quot;, borderWidth: 2, backgroundColor: &quot;&quot;, data: [122, 13, 10, 13, 9, 23, 21], }, ], dataZoom: { show: false, maxPointNum: 10, }, }, nameAlias: &quot;date&quot;, valueAlias: &quot;revenue&quot;, data: [ { date: &quot;星期一&quot;, revenue: 43 }, { date: &quot;星期二&quot;, revenue: 54 }, { date: &quot;星期三&quot;, revenue: 82 }, { date: &quot;星期四&quot;, revenue: 48 }, { date: &quot;星期五&quot;, revenue: 10 }, { date: &quot;星期六&quot;, revenue: 82 }, { date: &quot;星期天&quot;, revenue: 28 }, ], }; },};&lt;/script&gt; 5.3 组件配置项说明 basic（即 knobs 中的基础配置） 属性名 属性含义 数值类型 示例（默认值） width 整个统计图的宽度 百分比 | 数值 “width”: “500” height 整个统计图的高度 数值 “height”: “400” backgroundColor 统计图背景颜色 颜色值 “backgroundColor”: “#fff” options options 的配置项比较多，配置了 tooltip 、title 、legend 、grid 、xAxis 、yAxis 、series： （以下仅举例 tooltip 、title 、legend 这三种配置项的说明作为参考） tooltip（提示框组件） 属性名 属性含义 数值类型 示例（默认值） show 是否显示提示框组件 布尔值 “show”: true textStyle 提示框组件的字体样式配置 对象 “textStyle”: { “color”: “#333”, “fontSize”: “12”, “fontFamily”: “PF”, “fontWeight”: “normal” } backgroundColor 统计图背景颜色 颜色值 backgroundColor: ‘#fff’ title（统计图标题） 属性名 属性含义 数值类型 示例（默认值） show 是否显示统计图标题 布尔值 “show”: false text 统计图标题的文本内容 字符串 “text”: “这是标题” textStyle 统计图标题的字体样式配置 对象 “textStyle”: { “color”: “#666”, “fontSize”: “16”, “fontFamily”: “PF”, “fontWeight”: “bold” } left 统计图标题的排版设置 字符串 | 数字 “left”: “center” legend（图例） 属性名 属性含义 数值类型 示例（默认值） padding 图例的内边距 数组 “padding”: [0, 0, 0, 50] show 是否显示图例 布尔值 “show”: true left 图例的排版设置 字符串 | 数字 “left”: “center” top 图例到统计图顶部距离 字符串| 数字 “top”: 20 orient 图例的排列方向 字符串 “orient”: “horizontal”（水平排列） textStyle 图例的字体样式 对象 “textStyle”: { “color”: “#666”, “fontSize”: “12”, “fontFamily”: “PF”, “fontWeight”: “normal” } data 图例的数据 数组 “data”: [“示例”, “示例 2”]","link":"/2020/09/27/storybook%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"title":"Nginx入门","text":"概念（背景、F5）Nginx (engine x) 是一款轻量级的 Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，其特点是占有内存少，并发能力强。该软件由伊戈尔·赛索耶夫创建并于 2004 年首次公开发布。2011 年成立同名公司以提供支持。2019 年 3 月 11 日，Nginx 公司被 F5 Networks 以 6.7 亿美元收购。下载地址 配置文件配置文件 nginx.conf 中文详解 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889Nginx 进程数，建议设置为等于CPU总核心数。worker_processes 8;全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]error_log /usr/local/nginx/logs/error.log info;进程pid文件pid /usr/local/nginx/logs/nginx.pid;events{ #单个进程最大连接数（最大连接数=连接数*进程数） #根据硬件调整，和前面工作进程配合起来用，尽量大，但是别把cpu跑到100%就行。每个进程允许的最多连接数，理论上每台Nginx服务器的最大连接数为。 worker_connections 1024; #keepalive超时时间，单位秒。 keepalive_timeout 60;}设定http服务器，利用它的反向代理功能提供负载均衡支持http{ #文件扩展名与文件类型映射表 补充 include mime.types; #默认文件类型 default_type application/octet-stream; #默认编码 #charset utf-8; #长连接超时时间，单位是秒 keepalive_timeout 120; #gzip模块设置 （可以配置http,server和location模块下） gzip on; #开启gzip压缩输出 gzip_min_length 1k; #最小压缩文件大小 gzip_buffers 4 16k; #压缩缓冲区 gzip_http_version 1.0; #识别http协议的版本,早起浏览器可能不支持gzip自解压,用 户会看到乱码（默认1.1，前端如果是squid2.5请使用1.0） gzip_comp_level 5; #gzip压缩比（1~9），越小压缩效果越差，但是越大处理越慢，所以一般取中间值; gzip_types text/plain application/x-javascript text/css application/xml application/json; #压缩类型，默认就已经包含'text/html'，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。 gzip_vary on; #启用应答头&quot;Vary: Accept-Encoding&quot; gzip_disable &quot;MSIE [1-6]\\.&quot;; #ie6以下就不启用gzip gzip_proxied off; #Nginx做为反向代理时启用, off(关闭所有代理结果的数据的压缩), expired(启用压缩,如果header头中包括&quot;Expires&quot;头信息), no-cache(启用压缩,header头中包含&quot;Cache-Control:no-cache&quot;), no-store(启用压缩,header头中包含&quot;Cache-Control:no-store&quot;), private(启用压缩,header头中包含&quot;Cache-Control:private&quot;), no_last_modefied(启用压缩,header头中不包含&quot;Last-Modified&quot;), no_etag(启用压缩,如果header头中不包含&quot;Etag&quot;头信息), auth(启用压缩,如果header头中包含&quot;Authorization&quot;头信息) any - 无条件启用压缩 #虚拟主机的配置 server { #监听端口 listen 80; #域名可以有多个，用空格隔开 server_name www.w3cschool.cn w3cschool.cn; location / { root html; index index.html index.htm; } #图片缓存时间设置 location ~ .*.(gif|jpg|jpeg|png|bmp|swf)$ { expires 10d; } #JS和CSS缓存时间设置 location ~ .*.(js|css)?$ { expires 1h; } #对 &quot;/&quot; 启用反向代理 location / { proxy_pass http://127.0.0.1:88; expires 1h; #跨域资源共享 CORS add_header 'Access-Control-Allow-Origin' '*'; #允许来自所有的访问地址 add_header 'Access-Control-Allow-Credentials' 'true'; add_header 'Access-Control-Allow-Methods' 'GET, PUT, POST, DELETE, OPTIONS'; #支持请求方式 add_header 'Access-Control-Allow-Headers' 'Content-Type,*'; #表明服务器支持的所有头信息字段 }} 常用命令123456789start nginx 启动Nginx 或者双击文件夹下的nginx.exe nginx -s quit 优雅停止Nginx，有连接时会等连接请求完成再杀死worker进程 nginx -s reload 优雅重启，并重新载入配置文件nginx.conf nginx -s reopen 重新打开日志文件，一般用于切割日志 nginx -v 查看版本 nginx -t 检查Nginx的配置文件 nginx -h 查看帮助信息nginx -V 详细版本信息，包括编译参数 nginx -c filename 指定配置文件 功能（前端开发需要掌握）静态资源发布 使用场景发布前端的静态工程、或者发布静态资源。 优、缺点 根目录配置 在红框选择的地方指定 Nginx 的根目录即可。 反向代理 使用场景做外网映射；请求资源时，由于浏览器的同源策略导致的跨域 配置 location 负载均衡负载均衡，英文名称为 Load Balance，是一种技术，指通过某种算法实现负载分担的方法。通俗的讲就是统一分配请求的设备，负载均衡会统一接收全部请求，然后按照设定好的算法将这些请求分配给这个负载均衡组中的所有成员，以此来实现请求（负载）的均衡分配。 举个栗子：用电梯举例，假如从 1 楼到 24 楼吧，假如只有一部电梯，在早上上班高峰时期，10 个人以内没啥问题，但是同时来 50 个人呢，就会有很大压力，就需要等待。但是现在有 5 部电梯同时工作呢，是不是就可以很有效的缓解压力。负载均衡也就是这个道理，通过集群来完成本应该在一台服务器完成的工作。 upstream 指令upstream 指令用于定义服务器集群 123456upstream backend { server backend1.example.com weight=5; server 127.0.0.1:8080 max_fails=3 #最大次数 fail_timeout=30s; #延时30s server unix:/tmp/backend3; server backup1.example.com backup;} 分配方式Nginx 的 upstream 支持 5 种 分配方式，其中 轮询、权重、IP 散列这三种为 Nginx 原生支持的分配方式，fair 和 url_hash 为第三方支持的分配方式。1、轮询轮询是 upstream 的默认分配方式，即每个请求按照时间顺序轮流分配到不同的后端服务器，如果某个后端服务器 down 掉后，能自动剔除。 12345upstream zhang21（名称）{ server 192.168.1.11：8888； server 192.168.1.22：8888； server 192.168.1.33：8888；} 2、weight（权重）轮询的加强版，既可以指定轮询比率，weight 和访问几率成正比，主要应用于后端服务器异质的场景下。 12345upstream zhang21 { server 192.168.1.11 weight=1； server 192.168.1.22 weight=2； server 192.168.1.33 weight=3；} 3、ip_hash每个请求按照访问 Ip（即 Nginx 的前置服务器或客户端 IP）的 hash 结果分配，这样每个访客会固定访问一个后端服务器，可以解决 session 一致问题。 123456upstream zhang21 { ip_hash; server 192.168.1.11:7777; server 192.168.1.22:8888; server 192.168.1.33:9999;} 4、fairfair 顾名思义，公平地按照后端服务器的响应时间（rt）来分配请求，响应时间（rt）小的后端服务器优先分配请求。 12345upstream zhang21 { server 192.168.1.11; server 192.168.1.22; server 192.168.1.33;} 5、url_hash与 ip_hash 类似，但是按照访问 url 的 hash 结果来分配请求，使得每个 url 定向到同一个后端服务器，主要应用于后端服务器为缓存的场景下。 1234567upstream zhang21 { server 192.168.1.11; server 192.168.1.22; server 192.168.1.33; hash $request_uri； hash_method crc32；} 其中，hash_method 为使用的 hash 算法，需要注意，此时 server 语句中不能添加 weight 等参数。 动静分离服务端接收来自客户端的请求中，有一部分是静态资源的请求，例如 html, css, js 和图片资源等等，有一部分是动态数据的请求。因为 tomcat 处理静态资源的速度比较慢，所以我们可以考虑把所有静态资源独立开来，交给处理静态资源更快的服务器例如 Nginx 处理，而把动态请求交给 tomcat 处理。 如下图所示，我们在机器上同时安装了 Nginx 和 tomcat,把所有的静态资源都放置在 Nginx 的 webroot 目录下面，把动态请求的程序都放在 tomcat 的 webroot 目录下面，当客户端访问服务端的时候，如果是静态资源的请求，就直接到 Nginx 的 webroot 目录下面获取资源，如果是动态资源的请求，Nginx 利用反向代理的原理，把请求转发给 tomcat 进行处理，这样就实现了动静分离，提高了服务器处理请求的性能。 123456789101112131415location ~ .*.jsp$ #所有jsp的页面均交由tomcat处理{ index index.jsp; proxy_pass http://192.168.222.128:8080;#转向tomcat处理}location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$ #设定访问静态文件直接读取不经过tomcat{ expires 30d;}location ~ .*\\.(js|css)?${ expires 1h;} 其他gzipgzip 最佳配置 123456789gzip on; #开启gzip压缩输出gzip_min_length 1k; #最小压缩文件大小gzip_buffers 4 16k; #压缩缓冲区gzip_http_version 1.0; #识别http协议的版本,早起浏览器可能不支持gzip自解压,用 户会看到乱码（默认1.1，前端如果是squid2.5请使用1.0）gzip_comp_level 5; #gzip压缩比（1~9），越小压缩效果越差，但是越大处理越慢，所以一般取中间值;gzip_types text/plain application/x-javascript text/css application/xml application/json; #压缩类型，默认就已经包含'text/html'，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。gzip_vary on; #启用应答头&quot;Vary: Accept-Encoding&quot;gzip_disable &quot;MSIE [1-6]\\.&quot;; #ie6以下就不启用gzipgzip_proxied off; #Nginx做为反向代理时启用, 静态资源缓存设置Nginx 缓存，可以在一定程度上，减少源服务器的处理请求压力。因为静态文件（比如 css，js， 图片）中，很多都是不经常更新的。Nginx 使用 proxy_cache 将用户的请求缓存到本地一个目录。下一个相同请求可以直接调取缓存文件，就不用去请求服务器了。利用 expires 指令。 1234expires 3d; //表示缓存3天expires 3h; //表示缓存3小时expires max; //表示缓存10年expires -1; //表示永远过期。 #图片缓存时间设置 123456789 location ~ .*.(gif|jpg|jpeg|png|bmp|swf)${ expires 10d;}#JS和CSS缓存时间设置location ~ .*.(js|css)?${ expires 1h;} 如果不想让代理或浏览器缓存，加 no-cache 参数：add_header Cache-Control no-cache; ，这样浏览器 F5 刷新时，返回的就是 http 200，而不是 http 304 include 指令使用 include 指令简化 Nginx 配置。假如有多个虚拟主机，配在同一个配置文件中就会显得杂乱无章，因此可以将不同的虚拟主机的配置，放入到不同的配置文件中，通过 include 引入，达到简化配置、便于管理的目的。当然一些其他的配置项均可以使用 include 来引入。 ip 限制封 IP 段比如从 192.0.0.1 到 192.0.0.254 的命令是：deny 192.0.0.0/24 这其实就是把 192.0.0.x 这整个 C 端屏蔽了。还有一种方法，在 Nginx 的 conf 目录下面新建配置文件为 blocksip.conf：输入要屏蔽的地址 deny 24.112.16.30; 保存一下。在 Nginx 的配置文件 nginx.conf 中加入：include blocksip.conf; 重启一下 Nginx 的服务：service nginx reload 就可以生效了。blocksip.conf:的格式还有许多种，可以配置只允许的 IP 访问或者 IP 段访问： 1234# block all ipsdeny all;# allow all ipsallow all; 如果你想实现这样的应用，除了几个 IP 外，其他全部拒绝，在 ip.balcklist 中这样写 123allow 1.1.1.1;allow 1.1.1.2;deny all; ip 限制除了应用于整个 Nginx 的访问，还可以单独给某个或者某几个应用去设置。 https1234567891011121314151617server { listen 443 ssl; #监听的端口 server_name 127.0.0.1; #域名、或者ip ssl_certificate cert/2974467.pem; #证书路径 ssl_certificate_key cert/2974467.key; #key路径 ssl_session_cache shared:SSL:1m; #储存SSL会话的缓存类型和大小 ssl_session_timeout 5m; #会话过期时间 ssl_ciphers HIGH:!aNULL:!MD5; #为建立安全连接，服务器所允许的密码格式表 ssl_prefer_server_ciphers on; #依赖SSLv3和TLSv1协议的服务器密码将优先于客户端密码 location / { proxy_pass http://127.0.0.1; } } 安全配置1、 隐藏 Nginx 版本号在 http 或者 server 下添加这个指令 server_tokens off; 隐藏 Nginx 版本号。经常会有针对某个版本的 Nginx 安全漏洞出现，隐藏 Nginx 版本号就成了主要的安全优化手段之一，当然最重要的是及时升级修复漏洞。2、 开启 https参照上边部分3、 开启黑、白名单配置通过上边限制 ip 和允许指定 ip 的手段。4、 账号认证这个就需要借助 Nginx 的 ngx_http_auth_basic_module 模块5、消除目录浏览漏洞Nginx 默认不允许目录浏览，请检查目录浏览的相关配置，确保没有目录浏览漏洞：检查各个配置文件，确保 autoindex 的配置为 off。","link":"/2020/11/19/nginx%E5%85%A5%E9%97%A8/"},{"title":"CSS变量的基本用法","text":"目的 了解 css 变量是什么 了解变量用法以及兼容性如何处理 了解如何实现网页的换肤 一、 css 变量是什么？兼容？用途？1、 css？CSS 是一种定义样式结构如字体、颜色、位置等的语言，被用于描述网页上的信息显示的方式。CSS 样式可以直接存储于 HTML 网页或者单独的样式单文件。 2、 css 变量？变量就是拥有合法标识符和合法的值,可以被使用在任意的地方。CSS 变量也被称为 CSS 自定义属性。其中包含要在整个文档中重复使用的特定值，使用自定义属性来设置变量名，通过 var()函数使用变量。 3、 兼容 4、 用途主要用在有换肤功能的项目中。可减少样式代码的重复性。 二、 变量的声明1、声明变量的时候，变量名前面要加两根横线（–）1234:root { --color: #ff0; --background: #f00;} 上面代码中，：root 选择器里面声明了两个变量：–color 和–background。它们与 css 中正式属性没有什么不同，只是没有默认含义。所以 CSS 变量又叫做”CSS 自定义属性”。因为变量与自定义的 CSS 属性其实是一回事。注意：变量名大小写敏感，–color 和–Color 是两个不同变量。CSS 变量并不支持 !important。 2、为什么用两根横线（–）？因为$被 Sass 用掉了，@被 Less 用掉了。为了不产生冲突，官方的 CSS 变量就改用两根横线了。 1234567891011// sass$myColor: red;h1 { color: $myColor;}// less@myColor: #5B83AD;h1 { color: @myColor;} 3、:root 是什么？:root 选择器匹配文档根元素。在 HTML 中，根元素始终是 html 元素。也就是说：root 表示的是根元素 三、 var()函数语法：var( &lt;自定义属性名&gt; [, &lt;默认值 ]? ) 1、var()函数用于读取变量1234.box { background: var(--background); color: var(--color);} 2、var()函数还可以使用第二个参数，表示变量的默认值。如果该变量不存在就会使用这个默认值1color: var(--color, #00f); 3、var()函数还可以用在变量的声明中1234:root { --color: #f00; --color-word: var(--color);} 4、注意，变量值只能用作属性值，不能用作属性名12345.foo { --top: margin-top; /* 无效 */ var(--top): 20px;} 四、 变量的类型各种值都可以放入 CSS 变量。 123456789101112131415:root{ --color: #ff0; --background: rgb(255, 0, 0); --background: linear-gradient(blue, pink); --background: url(cyy.png); --border-color: blue; --padding: 50px 0; --width: calc(100% - 10px); --height: 200px; --margin-top: 100; --content: &quot;伪元素在这里哦！&quot;;} 1、 如果变量值是一个字符串，则可以与其他字符串拼接123456:root { --content: &quot;伪元素在这里哦！&quot;;}.box::after { content: var(--content)&quot;我在后面呢&quot;;} 2、 如果变量值带有单位，就不能写成字符串1234567891011/* 无效 */.box { --size: '20px'; font-size: var(--size);}/* 有效 */.box { --size: 20px; font-size: var(--size);} 3、 如果变量值是数值，则不能与数值单位直接连用。必须使用 calc()函数，将它们连接。也可以采用上面的方法，直接写 20px。（变量的空格尾随特性）1234567891011121314151617/* 无效 */.box { --top: 20; margin-top: var(--top)px; // 相等于20 px}/* 有效 */.box { --top: 20; margin-top: calc(var(--top) * 1px);}/* 有效 */.box { --size: 20px; font-size: var(--size);} 4、 当变量值不合法时，则采用缺省值。（变量不合法的缺省特性）12345body { --color: 20px; background-color: #369; background-color: var(--color, #cd0000);} 请问，此时的背景色是？A. transparent B. 20px C. #369 D. #cd0000 答案：A解释：对于 CSS 变量，只要语法是正确的，就算变量里面的值是个乱七八糟的东西，也是会作为正常的声明解析，如果发现变量值是不合法的，则使用背景色的缺省值，也就是默认值代替。于是，上面 CSS 等同于： 12345body { --color: 20px; background-color: #369; background-color: transparent;} 默认值示例 background 默认值是 transparent width 默认值是 auto position 默认值是 static opacity 默认值是 1 display 默认值是 inline 五、 变量的作用域同一个 CSS 变量，可以在多个选择器内声明。读取的时候，优先级最高的声明生效。这与 CSS 的”层叠”规则是一致的。 12345678910111213141516171819202122&lt;style&gt; :root { --color: blue; } div { --color: green; } .box { --color: red; } p, div { color: var(--color); font-size: 30px; font-weight: bold; text-align: center; }&lt;/style&gt;&lt;p&gt;蓝色&lt;/p&gt;&lt;div&gt;绿色&lt;/div&gt;&lt;div class=&quot;box&quot;&gt;红色&lt;/div&gt; 上面代码中，三个选择器都声明了–color 变量。不同元素读取这个变量的时候，会采用优先级最高的规则，因此三段文字的颜色是不一样的。 这就是说，变量的作用域就是它所在的选择器的有效范围。由于这个原因，全局的变量通常放在根元素:root 里面，确保任何选择器都可以读取它们。 123:root { --color: #06c;} 总结： 范围：在当前元素块作用域及其子元素块作用域下有效 优先级别：内联样式 &gt; ID 选择器 &gt; 类选择器 &gt; 标签选择器 等等 六、 js 操作变量1、 设置变量值 setProperty(name,val),第一个值代表变量名，第二个值代表变量值12// 设置变量document.body.style.setProperty(&quot;--color&quot;, &quot;#f00&quot;); 2、 获取变量值 getPropertyValue(name)12// 读取变量document.body.style.getPropertyValue(&quot;--color&quot;); 3、 计算样式 getComputedStyle()什么是计算样式？获取某个元素下用到的一组样式；可以将此方法简单的理解为 document.getXXXXX，都是需要先获取到元素再设置具体的样式在获取变量之前，如果没有在 js 中定义这个变量，是获取不到的，则需要用 getComputedStyle 获取 css 中计算的样式。 123456789// css:root { --color: blue;}// jsvar body = getComputedStyle(document.body);var variableColor = body.getPropertyValue('--color');console.log(variableColor); // blue 4、 删除变量 removeProperty()12// 删除变量document.body.style.removeProperty(&quot;--color&quot;); 七、 处理 IE 兼容问题1、 处理 ie 下不兼容的问题（推荐）使用 css-vars-ponyfill 解决 ie 不兼容的问题。 12345// 首先引入插件的js&lt;script src=&quot;https://cdn.jsdelivr.net/npm/css-vars-ponyfill@2&quot;&gt;&lt;/script&gt;;// 再调用插件的方法cssVars({}); 其他用法请参考官方网址：https://www.npmjs.com/package/css-vars-ponyfill","link":"/2020/12/05/CSS%E5%8F%98%E9%87%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"},{"title":"浅谈HTTPS","text":"1 OSI 模型开放式系统互联通信参考模型（英语：Open System Interconnection Reference Model，缩写为 OSI），简称为 OSI 模型（OSI model），一种概念模型，用来表述任意两台计算机数据交互的过程。 1.1 为什么需要会有 OSi 模型呢在网络建立的初始阶段，是由各个厂商自己建立两台主机的数据交换方式，从而导致异构（不同网络结构的）的主机不能互联。为了解决这个问题，由国际标准化组织提出创建了 OSI 模型。 1.2 为什么要使用分层网络模型 降低复杂性 标准化接口 简化模块化设计 确保技术的互操作性 加快发展速度 简化教学 1.3 OSI 七层模型OSI 将计算机网络体系结构( architecture ）划分为以下七层： 应用层提供为应用软件而设的接口，以设置与另一应用软件之间的通信。例如: HTTP，HTTPS，FTP，TELNET，SSH，SMTP，POP3 等。 表达层把数据转换为能与接收者的系统格式兼容并适合传输的格式 确保接收系统可以读出数据 格式化数据 构建数据 协商用于应用层的数据传输语法 提供加密 会话层建立、管理和终止在应用程序之间的会话（不同应用之间不能接收消息） 传输层 建立端到端（主机到主机）的连接 把传输表头（TH）加至数据以形成数据包。传输表头包含了所使用的协议等发送信息。例如:传输控制协议（TCP）等。 确保数据传输的可靠性 建立、维护和终止虚拟电路 通过错误检测和回复 信息流控制来保障可靠性 网络层决定数据的路径选择和转寄，将网络表头（NH）加至数据包，以形成分组。网络表头包含了网络数据。例如:互联网协议（IP）等。 路由数据包 选择传递数据的最佳路径 支持网逻辑寻址（IP）和路径选择 数据链路层负责网络寻址、错误侦测和改错。当表头和表尾被加至数据包时，会形成帧。数据链表头（DLH）是包含了物理地址和错误侦测及改错的方法。数据链表尾（DLT）是一串指示数据包末端的字符串。例如以太网、无线局域网（Wi-Fi）和通用分组无线服务（GPRS）等。分为两个子层：逻辑链路控制（logic link control，LLC）子层和介质访问控制（media access control，MAC）子层。 定义如何格式化数据以便进行传输以及如何控制对网络的访问。 物理层物理层（Physical Layer）在局部局域网上传送数据帧（data frame），它负责管理计算机通信设备和网络媒体之间的互通。为启动、维护以及关闭物理链路定义了电器规范、机械规范、过程规范和功能规范，包括了网线、针脚、电压、线缆规范、集线器、中继器、网卡、主机适配器等，不符合规范的将不能互联。 我们做的是软件相关的，所以只关注应用层、表示层、会话层就行，下面传输层、网络层、数据链路层是由专业的网络架构人员维护的，物理层一般是都已经定义好了的。 1.4 形象示例下面我以 QQ 甲向 QQ 乙发送一个笑脸表情为例来分析各层的处理： 应用层：输入一个笑脸 表达层：把笑脸命令通过加密等操作转换为机器能识别的语言（比如说二进制数据 101010） 会话层：维持 QQ 甲与 QQ 乙的会话连接 传输层：建立 QQ 甲与 QQ 乙的连接，QQ 使用的是UDP 协议,并把相关表头加到表达层的数据中 网络层：路由寻址，找到乙所在的位置（IP），并把这些信息加到传输层中 数据链路层：数据链路层是找到能唯一标识设备的MAC(用于在网络中唯一标示一个网卡)信息,并把数据加到网络层数据中 物理层：把所有数据转为二进制来传输 1.5 TCP/IP 协议栈TCP/IP（Transmission Control Protocol/Internet Protocol，传输控制协议/网际协议）是指能够在多个不同网络间实现信息传输的协议簇，也是 OSI 模型的一个实例。 2 HTTP 的四次挥手2.1 过程描述 几个报文的标识的解释: SYN: synchronization (同步) ACK: acknowledgement (确认:告知已收到) FIN: finish (结束) 首先，当前客户端和服务器的状态都为连接状态（ESTABLISHED），接下来我们详细讲解下上图的过程： 客户主机发起连接释放的请求，设置 FIN 为 1，当然，序号 seq 也会带上，这里假设为 u ；发送完毕后，客户端进入 FIN-WAIT-1 状态 服务端接收到 FIN 报文后，会返回一个 ACK 报文回去，此时设置 ACK 为 1 ，确认号为 u + 1 ；表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。发送完毕后，服务器端进入 CLOSE-WAIT 状态，客户端接收到这个确认包之后，进入 FIN-WAIT-2 状态，等待服务器端关闭连接。 服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为 1 ；发送完毕后，服务器端进入 LAST-ACK 状态，等待来自客户端的最后一个 ACK 。 客户端接收到服务端传来的 FIN 报文后，知道服务器已经准备好关闭了，发送一个确认包，并进入 TIME-WAIT 状态，等待可能出现的要求重传的 ACK 报文；服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。 2.2 形象示例儿子（客户端）和妈（服务端）的最后对话：儿子向妈：妈，我挂电话啦？妈向儿子：行。妈向儿子：挂吧。儿子向妈：挂啦，妈，拜拜！儿子稍微等一下，确定妈没有其他事了，就挂断了电话。 2.3 为什么挥手是四次不是三次（为什么握手是三次挥手是四次）因为只有在客户端和服务端都没有数据发送的时候才能断开连接，客户端发出 FIN 报文时只能保证客户端没有数据发了，服务端还有没有数据发给客户端是不知道的。所以服务端收到客户端的 FIN 报文后只能先回复客户端一个确认报文来告诉客户端服务端已经收到你的 FIN 报文了，但服务端还有一些数据没发完，等这些数据发完了服务端才能给客户端发 FIN 报文(所以不能一次性将确认报文和 FIN 报文发给客户端)。 2.4 为什么客户端发出第四次挥手的确认报文后不会立刻释放 TCP 连接这里同样是要考虑丢包的问题，如果第四次挥手的报文丢失，服务端没收到确认 ACK 报文就会重发第三次挥手的报文，这样报文一去一回最长时间就是 2MSL ，所以客户端需要等这么长时间来确认服务端确实已经收到了。 2.5 已经建立了连接如果客户端突然出现故障了怎么办TCP 有一个计时器机制，服务端每次接收到客户端的请求都会复位这个计时器，当一定时间没有收到客户端的信息服务端就会发送一个探测报文，如果依然没有响应之后每隔 75s 重新发送一次，如果连着 10 个探测报文没有响应服务器就认为客户端出现了故障，会主动关闭连接。 3 HTTPS 与 HTTP 的区别我们现在都只知道 https 已经是大势所趋，但对 https 和 http 之间的区别还不是特别清楚，下面是我总结的他们的对比： http vs https 明文传输，网站或相关服务与用户之间的数据交互无加密，极易被监听，破解甚至篡改 传输方式 在 HTTP 下加入了 SSL 层，是数据传输变成加密模式，从而保护了交换数据隐私和完整性，简单来说它就是安全版的 HTTP 无任何身份认证，用户无法通过 http 辨认出网站的真实身份 身份认证 经过证书颁发机构（CA, Certificate Authority）多重认证，包括域名管理权限认证，单位身份合法性确认等。EV 证书甚至可以直接在浏览器地址栏显示单位名称，提升用户体验 无任何使用成本，所有网站默认即 http 模式 实现成本 需要申请 SSL 证书来实现 https，价格几百元到上万元不等 80 端口 端口 443 端口 1.提示网站不安全 2.当您的网站上有类似注册登陆等表单时，用户一旦进行输入，浏览器便红色高亮显示“不安全” 浏览器兼容性 1.提示网站连接是安全的 2.当您申请的是“EVSSL 证书”时，浏览器地址栏会直接显示您的单位名称，可显著提升网站用户的信任度和单位形象 对 http 网站无任何优待 SEO 优化 百度谷歌等官方声明提高 https 网站的排名权重 极易被黑客或者恶意的同行进行流量劫持 网站劫持 隐私信息加密，防止流量劫持 访问速度根据网站服务器配置和客户端的浏览环境而定 访问速度 在同样配置的服务器以及客户端浏览环境下，可明显提高网页加载速度 当网站需要与第三方平台进行对接时，通常不接受 http 这种连接。例如微信小程序，苹果 ATS，抖音上做广告等等 数据对接 微信小程序，抖音，苹果等等越来越多的平台只接受 https 这种加密的安全链接 经常因为没有 https,而被各个浏览器或者其他平台显示风险警告，导致损害用户的信任度 网站形象 为网站的用户营造安全的浏览环境，是网站的基本责任，也是赢得用户信赖的一个重要因素 无任何风险保障，当网站数据传输被截取导致重大损失时，只有网站运营者自己承担 风险保障 拥有 10 万-175 万美元的商业保险，当网站数据传输被破解时，有巨额的保障额度 4 HTTPS 特性为了解决这些不足，HTTPS 多了以下特性： TLS/SSL 内容加密 数字证书(CA)验明身份: 防范中间人攻击 MD5、SHA-1 等散列值方法防止信息篡改 HTTPS 相对于 HTTP 性能上差点，因为多了 SSL/TLS 的几次握手和加密解密的运算处理，但是加密解密的运算处理已经可以通过特有的硬件来加速处理。 4.1 SSL/TLSSSL(Secure Sockets Layer 安全套接层),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS 与 SSL 在传输层对网络连接进行加密。 为了保护敏感数据在传送过程中的安全，全球许多知名企业采用 SSL 加密机制，也随着数据安全的重要性和趋势，越来越多的网站都开始接入 HTTPS。 SSL 协议提供的安全通道有以下三个特性： 机密性：SSL 协议使用密钥加密通信数据。 可靠性：服务器和客户都会被认证，客户的认证是可选的。 完整性：SSL 协议会对传送的数据进行完整性检查。 简单地讲，SSL/TLS 就是同时结合各种密码算法、数字签名算法及数字证书等技术的一套协议，目的就是为了保证通信的安全性。 采用 SSL/TLS 协议，通信双方建立连接之前需要进行握手，目的是协商出会话密钥，用于后续对通信数据的加解密操作 4.2 HTTPS 加密方式加密的目的是保证传输的内容只有对话双方能看懂 下面以中国的张大胖于米国的 Bill 进行通信为例 方式一、使用对称密钥 两人商量了一下，可以使用对称密钥进行加密。（对称密钥也就是加密和解密使用的是同一个密钥） 但是问题又来了，既然网络是不安全的，那么最开始的时候怎么将这个对称密钥发送出去呢？如果对称密钥在发送的时候就已经被拦截，那么发送的信息还是会被篡改和窥视啊~~ 所以这种对称密钥的弊端就是，可能被中间人拦截，这样中间人就可以获取到了密钥，就可以对传输的信息进行窥视和篡改。 方式二、使用非对称密钥 RSA（非对称加密算法）：双方必须协商一对密钥，一个私钥一个公钥。用私钥加密的数据，只有对应的公钥才能解密，用公钥加密的数据， 只有对应的私钥才能解密。 这样的话 Bill 将自己的公钥给张大胖，张大胖发送的信息使用 Bill 的公钥加密，这样，只有 Bill 使用自己的私钥才能获取 但是这样有个弊端： RSA 算法很慢= =，要慢很多 所以为了解决这个问题，我们使用非对称密钥+对称密钥结合的方式 方式三、非对称密钥+对称密钥 使用对称密钥的好处是速度比较快，使用非对称密钥的好处是可以使得传输的内容不能被破解，因为就算你拦截到了数据，但是没有 Bill 的私钥，也是不能破解内容的。就比如说你抢了一个保险柜，但是没有保险柜的钥匙也不能打开保险柜。所以我们要结合两者的优点。使用 RSA 的方法将加密算法的对称密钥发送过去，之后就可以使用这个密钥，利用对称密钥来通信了。就比如说我将钥匙放进了保险柜，然后将保险柜寄给对方。 中间人攻击 还有一个问题就是在使用非对称密钥的时候，首先需要将 Bill 的公钥给张大胖，那么在这个过程中，安全是没有保障的，中间人可以拦截到 Bill 的公钥，就可以对拦截到的公钥进行篡改。 这也就是相当于我有手机号，虽然是公开的，谁都可以给我打电话，但是刚开始你并不知道我的手机号，我需要将我的手机号发给你，在我发给你我的手机号的时候，被中间人拦截了，然后将我正确的手机号换成了错误的手机号，比如：110，然后，你收到的就是错误的手机号：110，但是你自己还不知道你收到的是错的手机号，这时候，你要是给我打电话，就尴尬了~~ 确认身份 —— 数字证书 所以以上的步骤都是可行的，只需要最后一点就可以了，要确定 Bill 给张大胖的公钥确实是 Bill 的公钥，而不是别人的。（刚刚电话号码的那个例子，也就是说，需要确定我给你发的电话号码是我的，没有被修改的） 那怎么确认 Bill 给张大胖的公钥确实是 Bill 的呢？ 这个时候就需要公证处的存在了。也就是说我需要先将我的电话号码到公证处去公证一下，然后我将电话号码传给你之后，你在将你收到的电话号码和公证处的比对下，就知道是不是我的了。 对应到计算机世界，那就是数字签名 数字签名也就是相当于公证处在公证书上盖章。 数字签名和原始信息合在一起称为数字证书，Bill 只需将数字证书发送给张大胖就可以了。 在拿到数字证书之后，就用同样的 Hash 算法， 再次生成消息摘要，然后用 CA 的公钥对数字签名解密， 得到 CA 创建的消息摘要， 两者一比，就知道有没有人篡改了！ 4.3 SSL 协议的握手过程4.3.1 形象示例在正式分析之前，先引入阮一峰老师的图解 SSL/TLS 协议帮大家快速理解下基础概念，这边 john 将对话内容翻译成中文: 握手阶段分成五步： 第一步，爱丽丝给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法。 第二步，鲍勃确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server random）。 第三步，爱丽丝确认数字证书有效，然后生成一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给鲍勃。 第四步，鲍勃使用自己的私钥，获取爱丽丝发来的随机数（即 Premaster secret）。 第五步，爱丽丝和鲍勃根据约定的加密方法，使用前面的三个随机数，生成”对话密钥”（session key），用来加密接下来的整个对话过程。 4.3.2 综合分析 客户端先生成一个随机数，然后传输到服务端，并且会带上客户端这边支持的所有加密套件 服务端拿到这个随机数之后先存起来，服务端也生成一个随机数，这个随机数会伴随着服务端的证书，也就是我们之前说到的公钥，一起传输给客户端 客户端拿到了服务端的随机数之后也先存着，通过服务端传给他的公钥生成一个预主秘钥，生成过程当中会产生一个新的随机数，所以总共是有三个随机数，客户端生成的这个随机数用公钥加密后传输给服务器这边，这个过程就是没有办法被中间人解析的一个过程，因为它使用的是公钥进行加密，只有服务端这边的私钥可以对其解密 这个数据传输到服务器之后，服务器通过私钥解密，拿到了预主秘钥也就是我们说的那个随机字符串 最终服务端会选择一个客户端这边支持的加密套件，然后两边确定同时使用这同一个加密套件，对这三个随机数进行一个算法的操作，生成一个主秘钥，因为最后一个随机数只有客户端和服务端知道，中间人根本拿不到，所以他们生成的这个主秘钥也是中间人根本没有办法破解的，后期传输的数据就全部是通过这个主秘钥进行加密的，因为两边主秘钥是一样的，所以两边都能够对数据加密之后进行解密，中间人因为没有办法知道这个主秘钥，所以他没有办法对数据进行解密，所以这中间的数据传输就变成了安全的传输 6 域名申请域名申请以 西部数码 平台为例，其他平台操作基本相同。 注册后，在首页搜索你想要申请的域名，他会查出该域名及相关域名的注册情况和对应的首年的花费。 根据需求和要求填写相关资料 购买 实名认证 域名解析 域名解析是为了把域名和自己的服务器在整个网络中声明和绑定。 点击操作 -&gt; 解析，这里以有服务器（腾讯云）为例。 根据下面的温馨提示，在对应值除输入服务器的公网 IP，输入后点击保存（如果需要实名认证，请自行输入完成）。这时域名还不能直接使用，需要等待域名实名通过才行。 等域名实名通过后和这里服务器 IP 填写没有问题时，点击上方的解析诊断，应该会弹出下面的提示。 下面提供自己电脑解析使用的方式： 打开文件：C:\\Windows\\System32\\drivers\\etc\\host 在文件最后新增： 181.70.27.70 suyp.top 注： 域名解析时先会找浏览器缓存和本地的 HOST 文件，找不到才会向网络中的分布式域名存储节点查询 域名解析就是把你的域名和 IP 对应关系放到分布式域名存储节点中 到此，在域名到期前，域名和我们的服务器就绑定在一起了 7 证书申请7.1 申请平台下面列举了一些常见的证书申请平台： let’s encryptlet’s encrypt 可以申请免费的 TLS 证书，每 3 个月需要手动续 腾讯云 阿里云 西部数码 FreeSSL 7.2 证书的类型 域名验证型( DV ) SSL 证书 组织验证型( OV ) SSL 证书 扩展验证型( EV ) SSL 证书 DV 适用于个人，OV 和 EV 需要身份审核，EV 最高端。 EV 证书会在浏览器的地址栏显示证书的企业名称： 7.3 证书申请流程下面以 FreeSSL 证书申请平台为例。 打开 FreeSSL 网站，在输入框中输入自己的域名 品牌选择：亚洲诚信 （品牌差异后面介绍），点击 创建免费的 SSL 证书 输入自己的邮箱地址，一会用于验证，其他参数（后面介绍）如下图 下载 KeyManager 软件，注册，进入主页面，他会自动生成 CSR ，浏览器中点击继续 两种验证方式 DNS 验证：系统会为用户生成一条 CNAME 记录，用户只需在自己的域名服务商处增加此条 CNAME 的解析记录，即可完成域名验证。 验证信息： 如果没有服务器，可以在 DNS 解析平台通过 DNS 验证，步骤如下： 在服务器提供商处通过 DNS 验证： 文件验证：系统会为用户生成一个随机字符串，用户需将此页面放在域名指向服务器中的指定位置，并确认可通过公网访问。 验证信息： ![验证信息](ssl12.png) ![文件验证规则](ssl20.png) ![服务器验证文件](ssl21.png) 注：以点开头为名称的文件夹创建方式： cmd： 使用命令创建文件夹 md .well-know 在你命名文件夹的名称前后都加上点 返回 FreeSSL 平台界面，点击 配置完成，检测一下 域名解析指向添加成功和修改成功，需等待各地 DNS 刷新后解析方可生效。 验证成功后，返回 FreeSSL 页面，点击验证 点击保存到 KeyManager 软件中 导出 crt、key、pem 文件 导出 crt、key 文件在 KeyManager 中选择生成的证书 -&gt; 更多 -&gt; 导出证书 导出 pem 文件在 FreeSSL 网站中选择 控制台 -&gt; 证书列表 -&gt; 要导出的证书 -&gt; 更多操作 -&gt; 证书下载 把三个文件的名称统一的 到此，域名 suyp.top 的证书就申请成功了。 7.4 证书文件以下为不同后缀的 ssl 证书文件的作用: .key 文件：属于密钥文件，SSL 证书的私人密钥就包括在内。是信息内容的中枢； .csr 文件：文件里包括证书的公用密钥和一些公司内部重要秘密信息，要使用者通过请求签名之后才能够直接生出证书； .crt 文件：此文件也包含了 ssl 证书的公用密钥、签字讯息以及根据不同的类型伴随不同认证的信息，通常各类签名签字证书都会在这类文件中，如 IP 等； .pem 文件：该文件较其他后缀文件来说比较少见，里面包含着证书的私人密钥以及其他一部分证书重要的信息。 7.5 证书品牌差异 Symantec Symantec （SSL 业务已被 DigiCert 收购） 是全球最大的信息安全厂商和服务商，最权威的数字证书颁发机构，为企业、个人用户和服务供应商提供广泛的内容和网络安全解决方案，全球 500 强中有 93% 选择了 VeriSign SSL 数字证书，赛门铁克于 2010 年 8 月收购 VeriSign，目前 VeriSign 认证服务现均由赛门铁克提供，并在 2012 年 4 月对 VeriSign 的产品名称和品牌标识进行变更。 GeoTrust GeoTrust 是全球第二大数字证书颁发机构( CA )，也是身份认证和信任认证领域的领导者，该公司各种先进的技术使得任何大小的机构和公司都能安全地低成本地部署 SSL 数字证书和实现各种身份认证。从 2001 年成立到 2006 年占领全球市场 25% 的市场分额， 于 2006 年 5 月 / 2006 年 9 月 VeriSign 以 1.25 亿美元收购 GeoTrust，目前也同为赛门铁克旗下 SSL 证书的性价比品牌。 单纯从技术角度，symantec（原 verisign）和 GeoTrust 的区别如下： 算法支持上 Symantec（支持 RSA DSA ECC 三种算法）优于 Geotrust（支持 RSA DSA 两种算法）；兼容性 Symantec 优于 Geotrust； Symantec 可兼容市面上所有的浏览器，对移动端的支持也是最好的OCSP 响应速度上 Symantec 优于 Geotrust；CA 安全性方面 Symantec 优于 Geotrust，Symantec 是国际知名安全厂商，CA 的安全级别也是国际第一的安全系数；Symantec 证书除实现加密传输以外，还另外有恶意软件扫描和漏洞评估的附加功能；Symantec 对证书有商业保险赔付保障，金额最高为 175 万美金，GeoTrust 最高为 150 万美金。 TrustAsia 亚洲诚信是亚数信息科技（上海）有限公司应用于信息安全领域的品牌，是 Symantec™（赛门铁克）的白金合作伙伴，专业为企业提供包含数字证书在内的所有网络安全服务。同时，TrustAsia 品牌 SSL 证书由 Symantec 根证书签发 品牌的差异 不同品牌的证书在浏览器地址栏、加密强度、赔付保障上均存在差异，最重要的差异点在于根证书，例如 Geotrust 通配符是 Geotrust 根证书签发的，而 Symantec 通配符是 DigiCert 根证书签发的，Symantec 根证书可以兼容市面上所有的浏览器，对移动端的支持也是最好的。而 Trustasia 通配符也是赛门铁克的根证书，但是为域名型证书，在证书里面不体现公司信息，所以价格比较优惠。 因此用户可以根据不同 web 应用选择不同认证等级(DV、OV、EV)和域名支持能力的证书，个人网站只能选择域名型 DV 证书，OV、EV 类型证书要求是企业才能申请。 7.6 证书类型- RSA 和 ECCECC: （安全性高，效率高，密钥短）RSA: （最普通，算法复杂，密钥长） 7.7 ECC SSL 证书兼容性Web 服务器：Apache HTTP Server 2.2.26+，Apache Tomcat 1.1.30+，Dovecot 2.2.5+，IBM HTTP Server 8.0+，NGINX 1.1.0+，Windows Server 2008+ 浏览器：Firefox 2+，Apple Safari 4+ (with a compatible OS)，Google Chrome 1.0+ (with a compatible OS)，Microsoft Internet Explorer 7+ (Vista) 如果你的环境低于这些版本，说明不支持使用 ECC 算法的 SSL 证书。 ECC 算法 和 RSA 算法RSA 算法是 1976 年提出来的，为了保障数据的安全，RSA 的密钥需要不断增加，导致加解密的速度大为降低。 ECC 算法是 1985 年提出来的。和 RSA 相比，在许多方面都有对绝对的优势，抗攻击性强，CPU 占用少，内容使用少，网络消耗低，加密速度快。 7.8 如何选择在申请域名 SSL 证书的时候，该如何选择加密算法 RSA：考虑到更广的适用性，兼容所有平台。 ECC：更加安全高效，部分平台不支持。 来此加密：申请免费证书时，选择合适的加密类型。 8 nginx 和 tomcat 配置 nginx 把三个文件拷到 nginx/conf/ 下 修改文件 nginx.conf，主要是 HTTPS server 下面的配置， 示例如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#user nobody;worker_processes 1;events { worker_connections 1024;}http { include mime.types; default_type application/octet-stream; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server { listen 8081; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / { root html; index index.html index.htm; } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } # HTTPS server 配置 server { listen 443 ssl; # 端口 server_name suyp.top; # 域名 ssl_certificate suyptop.pem; # SSL文件 ssl_certificate_key suyptop.key; # SSL文件 ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; location / { root html; index index.html index.htm; } }} 效果： tomcat 版本：apache-tomcat-9.0.39 ssl 文件准备在 KeyManager 中选择域名 ssl ，导出证书（Tomcat（jks）），设置私钥加密密码，最终会导出一个 .jks 文件 tomcat 配置 把 .jks 文件拷到 tomcat/conf 下 打开文件 tomcat/conf/server.xml 找到代码 123456789&lt;!--&lt;Connector port=&quot;8443&quot; protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot; maxThreads=&quot;150&quot; SSLEnabled=&quot;true&quot;&gt; &lt;SSLHostConfig&gt; &lt;Certificate certificateKeystoreFile=&quot;conf/localhost-rsa.jks&quot; type=&quot;RSA&quot; /&gt; &lt;/SSLHostConfig&gt;&lt;/Connector&gt;--&gt; 替换为 12345678910&lt;Connector port=&quot;443&quot; protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot; maxThreads=&quot;150&quot; SSLEnabled=&quot;true&quot;&gt; &lt;SSLHostConfig&gt; &lt;!--certificateKeystoreFile放 .jks 的路径--&gt; &lt;!--certificateKeystorePassword 放刚设置的私钥的加密密码--&gt; &lt;Certificate certificateKeystoreFile=&quot;conf/suyptop.jks&quot; certificateKeystorePassword=&quot;TuytPY3y&quot; type=&quot;RSA&quot; /&gt; &lt;/SSLHostConfig&gt;&lt;/Connector&gt; 效果： 参考资料阿里面试： HTTP、HTTPS、TCP/IP、三次握手四次挥手过程？（附全网最具深度讲解） HTTP 相关网络知识点汇总 再谈 HTTPS HTTPS 详解 谈谈 HTTPS OSI 七层模型 浅谈 SSL 协议的握手过程","link":"/2020/11/12/%E6%B5%85%E8%B0%88HTTPS/"},{"title":"用可视化的方式解释事件循环和Promise","text":"本文是在原文翻译的基础上进行了部分删减和补充内容。若有问题请多多指正！原文链接： 1.https://dev.to/lydiahallie/javascript-visualized-event-loop-3dif 2.https://dev.to/lydiahallie/javascript-visualized-promises-async-await-5gke 用可视化的方式解释事件循环什么是事件循环？首先让我们来了解下 JavaScript 的单线程特性：一次只能运行一个任务。单线程的程序执行到了需要异步的操作，就会需要等待。这时程序就会停下，后面的代码就不会执行，就会阻塞程序 😬 幸运的是，浏览器为我们提供了 JavaScript 引擎自身都没有的特性—— Web API 。它包含 DOM API 、setTimeout 、HTTP 请求等等，可以帮助我们创建一些异步的、非阻塞的行为。 当我们调用一个函数，它会被添加到执行栈中。执行栈是 JavaScript 引擎的一部分，并不是浏览器的特性。它是一个先进后出的栈。当一个函数返回了一个值，就是出栈。👋1）当函数被调用的时候，函数会被压入执行栈中；当函数返回一个值的时候，会被移出执行栈。 图中的 respond 函数返回了一个 Web API 提供给我们的 setTimeout 函数。它允许我们在不打破主线程的情况下延迟执行任务。我们传递给 setTimeout 函数的回调函数 ()=&gt; {return ‘Hey’} 被添加到了 Web API 中。setTimeout 函数和 respond 函数被挨个儿移出堆栈。 2）Web API 监听着我们传递的回调。 在 Web API 中，计时器的运行时间为 1000ms。在等待了 1000ms 之后，这个回调函数并没有被立即添加到执行栈中，而是被送到了队列中。 3）当定时计时结束时，这个回调函数被送到了任务队列中。 注意了！这意味着回调函数不是在 1000ms 后被添加到执行栈中。它只是在 1000ms 后被添加到了任务队列中。函数得排着队，等到轮到它的时候才能被执行。 现在事件循环完成任务的时刻到来了——如果执行栈为空，当之前所有调用的函数都返回了值并被移出执行栈的时候，任务队列中的第一个元素就被加到执行栈中了。在此例中，没有其他函数被调用，这意味着当回调函数成为队列中的第一项时，执行栈为空。 4）事件循环机制监听着任务队列和执行栈。若执行栈为空，则将任务队列中的第一个元素移入到执行栈中。 事件循环的大致就是这么个流程。尝试着去计算以下例子中控制台的打印结果吧： 1234567const foo = () =&gt; console.log(&quot;First&quot;);const bar = () =&gt; setTimeout(() =&gt; console.log(&quot;Second&quot;), 500);const baz = () =&gt; console.log(&quot;Third&quot;);bar();foo();baz(); 让我们在浏览器上运行这段代码看看会发生什么吧： 1.我们调用了 bar 函数，bar 返回了一个 setTimeout 函数。 2.我们传递给 setTimeout 的回调被添加到 Web API 中，setTimeout 函数和 bar 被从执行栈中弹出。 3.定时器开始计时，同时执行栈中 foo 函数被调用并打印了 First ，foo 返回了值（ undefined ），baz 函数被调用，bar 的回调函数被添加到任务队列中。 4.baz 打印了 Third ，并返回值 undefined 。事件循环机制此时发现当前执行栈为空，然后将回调函数移入执行栈中。 5.回调函数打印了 Second 。 用可视化的方式解释 promise 和 async-await当我们在写 JavaScript 脚本时，我们会遇到这么一种情况：处理依赖其他任务的任务！假设我们想要获得一幅图像，压缩它，应用过滤器并保存它 📸我们要做的第一件事情，是获得我们想要去编辑的那张图片。一个getImage函数可以做到。只有当该图像成功加载后，我们才能将该值传递给resizeImage函数。当图像大小成功调整后，我们希望在applyFilter函数中对图像应用一个过滤器。在图像被压缩并且已经添加了一个过滤器之后，我们想要保存图像并让用户知道一切工作正常！🥳 最后，我们会得到这样的结果： em……虽然这么写没毛病，但我们会得到许多嵌套的回调函数，它们依赖于前面的回调函数。这通常被称为回调地狱——我们使用了 n 多个嵌套的回调函数。这使得代码变得难以阅读了！ 幸运的是，我们可以通过Promise来解决这个问题！让我们来看看Promise是什么，以及在这种情况下它们是如何帮助我们的！😃 Promise 语法ES6 引进了Promise。在使用 svn 时，你会看到这样的话： “ promise 是一个值的占位符，它将在未来的某个时刻 resolve 或者 reject 。” 这个解释对于我们来说没那么清晰，那么让我们来看看 Promise 到底是个啥吧！ 我们使用接收一个回调函数的Promise构造函数来创建一个 promise 。 哇哦，看看这返回了啥？ Promise是一个包含状态（[[PromiseStatus]]）和一个值（[[PromiseValue]]）的对象。在上例中，你能看到[[PromiseStatus]]的值是一个&quot;pending&quot;，而值是undefined。 不要担心，你永远都不需要关心该对象，甚至不能访问[[PromiseStatus]]和[[PromiseValue]]属性。不管怎样，这两个是使用 promise 时十分重要的属性。 PromiseStatus的值可能是以下三种值： ✅ fullfilled：promise 已经被解析。一切正常，promise 内部没有发生任何错误 🥳 ❌rejected：promise 已经被拒绝。呃，也就是遇到了些问题。 ⏳pending：promise 没有解析也没有拒绝，promise 处于一个等待状态。那么 promise 啥时候是fullfilled、rejected或pending呢？为什么这些状态很重要呢？在上例中，我们只要将简单的回调函数() =&gt; {}传递给Promise的构造函数。然而这个回调函数实际上收到了两个参数：第一个参数通常叫做resolve或res（即下文提到的解析），它是Promise应该解析的时候调用的函数。第二个参数的值通常叫做reject或rej（即下文提到的拒绝），它是Promise应该拒绝的时候（有哪些地方出错时）调用的函数。 让我们来看看当我们调用resolve或reject函数会打印出什么吧~在我的例子中，我调用了解析函数res和拒绝函数rej: 从上图看来，如果我们调用resolve函数，promise 的状态就是fulfilled。如果我们调用rejected函数，promise 的状态就是rejected。promise 的值，即[[PromiseValue]]的值，是resolved或rejected函数的传参。有趣的是，我让 Jake Archibald 校对了这篇文章，他指出 Chrome 浏览器有个 bug ，当前显示的状态是resolved而不是fullfilled。🥳🕺 译者插一嘴：这篇文章也许历史有些久远了，截至 2020.9.19 在谷歌的控制台打印结果为proto: Promise[[PromiseState]]: “fulfilled”[[PromiseResult]]: 123 现在我们知道如何更好地控制这个Promise对象了。但它是用来干什么的呢？在介绍部分中，我展示了一个例子，在该例子中，我们获得一个图像，对其进行压缩，应用一个文件处理程序并保存它！最终，形成了一个嵌套的回调乱象。幸运的是，Promise 能帮助我们解决这个问题。首先，让我们重写整个代码块，以便每个函数返回一个Promise。如果图像已经加载，并且一切正常，那么让我们用已加载的图像来解析promise!否则，如果在加载文件时某处出现错误，我们将拒绝包含所发生错误的promise。 让我们来看看运行它之后，终端返回了什么吧： 太酷了！正如我们所期望的那样，promise获得了已解析数据的值。我们不关心整个 promise 对象，我们只需要关心 data 的值。有一些内置的方法可以获取 promise 的值，对于一个 promise ，我们可以附上三种方法： .then()：在 promise 解析后调用。 .catch()：在 promise 拒绝后调用。 .finally()：无论 promise 是解析了还是拒绝了，通常情况下都会调用。 Promise.race()：传入一个元素为 Promise 实例的数组，谁先解析了谁先调用.then 里的回调函数。 Promise.all()：传入一个元素为 Promise 实例的数组，数组内的 Promise 实例全部先解析才调用.then 里的回调函数。 .then方法通过resolve方法收到数值。 .catch方法通过rejected方法收到数值。 Promise.race()的使用方法： 123456789101112131415161718192021const promise1 = new Promise((resolve, rejected) =&gt; { setTimeout(() =&gt; { console.log(&quot;promise1&quot;); resolve(&quot;a&quot;); }, 1000);});const promise2 = new Promise((resolve, rejected) =&gt; { setTimeout(() =&gt; { console.log(&quot;promise2&quot;); resolve(); }, 1500);});const promise3 = new Promise((resolve, rejected) =&gt; { setTimeout(() =&gt; { console.log(&quot;promise3&quot;); resolve(); }, 2000);});Promise.race([promise1, promise2, promise3]).then(() =&gt; { console.log(0);}); 打印结果： promise1 0 promise2 promise3 Promise.all()的使用方法： 1234// ...Promise.all([promise1, promise2, promise3]).then(() =&gt; { console.log(1);}); 打印结果： promise1 promise2 promise3 0 当我们知道一个 promise 通常会 resolve 或 reject ，你可以写成Promise.resolve或Promise.reject： 你将在以下示例中看到这种写法 😄在getImage的例子中，我们最终不得不嵌套多个回调才能运行它们。幸运的是，then可以帮助我们改变这个局面！🥳then的结果本身就是 promise 的值。这意味着我们可以根据需要链接任意多的.then：上一个 then 回调的结果将作为参数传递给下一个 then 回调！ 真棒！这个语法已经比嵌套的回调看起来好多了。 宏任务和微任务好了，我们知道了如何创建 promise 以及如何从 promise 中提取值。让我们添加更多的代码到脚本，并再次运行： 等等，发生了什么？！🤯 先是Start!被打印出来了。我们可以看到console.log('Start!')在第一行。第二个被打印的值却是End!，而不是 promise 解析后的值！只有在End!打印出来后，promise 的值才被打印出来。这其中发生了什么呢？我们终于看到了 promise 的真正力量！🚀 虽然 JavaScript 是单线程的，我们能通过Promise添加异步的行为！实际上在事件循环机制中有两种队列：宏队列（或称作任务队列）和微队列。宏任务队列用于宏任务，微任务队列用于微任务。那么什么是宏任务什么是微任务呢？最常见有以下几种： 啊，我们在微任务列表中看到了Promise！😃 当一个Promise 解析后调用它的then(),catch()或finally()方法，该方法中的回调将被添加到微任务队列中！这意味着then()、catch()或finally()方法中的回调不会立即执行，这实际上是在 JavaScript 代码中添加了一些异步行为！ 那么什么时候执行then()、catch()或finally()的回调呢？事件循环给了任务不同的优先级: 当前在调用堆栈中的所有函数将被执行。当它们返回一个值时，就会从堆栈中弹出。 当调用堆栈为空时，所有排队的微任务将一个接一个地弹出到调用堆栈并执行！(微任务自身也可以返回新的微任务，有效地创造一个无限微任务循环 😬) 如果调用堆栈和微任务队列都为空，则事件循环检查宏任务队列上是否还有任务。任务被弹出到调用堆栈上，执行，然后弹出!让我们看一个简单的例子: Task1：立即被添加到调用堆栈的函数，例如在我们的代码中立即调用它。 Task2, Task3, Task4：微任务，比如说一个 promise 的then中的回调函数，或一个被添加到微任务队列中的任务。 Task5, Task6：一个宏任务，例如setTimeout、setImmediate的回调 首先，Task1 返回一个值并从调用堆栈中弹出。然后，引擎检查微任务队列中排队的任务。一旦所有任务都被放到调用堆栈中并弹出，引擎就会检查宏任务队列上的任务，这些任务会弹出到调用堆栈中，并在它们返回了值时弹出。 在这段代码中，我们有宏任务setTimeout和微任务 promise 的 then()回调。一旦引擎到达setTimeout函数那行，让我们一步一步地运行这段代码，看看记录了什么! 在下面的示例中，我将展示被添加到调用堆栈的方法，例如console.log，setTimeout和Promise等。它们是内部方法，实际上不会出现在堆栈跟踪中——所以如果你正在使用调试器而在任何地方都看不到它们，请不要担心！它只是方便在没有添加很多示例代码的情况下更容易地解释这个概念 🙂在第一行中，引擎遇到了console.log()。它被添加到调用堆栈中，然后打印值’Start!’。方法从调用堆栈中弹出，引擎继续运行。 这时引擎遇到了被调用堆栈中弹出的setTimeout方法。setTimeout方法是浏览器的原生方法：它的回调函数(() =&gt; console.log('In timeout'))将被添加到 Web API 中，直到计时器计时完成。尽管我们为定时器提供了为 0 的值，回调仍然首先被推到 Web API ，之后它被添加到宏任务队列：setTimeout是一个宏任务！ 接着引擎遇到了Promise.resolve()方法。Promise.resolve()方法被添加到调用堆栈中，之后解析为值’Promise!’。然后它的回调函数then被添加到微任务队列中。 注意：.then 或者 .catch 的参数期望是函数，传入非函数则会发生值穿透。 1Promise.resolve(1).then(2).then(Promise.resolve(3)).then(console.log); // 1 引擎接着又遇到了console.log()方法。它会立即被添加到调用堆栈中，然后打印’End!’到控制台，弹出调用堆栈，引擎继续运行。 现在引擎看到调用堆栈是空的。由于调用堆栈为空，它将检查微任务队列中是否有排队的任务！是的，有，promise then回调正在排队中！它被弹出到调用堆栈上，然后打印 promise 的解析值：’Promise !’。 引擎看到调用堆栈是空的，因此它将再次检查微任务队列，以查看任务是否已进入该队列。哦不，微任务队列都是空的。是时候检查宏任务队列了：setTimeout回调仍然在那里等待！setTimeout的回调被弹出到调用堆栈。回调函数返回console.log方法，该方法打印了’In timeout!’，接着setTimeout回调被弹出到调用堆栈。 结束了！🥳 好像我们之前看到的输出也没那么意外嘛。 Async/AwaitES7 引入了一种在 JavaScript 中添加异步行为的新方法，能更容易地使用 promise ！通过引入 async 和 await 关键字，我们可以创建隐式返回 promise 的异步函数。我们怎么做呢？在前文中，我们看到可以使用Promise对象显式地创建Promise，无论是通过键入new Promise(() =&gt;{})，还是Promise.resolve，或者Promise.reject。我们现在可以创建隐式返回对象的异步函数，而不是显式地使用Promise对象！这意味着我们不再需要自己编写任何Promise对象了。 虽然异步函数隐式返回 promise 这一事实非常棒，但异步函数的真正强大之处可以在使用await关键字时体现出来！通过await关键字，我们可以在await等待的值返回已解析的 promise 时暂停异步函数。如果我们想要得到这个已解析的 promise 的值，就像我们之前对then()回调所做的那样，我们可以为等待的 promise 值分配变量！让我们看看当我们运行下面的代码块时会发生什么吧： 这其中发生了什么呢？ 首先，引擎遇到一个console.log。它被弹出到调用堆栈，之后打印了Before function!。 然后，调用异步函数myFunc()，之后运行myFunc的函数体。在函数体的第一行中，我们调用了另一个console.log，随后打印了In function！将console.log添加到调用堆栈，打印了值后弹出。 函数体继续被执行，这就到了第二行。最后，我们看到一个await关键字！🎉首先，等待的值被执行：在此例中是函数one。它被弹出到调用堆栈内，并最终返回一个已解析的 promise 。 promise 被解析并且one函数返回了值之后，引擎这时遇到了await关键字。当遇到await关键字时，async函数将被挂起。✋🏼 函数体就暂停执行了，剩下的异步函数被运行在微任务栈中！ 现在异步函数myFunc在遇到await关键字时被挂起，引擎跳出了异步函数并在该函数被调用的执行上下文中继续执行代码：在本例中是全局的执行上下文中!🏃🏽‍♀️ 最后在全局执行上下文中，没有需要运行的任何任务了！接着事件循环检查是否有微任务还在排队：确实有！在解析了one.myFunc的值并弹回调用栈之后，异步myFunc函数还在排队。myFunc 被弹出到调用堆栈上，并在先前停止的地方继续运行。变量res最终获得它的值，即one函数返回的已解析 promise 的值！我们用console.log打印出res的值：’One!’。’One!’被打印到到控制台中并弹出调用堆栈！😊 这就完事了！你注意到async函数与 promise 的then的不同之处了吗？await关键字将挂起async函数，而当我们使用 then 时，Promise体将继续执行！ 一些额外的细节1）async promise 谁先执行？ 1234async function async1() { await async2(); console.log(&quot; async1 end &quot;);} 在 Chrome 73 之前，遇到 await 会被解析成这样： 123456789async function async1() { return new Promise((resolve) =&gt; { Promise.resolve().then(() =&gt; { async2().then(resolve); }); }).then(() =&gt; { console.log(&quot;async1 end &quot;); });} 在 Chrome 73 之后，遇到 await 会被解析成这样： 12345async function async1() { async2().then(() =&gt; { console.log(&quot;async1 end &quot;); });} 所以浏览器的版本可能会影响 promise 和 async-await 的执行结果！ 2）遇到不确定什么时候能 return 的情况下，该任务会在 Web API 中被挂起，先往下执行任务，直到有返回值了才将 then 中的回调函数放入微任务队列中。 123456axios.get(&quot;http://192.168.0.183:8200/fe/menu&quot;).then(() =&gt; { console.log(9);});setTimeout(() =&gt; { console.log(0);}, 0);","link":"/2020/12/13/%E7%94%A8%E5%8F%AF%E8%A7%86%E5%8C%96%E7%9A%84%E6%96%B9%E5%BC%8F%E8%A7%A3%E9%87%8A%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%92%8CPromise/"},{"title":"web性能优化宝典","text":"Why Is Website Performance Important?Research shows that the amount of time a user will wait before losing focus is roughly from 0. to 3 seconds. If your website takes longer than that to display important information to the user, the user will lose focus and possibly close the browser window. 1 静态资源通过优化和压缩网页资源来最大限度地减少总下载大小，是提高网页加载速度最有效的措施。 1.1 缩减文件大小1.1.1 JavaScript借助工具 webpack 以及 terser-webpack-plugin 插件来实现对 JS 文件的压缩和混淆，删除 JavaScript 代码中所有注释、换行符号及无用的空格，从而压缩 JS 文件大小，优化页面加载速度。 配置示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243const TerserPlugin = require(&quot;terser-webpack-plugin&quot;);module.exports = { optimization: { minimize: true, minimizer: [ new TerserPlugin({ test: /\\.js(\\?.*)?$/i, extractComments: true, parallel: 4, // 启用多进程来运行并且设置了并发运行的次数为4 terserOptions: { ecma: undefined, parse: {}, compress: { // 移除日志 drop_console: true, // 在UglifyJs删除没有用到的代码时不输出警告 warnings: false, // 内嵌定义了但是只用到一次的变量 collapse_vars: true, // 提取出出现多次但是没有定义成变量去引用的静态值 reduce_vars: true, }, // 压缩配置 mangle: true, // Note `mangle.properties` is `false` by default. module: false, // Deprecated output: { // 最紧凑的输出 beautify: false, // 删除所有的注释 comments: false, }, format: null, toplevel: true, nameCache: null, ie8: false, // 是否支持 IE8 keep_classnames: undefined, keep_fnames: false, safari10: true, }, }), ], },}; 1.1.2 CSS使用 mini-css-extract-plugin 该插件将 CSS 提取到单独的文件中。它为每个包含 CSS 的 JS 文件创建一个 CSS 文件。使用 optimize-css-assets-webpack-plugin 插件进行 CSS 文件压缩。 配置示例: 123456789101112131415161718192021222324252627282930313233var OptimizeCssAssetsPlugin = require(&quot;optimize-css-assets-webpack-plugin&quot;);const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);module.exports = { module: { rules: [ { test: /\\.css$/, loader: MiniCssExtractPlugin.extract(&quot;style-loader&quot;, &quot;css-loader&quot;), loader: MiniCssExtractPlugin.loader, }, { test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, loader: &quot;url-loader&quot;, options: { limit: 10, // 小于10KB图片，转base64编码 }, }, ], }, plugins: [ new ExtractTextPlugin(&quot;styles.css&quot;), //new OptimizeCssAssetsPlugin() new OptimizeCSSAssetsPlugin({ assetNameRegExp: /\\.css$/g, cssProcessor: require(&quot;cssnano&quot;), cssProcessorPluginOptions: { preset: [&quot;default&quot;, { discardComments: { removeAll: true } }], }, canPrint: true, }), ],}; 1.1.3 HTML使用 html-webpack-plugin 插件的 minify 配置项来完成对 HTML 文件的压缩。 配置示例： 1234567891011121314{ plugins: [ new HtmlWebpackPlugin({ // 把生成的 index.html 文件的内容的没用空格去掉，减少空间 minify: { collapseWhitespace: true, removeComments: true, removeRedundantAttributes: true, minifyCSS: true, }, template: &quot;src/index.html&quot;, }), ];} 1.2 图片优化1.2.1 延迟加载（懒加载）页面初始加载时，先不给图片设置路径，只有当图片出现在浏览器可视区域时，才去加载真正的图片，这就是延迟加载。实现思路： 默认给图片设置一个自定义属性（data-src）； 页面加载完成后，根据 scrollTop 判断图片是否在用户的视野内，如果在，则将 data-src 属性中的值取出存放到 src 属性中； 在滚动事件中重复判断图片是否进入浏览器可视区域（注意使用节流函数）;如果进入，则将 data-src 属性中的值取出存放到 src 属性中。 具体代码： 1234567891011121314151617181920212223242526&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Lazyload&lt;/title&gt; &lt;style&gt; img { display: block; margin-bottom: 50px; height: 200px; width: 400px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;img class=&quot;lazy&quot; data-src=&quot;./img/default.png&quot; data-src=&quot;./img/1.jpg&quot; /&gt; &lt;img class=&quot;lazy&quot; data-src=&quot;./img/default.png&quot; data-src=&quot;./img/2.jpg&quot; /&gt; &lt;img src=&quot;./img/default.png&quot; data-src=&quot;./img/3.jpg&quot; /&gt; &lt;img src=&quot;./img/default.png&quot; data-src=&quot;./img/4.jpg&quot; /&gt; &lt;img src=&quot;./img/default.png&quot; data-src=&quot;./img/5.jpg&quot; /&gt; &lt;img src=&quot;./img/default.png&quot; data-src=&quot;./img/6.jpg&quot; /&gt; &lt;img src=&quot;./img/default.png&quot; data-src=&quot;./img/7.jpg&quot; /&gt; &lt;img src=&quot;./img/default.png&quot; data-src=&quot;./img/8.jpg&quot; /&gt; &lt;img src=&quot;./img/default.png&quot; data-src=&quot;./img/9.jpg&quot; /&gt; &lt;img src=&quot;./img/default.png&quot; data-src=&quot;./img/10.jpg&quot; /&gt; &lt;/body&gt;&lt;/html&gt; 先获取所有图片的 dom，通过 document.body.clientHeight 获取可视区高度，再使用 element.getBoundingClientRect() API 直接得到元素相对浏览的 top 值， 遍历每个图片判断当前图片是否到了可视区范围内。代码如下： 1234567891011121314function lazyload() { let viewHeight = document.body.clientHeight; //获取可视区高度 let imgs = document.querySelectorAll(&quot;img[data-src]&quot;); imgs.forEach((item, index) =&gt; { if (item.dataset.src === &quot;&quot;) return; // 用于获得页面中某个元素的左，上，右和下分别相对浏览器视窗的位置 let rect = item.getBoundingClientRect(); if (rect.bottom &gt;= 0 &amp;&amp; rect.top &lt; viewHeight) { item.src = item.dataset.src; item.removeAttribute(&quot;data-src&quot;); } });} 最后给 window 绑定 onscroll 事件。 window.addEventListener('scroll', throttle(lazyload, 200)) IntersectionObserver:IntersectionObserver 是一个新的 API，可以自动”观察”元素是否可见，Chrome 51+ 已经支持。由于可见（visible）的本质是，目标元素与视口产生一个交叉区，所以这个 API 叫做”交叉观察器”。我们来看一下它的用法： 12345678910var io = new IntersectionObserver(callback, option);// 开始观察io.observe(document.getElementById(&quot;example&quot;));// 停止观察io.unobserve(element);// 关闭观察器io.disconnect(); IntersectionObserver 是浏览器原生提供的构造函数，接受两个参数：callback 是可见性变化时的回调函数，option 是配置对象（该参数可选）。 目标元素的可见性变化时，就会调用观察器的回调函数 callback。callback 一般会触发两次。一次是目标元素刚刚进入视口（开始可见），另一次是完全离开视口（开始不可见）。 123var io = new IntersectionObserver((entries) =&gt; { console.log(entries);}); callback 函数的参数（entries）是一个数组，每个成员都是一个 IntersectionObserverEntry 对象。举例来说，如果同时有两个被观察的对象的可见性发生变化，entries 数组就会有两个成员。 time：可见性发生变化的时间，是一个高精度时间戳，单位为毫秒； target：被观察的目标元素，是一个 DOM 节点对象； isIntersecting: 目标是否可见； rootBounds：根元素的矩形区域的信息，getBoundingClientRect()方法的返回值，如果没有根元素（即直接相对于视口滚动），则返回 null； boundingClientRect：目标元素的矩形区域的信息； intersectionRect：目标元素与视口（或根元素）的交叉区域的信息； intersectionRatio：目标元素的可见比例，即 intersectionRect 占 boundingClientRect 的比例，完全可见时为 1，完全不可见时小于等于 0。 用 IntersectionObserver 实现图片懒加载。 1234567891011121314151617181920const imgs = document.querySelectorAll(&quot;img[data-src]&quot;);let observer = new IntersectionObserver((entries, self) =&gt; { entries.forEach((entry) =&gt; { if (entry.isIntersecting) { let img = entry.target; let src = img.dataset.src; if (src) { img.src = src; img.removeAttribute(&quot;data-src&quot;); } // 解除观察 self.unobserve(entry.target); } });});imgs.forEach((image) =&gt; { observer.observe(image);}); 1.2.2 合理的尺寸1.2.2.1 实际大小例如，你有一个 1920 * 1080 大小的图片，用缩略图的方式展示给用户，并且当用户鼠标悬停在上面时才展示全图。如果用户从未真正将鼠标悬停在缩略图上，则浪费了下载图片的时间。所以，我们可以用两张图片来实行优化。一开始，只加载缩略图，当用户悬停在图片上时，才加载大图。还有一种办法，即对大图进行延迟加载，在所有元素都加载完成后手动更改大图的 src 进行下载。 1.2.2.2 响应式图片（媒体查询）响应式图片的优点是浏览器能够根据屏幕大小自动加载合适的图片。通过 picture 实现 12345&lt;picture&gt; &lt;source srcset=&quot;banner_w1000.jpg&quot; media=&quot;(min-width: 801px)&quot; /&gt; &lt;source srcset=&quot;banner_w800.jpg&quot; media=&quot;(max-width: 800px)&quot; /&gt; &lt;img src=&quot;banner_w800.jpg&quot; alt=&quot;&quot; /&gt;&lt;/picture&gt; 通过 @media 实现 12345678910@media (min-width: 769px) { .bg { background-image: url(bg1080.jpg); }}@media (max-width: 768px) { .bg { background-image: url(bg768.jpg); }} 1.2.3 图片压缩例如 JPG 格式的图片，100% 的质量和 90% 质量的通常看不出来区别，尤其是用来当背景图的时候。用 PS 切背景图时，将图片切成 JPG 格式，并且将它压缩到 60% 的质量，基本上看不出来区别。压缩方法有两种，一是通过 webpack 插件 image-webpack-loader，二是通过在线网站进行压缩。webpack 配置 12345678910111213141516171819{ test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, use:[ { loader: 'url-loader', options: { limit: 10000, /* 图片大小小于1000字节限制时会自动转成 base64 码引用*/ name: utils.assetsPath('img/[name].[hash:7].[ext]') } }, /*对图片进行压缩*/ { loader: 'image-webpack-loader', options: { bypassOnDebug: true, } } ]} 1.2.4 尽可能利用 CSS3 效果代替图片有很多图片使用 CSS 效果（渐变、阴影等）就能画出来，这种情况选择 CSS3 效果更好。因为代码大小通常是图片大小的几分之一甚至几十分之一。 1.2.5 使用 webp 格式的图片WebP 的优势体现在它具有更优的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量；同时具备了无损和有损的压缩模式、Alpha 透明以及动画的特性，在 JPEG 和 PNG 上的转化效果都相当优秀。 1.3 静态资源使用 CDN内容分发网络（CDN）是一组分布在多个不同地理位置的 Web 服务器。我们都知道，当服务器离用户越远时，延迟越高。CDN 就是为了解决这一问题，在多个位置部署服务器，让用户离服务器更近，从而缩短请求时间。 1.3.1 CDN 原理当用户访问一个网站时，如果没有 CDN，过程是这样的： 浏览器要将域名解析为 IP 地址，所以需要向本地 DNS 发出请求； 本地 DNS 依次向根服务器、顶级域名服务器、权限服务器发出请求，得到网站服务器的 IP 地址； 本地 DNS 将 IP 地址发回给浏览器，浏览器向网站服务器 IP 地址发出请求并得到资源。 如果用户访问的网站部署了 CDN，过程是这样的： 浏览器要将域名解析为 IP 地址，所以需要向本地 DNS 发出请求； 本地 DNS 依次向根服务器、顶级域名服务器、权限服务器发出请求，得到全局负载均衡系统（GSLB）的 IP 地址； 本地 DNS 再向 GSLB 发出请求，GSLB 的主要功能是根据本地 DNS 的 IP 地址判断用户的位置，筛选出距离用户较近的本地负载均衡系统（SLB），并将该 SLB 的 IP 地址作为结果返回给本地 DNS； 本地 DNS 将 SLB 的 IP 地址发回给浏览器，浏览器向 SLB 发出请求； SLB 根据浏览器请求的资源和地址，选出最优的缓存服务器发回给浏览器； 浏览器再根据 SLB 发回的地址重定向到缓存服务器； 如果缓存服务器有浏览器需要的资源，就将资源发回给浏览器。如果没有，就向源服务器请求资源，再发给浏览器并缓存在本地。 2 页面2.1 减少 HTTP 请求每个请求都是有成本的，既包含时间成本也包含资源成本。一个完整的请求都需要经过 DNS 寻址、与服务器建立连接、发送数据、等待服务器响应、接收数据这样一个 “漫长” 而复杂的过程。时间成本就是用户需等待这个资源加载结束；资源成本就是由于每个请求都需要携带数据，因此每个请求都需要占用带宽。另外，由于浏览器进行并发请求的请求数是有上限的，因此请求数多了以后，浏览器需要分批进行请求，因此会增加用户的等待时间，会给用户造成站点速度慢这样一个印象，即使可能用户能看到的第一屏的资源都已经请求完了，但是浏览器的进度条会一直存在。 2.1.1 从设计实现层面简化页面如果页面像百度首页一样简单，那么接下来的规则基本上都用不着了。保持页面简洁、减少资源的使用是最直接有效的。 2.1.2 减少请求文件的个数通过工具将多个零散的 JS、CSS 文件压缩合并后使用。 2.1.3 将图片转为 Base64 编码采用 Base64 编码方式将图片直接嵌入到网页中，而不是从外部载入。 2.1.4 其他 避免无效请求（图片，JavaScript，CSS 等 404）； 避免页面跳转或者重定向； 使用字体图标 iconfont 代替图片图标； 2.2 延迟加载脚本&lt;script&gt; 标签上有两个属性可以为我们提供延迟加载脚本：defer 和 async。 2.2.1 deferdefer 属性会告诉浏览器不用等待这个脚本加载，浏览器则可以继续处理 HTML 构建 DOM 元素，当 DOM 元素完全构建完成后，才会加载脚本。 123456&lt;p&gt;...content before script...&lt;/p&gt;&lt;script defer src=&quot;https://javascript.info/article/script-async-defer/long.js?speed=1&quot;&gt;&lt;/script&gt;&lt;!-- visible immediately --&gt;&lt;p&gt;...content after script...&lt;/p&gt; 总结： 带有 defer 属性的 &lt;script&gt; 标签永远不会阻塞页面； 延迟加载的脚本始终在 DOM 准备就绪时执行（但在 DOMContentLoaded 事件之前）。 1234567891011121314&lt;p&gt;...content before scripts...&lt;/p&gt;&lt;script&gt; document.addEventListener(&quot;DOMContentLoaded&quot;, () =&gt; alert(&quot;DOM ready after defer!&quot;) );&lt;/script&gt;&lt;script defer src=&quot;https://javascript.info/article/script-async-defer/long.js?speed=1&quot;&gt;&lt;/script&gt;&lt;p&gt;...content after scripts...&lt;/p&gt; 同样都是延迟脚本时，执行会保持相对顺序。 12345678&lt;script defer src=&quot;https://javascript.info/article/script-async-defer/long.js&quot;&gt;&lt;/script&gt;&lt;script defer src=&quot;https://javascript.info/article/script-async-defer/small.js&quot;&gt;&lt;/script&gt; 像上边两个 JS 文件都拥有 defer 属性，即使 small.js 可能先加载完毕，依旧会等待 long.js 加载完执行后在执行。js 之前有相互依赖关系时，这一点就需要注意。 注意： defer 属性仅适用于外部脚本； 如果 &lt;script&gt; 标记没有 src，则将忽略 defer 属性。 2.2.2 asyncasync 属性有点像 defer。这也使脚本无阻塞。但是它在行为上有着重要的区别；如果有 async 属性，则意味着这些脚本之间是完全独立的。 浏览器也不会阻塞带有 async 属性的脚本和 defer 一致； 其他脚本不会等待带有 async 属性的脚本,带有 async 属性的脚本也不会等待其他脚本； DOMContentLoaded 和 带有 async 属性的脚本也不会互相等待； 带有 async 属性的脚本以“加载优先”的原则顺序运行。 12345678910111213141516&lt;p&gt;...content before scripts...&lt;/p&gt;&lt;script&gt; document.addEventListener(&quot;DOMContentLoaded&quot;, () =&gt; alert(&quot;DOM ready!&quot;));&lt;/script&gt;&lt;script async src=&quot;https://javascript.info/article/script-async-defer/long.js&quot;&gt;&lt;/script&gt;&lt;script async src=&quot;https://javascript.info/article/script-async-defer/small.js&quot;&gt;&lt;/script&gt;&lt;p&gt;...content after scripts...&lt;/p&gt; 2.3 删除重复的脚本团队中形成良好工程目录结构，按照工程结构规范去存放脚本，团队成员之前提前沟通好，避免出现重复脚本。例如在实际开发过程中不同的功能模块中团队成员都各自引入同一个脚本库，导致脚本重复问题。 2.4 减少 DOM 的数量 布局是否合理，是否是更具语义化的标签； 通过伪元素实现对应的功能； 展示大数据量时，是否有分页展示； dom 元素是否按需加载。 可使用 document.getElementsByTagName('*').length; 检查页面元素数量。 2.5 样式表放页面顶部将 CSS 文件放在 &lt;head&gt; 标签中。 思考：为何将样式表放到页面头部？ 2.5.1 浏览器渲染页面流程 浏览器首先使用 HTTP 协议或者 HTTPS 协议，向服务端请求页面； 把请求回来的 HTML 代码经过解析，构建成 DOM 树； 计算 DOM 树上的 CSS 属性； 最后根据 CSS 属性对元素逐个进行渲染，得到内存中的位图； 一个可选的步骤是对位图进行合成，这会极大地增加后续绘制的速度； 合成之后，再绘制到界面上。 在上边 2、3 步时，构建 DOM 的过程是：从父到子，从先到后，一个一个节点构造，并且挂载到 DOM 树上的，在这个过程中，我们依次拿到上一步构造好的元素，去检查它匹配到了哪些规则，再根据规则的优先级，做覆盖和调整。整个过程中构建 DOM 树和匹配 CSS 规则是同步进行的。 2.5.2 重排（reflow）当改变 DOM 元素位置或大小时，会导致浏览器重新生成渲染树，这个过程叫重排。重排的示例包括：添加或删除内容，显式或隐式更改宽度，高度，字体，字体大小等。重排对于性能影响更严重，因为重排导致部分页面甚至整个页面布局的更改。 2.5.3 重绘（repaint）当元素的外观发生了明显更改但不影响其布局更改时，就会发生重绘。例如，轮廓，可见性，背景或颜色。根据 Opera 的说法，重绘是很耗性能的，因为浏览器必须验证 DOM 树中所有其他节点的可见性。 其他 CSS 优化策略 使用简写，使用缩写语句，如下面所示的 margin 声明，可以从根本上减小 CSS 文件的大小 12345678910p { margin-top: 1px; margin-right: 2px; margin-bottom: 3px; margin-left: 4px;}p { margin: 1px 2px 3px 4px;} 使用颜色快捷方式 123456target { background-color: #ffffff;}target { background: #fff;} 删除不必要的零和单位，CSS 支持多种单位和数字格式。它们是一个值得感谢的优化目标——可以删除尾随和跟随的零，如下面的代码片段所示。此外，请记住，零始终是零，添加维度不会为包含的信息附带价值。 123456padding: 0.2em;margin: 20em;avalue: 0px;padding: 0.2em;margin: 20em;avalue: 0; 省略 px，提高性能的一个简单方法是使用 CSS 标准的一个特性。为 0 的数值默认单位是 px—— 删除 px 可以为每个数字节省两个字节。 123456789h2 { padding: 0px; margin: 0px;}h2 { padding: 0; margin: 0;} 删除空格，空格——考虑制表符、回车符和空格——使代码更容易阅读，但从解析器的角度看，它没有什么用处。在发布前删除它们，更好的方法是将此任务委托给 shell 脚本或类似的工具。 删除注释，注释对编译器也没有任何作用。创建一个自定义解析器，以便在发布之前删除它们。这不仅节省了带宽，而且还确保攻击者和克隆者更难理解手头代码背后的思想（针对线上）。 避免需要性能要求的属性，分析表明，一些标签比其他标签更消耗性能。以下这些解析会影响性能—如果在没有必要的情况，尽量不要使用它们。 123456border-radiusbox-shadowtransformfilter:nth-childposition: fixed; 2.6 缓存 HTTP 请求2.6.1 为何要使用缓存 缓存可以减少用户等待时间，提升用户体验，直接从内存或磁盘中取缓存数据肯定是比从服务器请求更快的； 减少网络带宽消耗：对于网站运营者和用户，带宽都代表着成本，过多的带宽消耗，都需要支付额外的费用。试想一下如果可以使用缓存，只会产生极小的网络流量，这将有效的降低运营成本； 降低服务器压力：给网络资源设定有效期之后，用户可以重复使用本地的缓存，减少对源服务器的请求，降低服务器的压力。 2.6.2 缓存读写规则当浏览器对一个资源(比如一个外链的 a.js)进行请求的时候会发生什么？从缓存的角度来看大概如下： 调用 Service Worker 的 fetch 事件获取资源； 查看 memory cache； 查看 disk cache；这里又细分： 1)如果有强制缓存且未失效，则使用强制缓存，不请求服务器。这时的状态码全部是 200； 2)如果有强制缓存但已失效，使用协商缓存，比较后确定 304 还是 200。 发送网络请求，等待网络响应； 把响应内容存入 disk cache (如果请求头信息配置可以存的话)； 把响应内容的引用存入 memory cache (无视请求头信息的配置，除了 no-store 之外)； 把响应内容存入 Service Worker 的 Cache Storage (如果 Service Worker 的脚本调用了 cache.put())。 2.6.3 缓存位置 从浏览器开发者工具的 Network 面板下某个请求的 Size 中可以看到当前请求资源的大小以及来源，从这些来源我们就知道该资源到底是从 memory cache 中读取的呢，还是从 disk cache 中读取的，亦或者是服务器返回的。而这些就是缓存位置： 2.6.3.1 Service Worker是一个注册在指定源和路径下的事件驱动 worker；特点是： 运行在 worker 上下文，因此它不能访问 DOM； 独立于主线程之外，不会造成阻塞； 设计完全异步，所以同步 API(如 XHR 和 localStorage )不能在 Service Worker 中使用； 最后处于安全考虑，必须在 HTTPS 环境下才可以使用。 说了这么多特点，那它和缓存有啥关系？其实它有一个功能就是离线缓存：Service Worker Cache；区别于浏览器内部的 memory cache 和 disk cache，它允许我们自己去操控缓存，具体操作过程可以查阅 Using_Service_Workers；通过 Service Worker 设置的缓存会出现在浏览器开发者工具 Application 面板下的 Cache Storage 中。 2.6.3.2 memory cache是浏览器内存中的缓存，相比于 disk cache 它的特点是读取速度快，但容量小，且时效性短，一旦浏览器 tab 页关闭，memory cache 就将被清空。memory cache 会自动缓存所有资源吗？答案肯定是否定的，当 HTTP 头设置了 Cache-Control: no-store 的时候或者浏览器设置了 Disabled cache 就无法把资源存入内存了，其实也无法存入硬盘。当从 memory cache 中查找缓存的时候，不仅仅会去匹配资源的 URL，还会看其 Content-type 是否相同。 2.6.3.3 disk cache也叫 HTTP cache 是存在硬盘中的缓存，根据 HTTP 头部的各类字段进行判定资源的缓存规则，比如是否可以缓存，什么时候过期，过期之后需要重新发起请求吗?相比于 memory cache 的 disk cache 拥有存储空间时间长等优点，网站中的绝大多数资源都是存在 disk cache 中的。 浏览器如何判断一个资源是存入内存还是硬盘呢？关于这个问题，网上说法不一，不过比较靠谱的观点是：对于大文件大概率会存入硬盘中；当前系统内存使用率高的话，文件优先存入硬盘。 2.6.4 缓存策略 根据 HTTP header 的字段又可以将缓存分成强缓存和协商缓存。强缓存可以直接从缓存中读取资源返回给浏览器而不需要向服务器发送请求，而协商缓存是当强缓存失效后(过了过期时间)，浏览器需要携带缓存标识向服务器发送请求，服务器根据缓存标识决定是否使用缓存的过程。强缓存的字段有：Expires 和 Cache-Control。协商缓存的字段有：Last-Modified 和 ETag。 2.6.4.1 强制缓存 从上图我们得知，强制缓存，在缓存数据未失效的情况下，可以直接使用缓存数据，那么浏览器是如何判断缓存数据是否失效呢？我们知道，在没有缓存数据的时候，浏览器向服务器请求数据时，服务器会将数据和缓存规则一并返回，缓存规则信息包含在响应 header 中。 对于强制缓存来说，响应 header 中会有两个字段来标明失效规则（Expires/Cache-Control）使用 chrome 的开发者工具，可以很明显的看到对于强制缓存生效时，网络请求的情况 Expires Expires 是 HTTP/1.0 的字段，表示缓存过期时间，它是一个 GMT 格式的时间字符串。Expires 需要在服务端配置(具体配置也根据服务器而定)，浏览器会根据该过期日期与客户端时间对比，如果过期时间还没到，则会去缓存中读取该资源，如果已经到期了，则浏览器判断为该资源已经不新鲜要重新从服务端获取。由于 Expires 是一个绝对的时间，所以会局限于客户端时间的准确性，从而可能会出现浏览器判断缓存失效的问题。如下是一个 Expires 示例，是一个日期/时间： Expires: Wed, 21 Oct 2020 07:28:00 GMT Cache-Control 它是 HTTP/1.1 的字段，其中的包含的值很多： max-age 最大缓存时间，值的单位是秒，在该时间内，浏览器不需要向浏览器请求。这个设置解决了 Expires 中由于客户端系统时间不准确而导致缓存失效的问题； must-revalidate：如果超过了 max-age 的时间，浏览器必须向服务器发送请求，验证资源是否还有效； public 响应可以被任何对象(客户端、代理服务器等)缓存； private 响应只能被客户端缓存； no-cache 跳过强缓存，直接进入协商缓存阶段； no-store 不缓存任何内容，设置了这个后资源也不会被缓存到内存和硬盘。 Cache-Control 的值是可以混合使用的，比如： Cache-Control: private, max-age=0, no-cache 当混合使用的时候它们的优先级如下图所示： 「当 Expires 和 Cache-Control 都被设置的时候，浏览器会优先考虑后者」。当强缓存失效的时候，则会进入到协商缓存阶段。具体细节是这样：浏览器从本地查找强缓存，发现失效了，然后会拿着缓存标识请求服务器，服务器拿着这个缓存标识和对应的字段进行校验资源是否被修改，如果没有被修改则此时响应状态会是 304，且不会返回请求资源，而是直接从浏览器缓存中读取。 2.6.4.2 协商缓存浏览器缓存标识可以是：Last-Modified 和 ETag。 Last-Modified 资源的最后修改时间； 第一次请求的时候，响应头会返回该字段告知浏览器资源的最后一次修改时间； 浏览器会将值和资源存在缓存中； 再次请求该资源的时候，如果强缓存过期，则浏览器会设置请求头的 If-Modifined-Since 字段值为存储在缓存中的上次响应头 Last-Modified 的值，并且发送请求； 服务器拿着 If-Modifined-Since 的值和 Last-Modified 进行对比。如果相等，表示资源未修改，响应 304;如果不相等，表示资源被修改，响应 200，且返回请求资源。如果资源更新的速度是小于 1 秒的，那么该字段将失效，因为 Last-Modified 时间是精确到秒的。所以有了 ETag。 ETag 根据资源内容生成的唯一标识，资源是否被修改的判断过程和上面的一致，只是对应的字段替换了。Last-Modified 替换成 ETag，If-Modifined-Since 替换成 If-None-Match。 当 Last-Modified 和 ETag 都被设置的时候，浏览器会优先考虑后者。 总结： 对于强制缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。对于比较缓存，将缓存信息中的 Etag 和 Last-Modified 通过请求发送给服务器，由服务器校验，返回 304 状态码时，浏览器直接使用缓存。 浏览器第一次请求： 浏览器再次请求时： 2.6.5 浏览器的行为浏览器地址栏输入 URL 后回车：查找 disk cache 中是否有匹配。如有则使用；如没有则发送网络请求。 普通刷新 (F5)：因为 TAB 页并没有关闭，因此 memory cache 是可用的，会被优先使用(如果匹配的话)，其次才是 disk cache。 强制刷新 (ctrl+F5)：浏览器不使用缓存，因此发送的请求头部均带有 Cache-control: no-cache(为了兼容，还带了 Pragma: no-cache)。服务器直接返回 200 和最新内容。 当在开发者工具 Network 面板下设置了 Disabled cache 禁用缓存后，浏览器将不会从 memory cache 或者 disk cache 中读取缓存，而是直接发起网络请求。 2.6.6 前端开发设置不缓存在引用 js、css 文件的 url 后边加上 ?+Math.random() &lt;script src=&quot;/js/test.js?+Math.random()&quot;&gt;&lt;/script&gt; 设置 html 页面不让浏览器缓存的方法。 123&lt;meta http-equiv=&quot;pragma&quot; content=&quot;no-cache&quot; /&gt;&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-cache, must-revalidate&quot; /&gt;&lt;meta http-equiv=&quot;expires&quot; content=&quot;Wed, 26 Feb 1997 00:00:00 GMT&quot; /&gt; 2.7 预加载关键请求可以使用不同的预取和预加载技术向浏览器通知在页面展示时需要哪些资源。 2.7.1 Preload当浏览器解析到 preload 会立即进行资源的请求，需要注意的是使用 preload 进行预加载时需要指定文件的类型。 &lt;link href=/js/chunk-vendors.5e63c7cf.js rel=preload as=script&gt; 2.7.2 DNS-PrefetchDNS 预取。可以告诉浏览器，哪些域名需要提前解析为 IP 地址。当浏览网页时，浏览器会在加载网页时对网页中的域名进行解析缓存，这样在单击当前网页中的连接时就无需进行 DNS 的解析，减少用户等待时间，提高用户体验。 &lt;link rel=&quot;dns-prefetch&quot; href=&quot;//sematext.com&quot;&gt; 2.7.3 Prefetch预取。如果确定将来需要特定资源，则可以要求浏览器请求该项目并将其存储在缓存中以供以后使用。当浏览器解析到 prefetch 时，不会立即请求资源，会等待浏览器空闲以后再进行资源的请求 &lt;link rel=&quot;prefetch&quot; href=&quot;logo.png&quot;&gt; 2.7.4 PreconnectTCP 预连接。与 DNS 预取方法非常相似，预连接将解析 DNS，但也会进行 TCP 握手和 TLS 协商（可选）。 &lt;link rel=&quot;preconnect&quot; href=&quot;https://www.sematext.com&quot;&gt; 3 代码3.1 Web WorkerJavaScript 语言采用的是单线程模型，也就是说，所有任务只能在一个线程上完成，一次只能做一件事。前面的任务没做完，后面的任务只能等着。随着电脑计算能力的增强，尤其是多核 CPU 的出现，单线程带来很大的不便，无法充分发挥计算机的计算能力。 Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。 3.2 基本用法3.2.1 主线程const worker = new Worker('work.js') Worker()构造函数的参数是一个脚本文件，该文件就是 Worker 线程所要执行的任务。由于 Worker 不能读取本地文件，所以这个脚本必须来自网络。如果下载没有成功（比如 404 错误），Worker 就会默默地失败。 Worker()构造函数的参数也可以是一个与主线程在同一个网页的代码或者一个由二进制对象创建的 URL。 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt; &lt;body&gt; &lt;script id=&quot;worker&quot; type=&quot;app/worker&quot;&gt; addEventListener('message',function(){ postMessage('some message'); },false); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;//worker代码字符串const funStr = '···'//通过代码字符串直接创建二进制对象const blob1 = new Blob([funStr]);//通过script标签内容来创建二进制对象var blob2 = new Blob([document.querySelector('#worker').textContent]);var url1 = window.URL.createObjectURL(blob1);// 通过二进制对象创建workervar worker =new Worker(url);// 通过js文件的网络地址创建workervar worker2 =new Worker('worker.js');worker.onmessage = function(e){ // e.data === 'some message'}; 在 web 领域，Blob 对象表示一个只读原始数据的类文件对象，虽然是二进制原始数据但是是类似文件的对象，因此可以像操作文件对象一样操作 Blob 对象。 然后，主线程调用 worker.postMessage()方法，向 Worker 发消息。 12worker.postMessage(&quot;Hello World&quot;);worker.postMessage({ method: &quot;echo&quot;, args: [&quot;Work&quot;] }); worker.postMessage()方法的参数，就是主线程传给 Worker 的数据。它可以是各种数据类型，包括二进制数据。接着，主线程通过 worker.onmessage 指定监听函数，接收子线程发回来的消息。 12345678worker.onmessage = function (event) { console.log(&quot;Received message &quot; + event.data); doSomething();};function doSomething() { // 执行任务 worker.postMessage(&quot;Work done!&quot;);} Worker 完成任务以后，主线程就可以把它关掉。 worker.terminate(); 3.2.2 Worker 线程worker 线程内部需要有一个监听函数，监听 message 事件。 12345678910111213141516171819202122232425262728293031//写法一self.addEventListener( &quot;message&quot;, function (e) { self.postMessage(&quot;You said: &quot; + e.data); }, false);//写法二this.addEventListener( &quot;message&quot;, function (e) { self.postMessage(&quot;You said: &quot; + e.data); }, false);//写法三addEventListener( &quot;message&quot;, function (e) { self.postMessage(&quot;You said: &quot; + e.data); }, false);//写法四onmessage = function (e) { postMessage(&quot;You said: &quot; + e.data);}; 向主线程发消息。 12345678910111213141516171819self.addEventListener( &quot;message&quot;, function (e) { var data = e.data; switch (data.cmd) { case &quot;start&quot;: s; elf.postMessage(&quot;WORKER STARTED: &quot; + data.msg); break; case &quot;stop&quot;: self.postMessage(&quot;WORKER STOPPED: &quot; + data.msg); self.close(); // Terminates the worker. break; default: self.postMessage(&quot;Unknown command: &quot; + data.msg); } }, false); self.close()用于在 Worker 内部关闭自身。terminate 是 worker 创建者自己销毁 worker，close 是 worker 自己销毁自己。 3.2.3 错误处理主线程可以监听 Worker 是否发生错误。如果发生错误，Worker 会触发主线程的 error 事件。 123456789worker.onerror(function (event) { console.log( [&quot;ERROR: Line &quot;, e.lineno, &quot; in &quot;, e.filename, &quot;: &quot;, e.message].join(&quot;&quot;) );});// 或者worker.addEventListener(&quot;error&quot;, function (event) { // ...}); 3.2.4 关闭 Worker使用完毕，为了节省系统资源，必须关闭 Worker。 12345// 主线程worker.terminate();// Worker 线程self.close(); 3.3 注意事项 同源限制：分配给 Worker 线程运行的脚本文件，必须与主线程的脚步问文件同源； DOM 限制：Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在页面的 DOM 对象，也无法使用 document、window、parent 这些对象，但是，worker 线程可以使用 navigator 和 location 对象； 通信联系：Worker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成； 脚本限制：Worker 线程不能执行 alert()方法和 confirm()方法，但可以使用 XMLHttpRequest 对象发出 AJAX 请求； 文件限制：创建 Worker 线程时无法读取本地文件，即不能打开本机的文件系统（file://），它所加载的脚本，必须来自网络。 3.4 防抖和节流在前端开发的过程中，我们经常会需要绑定一些持续触发的事件，如 resize、scroll、mousemove 等等，但有些时候我们并不希望在事件持续触发的过程中那么频繁地去执行函数。 通常这种情况下我们怎么去解决的呢？一般来讲，防抖和节流是比较好的解决方案。 让我们先来看看在事件持续触发的过程中频繁执行函数是怎样的一种情况。 12345678910111213&lt;div id=&quot;content&quot; style=&quot;height:150px;line-height:150px;text-align:center; color: #fff;background-color:#ccc;font-size:80px;&quot;&gt;&lt;/div&gt;&lt;script&gt; let num = 1; let content = document.getElementById(&quot;content&quot;); function count() { content.innerHTML = num++; } content.onmousemove = count;&lt;/script&gt; 在上述代码中，div 元素绑定了 mousemove 事件，当鼠标在 div（灰色）区域中移动的时候会持续地去触发该事件导致频繁执行函数。效果如下 可以看到，在没有通过其它操作的情况下，函数被频繁地执行导致页面上数据变化特别快。所以，接下来让我们来看看防抖和节流是如何去解决这个问题的。 3.4.1 防抖函数（debounce）所谓防抖，就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间，即会重新开始等待，直到过了 n 秒后，才会再次执行。通俗理解就是首次事件触发并执行函数之后的 n 秒内，如果事件一直在触发，那么函数将永远不会执行，直到事件不触发了之后，并等待 n 秒之后，再次触发事件才会执行函数。 完整的防抖函数： 是否有无立即执行功能； 有无返回值； 能否取消。 123456789101112131415161718192021222324252627// immediate是否是触发事件时执行，为true时则是触发事件时执行，为false是则是停止触发事件才执行function debounce(fn,wait=2000,immediate=true){ let timer,res; let debounced = function(...args){ if(timer){ clearTimeout(timer); } if(immediate){ let callNow = !timer; timer =setTimeout(()=&gt;{ timer = null; },wait) if(callNow){ res = fn.apply(this,args); } }else{ timer =setTimeout(()=&gt;{ fn.apply(this,args); },wait) } retrun res; } debounced.cancel = function(){ clearTimeout(timer); } return debounced;} 依旧使用上述绑定 mousemove 事件的例子，通过上面的防抖函数 content.onmousemove = debounce(count,1000); 效果如下 3.4.2 节流函数（throttle）所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数。节流会稀释函数的执行频率。 12345678910111213function throttle(fn, wait) { let timer; return function () { let context = this; let args = arguments; if (!timer) { timer = setTimeout(() =&gt; { timer = null; fn.apply(context, args); }, wait); } };} 依旧使用上述绑定 mousemove 事件的例子，通过上面的防抖函数 content.onmousemove = throttle(count,1000); 效果如下 3.4.3 区别防抖，连续触发事件时，最多只会执行一次，停止后，再次触发，重新计时；节流，连续触发事件时，n 秒内只会执行一次，但是会继续执行，只是稀释了函数执行的次数。 3.4.4 应用场景 3.5 慎用 with 和 evalJavaScript 引擎会在编译阶段进行性能优化，其中有些优化依赖于根据代码的词法进行静态分析，并预先确定所有变量的位置和函数定义位置，才能在执行过程中快速的找到标识符。但是如果引擎在代码中发现了 eval() 或者 with，它就只能简单的假设关于标识符的位置判断都是无效的，因为无法在词法分析阶段明确的知道 eval() 会接收什么代码，这些代码会如何对作用域进行修改，也无法知道传递给 with 用来创建新词法作用域的对象的内容到底是什么。这个两个的机制会‘欺骗’词法作用。 3.6 减少作用域链查找js 代码在执行的时候，如果需要访问一个变量或者一个函数的时候，它需要遍历当前执行环境的作用域链，而遍历是从这个作用域链的前端一级一级的向后遍历，直到全局执行环境，所以这里往往会出现一个情况，那就是如果我们需要经常访问全局环境的变量对象的时候，我们每次都必须在当前作用域链上一级一级的遍历，显然这是比较耗时的。 优化方法： 使用局部变量来缓存全局变量，来减少作用域链上的查找次数。 12345678// 全局变量var globalVar = 1;function myCallback(info){ for( var i = 100000; i &gt; 0; i--;){ //每次访问 globalVar 都需要查找到作用域链最顶端，本例中需要访问 100000 次 globalVar += i; }} 优化后： 123456789101112// 全局变量var globalVar = 1;function myCallback(info){ //局部变量缓存全局变量 var localVar = globalVar; for( var i = 100000; i &gt; 0; i--;){ //访问局部变量是最快的 localVar += i; } //本例中只需要访问 2次全局变量。在函数中只需要将 globalVar 中内容的值赋给 localVar globalVar = localVar;} 3.7 合理使用闭包12345678910111213function foo() { var a = 2; function bar() { console.log(2); } return bar;}var baz = foo();baz(); //2 上边示例中，在 foo() 执行后，通常会将 foo 中的整个内部作用域都会被销毁，因为 js 引擎有垃圾回收器用来释放不再使用的内存空间，由于看上去 foo 中的内容不再会被使用，所以很自然的会考虑对其进行回收。然而，闭包的神奇之处正是可以阻止这件事的发生。事实上内部作用域依然存在，因此没有被回收。 闭包有三大特性： 函数嵌套函数； 函数内部可以引用外部的参数和变量； 参数和变量不会被垃圾回收机制回收。 闭包有些什么好处呢？ 变量长期存储在内存中； 避免全局变量的污染。 而闭包的缺点，恰恰也就是由这些优点带来的 常驻内存必然增加内存的使用量； 使用不当很容易造成内存泄漏。 以下两篇博客比较详细的讲了闭包、with、eval 对浏览器垃圾回收机制的影响，大家有时间可以看下。https://zhuanlan.zhihu.com/p/22486908https://www.cnblogs.com/rubylouvre/p/3345294.html 3.8 数据访问Javascript 中的数据访问包括直接量 (字符串、正则表达式 )、变量、对象属性以及数组，其中对直接量和局部变量的访问是最快的，对对象属性以及数组的访问需要更大的开销。当出现以下情况时，建议将数据放入局部变量： 对任何对象属性的访问超过 1 次； 对任何数组成员的访问次数超过 1 次； 避免对象嵌套； 还应当尽可能的减少对对象以及数组深度查找。 3.9 使用 GPU.JS 改善 JavaScript 性能你是否曾经尝试过运行复杂的计算，却发现它需要花费很长时间，并且拖慢了你的进程？ 有很多方法可以解决这个问题，例如使用 web worker 或后台线程。GPU 减轻了 CPU 的处理负荷，给了 CPU 更多的空间来处理其他进程。同时，web worker 仍然运行在 CPU 上，但是运行在不同的线程上。 3.9.1 什么是 GPU.jsGPU.js 是一个针对 Web 和 Node.js 构建的 JavaScript 加速库，用于在图形处理单元（GPU）上进行通用编程，它使你可以将复杂且耗时的计算移交给 GPU 而不是 CPU，以实现更快的计算和操作。还有一个备用选项：在系统上没有 GPU 的情况下，这些功能仍将在常规 JavaScript 引擎上运行。 高性能计算是使用 GPU.js 的主要优势之一。如果你想在浏览器中进行并行计算，而不了解 WebGL，那么 GPU.js 是一个适合你的库。 3.9.2 为什么要使用 GPU.js GPU 可用于执行大规模并行 GPU 计算。这是需要异步完成的计算类型； 当系统中没有 GPU 时，它会优雅地退回到 JavaScript； GPU 当前在浏览器和 Node.js 上运行，非常适合通过大量计算来加速网站； GPU.js 是在考虑 JavaScript 的情况下构建的，因此这些功能均使用合法的 JavaScript 语法； 如果你认为你的处理器可以胜任，你不需要 GPU.js，看看下面这个 GPU 和 CPU 运行计算的结果。 如你所见，GPU 比 CPU 快 22.97 倍。 3.9.3 GPU.js 的工作方式考虑到这种速度水平，JavaScript 生态系统仿佛得到了一个可以乘坐的火箭。GPU 可以帮助网站更快地加载，特别是必须在首页上执行复杂计算的网站。你不再需要担心使用后台线程和加载器，因为 GPU 运行计算的速度是普通 CPU 的 22.97 倍。 gpu.createKernel 方法创建了一个从 JavaScript 函数移植过来的 GPU 加速内核。 与 GPU 并行运行内核函数会有更快的计算速度——快 1-15 倍，这取决于你的硬件。 3.9.4 GPU.js 入门安装 123npm install gpu.js --save// ORyarn add gpu.js 在你的项目中要导入 GPU.js。 123456import { GPU } from ('gpu.js')// ORconst { GPU } = require('gpu.js')const gpu = new GPU(); 3.9.5 乘法演示在下面的示例中，计算是在 GPU 上并行完成的。 首先，生成大量数据。 12345678910111213141516171819const getArrayValues = () =&gt; { // 在此处创建2D arrary const values = [[], []]; // 将值插入第一个数组 for (let y = 0; y &lt; 600; y++) { values[0].push([]); values[1].push([]); // 将值插入第二个数组 for (let x = 0; x &lt; 600; x++) { values[0][y].push(Math.random()); values[1][y].push(Math.random()); } } // 返回填充数组 return values;}; 创建内核（运行在 GPU 上的函数的另一个词）。 123456789101112const gpu = new GPU();// 使用 `createKernel()` 方法将数组相乘const multiplyLargeValues = gpu .createKernel(function (a, b) { let sum = 0; for (let i = 0; i &lt; 600; i++) { sum += a[this.thread.y][i] * b[i][this.thread.x]; } return sum; }) .setOutput([600, 600]); setOutput：根据输出类型指定输出的预期大小，使用 GPU 加速必须定义输出大小。this.thread：即为输出大小的宽、高以及深度 使用矩阵作为参数调用内核。 12const largeArray = getArrayValues();const out = multiplyLargeValues(largeArray[0], largeArray[1]); 输出 1console.log(out[10][12]); // 记录输出数组第10行和第12列的元素 3.10 其他 使用 requestAnimationFrame 来实现动画； 不要覆盖原生方法。无论你的 JavaScript 代码如何优化，都比不上原生方法。因为原生方法是用低级语言写的（C/C++），并且被编译成机器码，成为浏览器的一部分。当原生方法可用时，尽量使用它们，特别是数学运算和 DOM 操作。 查找并删除未使用的代码，删除不必要的部分 CSS，JS 显然会加快网页的加载速度。谷歌的 Chrome 浏览器有这种开箱即用的功能。只需转到查看&gt;开发人员&gt;开发人员工具，并在最近的版本中打开 Sources 选项卡，然后打开命令菜单。然后，选择 Show Coverage，在 Coverage analysis 窗口中高亮显示当前页面上未使用的代码，让您大开眼界。 4 服务器4.1 启用压缩4.1.1 Gzip 最佳配置（Nginx）文件位置：/nginx/conf/nginx.conf 文件中的 http 标签内 12345678gzip on; #开启gzip压缩功能gzip_min_length 1k; #设置允许压缩的页面最小字节数; 这里表示如果文件小于1024个字节，就不用压缩，因为没有意义，本来就很小.gzip_buffers 4 16k; #设置压缩缓冲区大小，此处设置为4个16K内存作为压缩结果流缓存gzip_http_version 1.1; #压缩版本gzip_comp_level 4; #设置压缩比率，最小为1，处理速度快，传输速度慢；9为最大压缩比，处理速度慢，传输速度快; 这里表示压缩级别，可以是1到9中的任一个，级别越高，压缩就越小，节省了带宽资源，但同时也消耗CPU资源。gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php application/javascript application/json; #制定压缩的类型,线上配置时尽可能配置多的压缩类型!gzip_disable &quot;MSIE [1-6]\\.&quot;; #配置禁用gzip条件，支持正则。此处表示ie6及以下不启用gzip（因为ie低版本不支持）gzip_vary on; #选择支持vary header；该选项可以让前端的缓存服务器缓存经过gzip压缩的页面; 这个可以不写，表示在传送数据时，给客户端说明我使用了gzip压缩 4.2 开启 HTTP/2利用 HTTP2 新特性来提升效率： 多工：HTTP/2 复用 TCP 连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或响应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”。 头信息压缩：HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。 服务器推送：客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析 HTML 源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预测到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了，从而提高的性能。 4.3 SSR 服务端渲染SPA 模型SPA 全称是 single page web application。是一种网络应用程序 (WebApp) 模型。在传统的网站中，不同的页面之间的切换都是直接从服务器加载一整个新的页面，而在 SPA 这个模型中，是通过动态地重写页面的部分与用户交互，而避免了过多的数据交换，响应速度自然相对更高。常见的几个 SPA 框架：AgularJS、React、Vue.js。 优点： 页面之间的切换非常快; 一定程度上减少了后端服务器的压力（不用管页面逻辑和渲染）; 后端程序只需要提供 API，完全不用管客户端到底是 Web 界面还是手机等。 缺点： 首屏打开速度很慢，因为用户首次加载需要先下载 SPA 框架及应用程序的代码，然后再渲染页面； 不利于 SEO。 SEOSEO（Search Engine Optimization），中文一般译作：搜索引擎优化。SEO 是一种通过了解搜索引擎的运作规则（如何抓取网站页面，如何索引以及如何根据特定的关键字展现搜索结果排序等）来调整网站，以提高该网站在搜索引擎中某些关键词的搜索结果排名。 SPA 与 SEO 的冲突既然，SPA 有这么多的优点，但是同时呢又带来了新的问题，SEO 对于提供内容的网站来说是非常重要的。不知谁说的：技术上的问题总有技术去解决，所以呢，SSR 闪亮登场。 SSR服务端渲染（Server-Side Rendering），是指由服务侧完成页面的 HTML 结构拼接的页面处理技术，发送到浏览器，然后为其绑定状态与事件，成为完全可交互页面的过程。 优势： 更好的 SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面。 请注意，截至目前，Google 和 Bing 可以很好对同步 JavaScript 应用程序进行索引。在这里，同步是关键。如果你的应用程序初始展示 loading 图，然后通过 Ajax 获取内容，抓取工具并不会等待异步完成后再行抓取页面内容。也就是说，如果 SEO 对你的站点至关重要，而你的页面又是异步获取内容，则你可能需要服务器端渲染(SSR)解决此问题。 更快的内容到达时间 (time-to-content)，特别是对于缓慢的网络情况或运行缓慢的设备。无需等待所有的 JavaScript 都完成下载并执行，才显示服务器渲染的标记，所以你的用户将会更快速地看到完整渲染的页面。通常可以产生更好的用户体验，并且对于那些「内容到达时间 (time-to-content) 与转化率直接相关」的应用程序而言，服务器端渲染 (SSR) 至关重要。 使用服务器端渲染 (SSR) 时还需要有一些权衡之处： 开发条件所限。浏览器特定的代码，只能在某些生命周期钩子函数 (lifecycle hook) 中使用；一些外部扩展库 (external library) 可能需要特殊处理，才能在服务器渲染应用程序中运行。 涉及构建设置和部署的更多要求。与可以部署在任何静态文件服务器上的完全静态单页面应用程序 (SPA) 不同，服务器渲染应用程序，需要处于 Node.js server 运行环境。 更多的服务器端负载。在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用 CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 (high traffic) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。 SSR 资料","link":"/2021/01/09/web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9D%E5%85%B8/"},{"title":"es6模块导入导出","text":"es6 模块化导入导出简介一、模块化和模块加载方案模块化指的就是将一个大程序拆分成若干个互相依赖的小文件,然后在用简单的方法拼装起来。 前端工程，在最早的时候是没有模块的概念的。随着前端工程的发展，前端开发也越来越规范化，更像是软件工程了。那么随之而来的，为了解决工程化的问题，就引入了模块的概念。 在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。 当模块化的概念越来越重要的时候，ES6 在语言标准的层面上，实现了模块功能。了解更多。 二、es6 导入导出功能命令模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。 2.1 export（导出命令）一个 JS 文件，可以理解成一个模块，这个模块可以被任意其他的模块引入。文件模块被引入后，所有的东西，都是在自己的作用域中，主动发起引入行为的那个文件，虽然获取到了被引入的对象，但是并不能访问作用域里的东西，所以提供了 export，来决定一个模块对外暴露什么东西。 export 的作用，就是用于从模块中导出函数、对象或原始值，以便其他程序可以通过 import 语句使用它们. 下面介绍下 export 的相关用法。 定义一个模块文件，名为为 moude1.js。里面定义了函数，对象，以及字符串： 12345678910111213function sayHello() { console.log(&quot;module - 1 : sayHello函数&quot;);}let people = { hair: &quot;color&quot;,};let firstName = &quot;lili&quot;;let lastName = &quot;wang&quot;;export { sayHello, people, firstName }; 上面的 export 关键词可以规定这个文件对外暴露哪些变量。在 export 后的{}内中的变量就是对外暴露的变量可供其他文件使用。所以，在使用 import 导入的文件对象，就不再是一个空对象，而是包含了 export 内容的对象，所以，我们打印出moude1.js 文件对象得到的如图所示： 2.1.1 命名导出的几种写法第 1 种写法：2.1 的例子中是其中一种写法。 第 2 种写法：每个对外暴露的变量前加上 export 1234567891011export function sayHello() { console.log(&quot;module - 1 : sayHello函数&quot;);}export let people = { hair: &quot;color&quot;,};export let firstName = &quot;lili&quot;;export let lastName = &quot;wang&quot;; 第 3 种写法： 123456789101112131415161718function sayHello() { console.log(&quot;module - 1 : sayHello函数&quot;);}let people = { hair: &quot;color&quot;,};let firstName = &quot;lili&quot;;let lastName = &quot;wang&quot;;export { people, firstName, sayHello as peopleSayHello, sayHello as liliSayHello,}; 如果你不想暴露模块当中的变量名字，可以通过 as 来进行操作，上面代码使用as关键字，重命名了函数sayHello的对外接口。重命名后，sayHello可以用不同的名字输出两次。 注意：需要说明一点的是，export命令可以出现在模块的任何位置，只要处于模块顶层就可以。及，针对上面的代码来说不能处于 sayHello 函数中，会报错。如： 123456789function sayHello() { console.log(&quot;module - 1 : sayHello函数&quot;); export { people, firstName, sayHello as peopleSayHello, sayHello as liliSayHello, };} 上面代码报错如下： 2.1.2 默认导出（export default）export default 文件的默认导出接口。 在一个文件或模块中，export、import 可以有多个，export default 仅有一个。 export default 中的 default 是对应的导出接口变量。 通过 export 方式导出，在导入时要加{ }，export default 则不需要。（在导入的时候会举例说明） export default 向外暴露的成员，可以使用任意变量来接收。 12345678910111213141516171819function sayHello() { console.log(&quot;module - 1 : sayHello函数&quot;);}let people = { hair: &quot;color&quot;,};let firstName = &quot;Michael&quot;;let lastName = &quot;Jackson&quot;;let year = 1958;export { sayHello, people, firstName };export default { name: &quot;default&quot;,}; 2.1.3 取到模块内部实时的值export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。 module1.js 12export var foo = &quot;bar&quot;;setTimeout(() =&gt; (foo = &quot;baz&quot;), 500); 2.3 import 命令使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。 比如上面的 module1.js。在其他文件中要使用 module1.js 中暴露的变量，该如何使用呢。 2.3.1 导入整个文件对象在 main.js 中引入整个文件对象。 123import * as m1 from &quot;./moude1.js&quot;;console.log(m1); 示例中，impot 所有（*），使用 as 为文件对象命名为m1 ，可以访问到文件对象的所有对外接口。 2.3.2 导入部分接口在实际开发中，我们并不需要导出所有的接口。我们知道，import 导出的是整个文件对象，那么我们直接在 import 语句中，对这个对象进行解构，就可以获得其中某一部分接口： 12345import { sayHello, people } from &quot;./moude1.js&quot;;console.log(sayHello);console.log(people); 上面的语句中，只导入了 moude1.js 中的 sayHello 对象和 people 对象。打印结果如下： (1**)变量名保持一致**：需要注意的是，导出部分接口的时候，import 大括号里面的变量名，必须与被导入模块（module1.js）对外接口的暴露对象名一致。 比如，sayHello，people都是moude1.js中*export{}*中对应的名称。（比如 module1.js 中对外暴露的对象，如下图） 1export { sayHello, people, firstName }; (2)import使用 as 关键字：如果导入的多个文件中，变量名字相同，即会产生命名冲突的问题，为了解决该问题，ES6 为提供了重命名的方法，如果想为输入的变量重新取一个名字，import命令要使用as关键字，为变量重命名。（比如我们将 moude1.js 中暴露的sayHello 在 main.js 中引入的时候重命名为peopleSayHello） 12345import { sayHello as moude1Sayhello, people } from &quot;./moude1.js&quot;;console.log(moude1Sayhello);console.log(people); 打印结果如下： 2.3.3 import 命令的几点特点只读属性：import 导入的变量为常量，所以不允许修改。对于引用类型的变量，变量名不指向数据，而是指向数据所在的地址。故可以修改引用类型的属性的值。常量只是保证变量名指向的地址不变，并不保证该地址的数据不变。 12345import { a } from &quot;./xxx.js&quot;;a = {}; // errorimport { a } from &quot;./xxx.js&quot;;a.foo = &quot;hello&quot;; // a = { foo : 'hello' } 单例模式：多次重复执行同一句 import 语句，那么只会执行一次，而不会执行多次。import 同一模块，声明不同接口引用，会声明对应变量，但只执行一次 import 。 123import { a } from &quot;./xxx.js&quot;;import { b } from &quot;./xxx.js&quot;;// 相当于 import { a, b } from &quot;./xxx.js&quot;; 静态执行特性：import 是静态执行，所以不能使用表达式和变量。 1234567891011import { &quot;f&quot; + &quot;oo&quot; } from &quot;methods&quot;; // errorlet module = &quot;methods3&quot;;import { foo } from module; // errorif (true) { import { foo } from &quot;method1&quot;; // error} else { import { foo } from &quot;method2&quot;; // error} 2.3.4 导入默认接口（1）导入带有 export default 的文件对象，module1.js 如下所示 12345678910111213141516171819function sayHello() { console.log(&quot;module - 1 : sayHello函数&quot;);}let people = { hair: &quot;color&quot;,};let firstName = &quot;Michael&quot;;let lastName = &quot;Jackson&quot;;let year = 1958;export { sayHello, people, firstName };export default { name: &quot;default&quot;,}; 在 main.js 中引入整个文件对象。 123import * as m1 from &quot;./moude1.js&quot;;console.log(m1); 打印如下： 可以看出，export default 的作用，是给文件对象添加一个 default 属性，default 属性的值也是一个对象，且和 export default 导出的内容完全一致。 （2）如何只导入默认接口呢？ 上面我们说到，本质上，export default就是输出一个叫做default的变量或方法，然后系统允许你为它取任意名字。如下： 123import d from &quot;./moude1.js&quot;; // 不需要加{}， 使用任意变量接收 等价为 import {default as d} from &quot;./moude1.js&quot;console.log(d); 注意：但是这个任意名字不包括default。 2.3.5 动态导入2.3.3 中我们说到 import 是静态执行，所以不能使用表达式和变量。 123456if (true) { import { foo } from &quot;method1&quot;;} else { import { foo } from &quot;method2&quot;;}// error 引擎处理import语句是在编译时，这时不会去分析或执行if语句。所以import语句放在if代码块之中毫无意义，因此会报句法错误，而不是执行时错误。这样的设计，固然有利于编译器提高效率，但也导致无法在运行时加载模块。在语法上，条件加载就不可能实现。ES2020 提案 引入import()函数，支持动态加载模块。 1import(specifier); 上面代码中，import函数的参数specifier，指定所要加载的模块的位置。 import()返回一个 Promise 对象。下面是一个例子： 123import(&quot;./moude1.js&quot;).then((data) =&gt; { console.log(data);}); 在这段代码中，then 中回调的 data 就是文件模块的整个文件对象（包括 export 和 export default）。 import()函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行，也就是说，什么时候运行到这一句，就会加载指定的模块。 import()类似于 Node 的require方法，区别主要是前者是异步加载，后者是同步加载。 适合场合 （1）按需加载。 import()可以在需要的时候，再加载某个模块。 123456789button.addEventListener(&quot;click&quot;, (event) =&gt; { import(&quot;./dialogBox.js&quot;) .then((dialogBox) =&gt; { dialogBox.open(); }) .catch((error) =&gt; { /* Error handling */ });}); 上面代码中，import()方法放在click事件的监听函数之中，只有用户点击了按钮，才会加载这个模块。 （2）条件加载 import()可以放在if代码块，根据不同的情况，加载不同的模块。 12345if (condition) { import('moduleA').then(...);} else { import('moduleB').then(...);} 上面代码中，如果满足条件，就加载模块 A，否则加载模块 B。 （3）动态的模块路径 import()允许模块路径动态生成。 12import(f()).then(...); 上面代码中，根据函数f的返回结果，加载不同的模块 注意点 import()加载模块成功以后，这个模块会作为一个对象，当作then方法的参数。因此，可以使用对象解构赋值的语法，获取输出接口。还是用之前的 moude1.js 举例。 123456789101112131415function sayHello() { console.log(&quot;module - 1 : sayHello函数&quot;);}let people = { hair: &quot;color&quot;,};let firstName = &quot;Michael&quot;;export { sayHello, people, firstName, foo };export default { name: &quot;default&quot;,}; 123import(&quot;./moude1.js&quot;).then(({ sayHello, people }) =&gt; { // ...·}); 上面代码中，sayHello和people都是myModule.js的输出接口，可以解构获得。 如果模块有default输出接口，可以用参数直接获得。 123import(&quot;./moude1.js&quot;).then((myModule) =&gt; { console.log(myModule.default);}); 上面的代码也可以使用具名输入的形式。 123import(&quot;./myModule.js&quot;).then(({ default: theDefault }) =&gt; { console.log(theDefault);}); 如果想同时加载多个模块，可以采用下面的写法。 12345678Promise.all([ import('./module1.js'), import('./module2.js'), import('./module3.js'),]).then(([module1, module2, module3]) =&gt; { ···}); import()也可以用在 async 函数之中。 12345678910async function main() { const myModule = await import(&quot;./myModule.js&quot;); const { export1, export2 } = await import(&quot;./myModule.js&quot;); const [module1, module2, module3] = await Promise.all([ import(&quot;./module1.js&quot;), import(&quot;./module2.js&quot;), import(&quot;./module3.js&quot;), ]);}main(); 2.4 export 与 import 的复合写法如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起。 12345export { foo, bar } from &quot;my_module&quot;;// 可以简单理解为import { foo, bar } from &quot;my_module&quot;;export { foo, bar }; 上面代码中，export和import语句可以结合在一起，写成一行。但需要注意的是，写成一行以后，foo和bar实际上并没有被导入当前模块，只是相当于对外转发了这两个接口，导致当前模块不能直接使用foo和bar。 模块的接口改名和整体输出，也可以采用这种写法。 12345// 接口改名export { foo as myFoo } from &quot;my_module&quot;;// 整体输出export * from &quot;my_module&quot;; 默认接口的写法如下。 1export { default } from &quot;./someModule&quot;; 具名接口改为默认接口的写法如下。 12345export { es6 as default } from './someModule';// 等同于import { es6 } from './someModule';export default es6; 同样地，默认接口也可以改名为具名接口。 1export { default as es6 } from &quot;./someModule&quot;; ES2020 之前，有一种import语句，没有对应的复合写法。 1import * as someIdentifier from &quot;./someModule&quot;; ES2020补上了这个写法。 12345export * as someIdentifier from &quot;./someModule&quot;;// 等同于import * as someIdentifier from &quot;./someModule&quot;;export { someIdentifier }; 2.5 例子模块 1（module1.js） 123456789101112131415161718let people = { hair: &quot;red&quot;,};let address = &quot;china&quot;;var foo = &quot;bar&quot;;setTimeout(() =&gt; (foo = &quot;baz&quot;), 500);export function sayHello() { console.log(&quot;module - 1 : sayHello函数&quot;);}export { people, address, foo as fooDelayedTest };export default { name: &quot;default&quot;,}; 模块 2 （module2.js） 1234567891011121314let address = &quot;Japan&quot;;export { address };export default { name: &quot;default2&quot;, init: function init(params) { console.log(init); }, baseInfo: { number: 0, length: 10, },}; 主引用 （main.js） 12345678910import * as m1 from &quot;./moude1.js&quot;; // 导入整个文件对象import { sayHello, address } from &quot;./moude1.js&quot;; // 导入部分接口import { fooDelayedTest } from &quot;./moude1.js&quot;; // 导入export中用as重命名后的接口import { address as japanAddress } from &quot;./moude2.js&quot;; // 导入address后重命名为peopleAddressimport def from &quot;./moude1.js&quot;; // 导入moude1.js中的默认接口import def2 from &quot;./moude2.js&quot;; // 导入moude2.js中的默认接口console.log(address);console.log(japanAddress);let { name, init, baseInfo } = def2; // 导出的默认接口可以被解构 2.6 试试问题 答案","link":"/2021/01/18/es6%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/"},{"title":"正则表达式","text":"PPT 在线查看(可下载)：https://www.yuque.com/heq286/xakx9r/10490826 视频回放地址：https://www.bilibili.com/video/BV1Ft4y1B768/ 以下内容为基本语法，详细请见 PPT 1 界定符定义：表示一个正则表达式的开始和结束 在 JavaScript 中，界定符以斜线（/）开始和结束： 1const reg = /正则表达式/; 可以这样理解：字符串是通过单引号或者双引号界定，那么正则的界定就好理解了吧。 2 原子定义：正则表达式中最小的匹配单位 分为：可见原子、不可见原子（空格、换行符等） 123const reg = /A/;const reg = /,/;const reg = / /; 以上正则表达式中，均只有一个原子。 可以这样理解：一篇文章的最小单位是一个文字或者一个单词，他们组合在一起就是一篇文章，正则表达式也是有原子组合而来的。 3 元字符定义：一系列原子的集合 作用：定义原子的筛选方式；对某一类原子归类缩写； 有三种筛选方式： 123原子|原子 // 表示：或（匹配其中一个原子即可）[原子原子...] // 表示：任一（匹配括号里的任一一个原子即可，原子之间不用竖线）[^原子原子...] // 表示：除此之外（和前一种情况相反） 中括号中，如果原子是连续的（ASCII 码），那么可以用横线（-）表示连续： 12[0123456789] = [0-9][abcdefghijklmn] = [a-n] 内置原子集合： 元字符 解释 等价于 . 除换行符之外任意一个字符 \\d 匹配任意一个十进制数 [0-9] \\D 匹配任意一个非十进制数 [^0-9] \\s 匹配一个不可见原子 [\\f\\n\\r\\t\\v] \\S 匹配一个可见原子 [^\\f\\n\\r\\t\\v] \\w 匹配任意一个数字、字母、下划线 [0-9a-zA-Z_] \\W 匹配任意一个非数字、字母、下划线 [^0-9a-za-z_] 可以这样理解：单词可以组成一句话，文章是由很多句话组成。元字符也是对一类原子组成的一小段，最终这些元字符汇聚就可以组成正则表达式。 4 量词定义：描述原子连续出现的次数 用法： 123原子{n} // 表示要前面紧邻的这个原子要匹配n次原子{n,} // 表示要前面紧邻的这个原子要匹配大于等于n次：半开半闭区间 [n, +无穷)原子{n,m} // 表示要前面紧邻的这个原子要匹配大于等于n次，小于等于m次：[n, m] 特殊量词： 特殊量词 解释 等价于 * 匹配&gt;=0 次之前的原子（可存在） {0,} + 匹配 1 次或多次之前的原子（存在） {1,} ? 匹配 0 次或 1 次之前的原子（可有可无） {0,1} 示例： 12/ES\\d{4}/ // 可以匹配到：ES000 ES2015 ES2020等/go{2,}gle/ // 可以匹配到：google gooooooogle等 5 边界控制定义：对目标位置的控制，以^表示开始，以$表示结束。 用法： 1234/go{2,}gle/ // &quot;This is google website!&quot; 可以匹配/^go{2,}gle/ // &quot;This is google website!&quot; 匹配失败 // &quot;google&quot; 可以匹配 此外边界控制还有模式单元()，小括号的作用可以将整体作为一个原子。 1234[Dd]( // 2个原子 D | d); // 1个原子 6 修正模式定义：给正则表达式的匹配过程设定一种模式 修正表达式 解释 i 忽略字母大小写 g 执行全局匹配（查找所有匹配而非在找到第一个匹配后停止） m 执行多行匹配。 用法： 1/正则表达式/i; 7 贪婪模式和懒惰模式定义： 贪婪模式：在条件允许的范围内，利益最大化（得寸进尺） 懒惰模式：达到最低标准即可（不思进取） 用法：量词后面加？表示懒惰模式 12tasssssk /s+/ 匹配结果：sssss (贪婪模式，可以匹配1个以上的s，那就全匹配)tasssssk /s+?/ 匹配结果：s (懒惰模式，可以匹配1个以上的s，那最低标准1个s) 贪婪模式 懒惰模式 解释 ? ?? 匹配 0 个或 1 个 + +? 匹配 1 个或多个 * *？ 匹配 0 个或多个 {n} {n}? 匹配 n 个 {n,m} {n,m}? 匹配 n 个或者 m 个 {n,} {n,}? 匹配 n 个或者多个 8 神奇的问号?正向断言：(?=原子) 表示后面必须接正向断言的原子，且匹配结果不包括该原子 负向断言：(?!原子)表示后面不能接正向断言的原子，匹配结果不包括该原子 12/string(?=s)/ 可以匹配：strings (匹配结果：stirng) 不可以匹配：stringS stringa/string(?!s)/ 可以匹配：stringS (匹配结果：string) 不可以匹配：strings ?:产生无编号分组： 12正则：/(ab)c(ba)/ /(?:ab)c(ba)/ /((a)(b))(c)/编号： 1 2 1 1 2","link":"/2021/01/29/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"title":"30分钟快速掌握微前端qiankun的所有核心技术","text":"一、引言微前端是什么？已经了解微前端的朋友可自行跳过本节，简单介绍下微前端，微前端是将前端更加细分化的一种技术方案，类似与后端微服务，下图所示 3 个可独立构建测试部署并可增量升级的不同技术栈应用，可以集成在一个基座应用中一起展示。 微前端是一种多个团队通过独立发布功能的方式来共同构建现代化 web 应用的技术手段及方法策略。 微前端架构具备以下几个核心价值： 技术栈无关主框架不限制接入应用的技术栈，微应用具备完全自主权 独立开发、独立部署微应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新 增量升级 在面对各种复杂场景时，我们通常很难对一个已经存在的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略 独立运行时每个微应用之间状态隔离，运行时状态不共享 演示一个微前端项目，其中菜单、地图都是微应用，菜单是 vue 项目，地图是 h5 项目，地图可独立运行，集成到基座中时原本入口的 html 会转换成 div，html 里的 css 会被转换成 style，js 会转换成字符串并通过 eval 函数直接执行。 微前端解决了什么问题？微前端架构旨在解决单体应用在一个相对长的时间跨度下，由于参与的人员、团队的增多、变迁，从一个普通应用演变成一个巨石应用(Frontend Monolith)后，随之而来的应用不可维护的问题。这类问题在企业级 Web 应用中尤其常见。 如何实现微前端？实现微前端需要解决的技术问题有： 应用接入 应用入口 应用隔离 样式隔离 应用通信 应用路由 为什么选择 qiankun？ 在利用 Single SPA 或其它微应用框架构建微前端系统中遇到的一些问题，如样式隔离、JS 沙箱、资源预加载、JS 副作用处理等等这些你需要的能力全部内置到了 qiankun 里面 到目前为止，已经大概有 200+ 的应用，使用 qiankun 来接入自己的微前端体系。qiankun 在蚂蚁内外受过了大量线上系统的考验，所以它是一个值得信赖的生产可用的解决方案。 短短一年时间，qiankun 已然成为最热门的微前端框架之一，虽然源码一直在更新，但是他的核心技术始终是那么几个：JS 沙箱、CSS 样式隔离、应用 HTML 入口接入、应用通信、应用路由等，接下来将通过演示demo的方式详细说明几种技术的设计与实现。 二、JS 沙箱隔离的设计与实现2.1 JS 沙箱简介JS 沙箱简单点说就是，主应用有一套全局环境window，子应用有一套私有的全局环境fakeWindow，子应用所有操作都只在新的全局上下文中生效，这样的子应用好比被一个个箱子装起来与主应用隔离，因此主应用加载子应用便不会造成JS 变量的相互污染、JS 副作用、CSS 样式被覆盖等，每个子应用的全局上下文都是独立的。 2.2 快照沙箱 - snapshotSandbox快照沙箱就是在应用沙箱挂载和卸载的时候记录快照，在应用切换的时候依据快照恢复环境。 demo 演示 实现代码 12345678// 子应用AmountSnapshotSandbox();window.a = 123;console.log(&quot;快照沙箱挂载后的a:&quot;, window.a); // 123unmountSnapshotSandbox();console.log(&quot;快照沙箱卸载后的a:&quot;, window.a); // undefinedmountSnapshotSandbox();console.log(&quot;快照沙箱再次挂载后的a:&quot;, window.a); // 123 123456789101112131415161718192021222324252627282930313233343536// snapshotSandbox.ts// 遍历对象key并将key传给回调函数执行function iter(obj: object, callbackFn: (prop: any) =&gt; void) { for (const prop in obj) { if (obj.hasOwnProperty(prop)) { callbackFn(prop); } }}// 挂载快照沙箱mountSnapshotSandbox() { // 记录当前快照 this.windowSnapshot = {} as Window; iter(window, (prop) =&gt; { this.windowSnapshot[prop] = window[prop]; }); // 恢复之前的变更 Object.keys(this.modifyPropsMap).forEach((p: any) =&gt; { window[p] = this.modifyPropsMap[p]; });}// 卸载快照沙箱unmountSnapshotSandbox() { // 记录当前快照上改动的属性 this.modifyPropsMap = {}; iter(window, (prop) =&gt; { if (window[prop] !== this.windowSnapshot[prop]) { // 记录变更，恢复环境 this.modifyPropsMap[prop] = window[prop]; window[prop] = this.windowSnapshot[prop]; } });} 优点 兼容几乎所有浏览器 缺点 无法同时有多个运行时快照沙箱，否则在 window 上修改的记录会混乱，一个页面只能运行一个单实例微应用 2.3 代理沙箱 - proxySandbox当有多个实例的时候，比如有A、B两个应用，A 应用就活在 A 应用的沙箱里面，B 应用就活在 B 应用的沙箱里面，A 和 B 无法互相干扰，这样的沙箱就是代理沙箱，这个沙箱的实现思路其实也是通过 ES6 的 proxy，通过代理特性实现的。 Proxy 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。简单来说就是，可以在对目标对象设置一层拦截。无论对目标对象进行什么操作，都要经过这层拦截 Proxy vs Object.definePropertyObject.defineProperty 也能实现基本操作的拦截和自定义，那为什么用 Proxy 呢？因为 Proxy 能解决以下问题： 删除或者增加对象属性无法监听到 数组的变化无法监听到（vue2 正是使用的 Object.defineProperty 劫持属性，watch 中无法检测数组改变的元凶找到了） demo 演示简单版本 实际场景版本 实现代码 简单版本 1234567891011121314151617181920212223242526const proxyA = new CreateProxySandbox({});const proxyB = new CreateProxySandbox({});proxyA.mountProxySandbox();proxyB.mountProxySandbox();(function (window) { window.a = &quot;this is a&quot;; console.log(&quot;代理沙箱 a:&quot;, window.a); // undefined})(proxyA.proxy);(function (window) { window.b = &quot;this is b&quot;; console.log(&quot;代理沙箱 b:&quot;, window.b); // undefined})(proxyB.proxy);proxyA.unmountProxySandbox();proxyB.unmountProxySandbox();(function (window) { console.log(&quot;代理沙箱 a:&quot;, window.a); // undefined})(proxyA.proxy);(function (window) { console.log(&quot;代理沙箱 b:&quot;, window.b); // undefined})(proxyB.proxy); 真实场景版本 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;body data-qiankun-A&gt; &lt;h5&gt;代理沙箱：&lt;/h5&gt; &lt;button onclick=&quot;mountA()&quot;&gt;代理沙箱模式挂载a应用&lt;/button&gt; &lt;button onclick=&quot;unmountA()&quot;&gt;代理沙箱模式卸载a应用&lt;/button&gt; &lt;button onclick=&quot;mountB()&quot;&gt;代理沙箱模式挂载b应用&lt;/button&gt; &lt;button onclick=&quot;unmountB()&quot;&gt;代理沙箱模式卸载b应用&lt;/button&gt; &lt;script src=&quot;proxySandbox.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; a 应用 js，在 a 应用挂载期间加载的所有 js 都会运行在 a 应用的沙箱(proxyA.proxy)中 123// a.jswindow.a = &quot;this is a&quot;;console.log(&quot;代理沙箱1 a:&quot;, window.a); b 应用 js，，在 b 应用挂载期间加载的所有 js 都会运行在 b 应用的沙箱(proxyB.proxy)中 123// b.jswindow.b = &quot;this is b&quot;;console.log(&quot;代理沙箱 b:&quot;, window.b); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455const proxyA = new CreateProxySandbox({});const proxyB = new CreateProxySandbox({});function mountA() { proxyA.mountProxySandbox(); fetch(&quot;./a.js&quot;) .then((response) =&gt; response.text()) .then((scriptText) =&gt; { const sourceUrl = `//# sourceURL=a.js\\n`; window.proxy = proxyA.proxy; eval( `;(function(window, self){with(window){;${scriptText}\\n${sourceUrl}}}).bind(window.proxy)(window.proxy, window.proxy);` ); });}function unmountA() { proxyA.unmountProxySandbox(); fetch(&quot;./a.js&quot;) .then((response) =&gt; response.text()) .then((scriptText) =&gt; { const sourceUrl = `//# sourceURL=a.js\\n`; eval( `;(function(window, self){with(window){;${scriptText}\\n${sourceUrl}}}).bind(window.proxy)(window.proxy, window.proxy);` ); });}function mountB() { proxyB.mountProxySandbox(); fetch(&quot;./b.js&quot;) .then((response) =&gt; response.text()) .then((scriptText) =&gt; { const sourceUrl = `//# sourceURL=b.js\\n`; window.proxy = proxyB.proxy; eval( `;(function(window, self){with(window){;${scriptText}\\n${sourceUrl}}}).bind(window.proxy)(window.proxy, window.proxy);` ); });}function unmountB() { proxyB.unmountProxySandbox(); fetch(&quot;./b.js&quot;) .then((response) =&gt; response.text()) .then((scriptText) =&gt; { const sourceUrl = `//# sourceURL=b.js\\n`; eval( `;(function(window, self){with(window){;${scriptText}\\n${sourceUrl}}}).bind(window.proxy)(window.proxy, window.proxy);` ); });} 代理沙箱代码 123456789101112131415161718192021222324252627// proxySandbox.tsfunction CreateProxySandbox(fakeWindow = {}) { const _this = this; _this.proxy = new Proxy(fakeWindow, { set(target, p, value) { if (_this.sandboxRunning) { target[p] = value; } return true; }, get(target, p) { if (_this.sandboxRunning) { return target[p]; } return undefined; }, }); _this.mountProxySandbox = () =&gt; { _this.sandboxRunning = true; }; _this.unmountProxySandbox = () =&gt; { _this.sandboxRunning = false; };} 优点 可同时运行多个沙箱 不会污染 window 环境 缺点 不兼容 ie 在全局作用域上通过 var 或 function 声明的变量和函数无法被代理沙箱劫持，因为代理对象 Proxy 只能识别在该对象上存在的属性，通过 var 或 function 声明声明的变量是开辟了新的地址，自然无法被 Proxy 劫持，比如 12345678910111213const proxy1 = new CreateProxySandbox({});proxy1.mountProxySandbox();(function (window) { mountProxySandbox(); var a = &quot;this is proxySandbox1&quot;; function b() {} console.log(&quot;代理沙箱1挂载后的a, b:&quot;, window.a, window.b); // undefined undefined})(proxy1.proxy);proxy1.unmountProxySandbox();(function (window) { console.log(&quot;代理沙箱1卸载后的a, b:&quot;, window.a, window.b); // undefined undefined})(proxy1.proxy); 一种解决方案是不用 var 和 function 声明全局变量和全局函数，比如 1234567var a = 1; // 失效a = 1; // 有效window.a = 1; // 有效function b() {} // 失效b = () =&gt; {}; // 有效window.b = () =&gt; {}; // 有效 三、CSS 隔离的设计与实现3.1 CSS 隔离简介页面中有多个微应用时，要确保 A 应用的样式 不会影响 B 应用的样式，就需要对应用的样式采取隔离。 3.2 动态样式表 - Dynamic Stylesheet 3.3 工程化手段 - BEM、CSS Modules、CSS in JS通过一系列约束和编译时生成不同类名、JS 中处理 CSS 生成不同类名来解决隔离问题 3.4 Shadow DOMShadow DOM 允许将隐藏的 DOM 树附加到常规的 DOM 树中——它以 shadow root 节点为起始根节点，在这个根节点的下方，可以是任意元素，和普通的 DOM 元素一样，隐藏的 DOM 样式和其余 DOM 是完全隔离的，类似于 iframe 的样式隔离效果。 移动端框架 Ionic 的组件样式隔离就是采用的 Shadow DOM 方案，保证相同组件的样式不会冲突。 demo 演示 代码实现 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;body data-qiankun-A&gt; &lt;h5&gt;样式隔离：&lt;/h5&gt; &lt;p class=&quot;title&quot;&gt;一行文字&lt;/p&gt; &lt;script src=&quot;scopedCSS.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 123// index.jsvar bodyNode = document.getElementsByTagName(&quot;body&quot;)[0];openShadow(bodyNode); 123456// scopedCss.jsfunction openShadow(domNode) { var shadow = domNode.attachShadow({ mode: &quot;open&quot; }); shadow.innerHTML = domNode.innerHTML; domNode.innerHTML = &quot;&quot;;} 优点 完全隔离 CSS 样式 缺点 在使用一些弹窗组件的时候（弹窗很多情况下都是默认添加到了 document.body ）这个时候它就跳过了阴影边界，跑到了主应用里面，样式就丢了 3.5 运行时转换样式 - runtime css transformer动态运行时地去改变 CSS ，比如 A 应用的一个样式 p.title，转换后会变成div[data-qiankun-A] p.title，div[data-qiankun-A] 是微应用最外层的容器节点，故保证 A 应用的样式只有在 div[data-qiankun-A] 下生效。 demo 演示 代码实现 12345678910111213141516171819&lt;!-- index.html --&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;style&gt; p.title { font-size: 20px; } &lt;/style&gt; &lt;/head&gt; &lt;body data-qiankun-A&gt; &lt;p class=&quot;title&quot;&gt;一行文字&lt;/p&gt; &lt;script src=&quot;scopedCSS.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var styleNode = document.getElementsByTagName(&quot;style&quot;)[0]; scopeCss(styleNode, &quot;body[data-qiankun-A]&quot;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435// scopedCSS.jsfunction scopeCss(styleNode, prefix) { const css = ruleStyle(styleNode.sheet.cssRules[0], prefix); styleNode.textContent = css;}function ruleStyle(rule, prefix) { const rootSelectorRE = /((?:[^\\w\\-.#]|^)(body|html|:root))/gm; let { cssText } = rule; // 绑定选择器, a,span,p,div { ... } cssText = cssText.replace(/^[\\s\\S]+{/, (selectors) =&gt; selectors.replace(/(^|,\\n?)([^,]+)/g, (item, p, s) =&gt; { // 绑定 div,body,span { ... } if (rootSelectorRE.test(item)) { return item.replace(rootSelectorRE, (m) =&gt; { // 不要丢失有效字符 如 body,html or *:not(:root) const whitePrevChars = [&quot;,&quot;, &quot;(&quot;]; if (m &amp;&amp; whitePrevChars.includes(m[0])) { return `${m[0]}${prefix}`; } // 用前缀替换根选择器 return prefix; }); } return `${p}${prefix} ${s.replace(/^ */, &quot;&quot;)}`; }) ); return cssText;} 优点 支持大部分样式隔离需求 解决了 Shadow DOM 方案导致的丢失根节点问题 缺点 运行时重新加载样式，会有一定性能损耗 四、清除 js 副作用的设计与实现4.1 清除 js 副作用简介子应用在沙箱中使用 window.addEventListener、setInterval 这些 需异步监听的全局api 时，要确保子应用在移除时也要移除对应的监听事件，否则会对其他应用造成副作用。 4.2 实现清除 js 操作副作用 demo 演示 代码实现 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;body&gt; &lt;h5&gt;清除window副作用：&lt;/h5&gt; &lt;button onclick=&quot;mountSandbox()&quot;&gt;挂载沙箱并开启副作用&lt;/button&gt; &lt;button onclick=&quot;unmountSandbox(true)&quot;&gt;卸载沙箱并关闭副作用&lt;/button&gt; &lt;button onclick=&quot;unmountSandbox()&quot;&gt;普通卸载沙箱&lt;/button&gt; &lt;script src=&quot;proxySandbox.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;patchSideEffects.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334353637let mountingFreer;const proxy2 = new CreateProxySandbox({});function mountSandbox() { proxy2.mountProxySandbox(); // 在沙箱环境中执行的代码 (function (window, self) { with (window) { // 记录副作用 mountingFreer = patchSideEffects(window); window.a = &quot;this is proxySandbox2&quot;; console.log(&quot;代理沙箱2挂载后的a:&quot;, window.a); // undefined // 设置屏幕变化监听 window.addEventListener(&quot;resize&quot;, () =&gt; { console.log(&quot;resize&quot;); }); // 定时输出字符串 setInterval(() =&gt; { console.log(&quot;Interval&quot;); }, 500); } }.bind(proxy2.proxy)(proxy2.proxy, proxy2.proxy));}/** * @param isPatch 是否关闭副作用 */function unmountSandbox(isPatch = false) { proxy2.mountProxySandbox(); console.log(&quot;代理沙箱2卸载后的a:&quot;, window.a); // undefined if (isPatch) { mountingFreer(); }} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// patchSideEffects.jsconst rawAddEventListener = window.addEventListener;const rawRemoveEventListener = window.removeEventListener;const rawWindowInterval = window.setInterval;const rawWindowClearInterval = window.clearInterval;function patch(global) { const listenerMap = new Map(); let intervals = []; global.addEventListener = (type, listener, options) =&gt; { const listeners = listenerMap.get(type) || []; listenerMap.set(type, [...listeners, listener]); return rawAddEventListener.call(window, type, listener, options); }; global.removeEventListener = (type, listener, options) =&gt; { const storedTypeListeners = listenerMap.get(type); if ( storedTypeListeners &amp;&amp; storedTypeListeners.length &amp;&amp; storedTypeListeners.indexOf(listener) !== -1 ) { storedTypeListeners.splice(storedTypeListeners.indexOf(listener), 1); } return rawRemoveEventListener.call(window, type, listener, options); }; global.clearInterval = (intervalId) =&gt; { intervals = intervals.filter((id) =&gt; id !== intervalId); return rawWindowClearInterval(intervalId); }; global.setInterval = (handler, timeout, ...args) =&gt; { const intervalId = rawWindowInterval(handler, timeout, ...args); intervals = [...intervals, intervalId]; return intervalId; }; return function free() { listenerMap.forEach((listeners, type) =&gt; [...listeners].forEach((listener) =&gt; global.removeEventListener(type, listener) ) ); global.addEventListener = rawAddEventListener; global.removeEventListener = rawRemoveEventListener; intervals.forEach((id) =&gt; global.clearInterval(id)); global.setInterval = rawWindowInterval; global.clearInterval = rawWindowClearInterval; };}function patchSideEffects(global) { return patch(global);} 未完待续下期会接着从应用接入的设计与实现、通信的设计与实现、应用路由监听的设计与实现继续探秘微前端技术，敬请期待，如果觉得本文内容对您有帮助，请点个赞支持，你们的支持就是偶更新滴动力！ 参考资料： 微前端连载 6/7：微前端框架 - qiankun 大法好 qiankun 官方文档","link":"/2021/01/31/30%E5%88%86%E9%92%9F%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1%E5%BE%AE%E5%89%8D%E7%AB%AFqiankun%E7%9A%84%E6%89%80%E6%9C%89%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"},{"title":"Windows OpenSSH 安装与配置","text":"1 目的实现免密远程登录到 Windows 服务，并可以进行文件传输扩展知识：SSH 2 安装2.1 根据系统情况，下载程序包下载地址：[https://github.com/PowerShell/Win32-OpenSSH/releases](https://github.com/PowerShell/Win32-OpenSSH/releases) 比如我的服务器系统是64位的，下载的[OpenSSH-Win64.zip](https://github.com/PowerShell/Win32-OpenSSH/releases/download/v8.1.0.0p1-Beta/OpenSSH-Win64.zip) 2.2 解压在第一步下载的压缩包内容到 C:\\Program Files\\OpenSSH2.3 将以上目录配置环境变量中 验证： 2.4 使用管理员命令行工具运行以下命令，安装 SSH 服务命令行进入到OpenSSH文件夹目录（这里为：C:\\Program Files\\OpenSSH），执行以下命令 1powershell.exe -ExecutionPolicy Bypass -File install-sshd.ps1 2.5 在防火墙开启端口 22 端口号(命令行窗口)1New-NetFirewallRule -Name sshd -DisplayName 'OpenSSH Server (sshd)' -Enabled True -Direction Inbound -Protocol TCP -Action Allow -LocalPort 22 注意：Windows10 以及 Windows 2008 R2 以下版本请使用以下命令(命令行窗口) 1netsh advfirewall firewall add rule name=sshd dir=in action=allow protocol=TCP localport=22 2.6 启动 SSH 服务(命令行窗口)1net start sshd 2.7 设置 SSH 服务开机启动（以下操作，在不同系统版本内设置稍有不同，大致操作一致）点击左下角服务器管理器 找到服务选项以下为 Windows server 2012 r2 截图，跟上图老版本的系统稍微有些差别找到 OpenSSH SSH Server 服务（进入列表后输入 O）可快速找到该服务，选中服务右键属性，将启动类型改为自动 2.8 测试是否可以连接通过带有 SSH 客户端的机器测试这里使用 Win10 自带 SSH 功能远程连接(命令行窗口)命令格式：ssh 用户名@ip 1ssh weihu@192.168.0.183 使用以上命令时，大家可能看到还需要输入用户名密码才能连接上服务器，这个还没达到咱们要实现的目的 3 配置免密登录3.1 修改 SSH 配置修改 C:\\ProgramData\\ssh\\sshd_config 文件 将文件中以下配置解开注释 123PubkeyAuthentication yesAuthorizedKeysFile .ssh/authorized_keysPasswordAuthentication no 将文件中以下配置注释掉 1#Match Group administrators#AuthorizedKeysFile __PROGRAMDATA__/ssh/administrators_authorized_keys 修改默认配置，配置ssh 默认可访问的根目录 1ChrootDirectory D:\\ 重启 sshd 服务 配置客户端公钥 将客户端公钥文件内容拷贝进入服务器 authorized_keys（文件不存在就创建），文件中 C:\\Users\\用户名.ssh\\authorized_keys说明：由于 Windows 默认不允许创建.开头的文件夹，这里使用命令创建（mkdir .ssh）客户端公钥如何获取，请查看下面章节 免密登录验证 1ssh weihu@192.168.0.183 此时再进行连接时，就不需要输入密码直接连接成功了 4 其他4.1 客户端 SSH 密钥获取 在本地（客户端）生成公钥（需要安装openssh，win10及Windows Server 2019以上版本自带ssh功能，无需再安装，如果需要安装，可按照章节“安装”中1.2.3步骤配置客户端） 执行以下命令前，先检查C:\\Users\\你的用户.ssh目录下是否已经存在.pub结尾的文件，如果存在，无需执行以下命令，该文件即为公钥文件。不存在时，执行以下命令生成密钥 1ssh-keygen -t rsa 使用文本编辑器打开上一步骤中.pub结尾的文件，拷贝里边的内容，即为公钥内容 注：这里的说的客户端是相对的，如果服务器 A 通过 SSH 访问服务器 B，那A也是客户端。 4.2 免密拷贝文件 从本地复制文件到远程服务器 命令格式：scp [-r] 本地路径 远程服务器用户名@远程服务器ip:远程服务器相对配置根路径的目录 1// 拷贝单个文件scp 工具\\hello.txt weihu@192.168.0.183:/Product// 拷贝目录（多文件）scp -r dist/* weihu@192.168.0.183:/Product/test 从服务器往本地复制文件 将以上命令本地和服务器参数对调下即可了解更多：https://www.runoob.com/linux/linux-comm-scp.html 4.3 执行远程主机上命令行命令格式：ssh 用户@主机ip “命令”以下示例实现了进入/Product/test目录，并查看目录信息及主机安装node版本信息 1ssh weihu@192.168.0.183 &quot;cd /Product/test &amp;&amp;dir&amp;&amp;node -v&quot;","link":"/2021/02/04/Windows-OpenSSH%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"},{"title":"GitLab-从零打造自己的 CI&#x2F;CD 系统","text":"1 为什么要做 CI/CD（持续集成、持续交付、持续部署）1.1 公司项目/产品开发-发布现状 开发人员开发阶段通过代码仓库实现多人协作开发。 开发完成后，开发人员在本机运行编译，等待编译打包。 打包完后通过远程桌面部署最新的包到测试环境。 通知测试人员进行测试验证。 测试人员反馈 BUG，开发人员修改后，重复 2.3.4。 测试通过，准备某个晚上半夜或者周末上线生产环境。 测试人员等待到半夜或者周末验证生产环境系统。 1.2 存在问题1.2.1 工作效率低重复性工作较多，编译打包的过程浪费开发资源，每次测试部署正常 10 到 20 分钟。 1.2.2 容易出现低级错误产品/项目成果交付全部采用手工操作，打包编译过程中各种莫名其妙问题。 1.2.3 不能尽早的发现问题，要花费更大的代价修复项目经理及需求人员不清楚项目进展，不能提前把空风险；开发团队成员间不能及时发现合并代码后的问题。 1.2.4 功能开发完后，发现不是客户想要的效果一般都是等项目整体功能开发完成后给客户看，客户不能尽早看到成果，最后发现不是想要的效果。 1.2.5 测试深度不够，上线项目问题较多测试人员测试基本属于功能性测试，上线后往往发现一些未测试到的功能及问题。 1.2.6 测试成本较高需要投入大量的测试人员进行测试存在以上这些问题，我们应该要怎么做呢？ 1.3 CI/CD（持续集成、持续交付、持续部署）要解决以上问题，可以通过软件开发的持续方法来解决。软件开发的持续方法是基于自动执行脚本，以最大程度地减少在开发时引入错误的机会。从开发新代码到部署新代码，几乎不需要人工干预，甚至根本不需要干预。它涉及到在每次小的迭代中就不断地构建，测试和部署代码更改，从而减少了基于错误或失败的先前版本开发新版本代码的机会。使用软件开发的持续方法能够实现快速迭代，保持高质量，避免不必要的成本投入。 1.3.1 持续集成 CI（Continuous integration）通过持续合并团队开发人员代码并进行自动化构建及测试来确保没有集成问题并及早发现任何问题的一种做法。投入： 需要为每个新功能，改进或错误修复编写自动化测试。（单元测试、集成测试等） 需要一个持续集成服务器（jenkins、GitLab CI），该服务器可以监视代码仓库并针对推送的每个新提交自动运行测试。 尽可能多地提交代码，合并更改。 产出： 减少 BUG，因为通过自动化测试可以获取测试结果，避免将一些问题提交到交付生产中。 编译部署产品更顺利，因为集成时问题都已解决。 开发者可以无缝工作，不需要间断的来解决问题，因为开发者可以很快获得构建失败的结果，在开始下一个任务之前就可以很快解决。 测试成本降低，因为集成服务器可以一秒运行几百个测试用例。 测试团队花更少的时间测试，可以重点关注测试上的改进。 1.3.2 持续交付 CD（Continuous Delivery）在持续集成的基础上，进行验收测试（QA）,通过验收测试后发布到预发布环境中，预发布环境到生产环境的发布，需要通过手动点击触发自动部署。也就是所有的变更都可以被部署到生产环境中，但是不会自动触发部署。投入： 要有持续集成的基础，测试用例需要覆盖足够的代码。 部署需要自动化，只是触发部署是手动的。 团队需要增加新功能标识，避免未完成的新功能进入待发布的产品。 产出： 部署软件变得非常简单。团队不需要提前几天准备发布。 可以提高发布频率，用户可以尽早接触到新功能。 每次都是小的更改，对决策的压力要小得多，可以更快地迭代。 1.3.3 持续部署 CD（Continuous Deployment）在持续集成的基础上，进行验收测试（QA）,通过验收测试后发布到预发布环境中，预发布环境到生产环境的发布自动完成。持续部署可以加速用户反馈新功能，避免发布日带来的压力。开发可以着力于开发系统，开发结束后几分钟就可以触达到用户。投入： 测试必须要做到足够。测试的质量将决定发布的质量。 文档建设需要和产品部署保持同步。 新功能的发布需要协调其他部门，包括售后支持&amp;市场&amp;推广等。 产出： 快速的发布节奏，因为每个新功能一旦完成都会自动的发布给用户。 发布风险降低，修复问题更容易，因为每次变更都是小步迭代发布。 用户可以看到持续性的优化和质量提升，而不是非要等到按月，按季度，甚至按年。 1.3.4 它们之间的关系持续集成是持续交付和持续部署的一部分。持续部署和持续交付区别在于持续部署是自动执行发布，持续交付需要手动点击触发自动发布。![CICD之间关系](CICD 之间关系.png) 2 GitLab2.1 GitLab CI/CDGitLab CI / CD 是 GitLab 内置的工具，可以将所有软件开发的持续方法（持续集成、持续交付、持续部署）应用于软件，而无需第三方应用程序。（使用过 Jenkins 的，可以理解为他跟 Jenkins 一样的功能，只是它是 GitLab 自带的，使用起来更简单） 2.2 GitLab-RunnerGitLab Runner 用于运行项目持续集成、持续部署脚本并将结果发送回 GitLab，与 GitLab CI/CD 一起使用。 2.3 GitLab、GitLab CI 、GitLab-Runner 关系开发推送代码到 GitLab，GitLab 检测项目中是否存在 .gitlab-ci.yml 配置，通过该配置找到指定的 GitLab-Runner，runner 执行提前配置好的脚本，进行编译、 集成、测试、交付、部署，一切顺利地话会分发到各个服务器（测试服务器、预发布服务器、正式服务器等），此时一个迭代开发上线流程走完。 2.4 .gitlab-ci.yml项目根目录下的一个文件，记录了一系列的阶段和执行规则。GitLab-CI 在检测到代码 push 后会解析它，根据里面的内容调用该项目可访问的 Runner 来运行。 2.4.1 YAML 常用语法说明 通过类似大纲的缩进方式组织层级（空格，不能使用跳格字符(TAB)） 12345job1: script: &quot;execute-script-for-job1&quot;job2: script: &quot;execute-script-for-job2&quot; “# “号注释，而且只能是一行的注释，也就是单行注释 12job1: # 这是一个注释 script: &quot;execute-script-for-job1&quot; 短杠+空格+内容表示数组的一项，以下例子中代表 stages 里边有三项，转换为 JSON 来理解的话是{“stages”:[“build”,”test”,”deploy”]} 1234stages: - build - test - deploy 对象使用冒号+空格（ : ）分开键值和内容，以下例子中代表 variables 里边有三项，转换为 JSON 来理解的话是{“variables”:{“deployServer”:”weihu@192.168.0.183“,”deployDirectory”:”……”,”deployWebUrl”:”…….”}} 1234variables: deployServer: weihu@192.168.0.183 deployDirectory: \\Product\\test\\nginx-1.18.0\\html\\pinxx deployWebUrl: http://192.168.0.183:8104/pinxx 字符串可以不加引号 12variables: deployTarget: weihu@192.168.0.183:/Product/test/ 了解更多：https://zh.wikipedia.org/wiki/YAML 2.4.2 相关概念 Pipeline（流水线）：每次推送到 GitLab 的代码会根据项目 .gitlab-ci.yml 文件产生一个流水线，流水线就是一个分成不同阶段(stage)的作业(job)的集合。 Stage（阶段）：阶段是对批量的作业(job)的一个逻辑上的划分，每个 GitLab CI/CD 都必须包含至少一个 Stage。多个 Stage 默认是按照顺序执行的，默认情况下如果其中任何一个 Stage 失败，则后续的 Stage 不会被执行，整个 CI 过程被认为失败，当然这种默认行为也可以通过配置去修改它。 job（作业）：作业就是运行器(Runner)要执行的指令集合。当一个 Stage 执行的时候，与其关联的所有 Job 都会被执行。在有足够 Runner 的前提下,同一阶段的所有作业会并发执行。作业状态直接影响阶段的状态。 2.4.3 常用配置（点击关键词有惊喜） 关键词 描述 script 在作业里边会被 runner 执行的脚本，脚本执行的目录为你项目的目录 after_script 在作业运行后执行的脚本，可以全局定义，也可以在作业中定义 allow_failure 允许一个作业失败后影响流水线的失败 artifacts 翻译过来是制品的意思，会将流水线过程中的一些文件、文件夹打包生成一个外部可下载的链接，还用于在后续作业中传递缓存。有以下属性：1.paths 文件路径 2.exclude 要排除的文件 3.name 制品名称 4.expose_as 在 UI 页面导出名 5.untracked 布尔类型，是否将 git 忽略的文件加到制品中 6.when on_success；on_failure；always 何时上传制品 7.expire_in 过期时间默认 30 天 8.reports 收集测试报告 before_script 在作业运行前执行的脚本，可以全局定义，也可以在作业中定义 cache 缓存一些文件，用于后续任务使用。比如 node_modules、maven 下载的包这些缓存下来，可以大大优化流水线效率 coverage 用于获取项目的代码覆盖率 dependencies 提供要从哪些作业获取制品 environment 作业部署到的环境 except 限定什么条件下不创建作业 extends 配置作业继承的一些配置条目 image 指定 docker 镜像为基础运行环境 include 引入外部的 YAML 文件 interruptible 定义在新的运行使其冗余时是否可以取消该作业 only 可以限定特定分支，特定 tag 等才执行作业 pages 用于将静态内容上传到 GitLab parallel 一个作业并行多少个实例 release 用于创建一个 release resource_group 限制作业并发执行 retry 设置一个任务在某种情况下的重试次数 rules 规定任务的执行规则，使用表达式来确定哪些作业执行哪些不执行等等 services 使用 docker 服务镜像 stage 翻译过来是阶段的意思，用于归类作业，按照阶段定义的顺序来执行 tags 指定该项目可访问范围内用于执行任务的 runner，跟注册 runner 时的 tag 对应 timeout 设置一个任务的超时时间 trigger 一个项目的流水线触发另一个项目的流水线执行 variables 定义变量 when 什么时候去运行这个作业. 比如: when:manual 手动执行一个作业、 when:delayed延迟执行作业 了解更多：https://docs.gitlab.com/ee/ci/yaml/README.html配置示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647before_script: - echo &quot;Start pipelines&quot;variables: deployTarget: weihu@192.168.0.183:/Product/test/cache: key: files: - package.json paths: - node_modulesstages: - build - test - deploybuild-job: before_script: - echo &quot;Start build job&quot; stage: build tags: - vue script: - echo &quot;build ..........&quot; after_script: - echo &quot;End of build&quot;test-job: before_script: - echo &quot;Start test job&quot; stage: test tags: - vue script: - echo &quot;test..........&quot; after_script: - echo &quot;End of test&quot;deploy-job: before_script: - echo &quot;Start deploy job&quot; stage: deploy tags: - vue script: - echo &quot;deploy..........&quot; after_script: - echo &quot;End of deploy&quot;after_script: - echo &quot;End of pipelines&quot; 2.5 通知通过设置通知您可以随时了解 GitLab 中发生了什么事情，比如可以设置通知获取 CI 构建结果。 2.5.1 编辑通知 编辑通知设置： 点击个人资料图片，然后选择设置 。 点击左侧边栏中的通知 。 编辑所需的通知设置。 编辑的设置将自动保存并启用。 这些通知设置仅适用于您。 它们不会影响同一项目或组中其他任何人收到的通知。 2.5.2 通知设置示例需求：设置 xxx 项目只在构建失败后发送通知邮件。 了解更多 3 快速上手3.1 场景实现产品拼夕夕（vue 的 PC 端站点）在开发人员提交一个小功能到代码仓库后自动部署到测试服务器上，产品经理可以及时看到产品开发情况,开发人员也能及时发现集成的问题。 3.2 环境准备3.2.1 部署应用的测试服务器环境 这里使用一台 Windows server 2008 R2 Enterprise，服务器 IP 为 192.168.0.183，服务器用户名 weihu。 服务器 web 容器安装：这里使用 nginx,nginx 静态资源目录为默认的 D:\\Product\\test\\nginx-1.18.0\\html\\，端口设置为 8104，在 html 目录下创建 pinxx 目录用于部署拼夕夕产品（服务器已有其他 web 容器也可以直接使用，比如 node 服务、tomcat 等） 安装服务器的 OpenSSH 并配置免密登录，参照以下文档配置：https://www.yuque.com/docs/share/d3254cc2-2f11-4080-8af1-4b267b6c8235?# 《Windows OpenSSH》 注：同一台服务器/ PC，只需要配置一次 OpenSSH，其他项目都可以基于此 SSH 进行远程配置。 3.2.2 GitLab-Runner 安装 这里使用一台 Windows server 2012 R2 Standard,服务器 IP 为 192.168.0.231，服务器用户名为 administrator。（也可以直接使用上边 183 的服务器进行安装，这里是为了演示通过 SSH 远程部署） 安装配置 GitLab-Runner，参照以下文档配置：https://www.yuque.com/docs/share/36b9f6ce-a9e2-47ff-ad4c-61a4b3f4256f?# 《GitLab-Runner 安装配置(windows)》 注：一台安装了 GitLab-Runner 的服务器/PC 可以供多个项目使用，具有相同打包需求的项目，可以使用已有的 GitLab-Runner。 3.3 项目配置假设拼夕夕项目代码已经上传至代码仓库 GitLab，在“GitLab-Runner 安装”章节也已经为该项目注册了 tags 为“android、node、vue、ionic”的 GitLab-Runner。 添加 CI/CD 配置文件：登录 GitLab 打开拼夕夕项目详情页面，点击“Set up CI/CD”配置按钮，会打开新建 .gitlab-ci.yml 页面（也可以在自己本机项目根目录新建该文件）。 在打开的 .gitlab-ci.yml 文件中，编写以下内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475before_script: - echo &quot;Start pipelines&quot; # 定义变量variables: # 部署的服务器 deployServer: weihu@192.168.0.183 # 部署的服务器位置（相对ssh 根路径） deployDirectory: \\Product\\test\\nginx-1.18.0\\html\\pinxx # 测试环境地址 deployWebUrl: http://192.168.0.183:8104/pinxx # npm 源地址 npmRegistry: http://192.168.0.180:4873 # sassBinary 下载源 sassBinaryDownloadUrl: https://npm.taobao.org/mirrors/node-sass/# 定义三个阶段stages: - build - test - deploy# 定义build作业build-job: before_script: - echo &quot;Start build job&quot; stage: build tags: - vue script: - echo &quot;build ..........&quot; - npm config set registry $npmRegistry - npm config set sass_binary_site $sassBinaryDownloadUrl - npm install - npm run build cache: key: files: - package.json paths: - node_modules after_script: - echo &quot;End of build&quot; artifacts: expire_in: 1 week paths: - dist/# 定义一个测试作业test-job: before_script: - echo &quot;Start test job&quot; stage: test tags: - vue script: - echo &quot;test..........&quot; after_script: - echo &quot;End of test&quot;# 定义个部署作业deploy-job: before_script: - echo &quot;Start deploy job&quot; stage: deploy dependencies: - build-job tags: - vue script: - echo &quot;deploy..........&quot; - scp -r dist/* $deployServer':'$deployDirectory environment: name: staging url: $deployWebUrl after_script: - echo &quot;End of deploy&quot;after_script: - echo &quot;End of pipelines&quot; 提交以上文件会自动触发流水线，可以切换到流水线页面查看流水线执行进度。","link":"/2021/02/02/GitLab-%E4%BB%8E%E9%9B%B6%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E7%9A%84CICD%E7%B3%BB%E7%BB%9F/"},{"title":"基于 qiankun 的微前端应用实践","text":"业务背景大鹏地图可视化大屏项目是一个集地图应用和视图应用为一体的大屏应用，通过头部菜单可切换视图应用，视图应用包括左右两边的内容展示区域，视图应用可以和地图应用通信和交互。项目采用Vue3 搭建，核心问题在于，3D 地图如果使用iframe 方式集成，那么性能和用户体验会大幅降低，为了解决这个问题，我们采用微前端服务框架 qiankun 成功将地图 h5 应用和 Vue3 视图应用以 DOM 的方式嵌入同一个页面中，这些嵌入的应用就称为微应用，下图中的地图应用和视图应用均为微应用。 为什么采用微前端方案 1.技术栈无关 - 支持接入任意技术栈的应用，支持未来任何技术栈 试想一下，5 年前的 Angular.js 在当时也是非常火的技术栈，许多大型项目都在用，然而技术每年都会迭代更新，每年前端都只会学习使用最新的技术栈，如今的 Angular.js 已经几乎无人问津，而当初用这在当时很热门的技术栈搭建的项目，现在却已是没人想去改、去优化、去移植、甚至没人会修改的地步。 2.可独立开发、测试、部署 - 不同团队或人员维护对应应用，职责拆分，从巨石解耦，加快构建和开发 你能想象把百度和谷歌放在一个页面里同时运行吗？甚至是把 qq 音乐、网易云音乐、酷狗音乐放在一个页面里运行？没错，微前端他实现了，你可以随时把一个应用单独拿出来开发、部署，同时也能在一个基座中将这些单独的应用集成进来组合成新的应用。 3.增量升级 - 不用打包全部代码更新升级，快速且更有针对性 抛开以前传统应用的整体打包升级方式，微前端方案是将细粒度更小的应用组合成一个大的应用，因此只需要小应用升级即可，好比你有一套房，只需要对其中一个房间进行升级改造，其余房间丝毫不用动。 4.独立运行时 每个微小应用都拥有自己的独立运行时上下文，也就是说他们的 js、css 环境是互相不受影响的，比如 A 应用修改了 window.a，B 应用也修改了 window.a，但他们的 window 不是同一个 window对象，故不会造成变量污染。 方案实践基座应用改造基座采用 vue-cli 搭建，子应用也一样用 vue-cli 搭建，技术栈统一为 Vue3，后续接入子应用可以接入其他技术栈的应用。 安装 qiankun1npm install qiankun -P 路由配置让 /home 作为整个基座和子应用的共同主路由 123456789101112131415161718192021222324252627282930313233// router/index.tsconst Login = () =&gt; import(&quot;../views/login.vue&quot;);const Home = () =&gt; import(&quot;../views/home.vue&quot;);const NotFound = () =&gt; import(&quot;@/components/exception/not-found.vue&quot;);// 首次必然要加载的路由const routes: Array&lt;any&gt; = [ // 默认进入首页 { path: &quot;&quot;, redirect: { name: &quot;home&quot;, }, }, { path: &quot;/&quot;, redirect: { name: &quot;home&quot;, }, }, { path: &quot;/home&quot;, name: &quot;home&quot;, component: Home, }, // 全不匹配的情况下，返回404 { path: &quot;/:catchAll(.*)&quot;, component: NotFound, },];export default routes; 基座通过 createWebHashHistory 创建 hash 路由，使用 history 和 memory 路由也可以 1234567891011// main.tsimport routes from &quot;./router&quot;;function render() { router = createRouter({ history: createWebHashHistory(), routes, }); instance.use(router);} 配置导航菜单点击菜单要切换视图子应用，因此菜单每个选项都应该包含一个应用信息，包括目录 id，名称、入口、挂载容器 id，用于切换视图微应用。 导航目录的数据结构如下，真实场景是通过接口获取的，便于动态修改 12345678910111213141516171819202122232425262728// menu.tsexport default [{ &quot;id&quot;: 1, // 目录id &quot;name&quot;: &quot;蓝天&quot;, // 目录名称 &quot;app&quot;: { &quot;name&quot;: &quot;vue3-air-app&quot;, // 应用名称 &quot;entry&quot;: { &quot;dev&quot;: &quot;//localhost:8081/&quot;, // 开发版应用入口 &quot;product&quot;: &quot;http://182.48.115.108:8887/vue3-air-app/&quot; // 线上版应用入口 }, &quot;container&quot;: &quot;#microapp&quot; // 挂载容器id }, &quot;active&quot;: false}, { &quot;id&quot;: 2, &quot;name&quot;: &quot;碧水&quot;, &quot;app&quot;: { &quot;name&quot;: &quot;vue3-water-app&quot;, &quot;entry&quot;: { &quot;dev&quot;: &quot;//localhost:8082/&quot;, &quot;product&quot;: &quot;http://182.48.115.108:8887/vue3-water-app/&quot; }, &quot;container&quot;: &quot;#microapp&quot; }, &quot;active&quot;: false},……] 当菜单切换时，通过 loadMicroApp 加载菜单中的应用信息即可完成视图应用的切换，例如 1234567891011121314import { loadMicroApp } from &quot;qiankun&quot;;import MENU from &quot;./menu&quot;;const isProd = process.env.NODE_ENV === &quot;production&quot;; // 是否开发环境// 菜单切换function onChangeMenu(id) { const currentApp = MENU.find((menu) =&gt; menu.id === id).app; loadMicroApp({ name: currentApp.name, entry: currentApp.entry[isProd ? &quot;dev&quot; : &quot;product&quot;], container: currentApp.container, props: {}, });} 加载微应用基座加载微应用有两种方式，一种是通过 registerMicroApps 注册子应用信息包括子应用的名称(name)、入口(entry)、挂载容器 id(container)、路由匹配规则(activeRule)**，注册后的应用会根据浏览器url 的变化来匹配对应的子应用并加载，第二种是通过 loadMicroApp 来手动加载子应用，也是需要传入子应用的名称、入口、挂载容器 id，不过是少了路由匹配规则，他能让你的子应用立即挂载，无须匹配任何路由规则，本项目采用的是 loadMicroApp，因为要同时加载地图应用和视图应用**。 loadMicroApp 使用说明 作用：通过 qiankun 的loadMicroApp 函数实现在基座中挂载/卸载子应用。 优点：在一个页面中可以同时挂载多个微应用，比如可以同时挂载地图应用和视图应用。 缺点：无法根据路由匹配规则来挂载应用，因为一个路由只能匹配一个应用。 适用场景：当需要在一个页面中同时挂载 2 个以上子应用，并且子应用的挂载不需要通过路由匹配来实现。 demo 演示 代码实现 1234567&lt;!-- template --&gt;&lt;template&gt; &lt;div class=&quot;container&quot;&gt; &lt;div id=&quot;micro-app1&quot;&gt;&lt;/div&gt; &lt;div id=&quot;micro-app2&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 123456789101112131415// main.tsimport { loadMicroApp } from &quot;qiankun&quot;;loadMicroApp({ name: &quot;app1&quot;, // 应用唯一名称 entry: &quot;//localhost:8088/&quot;, // 应用唯一HTML入口，可以省略index.html container: &quot;#micro-app1&quot;, // 基座挂载该应用的容器DOM的id props: {}, // 基座传递给微应用的参数，微应用通过mount生命周期函数的参数props获取});loadMicroApp({ name: &quot;app2&quot;, entry: &quot;//localhost:8089/&quot;, container: &quot;#micro-app2&quot;, props: {},}); 注意：loadMicroApp 重复挂载 name 和 container 一样的应用是会出错的，比如下面操作 1234567891011121314151617181920212223// main.tsimport { loadMicroApp } from &quot;qiankun&quot;;loadMicroApp({ name: &quot;app1&quot;, // 应用唯一名称 entry: &quot;//localhost:8088/&quot;, // 应用唯一HTML入口，可以省略index.html container: &quot;#micro-app1&quot;, // 基座挂载该应用的容器DOM的id props: {}, // 基座传递给微应用的参数，微应用通过mount生命周期函数的参数props获取});loadMicroApp({ name: &quot;app2&quot;, entry: &quot;//localhost:8088/&quot;, container: &quot;#micro-app2&quot;, props: {},});// 这里重复挂载上面的应用后，页面会变成空白loadMicroApp({ name: &quot;app2&quot;, entry: &quot;//localhost:8089/&quot;, container: &quot;#micro-app2&quot;, props: {},}); 解决方案：通过 loadMicroApp 进一步封装了 switchMicroApp 函数，实现根据应用的挂载情况来决定如何切换应用，首次挂载应用时直接调用 loadMicroApp 加载应用，非首次挂载应用时，则需要先卸载之前挂载的应用后才挂载新的应用。 12345678910111213141516171819202122232425262728293031323334353637383940import { LoadableApp, loadMicroApp } from &quot;qiankun&quot;;// loadMicroApp的实例对象const contentApp: any = ref(null);/** * 切换微应用 * @param runningMicroApp qiankun规定的微应用配置对象 */function switchMicroApp(runningMicroApp: LoadableApp&lt;any&gt;) { const microApp = runningMicroApp; // 切换微应用时，先卸载前一个微应用 if (microApp &amp;&amp; contentApp?.value?.getStatus() === &quot;MOUNTED&quot;) { // 卸载前一个应用 contentApp.value.unmount(); // 卸载完前一个应用后紧接着加载新的应用，这里用qiankun的loadMicroApp来加载微应用，返回一个实例，可以通过实例上的unmount方法卸载自身。 contentApp.value = loadMicroApp(microApp); return; } // 如果微应用是初次加载，那么不用先卸载之前挂载的应用直接加载 contentApp.value = loadMicroApp(microApp);}switchMicroApp({ name: &quot;app2&quot;, entry: &quot;//localhost:8088/&quot;, container: &quot;#micro-app2&quot;, props: {},});// 这里重复挂载上面的应用，正常加载switchMicroApp({ name: &quot;app2&quot;, entry: &quot;//localhost:8089/&quot;, container: &quot;#micro-app2&quot;, props: {},}); Layout 组件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;template&gt; &lt;div class=&quot;ths-main&quot;&gt; &lt;!-- 导航菜单 --&gt; &lt;t-header :data=&quot;headerNavs&quot; @click=&quot;onClickHeader&quot;&gt;&lt;/t-header&gt; &lt;!-- 视图微应用容器 --&gt; &lt;div class=&quot;content&quot; id=&quot;microapp&quot;&gt;&lt;/div&gt; &lt;div class=&quot;map&quot;&gt; &lt;div class=&quot;map-mask&quot;&gt;&lt;/div&gt; &lt;!-- 地图微应用容器 --&gt; &lt;div id=&quot;map-app&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;export default defineComponent({ name: 'Home', setup() { // 当前头部菜单配置 const headerNavs = ref&lt;HeaderNavItems&gt;([]); // 当前选中的应用id const curAppId = ref&lt;number&gt;(0); // 默认要加载的子应用，地图+首页 const BASE_MICRO_APPS: BaseMicroApps = { map: { id: 99, name: 'h5-map-app', entry: !isProd ? '//localhost:8088/' : `${webUrl}h5-map-app/`, container: '#map-app', props: { baseUrl, experimentalStyleIsolation: true, }, }, home: { id: 0, name: 'vue3-home-app', entry: !isProd ? '//localhost:8090/' : `${webUrl}vue3-home-app/`, container: '#microapp', props: { baseUrl, experimentalStyleIsolation: false, }, }, }; /** * 点击菜单切换子应用 * @param id 应用id */ onClickHeader(id: number) { // 点击的是当前选中的则返回 if (curAppId.value === id) { return; } // 当前选中的应用id curAppId.value = id; // 根据点击的应用id，选中加载哪个应用 headerNavs.value.forEach((item) =&gt; { if (item.id === id) { switchMicroApp(item.id, { ...item.app, entry: item.app.entry[isProd ? 'product' : 'dev'], }); } }); } onBeforeMount(() =&gt; { // 默认加载地图应用 loadMicroApp(BASE_MICRO_APPS.map); // 默认加载首页应用 loadMicroApp(BASE_MICRO_APPS.home); }); onMounted(() =&gt; { // 请求导航菜单数据，返回上面‘配置导航菜单’中的MENU对象 getHeaderMenu('dapeng-header-menu').then((data: HeaderNavItems) =&gt; { if (isEmpty(data)) { headerNavs.value = []; return false; } headerNavs.value = data; return true; }); }); return { onClickHeader, }; },});&lt;/script&gt; 刷新路由保存应用状态由于通过 loadMicroApp 方式加载的应用无法匹配路由，所以当路由变化时就无法刷新或保持状态，一旦刷新路由，那么基座中加载的应用都会重置成首次加载的应用，例如大气、水环境的应用刷新后都会重新渲染成首页应用。 解决方案 每个应用对应菜单的一个 id，所以通过 localStorage 的方式缓存切换的菜单 id，路由刷新后再根据 localStorage 中的 id 切换对应应用即可。 预加载微应用在获取到包含所有子应用信息的菜单数据后，可以预先请求其余子应用的html、js、css等静态资源，等切换子应用时，可以直接从缓存中读取这些静态资源，从而加快渲染子应用。 1234567891011121314151617import { prefetchApps } from &quot;qiankun&quot;;getHeaderMenu(&quot;dapeng-header-menu&quot;).then((data: HeaderNavItems) =&gt; { if (isEmpty(data)) { headerNavs.value = []; return false; } headerNavs.value = data; // 预加载其余微应用 prefetchApps( headerNavs.value.map((nav) =&gt; ({ name: nav.app.name, entry: nav.app.entry[isProd ? &quot;product&quot; : &quot;dev&quot;], })) ); return true;}); 打造 qiankun 子应用我们基于公司 fe-cli 创建一个 Vue3 项目应用，由上述的流程描述，我们知道子应用得向外暴露一系列生命周期函数供 qiankun 调用，在 index.js 文件中进行改造： 增加 public-path.ts 文件目录外层添加 public-path.ts 文件，当子应用挂载在主应用下时，如果我们的一些静态资源沿用了 publicPath=/ 的配置，我们拿到的域名将会是主应用域名，这个时候就会造成资源加载出错，好在 Webpack 提供了 __webpack_public_path__ 动态更改 publicPath 的修改方式，window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__ 等同于 location.host + location.pathname 如 http://localhost:8081/ 或 http://182.48.115.108:8887/vue3-air-home/ ，如下： 1234// public-path.tsif ((window as any).__POWERED_BY_QIANKUN__) { __webpack_public_path__ = (window as any).__INJECTED_PUBLIC_PATH_BY_QIANKUN__;} 路由 base 设置试想一下，当基座的路由 base不再是本地的 '/'，而是线上的 '/microFE-dapeng-base/' ，而子应用的路由 base设置还是’/‘，会发生什么，没错，答案是无法匹配到 '/microFE-dapeng-base/' 路由，导致本地子应用路由无法匹配，资源无法加载。注意 createWebHistory 的第一个参数就是设置的路由 base，那么通过如下配置即可解决子应用 base 设置问题： 123456789const isProd = process.env.NODE_ENV === &quot;production&quot;; // 是否开发环境const BASE_PREFIX = isProd ? &quot;/microFE-dapeng-base/&quot; : &quot;/&quot;; // 根据环境设置baserouter = createRouter({ // 根据是否qiankun环境设置base history: createWebHistory( (window as any).__POWERED_BY_QIANKUN__ ? BASE_PREFIX : &quot;/&quot; ), routes,}); 可见，只要是开发环境，不管子应用是 qiankun 环境下或者独立运行，base 始终都是 '/'，因为本地开发基座应用都不会设置域名二级目录；而线上环境的话，如果子应用是独立运行，那么 base 就是 '/'，相对于当前根路径；如果是 qiankun 环境下，那么 base 就是 '/microFE-dapeng-base/' 相对于基座路由。 增加生命周期函数子应用的入口文件加入生命周期函数初始化，方便主应用调用资源完成后按应用名称调用子应用的生命周期 1234567891011121314151617181920212223242526/** * bootstrap 只会在微应用初始化的时候调用一次，下次微应用重新进入时会直接调用 mount 钩子，不会再重复触发 bootstrap。 * 通常我们可以在这里做一些全局变量的初始化，比如不会在 unmount 阶段被销毁的应用级别的缓存等。 */export async function bootstrap() { console.log(&quot;bootstraped&quot;);}/** * 应用每次进入都会调用 mount 方法，通常我们在这里触发应用的渲染方法 */export async function mount(props) { console.log(&quot;mount&quot;, props); render(props); // 执行createApp创建instance并挂载子应用DOM}/** * 应用每次切出/卸载 会调用的方法，通常在这里我们会卸载微应用的应用实例 */export async function unmount() { console.log(&quot;unmount&quot;); instance.unmount(); instance._container.innerHTML = &quot;&quot;; instance = null; router = null;} 注意：所有的生明周期函数都必须是 Promise 子应用独立运行配置在上述的生命周期 mount 钩子中挂载了子应用的实例的 DOM，那么当子应用要单独运行，是不是也要挂载一次实例的 DOM 呢？通过 !window.__POWERED_BY_QIANKUN__ 判断如果不是 qiankun 环境的话，就立即挂载实例的 DOM。 1234567891011121314151617181920212223function render(props) { const container = props.container || null; const isProd = process.env.NODE_ENV === 'production'; // 是否开发环境 const BASE_PREFIX = isProd ? '/microFE-dapeng-base/' : '/'; // 根据环境设置base router = createRouter({ history: createWebHistory(window.__POWERED_BY_QIANKUN__ ? BASE_PREFIX : '/'), routes, }); instance = createApp(App); instance.use(router); instance.mount(container ? container.querySelector('#app') : '#app');}// 当不是qiankun环境时候，立即执行render挂载DOMif (!window.__POWERED_BY_QIANKUN__) { render();}// 生命周期钩子函数export async function bootstrap() {...}// 当是qiankun环境时候，才会在父容器挂载完成后执行mount钩子，然后执行render挂载DOMexport async function mount(props) { render(props) }export async function unmount() {...} 修改打包配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374function isProd() { return process.env.NODE_ENV === &quot;production&quot;;}// 图片公用地址前缀，请配置成微应用部署在三方服务器的完整根地址const publicPath = isProd() ? `http://182.48.115.108:8887/${name}/` : `http://localhost:${port}`;module.exports = { // 本地服务配置 devServer: { host: &quot;localhost&quot;, hot: true, disableHostCheck: true, port, overlay: { warnings: false, errors: true, }, headers: { // 设置本地资源允许跨域，部署后服务端也需要设置允许跨域，因为基座是通过 fetch 来拉取子应用资源的，跨域才能拉 &quot;Access-Control-Allow-Origin&quot;: &quot;*&quot;, }, }, publicPath, // 注意这里很重要，设置所有静态资源的加载路径为绝对路径 configureWebpack: (config) =&gt; { return { output: { // 微应用的包名，这里与主应用中注册的微应用名称一致，比如name = 'vue3-home-app' library: `${name}-[name]`, // 将你的 library 暴露为所有的模块定义下都可运行的方式 libraryTarget: &quot;umd&quot;, // 按需加载相关，设置为 webpackJsonp_VueMicroApp 即可 jsonpFunction: &quot;webpackJsonp_VueMicroApp&quot;, }, }; }, chainWebpack: (config) =&gt; { // 替换打包后的字体资源地址为绝对地址或压缩成base64 config.module .rule(&quot;fonts&quot;) .use(&quot;url-loader&quot;) .loader(&quot;url-loader&quot;) .options({ limit: 4096, // 小于4kb将会被打包成 base64 fallback: { loader: &quot;file-loader&quot;, options: { name: &quot;fonts/[name].[hash:8].[ext]&quot;, // 将图片相对地址替换为本地或线上完整地址，防止相对地址会相对于基座地址来查找静态资源 // 如 'http://localhost:8082/'或'http://182.48.115.108:8887/vue3-air-app/' publicPath, }, }, }) .end(); // 替换打包后的图片资源地址为绝对地址或压缩成base64 config.module .rule(&quot;images&quot;) .use(&quot;url-loader&quot;) .loader(&quot;url-loader&quot;) .options({ limit: 4096, // 小于4kb将会被打包成 base64 fallback: { loader: &quot;file-loader&quot;, options: { name: &quot;img/[name].[hash:8].[ext]&quot;, // 同上 publicPath, }, }, }); },}; 注意：配置的修改为了达到三个目的，一个是暴露生命周期函数给主应用调用，第二点是允许跨域访问，第三点是将图片等静态资源的相对路径地址修改为绝对路径从而解决资源相对于基座路径的问题，修改的注意点可以参考代码的注释。 暴露生命周期： UMD 可以让 qiankun 按应用名称匹配到生命周期函数 跨域配置： 主应用是通过 Fetch 获取资源，所以为了解决跨域问题，必须设置允许跨域访问 项目中遇到的问题1、子应用未成功加载如果项目启动完成后，发现子应用系统没有加载，我们应该打开控制台分析原因： 控制台无报错：子应用未加载，检查子应用导出的生命周期 mount 中是否调用了 render 挂载 DOM **挂载容器未找到**：检查容器 DIV 是否在 loadMicroApp 时一定存在，如不能保证需设法在 DOM 挂载后执行。 2、基座应用路由模式基座路由配置 12345exports routes = [{ path: '/home', name: 'home', component: Home, }]; 基座应用项目是 hash 模式路由，子路由是 history 模式 子应用配置路由 123456789101112131415// routes.tsexport default [ { path: &quot;/&quot;, // 这里必须是 '/'，不能变更pathname name: &quot;Home&quot;, component: () =&gt; import(&quot;@/views/home.vue&quot;), },];// main.tsrouter = createRouter({ // history 模式 history: createWebHistory(window.__POWERED_BY_QIANKUN__ ? BASE_PREFIX : &quot;/&quot;), routes,}); 基座应用项目是 hash 模式路由，子路由是 hash 模式 子应用配置路由 1234567891011121314151617// routes.tsexport default [ { path: &quot;/home&quot;, // 这里必须跟基座保持一致 name: &quot;Home&quot;, component: () =&gt; import(&quot;@/views/home.vue&quot;), },];// main.tsrouter = createRouter({ // hash 模式 history: createWebHashHistory( window.__POWERED_BY_QIANKUN__ ? BASE_PREFIX : &quot;/&quot; ), routes,}); 3、CSS 样式错乱由于默认情况下 qiankun 并不会开启 CSS 沙箱进行样式隔离，当主应用和子应用产生样式错乱时，有两种样式隔离配置： strictStyleIsolation - boolean 这个时候会用 Shadow Dom 节点包裹子应用，相信大家看到这个也很熟悉，和 Ionic 中组件的样式隔离方案一致。 12345loadMicroApp(microApp, { sandbox: { strictStyleIsolation: true, },}); 优点 完全隔离 CSS 样式 缺点 在使用一些弹窗组件的时候（弹窗很多情况下都是默认添加到了 document.body ）这个时候它就跳过了阴影边界，跑到了主应用里面，样式就丢了 experimentalStyleIsolation - boolean 会在运行时劫持应用 style 的规则，并且添加前缀来控制隔离，比如 .title，劫持后输出 div[data-qiankun-app] .title 12345loadMicroApp(microApp, { sandbox: { experimentalStyleIsolation: true, },}); 优点 支持大部分样式隔离需求 解决了 Shadow DOM 方案导致的丢失根节点问题 缺点 - 运行时重新加载样式，会有一定性能损耗具体如何样式隔离的原理可以参考 这篇文章 4、H5 微应用静态资源 404h5 子应用如果没有通过 webpack 等工具打包，没有在打包的时候将静态资源相对地址替换成 publicPath，那么还是那个问题，应用被转换成 DOM 后 append 到基座 html 中，相对路径其实已经从原来应用的 url 变为了当前页面也就是基座的 url，通过设置 head 中的 base 标签 href 属性解决相对路径问题： 1234&lt;!-- 本地 --&gt;&lt;base href=&quot;http://localhost:8088/&quot; /&gt;&lt;!-- 线上 --&gt;&lt;base href=&quot;http://182.48.115.108:8887/h5-map-app/&quot; /&gt; 5、异步加载的 js 中再异步加载了其他 js，loadMicroApp 加载的应用全局作用域会错乱qiankun 在加载 js 时，会根据加载的 js 来匹配对应所属的微应用，并开启对应沙箱隔离 js，如果异步加载的 js 中再次异步加载了 js，那么最后异步加载的 js 对应的应用就无法正确匹配到属于哪个微应用，就会造成无法开启正确的沙箱进行隔离，导致 js 全局作用域污染。 解决方案 先只加载有多重异步引入 js 的应用，让所有异步的 js 只能匹配该应用的沙箱，加载完后再通知基座开始加载其余正常应用。 6、配置线上和本地环境的 publicPath 设置资源加载的默认路径微应用不能使用相对路径的资源，因此需设置资源加载路径为绝对路径，并且区分线上和本地环境。 12345678910111213141516const isProd = process.env.NODE_ENV === &quot;production&quot;;const publicPath = isProd ? `http://182.48.115.108:8887/${name}/` : `http://localhost:${port}`;// vue.config.jsmodule.exports = { // ... publicPath,};// webpackmodule.exports = { // ... assetsPublicPath: publicPath,}; 如果需要本地打包后能正常访问应用，需将 isProd 手动改为 false 7.线上子应用单独运行需修改路由 path子应用打包部署后，为了能让子应用独立运行，则需要根据子应用部署地址的 path 来设置路由 path，比如子应用部署地址是 http://182.48.115.108:8887/vue3-air-app/，那么子应用路由的 path 就应该变成 '/vue3-air-app' + '/' 而不是 '/'，为了统一，访问地址的 path 就是应用的名称 packageName 1234567891011const packageName = require('../../package.json').name;const basePath = '/';// routes.tsexport default [ { // 非qiankun环境即独立运行并且是正式版本的应用的 path 要加上应用名称，否则无法独立运行 path: !(window as any).__POWERED_BY_QIANKUN__ &amp;&amp; process.env.NODE_ENV === 'production' ? `/${packageName}${basePath}` : basePath;, name: 'Home', component: () =&gt; import('@/views/home.vue'), },]; 8、 另外，在接入过程中，总结了几个需要注意的点 虽然 qiankun 支持 jQuery，但对多页应用的老项目接入不是很友好，需要每个页面都修改，成本也很高，这类老项目接入还是比较推荐 iframe ； 因为 qiankun 的方式，是通过 HTML-Entry 抽取 JS 文件和 DOM 结构的，实际上和主应用共用的是同一个 Document，如果子应用和主应用同时定义了相同事件，会互相影响，如，用 onClick 或 addEventListener 给 &lt;body&gt; 添加了一个点击事件，JS 沙箱并不能消除它的影响，还得靠平时的代码规范 部署上有点繁琐，需要手动解决跨域问题 在 vue 中使用图片得用 require(相对/绝对路径).default 获取图片路径 在子应用 js 中通过 function 或者 var 声明在 window 上的全局变量无法识别，原因在于 Proxy 沙箱将 window 替换成 Proxy 实例了，所以声明的变量无法保存在 proxy 对象上，如果要使用全局变量，可以用 (function(global){global.obj = {}, global.fn = function() {}}(window)) 像地图依赖的的三方 js 有很多不确定性，比如引入了 CesiumJs 和其他 qiankun 无法完美支持的 js 库等，以及其中引入了很多静态资源相对地址都无法在打包时替换为绝对地址，所以为了让这些三方 js 库能顺利集成，最好的方式是将他们在基座的 index.html 中加载，这样 qiankun 就不会劫持三方引入的 js 从而发生错误了。 切换子应用前需要先卸载前一个子应用，否则会报错 123app1 = loadMicroApp();app1.unmount;app2 = loadMicroApp(); 无法兼容 IE，在基座的 main.ts 中引入如下依赖解决 123456import &quot;whatwg-fetch&quot;;import &quot;custom-event-polyfill&quot;;import &quot;core-js/stable/promise&quot;;import &quot;core-js/stable/symbol&quot;;import &quot;core-js/stable/string/starts-with&quot;;import &quot;core-js/web/url&quot;; 8、未来可能需要考虑一些问题 自动化注入：每一个子应用改造的过程其实也是挺麻烦的事情，但是其实大多的工作都是标准化流程，在考虑通过脚本自动注册子应用，实现自动化 总结其实写下来整个项目，最大的感受 qiankun 的开箱可用性非常强，需要更改的项目配置基本很少，当然遇到的一些坑点也肯定是踩过才能更清晰。 如果文章有什么问题或者错误，欢迎指正交流，谢谢！ 完整的项目在线演示地址 点我查看","link":"/2021/03/30/%E5%9F%BA%E4%BA%8E-qiankun-%E7%9A%84%E5%BE%AE%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5/"},{"title":"Jest单元测试环境搭建","text":"依赖说明下面列出了一些使用 Jest 测试相关的依赖说明及配置，可以根据不同的需求进行安装。如果你想快速安装运行，也可以直接跳到 快速开始。 测试运行器—Jest官方推荐的其中一种配置简单、集成完善的测试机运行器。 1npm i --save-dev jest 配置 package.json 设置 scripts 启动，更多常用配置请跳转到Jest 的脚本 123456789{ ... &quot;scripts&quot;: { &quot;test&quot;: &quot;jest&quot;, &quot;test:init&quot;: &quot;jest --init&quot;, &quot;test:coverage&quot;: &quot;jest --coverage&quot; }, ...} 支持 TS1npm i ts-jest @types/jest 配置 jest.config.js 12345678910111213...transform: { transform: { '^.+\\\\.(t|j)sx?$': [ 'babel-jest', { presets: [ '@babel/preset-typescript', ], }, ], },},... Babel 转译虽然最新版本的 Node 已经支持绝大多数的 ES2015 特性，但是我们还想在测试中使用 ES modules 语法。所以需要需要安装 babel-jest进行语法转义。 1npm i --save-dev babel-jest @babel/core @babel/preset-env 配置 babel.config.json 1234567891011{ &quot;presets&quot;: [ [ &quot;@babel/preset-env&quot;, { &quot;targets&quot;: { &quot;node&quot;: &quot;current&quot; } } ] ]} 单元测试实用工具库—vue-test-utilsVue Test Utils 是 Vue.js 官方的单元测试实用工具库，通过两者结合来测试验证码组件，覆盖各功能测试 1npm i --save-dev @vue/test-utils 处理单文件组件告诉 Jest 如何处理 *.vue 文件 1npm i --save-dev vue-jest 配置 jest.config.js文件 12345...transform: { '^.+\\\\.vue$': 'vue-jest',},... 使用 Eslint 检测1npm i --save-dev eslint-plugin-jest 配置 .eslintrc文件 12345...&quot;extends&quot;: [ &quot;plugin:jest/recommended&quot; ],... 快照格式化默认快照测试，输出文件包含大量转义符号”/“，需要通过jest-serializer-vue插件处理，可以自定义快照输出目录位置 1npm i --save-dev jest-serializer-vue 配置 jest.config.js文件 12345678...// 处理快照文件转义符snapshotSerializers: [&quot;&lt;rootDir&gt;/node_modules/jest-serializer-vue&quot;],// 生成测试报告文件类型coverageReporters: ['json', 'html'],// 覆盖率报告的目录，测试报告所存放的位置coverageDirectory: './coverage-reports',... 浏览器显示测试结果执行测试后，会在项目最外层生成test-report.html，点开即可查看结果 1npm i --save-dev jest-html-reporter 配置 jest.config.js文件 12345678910...reporters: [ // 可以自定义报告 [&quot;./node_modules/jest-html-reporter&quot;, { &quot;pageTitle&quot;: &quot;Test Report&quot; }]],或者&quot;testResultsProcessor&quot;: &quot;./node_modules/jest-html-reporter&quot;... Jest 基本配置以下只列出常用的配置，更多配置请参考https://jestjs.io/docs/configuration。 可以通过npm run test:init创建jest.config.json 文件，里面包含全部配置的说明。也可以手动创建，并配置。 12345678910111213141516171819202122232425262728293031323334353637const path = require('path');module.exports = { // 匹配测试用例的文件 testMatch: [ &quot;**/__tests__/**/*.[jt]s?(x)&quot;, &quot;**/?(*.)+(spec|test).[tj]s?(x)&quot; ], reporters: [ &quot;default&quot;, // 需要安装依赖：jest-html-reporter [&quot;./node_modules/jest-html-reporter&quot;, { &quot;pageTitle&quot;: &quot;Test Report&quot; }] ], // 激活测试结果通知 notify: true, // 每次测试前清除模拟调用和实例 clearMocks: true, // 生成测试报告文件类型 coverageReporters: ['json', 'html'], // 覆盖率报告的目录，测试报告所存放的位置 coverageDirectory: './coverage-reports', // 处理快照文件转义符 snapshotSerializers: [&quot;&lt;rootDir&gt;/node_modules/jest-serializer-vue&quot;], // 转换器 -- ts需要配置该选项 transform: { '^.+\\\\.(t|j)sx?$': [ 'babel-jest', { presets: [ '@babel/preset-typescript', ], }, ], },}; 示例说明编写测试用例要测试的代码12345// fun.jsfunction foo(a, b) { return a + b;}export default foo; 测试用例这里只是一个简单的测试用例，更多常用方法、匹配器等跳转 Vue Test Utils 常用的 API 、 Jest 常用 API 。 12345// test.jsimport foo from './fun.js';test('add', () =&gt; { expect(foo(1, 2)).toBe(3);}); 运行测试默认测试命令1npm run test 测试结果![image-20210330142642772](/Users/zhangjinxiu/Library/Application Support/typora-user-images/image-20210330142642772.png)html 显示安装jest-html-reporter并在jest.config.json中进行配置（查看上述 Jest 基本配置），执行测试后，根目录会生成一个test-report.html文件，打开页面如下图所示： ![image-20210330140206336](/Users/zhangjinxiu/Library/Application Support/typora-user-images/image-20210330140206336.png) 测试并统计覆盖率命令1npm run test:coverage 测试结果![image-20210330142829459](/Users/zhangjinxiu/Library/Application Support/typora-user-images/image-20210330142829459.png)执行测试后，根目录下会生成目录coverage-reports/index.html文件（文件目录可以自定义，参考jest.config.js中的配置），打开页面如下图所示：![image-20210330142327049](/Users/zhangjinxiu/Library/Application Support/typora-user-images/image-20210330142327049.png) 语句覆盖率（statements）是否每个语句都执行了 分支覆盖率（branches）是否每个函数都调用了 函数覆盖率（functions）是否每个 if 代码块都执行了 行覆盖率（lines) 是否每一行都执行了 Jest 的脚本&quot;test&quot;: &quot;jest&quot; ：对项目目录下测试文件进行 Jest 测试 &quot;test:help&quot;: &quot;jest --help&quot;：查看 cli 命令 &quot;test:debug&quot;: &quot;jest --debug&quot;：debug &quot;test:verbose&quot;: &quot;jest --verbose&quot;：以层级方式在控制台展示测试结果 &quot;test:noCache&quot;: &quot;jest --no-cache&quot;：设置是否缓存，有缓存会快 &quot;test:init&quot;: &quot;jest --init&quot;：根目录下创建jest.config.js文件 &quot;test:caculator&quot;: &quot;jest ./test/caculator.test.js&quot;：单文件测试 &quot;test:caculator:watch&quot;: &quot;jest ./test/caculator.test.js --watch&quot;：单文件监视测试 &quot;test:watchAll&quot;: &quot;jest --watchAll&quot;：监视所有文件改动并测试 &quot;test:coverage&quot;: &quot;jest --coverage&quot;：测试覆盖率 Jest 常用 API全局函数 describe(name, fn) 把相关测试组合在一起 test(name, fn) 测试方法 expect(value) 断言 beforeEach(fn) 在每一个测试之前需要做的事情，比如测试之前将某个数据恢复到初始状态 afterEach(fn) 在每一个测试用例执行结束之后运行 beforeAll(fn) 在所有的测试之前需要做什么 afterAll(fn) 在测试用例执行结束之后运行 匹配器 toBe 使用 === 来测试完全相等 toEqual 递归检查对象或数组的每个字段 toContain 判断数组或字符串中是否包含指定值 toContainEqual 判断数组中是否包含一个特定对象 toBeNull 只匹配 null toBeUndefined 只匹配 undefined toBeDefined 与 toBeUndefined 相反 toBeTruthy 匹配任何 if 语句为真 toBeFalsy 匹配任何 if 语句为假 toThrow 特定函数抛出一个错误 toMatch 正则匹配 toThrow 要测试的特定函数会在调用时抛出一个错误 resolves 和 rejects 用来测试 promise toHaveBeenCalled 判断一个函数是否被调用过 toHaveBeenCalledTimes 判断函数被调用过几次 toBeGreaterThan 大于 toBeGreaterThanOrEqual 大于等于 toBeLessThan 小于 toBeLessThanOrEqual 小于等于 toBeCloseTo 浮点数比较 toMatchSnapshot() 记录快照 第一次调用的时候，会把 expect 中的值以字符串的形式存储到一个.snap文件中 多次运行快照时，每次都会与上一次的快照文件内容对比，相同则测试通过，不同则测试失败 重新生成快照文件 npm run test -- -u Vue Test Utils 常用的 API挂载组件 mout(component)创建一个包含被挂载和渲染的 Vue 组件的 Wrapper 1234567const wrapper = mount({ template: `&lt;div&gt;hello word&lt;/div&gt;`, components: { OtherComponent, },});const wrapper2 = mount(MyComponent); shallowMount 只挂载一个组件不渲染子组件 1234567const wrapper = shallowMount({ template: `&lt;div&gt;hello word&lt;/div&gt;`, components: { OtherComponent, },});const wrapper2 = mount(MyComponent); 参数 props 传入组件的参数 1234567const mountCom = (template, options) =&gt; mount(MyComponent, { ... props: { active: 'default', }, ...}; slots 设置组件的插槽 12345678const mountCom = (template, options) =&gt; mount(MyComponent, { ... slots: { default: 'Default', customerName: OtherComponent, }, ...}); data 传入组件数据 12345678cconst mountCom = (template, options) =&gt; mount(MyComponent, { ... data() { return { message: 'world', }; ...}); attrs 设置组件的属性 12345678ccconst mountCom = (template, options) =&gt; mount(MyComponent, { ... attrs: { id: 'hello', disabled: true, }, ...}); wrapper 的方法 attributes 返回DOM节点属性值 123456test('attributes', () =&gt; { const wrapper = mount(Component); expect(wrapper.attributes('id')).toBe('foo'); expect(wrapper.attributes('class')).toBe('bar');}); classes 返回元素上class的数组 一般用于测试样式 1234567test('classes', () =&gt; { const wrapper = mount(Component); expect(wrapper.classes()).toContain('my-span'); expect(wrapper.classes('my-span')).toBe(true); expect(wrapper.classes('not-existing')).toBe(false);}); emitted 返回组件发出的所有事件 一般用于测试派发事件及传输的参数 12345678test('emitted', () =&gt; { const wrapper = mount(Component); expect(wrapper.emitted()).toHaveProperty('greet'); expect(wrapper.emitted().greet).toHaveLength(2); expect(wrapper.emitted().greet[0]).toEqual(['hello']); expect(wrapper.emitted().greet[1]).toEqual(['goodbye']);}); exists 返回布尔值 验证元素是否存在 一般用于DOM元素是否存在 123456test('exists', () =&gt; { const wrapper = mount(Component); expect(wrapper.find('span').exists()).toBe(true); expect(wrapper.find('p').exists()).toBe(false);}); find 选择器查找DOM元素，返回DOMWrapper 如果未查到不报错 1234567test('find', () =&gt; { const wrapper = mount(Component); wrapper.find('span'); //=&gt; found; returns DOMWrapper wrapper.find('[data-test=&quot;span&quot;]'); //=&gt; found; returns DOMWrapper wrapper.find('p'); //=&gt; nothing found; returns ErrorWrapper}); getComponent 查找Vue Component实例，返回VueWrapper 或抛出异常 12345678test('getComponent', () =&gt; { const wrapper = mount(Component); wrapper.getComponent({ name: 'foo' }); // returns a VueWrapper wrapper.getComponent(Foo); // returns a VueWrapper expect(() =&gt; wrapper.getComponent('.not-there')).toThrowError();}); get 选择器查找DOM元素，返回DOMWrapper 或抛出异常 1234567test('get', () =&gt; { const wrapper = mount(Component); wrapper.get('span'); //=&gt; found; returns DOMWrapper expect(() =&gt; wrapper.get('.not-there')).toThrowError();}); html 返回元素的HTML 字符串 快照时会使用到 12345test('html', () =&gt; { const wrapper = mount(Component); expect(wrapper.html()).toBe('&lt;div&gt;&lt;p&gt;Hello world&lt;/p&gt;&lt;/div&gt;');}); props 返回传递给Vue组件的参数 12345678910111213141516test('props', () =&gt; { const wrapper = mount(Component, { global: { stubs: ['Foo'] }, }); const foo = wrapper.getComponent({ name: 'Foo' }); expect(foo.props('truthy')).toBe(true); expect(foo.props('object')).toEqual({}); expect(foo.props('notExisting')).toEqual(undefined); expect(foo.props()).toEqual({ truthy: true, object: {}, string: 'string', });}); setProps 更新props传参 用于修改参数测试组件是否有变化 12345678910111213test('updates prop', async () =&gt; { const wrapper = mount(Component, { props: { message: 'hello', }, }); expect(wrapper.html()).toContain('hello'); await wrapper.setProps({ message: 'goodbye' }); expect(wrapper.html()).toContain('goodbye');}); trigger 触发DOM事件，click submit keyup 1234567test('trigger', async () =&gt; { const wrapper = mount(Component); await wrapper.find('button').trigger('click'); expect(wrapper.find('span').text()).toBe('Count: 1');}); unmount 卸载组件 1234567test('unmount', () =&gt; { const wrapper = mount(Component); wrapper.unmount(); // Component is removed from DOM. // console.log has been called with 'unmounted!'}); 属性vm Vue 实例，可以获取所有实例的方法和属性。 12345test('unmount', () =&gt; { const wrapper = mount(Component); expect(wrapper.vm.$el.style.backgroundColor).toBe('red');}); 注意：vm 仅在 VueWrapper 上可用， 并且只能获取到 DOM 元素的内联样式 快速开始主要目录结构1234567├─ src └─ __tests__ *.spec.js├─ package.json├─ babel.config.json├─ .eslintrc├─ jest.config.js 普通 Js 项目1npm i jest babel-jest @babel/core @babel/preset-env jest-html-reporter vue-template-compiler package.json 1234567891011121314151617181920212223// package.json{ &quot;name&quot;: &quot;test-js&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: { &quot;test&quot;: &quot;jest&quot;, &quot;test:init&quot;: &quot;jest --init&quot;, &quot;test:coverage&quot;: &quot;jest --coverage&quot; }, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: { &quot;@babel/core&quot;: &quot;^7.13.14&quot;, &quot;@babel/preset-env&quot;: &quot;^7.13.12&quot;, &quot;babel-jest&quot;: &quot;^26.6.3&quot;, &quot;jest&quot;: &quot;^26.6.3&quot;, &quot;jest-html-reporter&quot;: &quot;^3.3.0&quot;, &quot;vue-template-compiler&quot;: &quot;^2.6.12&quot; }} babel.config.js 123456789101112{ &quot;presets&quot;: [ [ &quot;@babel/preset-env&quot;, { &quot;targets&quot;: { &quot;node&quot;: &quot;current&quot; } } ] ]} jest.config.js 123456789101112131415161718192021222324module.exports = { // 匹配测试用例的文件 testMatch: [ &quot;**/__tests__/**/*.[jt]s?(x)&quot;, &quot;**/?(*.)+(spec|test).[tj]s?(x)&quot; ], reporters: [ &quot;default&quot;, // 需要安装依赖：jest-html-reporter [&quot;./node_modules/jest-html-reporter&quot;, { &quot;pageTitle&quot;: &quot;Test Report&quot; }] ], // 激活测试结果通知 notify: true, // 每次测试前清除模拟调用和实例 clearMocks: true, // 生成测试报告文件类型 coverageReporters: ['json', 'html'], // 覆盖率报告的目录，测试报告所存放的位置 coverageDirectory: './coverage-reports', snapshotSerializers: ['./node_modules/jest-serializer-vue'],}; Ts 项目1npm i jest babel-jest @babel/core @babel/preset-env ts-jest @types/jest jest-html-reporter vue-template-compiler package.json 123456789101112131415161718192021222324{ &quot;name&quot;: &quot;test-ts&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: { &quot;test&quot;: &quot;jest&quot;, &quot;test:init&quot;: &quot;jest --init&quot;, &quot;test:coverage&quot;: &quot;jest --coverage&quot; }, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: { &quot;@babel/core&quot;: &quot;^7.13.14&quot;, &quot;@babel/preset-env&quot;: &quot;^7.13.12&quot;, &quot;@types/jest&quot;: &quot;^26.0.22&quot;, &quot;babel-jest&quot;: &quot;^26.6.3&quot;, &quot;jest&quot;: &quot;^26.6.3&quot;, &quot;jest-html-reporter&quot;: &quot;^3.3.0&quot;, &quot;ts-jest&quot;: &quot;^26.5.4&quot;, &quot;vue-template-compiler&quot;: &quot;^2.6.12&quot; }} babel.config.js 123456789101112{ &quot;presets&quot;: [ [ &quot;@babel/preset-env&quot;, { &quot;targets&quot;: { &quot;node&quot;: &quot;current&quot; } } ] ]} jest.config.js 12345678910111213141516171819202122232425262728293031323334module.exports = { // 匹配测试用例的文件 testMatch: [ &quot;**/__tests__/**/*.[jt]s?(x)&quot;, &quot;**/?(*.)+(spec|test).[tj]s?(x)&quot; ], reporters: [ &quot;default&quot;, // 需要安装依赖：jest-html-reporter [&quot;./node_modules/jest-html-reporter&quot;, { &quot;pageTitle&quot;: &quot;Test Report&quot; }] ], // 激活测试结果通知 notify: true, // 每次测试前清除模拟调用和实例 clearMocks: true, // 生成测试报告文件类型 coverageReporters: ['json', 'html'], // 覆盖率报告的目录，测试报告所存放的位置 coverageDirectory: './coverage-reports', // 转换器 -- ts需要配置该选项 transform: { '^.+\\\\.(t|j)sx?$': [ 'babel-jest', { presets: [ '@babel/preset-typescript', ], }, ], }, snapshotSerializers: ['./node_modules/jest-serializer-vue'],}; vue-test-utils + ts + jest 项目1npm i jest babel-jest @babel/core @babel/preset-env ts-jest @types/jest vue-jest @vue/test-utils slint-plugin-jest jest-html-reporter vue-template-compiler package.json 12345678910111213141516171819202122232425262728{ &quot;name&quot;: &quot;test-ts&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: { &quot;test&quot;: &quot;jest&quot;, &quot;test:init&quot;: &quot;jest --init&quot;, &quot;test:coverage&quot;: &quot;jest --coverage&quot; }, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: { &quot;@babel/core&quot;: &quot;^7.13.14&quot;, &quot;@babel/preset-env&quot;: &quot;^7.13.12&quot;, &quot;@types/jest&quot;: &quot;^26.0.22&quot;, &quot;@vue/test-utils&quot;: &quot;^2.0.0-rc.4&quot;, &quot;babel-jest&quot;: &quot;^26.6.3&quot;, &quot;eslint-plugin-jest&quot;: &quot;^24.3.2&quot;, &quot;jest&quot;: &quot;^26.6.3&quot;, &quot;jest-html-reporter&quot;: &quot;^3.3.0&quot;, &quot;ts-jest&quot;: &quot;^26.5.4&quot;, &quot;vite&quot;: &quot;^2.0.1&quot;, &quot;vue-jest&quot;: &quot;^5.0.0-alpha.8&quot;, &quot;vue-template-compiler&quot;: &quot;^2.6.12&quot; }} jest.config.js 组件库的配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172const path = require('path');module.exports = { // 运行时是否输出测试信息 verbose: true, // 根目录 rootDir: path.resolve(__dirname), preset: 'ts-jest', // 测试环境 testEnvironment: 'jsdom', // 转换器 transform: { '^.+\\\\.vue$': 'vue-jest', '^.+\\\\.(t|j)sx?$': [ 'babel-jest', { presets: [ [ '@babel/preset-env', { targets: { node: true, }, }, ], '@babel/preset-typescript', ], }, ], }, // 指定文件扩展名 moduleFileExtensions: ['vue', 'js', 'json', 'jsx', 'ts', 'tsx', 'node'], // 匹配测试用例的文件 testMatch: [ '&lt;rootDir&gt;/packages/**/__tests__/*.spec.js', ], // 是否收集测试时的覆盖率信息 collectCoverage: true, // 生成测试报告文件类型 coverageReporters: ['json', 'html'], // 覆盖率报告的目录，测试报告所存放的位置 coverageDirectory: '&lt;rootDir&gt;/testReports/', // 测试报告想要覆盖那些文件，目录，前面加！是避开这些文件 collectCoverageFrom: [ '!site/components/**/src/*.(js|vue|ts)', 'packages/**/*.(js|vue)', 'packages/testReports/*.(js|vue)', '!site/main.ts', '!site/router/index.ts', '!**/node_modules/**', ], // 测试覆盖效果阈值 当覆盖率达到预设值返回成功 小于预设值则返回失败 但不影响报告输出 coverageThreshold: { // 全部文件 // global: { // branches: 60, // functions: 60, // lines: 60, // statements: 60, // }, // 单独文件 // 'packages/header-base/src/index.vue': { // branches: 60, // statements: 60, // }, }, // 激活测试结果通知 notify: true, // 每次测试前清除模拟调用和实例 clearMocks: true, snapshotSerializers: ['&lt;rootDir&gt;/node_modules/jest-serializer-vue'],}; 参考文档Jest 中文文档 Vue Test Utils for Vue3 文档 Vue Test Utils for Vue3API Jest 配置","link":"/2021/04/06/Jest%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"title":"GitLab 安装、备份、恢复与升级","text":"1 前置工作1.1 操作系统准备一台装有 Centos7(8) Linux 操作系统的机器。由于要安装 docker ，根据 docker 官方说明，支持 x86_64 / amd64 和 ARM64 / AARCH64 两种架构的操作系统，本示例安装的 x86_64 Centos7 Linux （之前开始用 GitLab 时，官方还未正式支持 Centos8）。Centos7 系统镜像下载地址：http://isoredirect.centos.org/centos/7/isos/x86_64/Centos8 系统镜像下载地址：http://isoredirect.centos.org/centos/8/isos/x86_64/如果系统还没安装，可以通过该地址进行下载镜像，进行系统安装。根据本人经验（官方未找到相关说明）, 机器配置至少 8G 内存（目前在用的机器一般使用都是在 6G 左右），4核 2U 。当然，配置越高越好。以下为当前示例机器刚启动服务时的资源占用情况： 1.2 Docker 安装（资源仓库在线安装）使用该方式的前提条件是所安装的机器可以连接互联网。 1.2.1 移除机器上旧版本相关安装内容 新机器可以不做该操作 12345678sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 1.2.2 使用仓库进行安装1.2.2.1 安装 yum-utils1sudo yum install -y yum-utils 1.2.2.2 添加 docker 仓库源123sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo 1.2.3 安装 docker 相关1sudo yum install docker-ce docker-ce-cli containerd.io 1.2.4 启动 docker1sudo systemctl start docker 1.2.5 测试 docker 安装是否成功1sudo docker run hello-world 1.2.6 设置开机启动1sudo systemctl enable docker 1.2.7 安装 Compose 运行命令下载 Compose 1sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.28.5/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose 应用执行权限 1sudo chmod +x /usr/local/bin/docker-compose 验证安装结果 1docker-compose --version 2 GitLab 安装2.1 设置 GitLab 卷位置(docker 宿主机的文件目录)在命令行执行以下命令： 1export GITLAB_HOME=/srv/gitlab GitLab容器使用主机挂载的卷来存储持久数据： 主机位置 容器位置 用途 $GITLAB_HOME/data /var/opt/gitlab 应用存储应用数据 $GITLAB_HOME/logs /var/log/gitlab 用于存储应用日志 $GITLAB_HOME/config /etc/gitlab 用于存储 GitLab 配置文件 2.2 安装 创建 docker-compose.yml 文件在你的 linux 主机上 docker-compose.yml 建议备份该文件，用于后续升级。 12345678910111213141516web: image: 'gitlab/gitlab-ee:latest' container_name: gitlab2021 restart: always hostname: '192.168.44.6' environment: GITLAB_OMNIBUS_CONFIG: | external_url 'http://192.168.44.6:8929' gitlab_rails['gitlab_shell_ssh_port'] = 2224 ports: - '8929:8929' - '2224:22' volumes: - '$GITLAB_HOME/config:/etc/gitlab' - '$GITLAB_HOME/logs:/var/log/gitlab' - '$GITLAB_HOME/data:/var/opt/gitlab' 如果安装一个版本是为了恢复以前 gitlab 的数据，需要保证 image 版本一致。image: ‘gitlab/gitlab-ee:latest’ latest 需要换成指定版本的号，例如我这里是 13.6.1-ee.0 。 拉取 GitLab 镜像 并后台启动 在 docker-compose.yml 文件目录下执行以下命令 1docker-compose up -d 该操作会等待比较久，大概1000M的下载量。 访问地址测试是否安装成功 本例中的访问地址为：http://192.168.44.6:8929/users/sign_in 2.3 配置本例中 GitLab 系统的配置文件在该目录下（$GITLAB_HOME/config）: /srv/gitlab/config/gitlab.rb 2.3.1 LDAP该配置主要用于开启公司域账号登录。 在 /srv/gitlab/config/gitlab.rb 文件中添加以下配置： 可以在该文件中搜索 ldap ，找到指定注释掉的地方，将该内容粘贴进去 123456789101112131415161718gitlab_rails['ldap_enabled'] = truegitlab_rails['ldap_servers'] = YAML.load &lt;&lt;-'EOS' ###! **remember to close this block with 'EOS' below**main: # 'main' is the GitLab 'provider ID' of this LDAP server label: '域用户' host: '192.168.0.xx' port: 389 uid: 'sAMAccountName' bind_dn: 'CN=xxxx,OU=研发xx,OU=思路xx,DC=domain,DC=solution,DC=com' password: 'xxxxx' encryption: 'plain' # &quot;tls&quot; or &quot;ssl&quot; or &quot;plain&quot; #bind_dn: 'OU=思路xx,DC=domain,DC=solution,DC=com' active_directory: true allow_username_or_email_login: true block_auto_created_users: false base: 'dc=domain,dc=solution,dc=com' user_filter: '(userPrincipalName=*)'EOS 执行命令使配置生效 gitlab2021 为 docker 容器ID或者容器名称，运行后最后一行为“gitlab Reconfigured!”才说明是加载新配置成功，否则就是根据报错信息找错误。 1docker exec -t gitlab2021 gitlab-ctl reconfigure 执行命令查看 ldap 配置是否正常 执行命令后能查询出用户信息列表即正常 1docker exec -t gitlab2021 gitlab-rake gitlab:ldap:check 2.3.2 SMTP该配置主要用于开启使用公司 exchange服务器的 SMTP协议 发送邮件通知。 在 /srv/gitlab/config/gitlab.rb 文件中添加以下配置： 可以在文件中搜索 smtp ,按照以下配置解开注释并修改值 12345678910111213141516171819gitlab_rails['smtp_enable'] = truegitlab_rails['smtp_address'] = &quot;192.168.0.x&quot;gitlab_rails['smtp_port'] = 465gitlab_rails['smtp_user_name'] = &quot;zhangsan&quot;gitlab_rails['smtp_password'] = &quot;xxxxxx&quot;gitlab_rails['smtp_domain'] = &quot;thsdomain&quot;gitlab_rails['smtp_authentication'] = &quot;login&quot;gitlab_rails['smtp_enable_starttls_auto'] = truegitlab_rails['smtp_tls'] = falsegitlab_rails['smtp_ssl'] = falsegitlab_rails['smtp_force_ssl'] = falsegitlab_rails['smtp_openssl_verify_mode'] = 'none'gitlab_rails['gitlab_email_enabled'] = truegitlab_rails['gitlab_email_from'] = 'zhangsan@xxx.ths.com.cn'gitlab_rails['gitlab_email_display_name'] = 'git server' 执行命令使配置生效 1docker exec -t gitlab2021 gitlab-ctl reconfigure 依次输入以下命令，检查 smtp 配置是否正确 123456// 进入容器所在的 bashdocker exec -it gitlab2021 bin/bash// 在容器所在的 bash 中执行 gitlab-rails consolegitlab-rails console -e production// 测试邮件发送，如无错误产生，查看目标邮箱是否有邮件收到Notify.test_email('liuyx@xxx.ths.com.cn','Message Subject','message Body').deliver_now 3 备份3.1 编写备份脚本在 linux 上创建备份脚本文件，本例中在目录 /srv 下创建 gitlab_backup.sh，内容为以下内容： 该脚本会执行指定 GitLab 所在容器内的备份命令，备份除了 artifacts 外的所有内容（配置文件除外），gitlab2021为容器ID或容器名称 12#！ /bin/bashdocker exec -t gitlab2021 gitlab-backup create SKIP=artifacts 如需手动立即执行备份，可在该脚本文件所在目录下命令行窗口执行以下命令或直接执行脚本内命令： 1sh gitlab_backup.sh 3.2 编写自动上传备份文件到远程服务器脚本（ssh 免密上传）在 linux 上创建备份脚本文件，本例中在目录 /srv 下创建 auto_backup_to_remote.sh，内容为以下内容： 该脚本执行后会将本机指定目录下的备份文件上传到远程服务器的指定目录上。远程的备份的服务器需要支持SSH 免密上传，windows 系统配置可参看另外一篇文章https://ths.js.org/2021/02/04/Windows-OpenSSH%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/ 《Windows OpenSSH 安装与配置》 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#!/bin/bash# gitlab 备份路径,该路径为 gitlab 默认的备份路径LocalBackDir=/srv/gitlab/data/backups# 远程备份服务器 gitlab备份文件将传送到该路径RemoteBackDir=/gitlabDataBackup# 远程备份服务器 登录账户RemoteUser=administrator# 远程备份服务器 IP地址RemoteIP=192.168.0.231#当前系统日期DATE=`date +&quot;%Y-%m-%d&quot;`#Log存放路径LogFile=$LocalBackDir/log/$DATE.log# 查找 本地备份目录下 时间为60分钟之内的，并且后缀为.tar的gitlab备份文件# BACKUPFILE_SEND_TO_REMOTE=$(find /data/gitlabData/backups -type f -mmin -60 -name '*.tar*')BACKUPFILE_SEND_TO_REMOTE=$(find /srv/gitlab/data/backups -type f -mmin -60 -name '*.tar*')#新建日志文件touch $LogFile#追加日志到日志文件echo &quot;Gitlab auto backup to remote server, start at $(date +&quot;%Y-%m-%d %H:%M:%S&quot;)&quot; &gt;&gt; $LogFileecho &quot;---------------------------------------------------------------------------&quot; &gt;&gt; $LogFile# 输出日志，打印出每次scp的文件名echo &quot;---------------------The file to scp to remote server is: $BACKUPFILE_SEND_TO_REMOTE-------------------------------&quot; &gt;&gt; $LogFile #备份到远程服务器scp $BACKUPFILE_SEND_TO_REMOTE $RemoteUser@$RemoteIP:$RemoteBackDir# 查找本地备份路径下，超过3天 且文件后缀为.tar 的 Gitlab备份文件 然后删除find $LocalBackDir -type f -mtime +3 -name '*.tar*' -exec rm {} \\;echo &quot;删除$(find $LocalBackDir -type f -mtime +3 -name '*.tar*')3天前文件成功, start at $(date +&quot;%Y-%m-%d %H:%M:%S&quot;)&quot; &gt;&gt; $LogFile#追加日志到日志文件echo &quot;---------------------------------------------------------------------------&quot; &gt;&gt; $LogFile 3.3 设置系统定时任务，执行脚本编辑 /etc/crontab 系统配置文件，新增以下内容： 该配置会在凌晨两点执行备份脚本，3点执行备份上传远程服务器脚本。 1200 02 * * * root sh /srv/gitlab_backup.sh00 03 * * * root /srv/auto_backup_to_remote.sh 重启服务 1systemctl restart crond 3.4 配置文件备份以上备份命令不会备份配置文件，需手动进行备份。备份文件路径：/srv/gitlab/config（建议整个目录都备份）gitlab.rb 每次修改配置后需要进行备份。gitlab-secrets.json 建议进行迁移或者升级前进行备份。 GitLab提供的备份 Rake 任务不存储配置文件。主要原因是包含了用于双因素身份验证的加密信息和 CI/CD 安全变量。将加密信息与密钥存储在同一位置就违背了使用加密的目的。 4 恢复 在执行恢复之前，需要安装好一个正常的 GitLab ，版本要跟备份文件的 GitLab 版本一致。 4.1 恢复配置文件将 gitlab.rb 、 gitlab-secrets.json等config目录之前备份的文件拷贝到新安装的 GitLab 对应目录下（本示例为/srv/gitlab/config） 4.2 恢复数据 将要恢复的备份数据拷贝到将要恢复的 GitLab 所在的机器上（/srv/gitlab/data/backups/）。 依次执行以下命令 123456docker exec -it gitlab2021 bin/bashgitlab-ctl stop unicorngitlab-ctl stop pumagitlab-ctl stop sidekiq# Verifygitlab-ctl status 指定在第一步拷贝过来的备份文件进行恢复 12# 接着第二步中的命令继续执行以下命令gitlab-backup restore BACKUP=1616176926_2021_03_19_13.6.1-ee 出现以上内容，输入 yes 继续。恢复过程中出现以下错误，可以忽略（目前没有发现有什么影响）。 启动 1gitlab-ctl start 4.3 常见问题 在执行恢复数据时，出现以下问题 分析：备份文件与要恢复的 GitLab 版本要保持一致。解决：方法一，安装与备份文件相同的版本的 GitLab 后进行备份方法二，将老系统升级到与新的 GitLab 版本一致，然后手动立即进行一次备份生成备份文件，使用该备份文件进行还原。 未完待续….. 5 升级5.1 执行升级操作 升级前需要先进行手动备份。 找到最初安装 GitLab 时的 docker-compose.yml 文件，在该目录下执行以下命令 注意查看该文件内的 image 配置项，如果是 gitlab/gitlab-ee:latest ，则可安装最新的企业版本，也可修改latest 指定版本 123export GITLAB_HOME=/srv/gitlabdocker-compose pulldocker-compose up -d 执行以上命令后需等待几分钟（以下截图属于正常现象），几分钟后查看 GitLab 网址是否正常。 升级前截图：升级后截图： 5.2 常见问题 镜像文件下载完成后，启动失败。 分析：可能是网络原因。解决：重新执行即可。","link":"/2021/04/17/GitLab%E5%AE%89%E8%A3%85%E3%80%81%E5%A4%87%E4%BB%BD%E3%80%81%E6%81%A2%E5%A4%8D%E4%B8%8E%E5%8D%87%E7%BA%A7/"},{"title":"WebRTC入门","text":"一、协议1.1 P2P 通信原理与实现1.1.1 基本术语防火墙（Firewall）： 防火墙主要限制内网和公网的通讯，通常丢弃未经许可的数据包。防火墙会检测(但是不修改)试图进入内网数据包的 IP 地址和 TCP/UDP 端口信息。 网络地址转换协议（NAT）： 用来给你的（私网）设备映射一个公网的 IP 地址的协议。一般情况下，路由器的 WAN 口有一个公网 IP，所有连接这个路由器 LAN 口的设备会分配一个私有网段的 IP 地址（例如 192.168.1.3）。私网设备的 IP 被映射成路由器的公网 IP 和唯一的端口，通过这种方式不需要为每一个私网设备分配不同的公网 IP，但是依然能被外网设备发现。NAT 不止检查进入数据包的头部，而且对其进行修改，从而实现同一内网中不同主机共用更少的公网 IP（通常是一个）。 基本 NAT（Basic NAT）： 基本 NAT 会将内网主机的 IP 地址映射为一个公网 IP，不改变其 TCP/UDP 端口号。基本 NAT 通常只有在当 NAT 有公网 IP 池的时候才有用。 网络地址-端口转换器（NAPT）： 到目前为止最常见的即为 NAPT，其检测并修改出入数据包的 IP 地址和端口号，从而允许多个内网主机同时共享一个公网 IP 地址。 锥形 NAT（Cone NAT）： 在建立了一对（公网 IP，公网端口）和（内网 IP，内网端口）二元组的绑定之后，Cone NAT 会重用这组绑定用于接下来该应用程序的所有会话（同一内网 IP 和端口），只要还有一个会话还是激活的。 例如，假设客户端 A 建立了两个连续的对外会话，从相同的内部端点（10.0.0.1:1234）到两个不同的外部服务端 S1 和 S2。Cone NAT 只为两个会话映射了一个公网端点（155.99.25.11:62000）， 确保客户端端口的“身份”在地址转换的时候保持不变。由于基本 NAT 和防火墙都不改变数据包的端口号，因此这些类型的中间件也可以看作是退化的 Cone NAT。 12345678910111213141516171819 Server S1 Server S218.181.0.31:1235 138.76.29.7:1235 | | | | +----------------------+----------------------+ | ^ Session 1 (A-S1) ^ | ^ Session 2 (A-S2) ^ | 18.181.0.31:1235 | | | 138.76.29.7:1235 | v 155.99.25.11:62000 v | v 155.99.25.11:62000 v | Cone NAT 155.99.25.11 | ^ Session 1 (A-S1) ^ | ^ Session 2 (A-S2) ^ | 18.181.0.31:1235 | | | 138.76.29.7:1235 | v 10.0.0.1:1234 v | v 10.0.0.1:1234 v | Client A 10.0.0.1:1234 1.1.2 UDP 打洞(UDP hole punching)P2P 通信技术中被广泛采用的技术“UDP 打洞”。UDP 打洞技术依赖于通常防火墙和 cone NAT 允许正当的 P2P 应用程序在中间件中打洞且与对方建立直接链接的特性。 在学习 UDP 打洞之前，我们先了解一下另外两种 P2P 通信技术。 （1）中继（Relaying） 中继是最可靠但效率最低的一种 P2P 通信技术，它的原理是通过一台服务器来中继转发不同客户端的数据。 123456789 Server S | | +----------------------+----------------------+ | | NAT A NAT B | | | |Client A Client B 什么意思呢？就是我和你开视频，我和你的视频数据会直接被我们共同连接上的一台服务器接收，这台服务器会将你我的视频数据分别转发响应给我和你的客户端。这样服务器压力就很大，带宽需求也非常大，当仅仅只有两个客户端连接服务器开视频的话，服务器的带宽就至少是客户端带宽的两倍，CPU 消耗同样也是。那么当同时视频通话的人很多了，那么服务器的压力难以想象。 所以中继是一种效率很低的 P2P 通信技术。 （2）逆向连接（Connection reversal） 这种连接只有在两个通信端点中有一个不存在中间件的时候有效。 例如，客户端 A 在 NAT 之后而客户端 B 拥有全局 IP 地址，如下图： 123456789101112 Server S 18.181.0.31:1235 | | +----------------------+----------------------+ | | NAT A |155.99.25.11:62000 | | | | | Client A Client B 10.0.0.1:1234 138.76.29.7:1234 客户端 A 内网地址为 10.0.0.1，且应用程序正在使用 TCP 端口 1234。A 和服务器 S 建立了一个连接，服务器的 IP 地址为 18.181.0.31，监听 1235 端口。NAT A 给客户端 A 分配了 TCP 端口 62000，地址为 NAT 的公网 IP 地址 155.99.25.11， 作为客户端 A 对外当前会话的临时 IP 和端口。因此 S 认为客户端 A 就是 155.99.25.11:62000。而 B 由于有公网地址，所以对 S 来说 B 就是 138.76.29.7:1234。 当客户端 B 想要发起一个对客户端 A 的 P2P 链接时，要么链接 A 的外网地址 155.99.25.11:62000，要么链接 A 的内网地址 10.0.0.1:1234，然而两种方式链接都会失败。 链接 10.0.0.1:1234 失败自不用说，为什么链接 155.99.25.11:62000 也会失败呢？来自 B 的 TCP SYN 握手请求到达 NAT A 的时候会被拒绝，因为对 NAT A 来说只有外出的链接才是允许的。 在直接链接 A 失败之后，B 可以通过 S 向 A 中继一个链接请求，从而从 A 方向“逆向“地建立起 A-B 之间的点对点链接。 现在很多 P2P 系统都实现了这种技术，但是这种技术有局限性，只有当其中一放客户端有公网 IP 的时候才能建立起连接。为什么现在很多 P2P 系统都实现了逆向连接技术，因为我们接下来要讲的 UDP 打洞技术，主要是依赖这种技术。 UDP 打洞正文开始： 现在最多的网路连接情况是双方都是在内网下，都需要通过 NAT 进行地址转换，所以上面的逆向连接不适用，但是可以利用逆向连接技术进行改造。 假设客户端 A 和客户端 B 的地址都是内网地址，且在不同的 NAT 后面。A、B 上运行的 P2P 应用程序和服务器 S 都使用了 UDP 端口 1234，A 和 B 分别初始化了 与 Server 的 UDP 通信，地址映射如图所示: 123456789101112 Server S 18.181.0.31:1234 | | +----------------------+----------------------+ | | NAT A NAT B155.99.25.11:62000 138.76.29.7:31000 | | | | Client A Client B 10.0.0.1:1234 10.1.1.3:1234 现在假设客户端 A 打算与客户端 B 直接建立一个 UDP 通信会话。如果 A 直接给 B 的公网地址 138.76.29.7:31000 发送 UDP 数据，NAT B 将很可能会无视进入的 数据（除非是 Full Cone NAT），因为源地址和端口与 S 不匹配，而最初只与 S 建立过会话。B 往 A 直接发信息也类似。 假设 A 开始给 B 的公网地址发送 UDP 数据的同时，给服务器 S 发送一个中继请求，要求 B 开始给 A 的公网地址发送 UDP 信息。 A 往 B 的输出信息会导致 NAT A 打开 一个 A 的内网地址与与 B 的外网地址之间的新通讯会话，B 往 A 亦然。一旦新的 UDP 会话在两个方向都打开之后，客户端 A 和客户端 B 就能直接通讯， 而无须再通过引导服务器 S 了。 UDP 打洞技术有许多有用的性质。一旦一个的 P2P 链接建立，链接的双方都能反过来作为“引导服务器”来帮助其他中间件后的客户端进行打洞， 极大减少了服务器的负载。应用程序不需要知道中间件具体是什么（如果有的话），因为以上的过程在没有中间件或者有多个中间件的情况下 也一样能建立通信链路。 还有一些特殊情况：当通信双方都在同一局域网，也就是两个客户端都在一个内网下呢？是不是可以降低 NAT 转换，直接在内网上连接呢？此外还有，当一些大型企业，内网中有多级 NAT 转换呢？这里已不再本文的讨论中了，详细可以看以下参考文章详细了解： 参考文章：https://zhuanlan.zhihu.com/p/26796476 学到这里，根据上面的原理是可以实现自己的一套程序和通信规则，但很多时候是需要对接第三方的协议，往往这个适配是比较麻烦的。因此就产生了标准化的通用规则（STUN、TURN、ICE），下面的几个章节将逐个介绍这些协议。 1.2 STUN 协议STUN（STUN/RFC3489(废弃)，STUN/RFC5389）是 P2P 标准化通信规则（协议）之一。 1.2.1 简介NAT 的会话穿越功能Session Traversal Utilities for NAT (STUN) (缩略语的最后一个字母是 NAT 的首字母)是一个允许位于 NAT 后的客户端找出自己的公网地址，判断出路由器阻止直连的限制方法的协议。 STUN 是一个 C/S 架构的协议，支持两种传输类型。一种是请求/响应（request/respond）类型，由客户端给服务器发送请求，并等待服务器返回响应；另一种是指示类型（indication transaction），由服务器或者客户端 发送指示，另一方不产生响应。对于请求/响应类型，允许客户端将响应和产生响应的请求连接起来； 对于指示类型，通常在 debug 时使用。我们主要了解请求/响应类型。 1.2.2 通信过程客户端通过给公网的 STUN 服务器发送请求获得自己的公网地址信息，以及是否能够被（穿过路由器）访问。 客户端 A 向服务器产生一个 Request（STUN 叔叔，你能告诉我我的 ip 是多少吗） 服务器接收 Request，检查报文是否合法，并生成 Success 响应或 Error 响应（A 小朋友，你的 ip 是 208.141.55.130:3255） 1.3 TURN 协议TURN（TURN/RFC5766）是 P2P 标准化通信规则（协议）之一，是对 STUN 的补充。 1.3.1 简介TURN 的全称为Traversal Using Relays around NAT (TURN) ，是 STUN/RFC5389 的一个拓展，主要添加了 Relay 功能。前面介绍的 STUN 协议处理的是市面上大多数的 Cone NAT，但还有少量的设备使用的 Symmetric NAT。因此传统的打洞方法不适用，为了保证这一部分设备能够建立通信，我们不得不通过中继（Relaying）的方法进行连接，这时就需要公网的服务器作为一个中继， 对来往的数据进行转发。这个转发的协议就被定义为 TURN。这种情况会增加服务器负担，所以这是最坏的情况的通信解决方案。 TURN 服务器与客户端之间的连接都是基于 UDP 的，但是服务器和客户端之间可以通过其他各种连接来传输 STUN 报文, 比如 TCP/UDP/TLS-over-TCP。客户端之间通过中继传输数据时候，如果用了 TCP，也会在服务端转换为 UDP，因此建议客户端使用 UDP 来进行传输。至于为什么要支持 TCP，那是因为一部分防火墙会完全阻挡 UDP 数据，而对于三次握手的 TCP 数据则不做隔离。 1.3.2 通信过程客户端 A 向 STUN 服务器发送请求获取自己的公网地址，STUN 服务器可以获取到客户端 A 的地址，但发现客户端 A 的使用的 Symmetric NAT，因此 STUN 服务器告诉客户端 A，我不能帮助你和客户端 B 建立连接，你们之间可以通过 TURN 进行连接。因此客户端 A 和客户端 B 同时去连接 TURN 服务器，通过 TURN 服务器进行中继连接。 客户端 A 向 STUN 服务器产生一个 Request（STUN 叔叔，你能告诉我我的 ip 是多少吗） STUN 服务器响应（A 小朋友，你的 ip 是 208.141.55.130:3255，可是你的 ip 别人不能和你连接哦，你需要去找你 TURN 大伯，他是专门负责帮你连接） 客户端 A 向 TURN 服务器发起请求（TURN 大伯，STUN 叔叔叫我来找你） TURN 服务器响应（A 小侄儿，我知道了，但是现在还没有其他小朋友找你哦，你可以在这附近逛一逛，每 10 分钟要给我报告一下你还在这附近哦，一有其他小朋友来找你我就通知你。） 1.4 ICE 协议TURN（ICE/RFC5245）是 P2P 标准化通信规则（协议）之一，提供了完整的 NAT 传输解决方案。 STUN、TURN 都是工具类协议，只提供穿透 NAT 的功能。且 TURN 本身就是被设计为 ICE/RFC5245 的一部分 1.4.1 简介ICE 的全称为Interactive Connectivity Establishment (ICE)，即交互式连接建立。在实际的网络当中，有很多原因能导致简单的从 A 端到 B 端直连不能如愿完成。这需要绕过阻止建立连接的防火墙，给你的设备分配一个唯一可见的地址（通常情况下我们的大部分设备没有一个固定的公网地址），如果路由器不允许主机直连，还得通过一台服务器转发数据。ICE 通过使用 STUN、TURN、NAT、SDP 技术完成上述工作。(引用自：https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Protocols) ICE 是一个用于在Offer/Answer模式下的 NAT 传输协议，主要用于 UDP 下多媒体会话的建立，其使用了 STUN 协议以及 TURN 协议，同时也能被其他实现了 Offer/Answer 模型的的其他程序所使用，比如SIP(Session Initiation Protocol)。 网络编程的 ICE（Internate Communications Engine）：是一种用于分布式程序设计的网络通信中间件，本文指并非此 ICE 交互式连接 ICE（Interactive Connectivity Establishment）：是一个允许你的浏览器和对端浏览器建立连接的协议框架。 1.4.2 SDP 会话描述ICE 信息的描述格式通常采用标准的SDP，其全称为Session Description Protocol (SDP) ，即会话描述协议。SDP 不是一个真正的协议，而是一种数据格式，用于描述在设备之间共享媒体的连接。可以被其他传输协议用来交换必要的信息，如 SIP 和 RTSP 等。 SDP 格式： SDP 由一行或多行 UTF-8 文本组成，每行以一个字符的类型开头，后跟等号（“ =”），然后是包含值或描述的结构化文本，其格式取决于类型。 SDP 会话描述包含了多行如下类型的文本: 1&lt;type&gt;=&lt;value&gt; 以给定字母开头的文本行通常称为“字母行”。例如，提供媒体描述的行的类型为“ m”，因此这些行称为“ m 行”。 1m=audio 49170 RTP/AVP 0 &lt;type&gt;是大小写敏感的，其中一些行是必须要有的，有些是可选的，所有元素都必须以固定顺序给出。如下所示，其中可选的元素标记为* ： 1234567891011121314151617181920212223242526272829会话描述: v= (protocol version) o= (originator and session identifier) s= (session name) i=* (session information) u=* (URI of description) e=* (email address) p=* (phone number) c=* (connection information -- not required if included in all media) b=* (zero or more bandwidth information lines) One or more time descriptions (&quot;t=&quot; and &quot;r=&quot; lines; see below) z=* (time zone adjustments) k=* (encryption key) a=* (zero or more session attribute lines) Zero or more media descriptions时间信息描述: t= (time the session is active) r=* (zero or more repeat times)多媒体信息描述(如果有的话): m= (media name and transport address) i=* (media title) c=* (connection information -- optional if included at session level) b=* (zero or more bandwidth information lines) k=* (encryption key) a=* (zero or more media attribute lines) 所有元素的 type 都为小写，并且不提供拓展.但是我们可以用 a(attribute)字段来提供额外的信息。一个 SDP 描述的例子如下： 123456789101112v=0o=jdoe 2890844526 2890842807 IN IP4 10.47.16.5s=SDP Seminari=A Seminar on the session description protocolu=http://www.example.com/seminars/sdp.pdfe=j.doe@example.com (Jane Doe)c=IN IP4 224.2.17.12/127t=2873397496 2873404696a=recvonlym=audio 49170 RTP/AVP 0m=video 51372 RTP/AVP 99a=rtpmap:99 h263-1998/90000 具体字段的 type/value 描述和格式可以参考RFC4566。 1.4.3 Offer/Answer 模型SDP 用来描述多播主干网络的会话信息，但是并没有具体的交互操作细节是如何实现的，因此RFC3264 定义了一种基于 SDP 的 Offer/Answer 模型。 在该模型中，会话参与者的其中一方生成一个 SDP 报文构成 offer， 其中包含了一组 offer 希望使用的多媒体流和编解码方法，以及 offer 用来接收改数据的 IP 地址和端口信息。 offer 传输到会话的另一端(称为 answer)，由这一端生成一个 answer，即用来响应对应 offer 的 SDP 报文。 answer 中包含不同 offer 对应的多媒体流，并指明该流是否可以接受。 1.4.4 ICE 工作流程一个典型的 ICE 工作环境如下，有两个端点 A 和 B，都运行在各自的 NAT 之后(他们自己也许并不知道)，NAT 的类型和性质也是未知的。L 和 R 通过交换 SDP 信息在彼此之间建立多媒体会话，通常交换通过一个 SIP 服务器完成： 1234567891011121314151617181920 +-----------+ | SIP |+-------+ | Srvr | +-------+| STUN | | | | STUN || Srvr | +-----------+ | Srvr || | / \\ | |+-------+ / \\ +-------+ /&lt;- Signaling -&gt;\\ / \\ +--------+ +--------+ | NAT | | NAT | +--------+ +--------+ / \\ / \\ / \\ +-------+ +-------+ | Agent | | Agent | | A | | B | | | | | +-------+ +-------+ ICE 的基本思路是，每个终端都有一系列传输地址(包括传输协议，IP 地址和端口)的候选，可以用来和其他端点进行通信。其中可能包括： 直接和网络接口联系的传输地址(host address) 经过 NAT 转换的传输地址,即反射地址(server reflective address) TURN 服务器分配的中继地址(relay address) 通过之前的学习，我们可以了解到每个终端的情况是比较复杂的（有的终端可能同时连着 wifi 和网线，有多个内网地址），所有每个终端有多种可以连接的方案。 获取到这一系列传输地址后，会以一定优先级将地址排序。按照优先级和其他终端的传输地址进行组合检测连接可用性（连接性检查：Connectivity Checks）。 两端连接性检查，是一个 4 次握手过程: 1234567A B- -STUN request -&gt; \\ A's &lt;- STUN response / check &lt;- STUN request \\ B'sSTUN response -&gt; / check 连接性检查详细过程： 为中继候选地址生成许可(Permissions)； 从本地候选往远端候选发送 Binding Request： 在 Binding 请求中通常需要包含一些特殊的属性，以在 ICE 进行连接性检查的时候提供必要信息： PRIORITY 和 USE-CANDIDATE：优先级和候选 ICE-CONTROLLED 和 ICE-CONTROLLING：标识本端是受控方还是主控方（offer 生成方）。 生成 Credential：STUN 短期身份验证 处理 Response： 当收到 Binding Response 时，终端会将其与 Binding Request 相联系，通常生成事务 ID。随后将会将此事务 ID 与候选地址对进行绑定。 成功响应：要同时满足三个条件（STUN 传输产生一个 Success Response；response 的源 IP 和端口等于 Binding Request 的目的 IP 和端口；response 的目的 IP 和端口等于 Binding Request 的源 IP 和端口） 失败响应：487 错误，并将检测地址状态设置为 Waiting 以上仅对协议作了简单的介绍，具体服务器程序实现可参考：https://github.com/evilpan/TurnServer 1.5 经典 WebRTC 连接建立流程通过前面的协议了解学习，相信大家已经对 WebRTC 的底层连接流程有了一个模糊的意思，这里有张图展现了具体的连接流程。 引用自：https://aggresss.blog.csdn.net/article/details/106832965 二、服务器搭建2.1 STUN/TURN 服务器STUN 服务器已有现成项目：https://github.com/coturn/coturn 以下是在 ubuntu 上的安装和配置： 2.1.1 安装 coturn可以克隆 github 上的源码编译安装，在 ubuntu 里有直接的安装包 12apt-get -y updateapt-get -y install coturn 安装完毕后，先关闭 coturn 服务： 1systemctl stop coturn 2.1.2 配置 coturn(1) 允许 turnserver 首先需要允许 turnserver，打开/etc/default/coturn文件，将注释去掉： 1vim /etc/default/coturn 取消注释后如下： 1TURNSERVER_ENABLED=1 (2) 获取 ip 和 SSL 首选需要获取一下自己的内网 ip 以及网卡: 1ifconfig 生成 SSL 证书: 1apt install openssl 1openssl req -x509 -newkey rsa:2048 -keyout /etc/turn_server_pkey.pem -out /etc/turn_server_cert.pem -days 99999 -nodes (3) 配置 接下来正式改配置文件/etc/turnserver.conf，改之前先将原文件备份一个： 1mv /etc/turnserver.conf /etc/turnserver.conf.bat 然后新建配置文件： 1vim /etc/turnserver.conf 然后复制以下配置： 123456789101112131415161718192021222324server-name=turn.webrtc.zzboy.cnrealm=turn.webrtc.zzboy.cnfingerprintrelay-device=eth0 #与前ifconfig查到的网卡名称一致listening-ip=192.168.0.186 #内网IPlistening-port=3478tls-listening-port=5349relay-ip=192.168.0.186external-ip=121.36.105.109 #公网IPrelay-threads=50lt-cred-mechno-cliverbosecert=/etc/turn_server_cert.pempkey=/etc/turn_server_pkey.pem#pidfile=/var/run/turnserver.pidmin-port=49152max-port=65535user=jun:123456 #用户名密码，创建IceServer时用 2.1.3 测试工具：Trickle ICE 点击打开上面的工具 2.2 Nodejs 构建信令服务器(Signal Server)信令服务器我直接使用的一个开源项目：https://github.com/qdgx/WebRtcRoomServer 其实信令服务器已经涉及到实战了，这里就不讲具体实现，这里只先部署。 单纯地看，信令服务器其实可以算作是一个后端项目，我们这里部署也只是对该项目进行服务器部署。这里我使用的这个开源项目是使用 node.js 开发的，因此部署步骤和 node.js 部署步骤相差无异。 以下是我在 ubuntu 上的安装和配置： 2.2.1 安装 node 环境(1) 更新环境，安装 curl、git 12apt-get updateapt-get install -y curl git (2) 安装 node.js 先去官网https://nodejs.org/，查看最新稳定长期支持版，发现最新稳定版是14.15.3 LTS，node.js 的每个大版本号都有相对应的源，比如这里的 14.15.3 版本的源是 https://deb.nodesource.com/setup_14.x 所以在终端执行： 1curl -sL https://deb.nodesource.com/setup_10.x | sudo -E bash - 然后安装 node.js 1apt-get install nodejs node -v 和 npm -v 查看 node 和 npm 是否安装成功 2.2.2 克隆项目，安装依赖进入用户目录，克隆项目： 1cd ~/ &amp;&amp; git clone https://github.com/qdgx/WebRtcRoomServer.git 安装依赖： 12cd ~/WebRtcRoomServernpm i 启动服务： 1node app.js 在浏览器打开以下地址，测试一下是否访问： https://你服务器外网地址:8443 只要浏览器提示该页面存在风险，即表示项目已生效，点击高级，选择接受风险继续访问即可。（为什么提示风险：因为这个项目的证书是自签名证书） 如果无法访问，请检查服务器安全组是否打开了 TCP 和 UDP 协议的 8443 端口，有些服务器开端口需要在服务器上那配置安全组，比如阿里云 ECS 和华为云。 2.2.3 pm2 管理 node 服务直接用node app.js运行项目，在关闭终端后，node 项目也会随之被关闭，因此需要使用额外的工具来保持 node 服务一直开启。 安装 pm2： 1npm install pm2@latest -g 启动服务： 1pm2 start app.js --name signal-server --watch name：给应用命名，可以不管 watch：相当于热更新，应用文件更新后会重启应用 有关 pm2 的使用，可以百度查询一下，也可以参考本人之前写的一篇文章：https://www.zzboy.cn/Learning/f360ef90efef 三、API 学习以下主要介绍下一章节实战开中需要到的常用接口，完整的接口学习可查看对应官方文档。 3.1 socket.io 官方文档：https://socket.io/docs/v3/ 中文 w3chool：https://www.w3cschool.cn/socket/ Socket是一种全双工通信,当客户端和服务端建立起连接后，如果不主动断开，双方可以一直互相发送消息，适合于双方频繁通信的场景，也是支持服务端主动推送的一种通信方式。WebSocket是Html5推出的前端可以直接使用的 API，不过目前项目中用的还是 socket.io 比较多。socket.io 在浏览器环境下封装了 WebSocket, 可以给开发者带来更好的体验，在功能上也更完善。 socket.io 主要使用两个方法： emit(description: string, data: any：监听事件；description是标识；data是需要发送的数据。 on(description: string, callback: function：监听事件；description表示监听的标识；callback是监到事件后处理方法，参数是emit发送的数据。 通俗说，一个就是发送，一个是接收。发送方法需要指定谁(description)来接收；接收方法找到对应description接收。 3.1.1 服务器端(1) 安装 1npm install socket.io (2) 初始化 12345678910const httpServer = require(&quot;http&quot;).createServer(); // 创建http服务// 使用socket.io监听http服务const socketIO = require(&quot;socket.io&quot;);const io = socketIO.listen(httpServer);// 也可以使用如下方式const io = require(&quot;socket.io&quot;)(httpServer, { // options配置项}); 配置项：是初始配置 socket.io 的一些参数，我们使用默认的接口，如需要配置，可以看文档了解具体配置项：https://socket.io/docs/v3/server-api/#new-Server-httpServer-options 根据 WebRTC 安全策略，我们需要使用 https，因此，比较完整的初始化代码为： 123456789101112131415const fs = require(&quot;fs&quot;);const server = require(&quot;https&quot;).createServer({ key: fs.readFileSync(&quot;/tmp/key.pem&quot;), cert: fs.readFileSync(&quot;/tmp/cert.pem&quot;),});const options = { /* ... */};const io = require(&quot;socket.io&quot;)(server, options);io.on(&quot;connection&quot;, (socket) =&gt; { /* ... */});server.listen(3000); (3) 方法 io.on(‘connection’, fn) ：监听客户端连接 从上面初始化代码不难看出，socket.io 第一个方法应该io.on('connection', fn)。 connection 是保留description，当有客户端连接上当前服务器时，就会触发。 我们需要在其回调中处理相关业务： 1234567io.on(&quot;connection&quot;, (socket) =&gt; { // 监听断开连接 socket.on(&quot;disconnect&quot;, (reason) =&gt; console.log(reason)); // socket断开监听，disconnect也是保留字段 // 其他业务监听 socket.on(&quot;join&quot;, (data) =&gt; console.log(`欢迎${data.name}进入直播间`));}); socket.on(‘disconnect’, fn) ：监听客户端断开连接 123socket.on(&quot;disconnect&quot;, (reason) =&gt; { console.log(reason); // 断开原因有很多，可能是用户主动断开，也可能是浏览器直接关闭等}); socket.emit() : 发送信息 3.1.2 客户端3.2 音视频相关 API3.2.1 navigator.mediaDevices浏览器 API，可以通过该浏览器 API 获取用户媒体设备，通常只会用到一个方法：getUserMedia(options)，调用该方法时，浏览器会弹出请求音频或视频的权限，用户同意授权过后，即可获取到音视频流。 12345678navigator.mediaDevices .getUserMedia(options) .then(function (stream) { /* use the stream */ }) .catch(function (err) { /* handle the error */ }); 需要注意：navigator的mediaDevices属性需要在 https 环境下才会有，这是浏览器的限制。 options: 配置项 一般可直接设置为：{ audio: true, video: true }，表示为获取音频和视频。 1234567891011navigator.mediaDevices .getUserMedia({ audio: true, video: true, }) .then(function (stream) { /* use the stream */ }) .catch(function (err) { /* handle the error */ }); 视频方面，也可以准确定义视频画面的宽高： 1234567891011navigator.mediaDevices .getUserMedia({ audio: true, video: { width: 1280, height: 720 }, // 当定义宽高是，视频算是true，请求视频权限 }) .then(function (stream) { /* use the stream */ }) .catch(function (err) { /* handle the error */ }); 其他更多配置可参考：https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia 3.2.2 video(1) video 标签 123&lt;video src=&quot;path/to/movie.mp4&quot; controls=&quot;controls&quot;&gt; 您的浏览器不支持 video 标签。&lt;/video&gt; 属性： autoplay: 如果出现该属性，则视频在就绪后马上播放 controls：如果出现该属性，则向用户显示控件，比如播放按钮 loop：如果出现该属性，则当媒介文件完成播放后再次开始播放 muted：规定视频的音频输出应该被静音 poster：规定视频下载时显示的图像，或者在用户点击播放按钮前显示的图像 preload：如果出现该属性，则视频在页面加载时进行加载，并预备播放。如果使用 “autoplay”，则忽略该属性 src：要播放的视频的 URL width：设置视频播放器的宽度，单位 px height：设置视频播放器的高度，单位 px 我们在进行音视频通话时，通常 本地视频（我方视频）应如下： 1&lt;video id=&quot;local&quot; muted autoplay&gt;您的浏览器不支持 video 标签。&lt;/video&gt; 本地视频静音播放，因为我们无需我们自己发出的声音，因为我们到时候视频资源是从设备直接实时获取视频流，因此无需设置 src，并且设置autoplay，可以让我们获取到视频流直接播放。 远程视频（对方视频）应如下： 1&lt;video id=&quot;remote&quot; poster=&quot;xxx&quot; autoplay&gt;您的浏览器不支持 video 标签。&lt;/video&gt; 远程视频同样设置autoplay属性，让接收到的视频流直接播放。另外可设置一个poster属性，可以在呼叫过程中或者被呼叫时，让页面显示呼叫中或者是显示对方头像肖像等，不然页面全黑会显得很尴尬。 (2) video 对象 使用音视频通话，我们控制音视频的播放基本通过js实现的，就连前面介绍的video标签一般都是通过js创建。video对象有很多属性，我这里只简单介绍部分属性，能基本满足 WebRTC 音视频通话。 我们要实现音视频实时通讯，传递的数据是音视频流，音视频流怎么让video播放出来呢？看看下面代码： 123456789101112131415161718192021222324/** * 视频流绑定到video节点展示 * @param {dom} video video节点 * @param {obj} stream 视频流 */const pushStreamToVideo = (video, stream) =&gt; { video.srcObject = stream;};// 获取video节点const domLocalVideo = $(&quot;#local&quot;);// 调用摄像头navigator.mediaDevices .getUserMedia({ audio: true, video: true, }) .then((stream) =&gt; { pushStreamToVideo(domLocalVideo[0], stream); // 实时显示 }) .catch((err) =&gt; { alert(`getUserMedia() error: ${err.name}`); }); 不难看出，video对象有个srcObject的属性，初始时该属性值是null，将我们获取到音视频流直接赋值给该属性，我们的video标签就可以实时播放了。上面这个例子是调用本地摄像头并展示到一个 id=local 的video标签上，需要在 https 上就可以正常运行了。 我们如何关闭视频呢？ 方法一：简单粗暴，关闭页面或者关闭浏览器。（你会让用户这么干么？） 方法二：使用MediaStream.getTracks()，获取到所有媒体流轨道，每条轨道调用一个方法stop()，就可以关闭当前流，摄像头也会停止录制。 12345678/** * 关闭摄像头 * @param {dom} video video节点 */const closeCamera = (video) =&gt; { video.srcObject.getTracks()[0].stop(); // audio video.srcObject.getTracks()[1].stop(); // video}; 音频是第一条轨道，视频是第二条轨道，两个同时关闭即可。 3.3 WebRTC 官方文档（不推荐）：https://www.w3.org/TR/webrtc/#peer-to-peer-connections 官方文档中文翻译（不推荐）：https://github.com/RTC-Developer/WebRTC-Documentation-in-Chinese/tree/master/resource MDN Web Docs（推荐）：https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API 3.3.1 RTCPeerConnection https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/ RTCPeerConnection是浏览器之间点对点连接的核心 API，用于处理对等体之间流数据的稳定和有效通信， 1const pc = new RTCPeerConnection(serverConfig); serverConfig 包含 iceServers 参数，它包含有关 STUN 和 TURN 服务器相关信息数组，在查找 ICE 的时候候选使用。可以在网上找一些公共的 STUN 服务器，也可以使用前面章节我们自己通过 coturn 搭建的 STUN 服务器。 123456789101112const serverConfig = { iceServers: [ { urls: &quot;stun:stun.xten.com&quot;, }, { urls: &quot;stun:你的服务器ip:3478&quot;, // 见2.1服务器搭建 username: &quot;用户名&quot;, credential: &quot;密码&quot;, }, ],}; (1) onicecandidate = eventHandler 作用：监听 RTCPeerConnection 实例上发生 icecandidate 事件，该函数会返回 ICE 协商结果，我们需要将结果发送给信令服务器，交由信令服务器转发给对方。 1234567pc.onicecandidate = (event) =&gt; { if (event.candidate) { sendCandidateToRemotePeer(event.candidate); } else { /* there are no more candidates coming during this negotiation */ }}; (2) ontrack = eventHandler 作用：监听 RTCPeerConnection 实例上接收到远程的数据流，该函数可获取到对端的媒体流。 123pc.ontrack = (event) =&gt; { document.getElementById(&quot;received_video&quot;).srcObject = event.streams[0];}; (3) addTrack(track, stream…) 作用：设置轨道，该轨道将会在连同后传输到对端。 123456async openCall(pc) { const gumStream = await navigator.mediaDevices.getUserMedia({video: true, audio: true}); for (const track of gumStream.getTracks()) { pc.addTrack(track); }} MDN 不建议使用 addStream() (3) removeTrack(sender) 作用：删除轨道，删除已添加的轨道，用于挂断的时候 123456789101112131415var pc, sender;navigator.getUserMedia({ video: true }, function (stream) { pc = new RTCPeerConnection(); var track = stream.getVideoTracks()[0]; sender = pc.addTrack(track, stream);});document.getElementById(&quot;closeButton&quot;).addEventListener( &quot;click&quot;, function (event) { pc.removeTrack(sender); pc.close(); }, false); 不建议的：onremovestream (5) setLocalDescription()/setRemoteDescription() setLocalDescription(sessionDescription)： 设置本地 offer，将自己的描述信息加入到PeerConnection中，参数类型：RTCSessionDescription（见下一小节 3.2.2 RTCSessionDescription） setRemoteDescription(sessionDescription)： 设置远端的answer，将对方的描述信息加入到PeerConnection中，参数类型：RTCSessionDescription（见下一小节 3.2.2 RTCSessionDescription） 通俗说：Alice为了和Bob建立合作关系(连接)，Alice我把拟好了一份合同，并签字了，我这里先保留扫描版，纸质合同通过快递(SDP)给你了，你通过快递(SDP)拿到合同后，先签字确认，这时候纸质合同上都有我们双方的签名了，但我这边还没有你的签名。你保存一下扫描版，然后通过快递把纸质再给我发回来，我拿到快递后，我也保存一下扫描版。这样，你我双放都有双方签名的扫描版合同。合同开始生效！ (6) createOffer()/createAnswer() createOffer([options])： 创建一个offer，表示我方的请求。通常在 WebRTC 通信中，我们会请求对方接收我们的音频和视频数据。 1234567const offerOptions = { offerToReceiveAudio: true, // 请求接收音频 offerToReceiveVideo: true, // 请求接收视频},pc.createOffer(offerOptions) .then(offer =&gt; onCreateOfferSuccess(offer.sdp)) .catch(error =&gt; onCreateOfferError()); createAnswer([options])： 创建一个answer，回应对方offer。answer也是有offer作用的，在回应的时候，表示答应你，并向你请求。 打个比方：A 向 B 表白，请求 B 做 A 的女朋友。如果 B 接受了，表示 B 成了 A 女朋友。同时，这也有另外一层含义，表示 B 有请求：请 A 做我的男朋友。 1234567const answerOptions = { offerToReceiveAudio: true, // 请求接收音频 offerToReceiveVideo: true, // 请求接收视频},pc.createAnswer(answerOptions) .then(answer =&gt; onCreateAnswerSuccess(answer.sdp)) .catch(error =&gt; onCreateAnswerError()); 3.3.2 RTCSessionDescription用于生成 Offer/Answer 协商过程中 SDP 协议的相关描述。 1new RTCSessionDescription(rtcDescription); rtcDescription 只有两个属性：type，sdp type只能设置：’answer’，’offer’，’pranswer’，’rollback’； sdp是标准的 SDP 会话描述（可由 createOffer/createAnswer 生成） 3.3.3 RTCIceCandidate https://developer.mozilla.org/en-US/docs/Web/API/RTCIceCandidate https://blog.51cto.com/zhangjunhd/25481 用于建立 ICE 连接。通常我们不会手动去实例化一个RTCIceCandidate对象，在前面3.3.1 RTCPeerConnection中的onicecandidate事件回调就是一个RTCIceCandidate对象，我们只需要了解其中几个属性即可。 candidate: 用于连接性检测的对象 sdpMid: candidate 的媒体流的识别标签 sdpMLineIndex: candidate 的媒体流的相关联的 SDP 描述索引号 address: 本机 IP 地址 relatedAddress: 中继 IP port: 本机端口 relatedPort: 中继端口 component: 候选协议，只有两种情况：RTP(Real-Time Transport Protocol)， RTCP(Real-Time Transport Control Protocol) foundation: 来自于 STUN 服务器的唯一标识符 priority: 优先级 tcpType: 如果使用的 TCP 协议，这个属性及表示 TCP 的状态 type: RTCIceCandidateType 类型 usernameFragment: ice-ufrag片段，用于生成ice-pwd，同一 ICE 进程的连接都将使用的是同一个片段。 四、实战开发前面基本上已经列举了大部分基础知识，现在开始运用起来。 本章实战开发，是开发一个 web 实时音视频聊天室 ：输入相同房间号，即可加入聊天室，进行视频聊天。 主要有两个项目，前端界面(页面+WebRTC+socket.io)，后端信令服务器控制转发(Express+socket.io)。 整个项目完整代码：http://223.223.179.203:8929/product/cp6666/webrtc-demo 4.1 环境准备 anywhere: npm i -g anywhere 4.2 信令服务器因为信令服务器代码结构比较简单，咱们先开发信令服务器。观察1.5 经典WebRTC连接建立流程，不难发现，信令服务器主要需要实现：转发offer、转发answer、转发candidate的三大核心功能。此外，我们开发聊天室，还需要：创建聊天室、退出聊天室的功能。 4.2.1 搭建项目（1）创建一个文件夹signal-server，在目录下创建两个文件： package.json 1234567891011121314{ &quot;name&quot;: &quot;signal-server&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;author&quot;: &quot;Patrick Jun&quot;, &quot;description&quot;: &quot;A webRTC signal server&quot;, &quot;scripts&quot;: { &quot;start&quot;: &quot;node app.js&quot; }, &quot;dependencies&quot;: { &quot;express&quot;: &quot;^4.17.1&quot;, &quot;express-session&quot;: &quot;^1.17.1&quot;, &quot;socket.io&quot;: &quot;^2.3.0&quot; }} app.js 12345678910111213141516171819202122232425const https = require(&quot;https&quot;); // https服务const fs = require(&quot;fs&quot;); // fsconst socketIO = require(&quot;socket.io&quot;);//读取密钥和签名证书const options = { key: fs.readFileSync(&quot;keys/server_key.pem&quot;), cert: fs.readFileSync(&quot;keys/server_crt.pem&quot;),};// 构建https服务器const apps = https.createServer(options);const SSL_PORT = 8443;apps.listen(SSL_PORT);// 构建signal serverconst io = socketIO.listen(apps);// socket监听连接io.sockets.on(&quot;connection&quot;, (socket) =&gt; { console.log(&quot;连接建立&quot;); // 之后所有业务处理，写在这里面}); （2）创建证书 在项目文件夹下，创建一个文件夹keys，然后开始生成自签名证书： linux 环境下： 1openssl req -x509 -newkey rsa:2048 -keyout ./keys/server_key.pem -out ./keys/server_crt.pem -days 99999 -nodes windows 下：参考 https://letsencrypt.org/zh-cn/docs/certificates-for-localhost/ 修改app.js，将秘钥和签名证书的路径改为你电脑中的绝对路径，例如： 12345//读取密钥和签名证书const options = { key: fs.readFileSync(&quot;D://signal-server/keys/server_key.pem&quot;), cert: fs.readFileSync(&quot;D://signal-server/keys/server_crt.pem&quot;),}; （3）运行 在项目根目录下，安装依赖： 1npm i 然后，启动： 1node app.js 打开浏览器，访问：https://localhost:8443 访问时，浏览器会提示不安全的访问，这个时候，直接敲键盘：thisisunsafe 即可继续访问。当看到浏览器地址栏继续一直在请求中，那么就表示项目成功运行。 4.2.2 房间功能房间功能主要包括：创建/加入房间、退出房间。 业务处理，都放在连接成功后的回调函数里。 （1）创建房间 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// socket监听连接io.sockets.on(&quot;connection&quot;, (socket) =&gt; { console.log(&quot;连接建立&quot;); // 创建/加入房间 socket.on(&quot;createAndJoinRoom&quot;, (message) =&gt; { const { room } = message; console.log(&quot;Received createAndJoinRoom：&quot; + room); // 判断room是否存在 const clientsInRoom = io.sockets.adapter.rooms[room]; const numClients = clientsInRoom ? Object.keys(clientsInRoom.sockets).length : 0; console.log(&quot;Room &quot; + room + &quot; now has &quot; + numClients + &quot; client(s)&quot;); if (numClients === 0) { // room 不存在 不存在则创建（socket.join） // 加入并创建房间 socket.join(room); console.log(&quot;Client ID &quot; + socket.id + &quot; created room &quot; + room); // 发送消息至客户端 [id,room,peers] const data = { id: socket.id, //socket id room: room, // 房间号 peers: [], // 其他连接 }; socket.emit(&quot;created&quot;, data); } else { // room 存在 // 加入房间中 socket.join(room); console.log(&quot;Client ID &quot; + socket.id + &quot; joined room &quot; + room); // joined告知房间里的其他客户端 [id,room] io.sockets.in(room).emit(&quot;joined&quot;, { id: socket.id, //socket id room: room, // 房间号 }); // 发送消息至客户端 [id,room,peers] const data = { id: socket.id, //socket id room: room, // 房间号 peers: [], // 其他连接 }; // 查询其他连接 const otherSocketIds = Object.keys(clientsInRoom.sockets); for (let i = 0; i &lt; otherSocketIds.length; i++) { if (otherSocketIds[i] !== socket.id) { data.peers.push({ id: otherSocketIds[i], }); } } socket.emit(&quot;created&quot;, data); } });}); （2）退出房间 在加入房间监听后面，继续添加： 123456789101112131415161718// 退出房间，转发exit消息至room其他客户端 [from,room]socket.on(&quot;exit&quot;, (message) =&gt; { console.log( &quot;Received exit: &quot; + message.from + &quot; message: &quot; + JSON.stringify(message) ); const { room } = message; // 关闭该连接 socket.leave(room); // 转发exit消息至room其他客户端 const clientsInRoom = io.sockets.adapter.rooms[room]; if (clientsInRoom) { const otherSocketIds = Object.keys(clientsInRoom.sockets); for (let i = 0; i &lt; otherSocketIds.length; i++) { const otherSocket = io.sockets.connected[otherSocketIds[i]]; otherSocket.emit(&quot;exit&quot;, message); } }}); 还有一种情况，当 socket 连接异常断开时，也需要退出房间： 12345678910// socket关闭socket.on(&quot;disconnect&quot;, function (reason) { const socketId = socket.id; console.log(&quot;disconnect: &quot; + socketId + &quot; reason:&quot; + reason); const message = { from: socketId, room: &quot;&quot;, }; socket.broadcast.emit(&quot;exit&quot;, message);}); 4.2.3 转发功能转发功能有：转发offer、转发answer、转发candidate （1）转发 offer 12345678910111213141516171819// 转发offer消息至room其他客户端 [from,to,room,sdp]socket.on(&quot;offer&quot;, (message) =&gt; { // const room = Object.keys(socket.rooms)[1]; console.log( &quot;收到offer: from &quot; + message.from + &quot; room:&quot; + message.room + &quot; to &quot; + message.to ); // 根据id找到对应连接 const otherClient = io.sockets.connected[message.to]; if (!otherClient) { return; } // 转发offer消息至其他客户端 otherClient.emit(&quot;offer&quot;, message);}); （2）转发 answer 12345678910111213141516171819// 转发answer消息至room其他客户端 [from,to,room,sdp]socket.on(&quot;answer&quot;, (message) =&gt; { // const room = Object.keys(socket.rooms)[1]; console.log( &quot;收到answer: from &quot; + message.from + &quot; room:&quot; + message.room + &quot; to &quot; + message.to ); // 根据id找到对应连接 const otherClient = io.sockets.connected[message.to]; if (!otherClient) { return; } // 转发answer消息至其他客户端 otherClient.emit(&quot;answer&quot;, message);}); （3）转发 candidate 123456789101112131415161718// 转发candidate消息至room其他客户端 [from,to,room,candidate[sdpMid,sdpMLineIndex,sdp]]socket.on(&quot;candidate&quot;, (message) =&gt; { console.log( &quot;收到candidate: from &quot; + message.from + &quot; room:&quot; + room + &quot; to &quot; + message.to ); // 根据id找到对应连接 const otherClient = io.sockets.connected[message.to]; if (!otherClient) { return; } // 转发candidate消息至其他客户端 otherClient.emit(&quot;candidate&quot;, message);}); 4.2.4 完整代码http://223.223.179.203:8929/product/cp6666/webrtc-demo/-/tree/master/signal-server 4.3 前端前端可以分为三大功能：音视频设备控制和音视频显示控制、Offer/Answer 沟通、ICE 连接。 4.3.1 搭建项目（1）创建一个文件夹webrtc-client，在目录下创建一个index.html文件，创建一个目录`js 123|- webrtc-client/ |- js/ |- index.html （2）在js目录下创建几个文件，并在从网上下载socket.io.js和jquery.min.js文件 12345678|- webrtc-client/ |- js/ |- config.js |- sdk.js |- main.js |- socket.io.js // 自行从网上下载 |- jquery.min.js // 自行从网上下载 |- index.html （3）代码 index.html 1234567891011121314151617181920212223242526272829303132333435363738&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no&quot; /&gt; &lt;title&gt;WebRtc视频通话demo&lt;/title&gt; &lt;style&gt; video { background-color: bisque; } &lt;/style&gt; &lt;script src=&quot;js/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/socket.io.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/config.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/sdk.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;text&quot; id=&quot;room&quot; value=&quot;1&quot; placeholder=&quot;输入房间号&quot; /&gt; &lt;button id=&quot;connect&quot;&gt;连接&lt;/button&gt; &lt;button id=&quot;logout&quot;&gt;挂断&lt;/button&gt; &lt;br /&gt; &lt;h3&gt;本地视频&lt;/h3&gt; &lt;video id=&quot;localVideo&quot; style=&quot;width:200px;height:200px;&quot; autoplay muted &gt;&lt;/video&gt; &lt;br /&gt; &lt;h3&gt;远程视频&lt;/h3&gt; &lt;div id=&quot;remoteDiv&quot;&gt;&lt;/div&gt; &lt;script src=&quot;js/main.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; config.js 12345678910111213141516// WebRTC配置文件const THSConfig = { // 信令服务器 signalServer: &quot;wss://localhost:8443&quot;, // Offer/Answer模型请求配置 offerOptions: { offerToReceiveAudio: true, // 请求接收音频 offerToReceiveVideo: true, // 请求接收视频 }, // ICE服务器 iceServers: { iceServers: [ { urls: &quot;stun:stun.xten.com&quot; }, // Safri兼容：url -&gt; urls ], },}; 4.3.2 兼容预处理因为部分web API在不同浏览器有不同的名称或者属性，因此需要处理兼容，以下是兼容代码，预先定义一下。 编辑sdk.js： 12345678910111213141516171819202122232425// 兼容处理const PeerConnection = window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection;const SessionDescription = window.RTCSessionDescription || window.mozRTCSessionDescription || window.webkitRTCSessionDescription;const GET_USER_MEDIA = navigator.getUserMedia ? &quot;getUserMedia&quot; : navigator.mozGetUserMedia ? &quot;mozGetUserMedia&quot; : navigator.webkitGetUserMedia ? &quot;webkitGetUserMedia&quot; : &quot;getUserMedia&quot;;const v = document.createElement(&quot;video&quot;);const SRC_OBJECT = &quot;srcObject&quot; in v ? &quot;srcObject&quot; : &quot;mozSrcObject&quot; in v ? &quot;mozSrcObject&quot; : &quot;webkitSrcObject&quot; in v ? &quot;webkitSrcObject&quot; : &quot;srcObject&quot;; 4.3.3 音视频控制音视频控制主要分打开关闭摄像头，视频流绑定到video标签，其实这一节前面3.2 音视频相关API已经学习过了，这里直接给出代码。 接着编辑sdk.js 12345678910111213141516171819202122232425262728/** * 启动摄像头 */const openCamera = () =&gt; { return navigator.mediaDevices[GET_USER_MEDIA]({ audio: true, video: true, });};/** * 关闭摄像头 * @param {dom} video video节点 */const closeCamera = (video) =&gt; { video[SRC_OBJECT].getTracks()[0].stop(); // audio video[SRC_OBJECT].getTracks()[1].stop(); // video};/** * 视频流绑定到video节点展示 * @param {dom} video video节点 * @param {obj} stream 视频流 */const pushStreamToVideo = (video, stream) =&gt; { console.log(&quot;视频流绑定到video节点展示&quot;, video, stream); video[SRC_OBJECT] = stream;}; 编辑main.js： 123456789101112131415161718192021222324252627/** * dom获取 */const btnConnect = $(&quot;#connect&quot;); // 连接domconst btnLogout = $(&quot;#logout&quot;); // 挂断domconst domLocalVideo = $(&quot;#localVideo&quot;); // 本地视频dom/** * 连接 */btnConnect.click(() =&gt; { //启动摄像头 if (localStream == null) { openCamera() .then((stream) =&gt; { pushStreamToVideo(domLocalVideo[0], stream); }) .catch((e) =&gt; alert(`getUserMedia() error: ${e.name}`)); }});/** * 挂断 */btnLogout.click(() =&gt; { closeCamera(domLocalVideo[0]);}); 测试一下摄像头功能，因为开启摄像头需要使用 https 服务，因此在前端项目根目录打开控制台命令，运行： 1anywhere 5000 然后浏览器打开命令行提示里的端口号为5001的那个 https 协议的地址，例如：https://192.168.1.4:5001/ 这时候，可能也会提示您的连接不是私密连接，点击高级，最下面继续前往。 点击连接按钮，允许访问摄像头，看摄像头是否正常打开，页面视频是否出现，然后点击断开，看摄像头是否关闭、画面是否消失。 4.3.4 Offer/Answer 模型从这节开始，就正式涉及到WebRTC相关 API 了，下面先写几个全局变量，用于保存一些公用数据： 编辑sdk.js 12345678910// socket连接const socket = io(THSConfig.signalServer);// 本地socket idlet socketId;// 房间 idlet roomId;// 对RTCPeerConnection连接进行缓存let rtcPeerConnects = {};// 本地streamlet localStream = null; （1）加入房间 在开始 Offer/Answer 模型前，我们必须得至少有两个客户端才行。因此，我们先写一下，怎么控制房间。 咱们先整理一下思路，我们先让甲创建一个房间，然后，这个房间里只有甲一个人，无法进行 Offer/Answer。这时候乙在进入房间时，可以获取一下房间的人数，如果房间有人，那么乙就给房间里的每一个人发送Offer请求。房间里的甲监听到了刚进来乙的 Offer 后，给乙回复 Answer。这样就建立起了Offer/Answer模型。 编辑sdk.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * 连接（给signal server 发送创建或者加入房间的消息） * @param {string} roomid 房间号 */const connect = (roomid) =&gt; { console.log(&quot;创建或者加入房间&quot;, roomid); socket.emit(&quot;createAndJoinRoom&quot;, { room: roomid, });};/** * 监听signal server创建房间或者加入房间成功的消息，signal server会判断房间里是否有人 */socket.on(&quot;created&quot;, async (data) =&gt; { // data: [id,room,peers] console.log(&quot;created: &quot;, data); // 保存signal server给我分配的socketId socketId = data.id; // 保存创建房间或者加入房间的room id roomId = data.room; // 如果data.peers = []，说明房间里没有人，是创建房间，以下步骤则不会执行 // 如果data.peers != []，说明房间里有人，是加入房间，给返回的每一个peers，创建WebRtcPeerConnection并发送offer消息 for (let i = 0; i &lt; data.peers.length; i++) { let otherSocketId = data.peers[i].id; // 创建WebRtcPeerConnection // 注意：这个函数是下一个步骤写的。 let pc = getWebRTCConnect(otherSocketId); // 创建offer const offer = await pc.createOffer(THSConfig.offerOptions); // 发送offer onCreateOfferSuccess(pc, otherSocketId, offer); }});/** * offer创建成功回调 * @param {*} pc * @param {*} otherSocketId * @param {*} offer */function onCreateOfferSuccess(pc, otherSocketId, offer) { console.log( &quot;createOffer: success &quot; + &quot; id:&quot; + otherSocketId + &quot; offer: &quot;, offer ); // 设置本地setLocalDescription 将自己的描述信息加入到PeerConnection中 pc.setLocalDescription(offer); // 构建offer const message = { from: socketId, to: otherSocketId, room: roomId, sdp: offer.sdp, }; console.log(&quot;发送offer消息&quot;, message); // 发送offer消息 socket.emit(&quot;offer&quot;, message);} 前面，可以算是把Offer发出去了，可以回顾4.2.3 转发功能，信令服务器收到Offer后，会将其转发给房间里的每一个用户，然后，我们就需要写一个监听，当信令服务器转发过来Offer后，我们应该进行Answer： 继续编辑sdk.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * 监听signal server转发过来的offer消息，将对方的描述信息加入到PeerConnection中，然后构建answer */socket.on(&quot;offer&quot;, (data) =&gt; { // data: [from,to,room,sdp] console.log(&quot;收到offer: &quot;, data); // 获取RTCPeerConnection const pc = getWebRTCConnect(data.from); console.log(&quot;getWebRTCConnect: &quot;, pc); // 构建RTCSessionDescription参数 const rtcDescription = { type: &quot;offer&quot;, sdp: data.sdp, }; console.log(&quot;offer设置远端setRemoteDescription&quot;); // 设置远端setRemoteDescription pc.setRemoteDescription(new SessionDescription(rtcDescription)); console.log(&quot;setRemoteDescription: &quot;, rtcDescription); // createAnswer pc.createAnswer(THSConfig.offerOptions) .then((offer) =&gt; onCreateAnswerSuccess(pc, data.from, offer)) .catch((error) =&gt; onCreateAnswerError(error));});/** * answer创建成功回调 * @param {*} pc * @param {*} otherSocketId * @param {*} offer */function onCreateAnswerSuccess(pc, otherSocketId, offer) { console.log( &quot;createAnswer: success &quot; + &quot; id:&quot; + otherSocketId + &quot; offer: &quot;, offer ); // 设置本地setLocalDescription，将对方的描述信息加入到PeerConnection中 pc.setLocalDescription(offer); // 构建answer信息 const message = { from: socketId, to: otherSocketId, room: roomId, sdp: offer.sdp, }; console.log(&quot;发送answer消息&quot;, message); // 发送answer消息 socket.emit(&quot;answer&quot;, message);}/** * answer创建失败回调 * @param {*} error */function onCreateAnswerError(error) { console.log(&quot;createAnswer: fail error &quot; + error);} 现在，我们把Answer信息回复出去了，通过信令服务器会转发指定的用户（刚刚发来 offer 的用户），然后我们还要添加一个监听Answer的信息： 继续编辑sdk.js 1234567891011121314151617181920/** * 监听signal server转发过来的answer消息，将对方的描述信息加入到PeerConnection中 */socket.on(&quot;answer&quot;, (data) =&gt; { // data: [from,to,room,sdp] console.log(&quot;收到answer: &quot;, data); // 获取RTCPeerConnection const pc = getWebRTCConnect(data.from); // 构建RTCSessionDescription参数 const rtcDescription = { type: &quot;answer&quot;, sdp: data.sdp, }; console.log(&quot;answer设置远端setRemoteDescription&quot;); console.log(&quot;setRemoteDescription: &quot;, rtcDescription); //设置远端setRemoteDescription pc.setRemoteDescription(new SessionDescription(rtcDescription));}); （2）获取 RTCPeerConnection、移除 RTCPeerConnection 接上一步骤，其中涉及到一个getWebRTCConnect的方法，这节就写如何实现它，以及本地如何管理与他人的连接。 继续编辑sdk.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 对RTCPeerConnection连接进行缓存let rtcPeerConnects = {}; // 这是开始前设置的全局变量/** * 获取RTCPeerConnection * @param {string} otherSocketId 对方socketId */function getWebRTCConnect(otherSocketId) { if (!otherSocketId) return; // 查询全局中是否已经保存了连接 let pc = rtcPeerConnects[otherSocketId]; console.log(&quot;建立连接：&quot;, otherSocketId, pc); if (typeof pc === &quot;undefined&quot;) { // 如果没有保存，就创建RTCPeerConnection // 构建RTCPeerConnection pc = new PeerConnection(THSConfig.iceServers); // PeerConnection是4.3.2定义的兼容处理 // 设置获取icecandidate信息回调 此处可暂时忽略，将在4.3.5讲解 pc.onicecandidate = (e) =&gt; onIceCandidate(pc, otherSocketId, e); // 设置获取对端stream数据回调-track方式 此处可暂时忽略，将在4.3.5讲解 pc.ontrack = (e) =&gt; { console.log(&quot;我接到数据流了！！&quot;, pc, otherSocketId, e); onTrack(pc, otherSocketId, e); }; // 设置获取对端stream数据回调 此处可暂时忽略，将在4.3.5讲解 pc.onremovestream = (e) =&gt; onRemoveStream(pc, otherSocketId, e); // peer设置本地流 此处可暂时忽略，将在4.3.5讲解 if (localStream != null) { localStream.getTracks().forEach((track) =&gt; { pc.addTrack(track, localStream); }); } // 缓存peer连接 rtcPeerConnects[otherSocketId] = pc; } return pc;}/** * 移除RTCPeerConnection连接缓存 * @param {string} otherSocketId 对方socketId */function removeRtcConnect(otherSocketId) { delete rtcPeerConnects[otherSocketId];} 4.3.5 ICE 连接/接收音视频流Offer/Answer 模型让两个客户端互相建立了签订了合同，建立了信任的合作伙伴关系，接下来可以开始进行交易了（传输音视频数据）。在交易前，我们要互相知道对方真实的交易地址和银行账号（允许主机直连的地址，详细可回顾 1.4ICE 协议），我给你发货，你给我打钱。 通常，在第一步乙的Offer发出后，乙客户端就开始通过 ICE 获取自己的地址（通过 ICE 协议可以了解，这个地址可能是自己的 IP 地址），只要等甲方同意（设置远程描述完成，这时候可能还未回复 Answer），甲方就可以接收到乙客户端的音视频流了。同理，甲方回复的Answer之后，只要乙客户端同意，乙客户端也就能收到甲方的音视频流了。至此，双方都收到对方的视频流了，视频通话建立。 回顾上一小节 4.3.4 (2) 获取RTCPeerConnection中的一段代码： 123456789101112131415161718// 构建RTCPeerConnectionpc = new PeerConnection(THSConfig.iceServers); // PeerConnection是4.3.2定义的兼容处理// 1. 设置获取icecandidate信息回调pc.onicecandidate = (e) =&gt; onIceCandidate(pc, otherSocketId, e);// 2. 设置获取对端stream数据回调-track方式 还有种方式是onaddstream，但这种方式已经不推荐使用了。pc.ontrack = (e) =&gt; { console.log(&quot;我接到数据流了！！&quot;, pc, otherSocketId, e); onTrack(pc, otherSocketId, e);};// 3. 设置获取对端stream数据回调pc.onremovestream = (e) =&gt; onRemoveStream(pc, otherSocketId, e);// 4. peer设置本地流if (localStream != null) { localStream.getTracks().forEach((track) =&gt; { pc.addTrack(track, localStream); });} 实例pc实际就是window.RTCPeerConnection对象，这个对象有几个回调方法在3.3.1节已经讲过了。 （1）onicecandidate 当 ICE 协商完成后，我们将协商结果发送至信令服务器，让其转发给指定的客户端。 继续编辑sdk.js 12345678910111213141516171819202122232425/** * RTCPeerConnection 事件回调，获取icecandidate信息回调 * @param {*} pc * @param {*} otherSocketId * @param {*} event */function onIceCandidate(pc, otherSocketId, event) { console.log(&quot;onIceCandidate to &quot; + otherSocketId + &quot; candidate: &quot;, event); if (event.candidate !== null) { // 构建信息 [from,to,room,candidate[sdpMid,sdpMLineIndex,sdp]] const message = { from: socketId, to: otherSocketId, room: roomId, candidate: { sdpMid: event.candidate.sdpMid, sdpMLineIndex: event.candidate.sdpMLineIndex, sdp: event.candidate.candidate, }, }; console.log(&quot;向信令服务器发送candidate&quot;, message); // 向信令服务器发送candidate socket.emit(&quot;candidate&quot;, message); }} 远程客户端收到 candidate 后，添加 candidate 后即可接收到本机的音视频流： 继续编辑sdk.js，添加监听事件： 123456789101112131415161718192021/** * 监听signal server转发过来的candidate消息 */socket.on(&quot;candidate&quot;, (data) =&gt; { // data: [from,to,room,candidate[sdpMid,sdpMLineIndex,sdp]] console.log(&quot;candidate: &quot;, data); const iceData = data.candidate; // 获取RTCPeerConnection const pc = getWebRTCConnect(data.from); const rtcIceCandidate = new RTCIceCandidate({ candidate: iceData.sdp, sdpMid: iceData.sdpMid, sdpMLineIndex: iceData.sdpMLineIndex, }); console.log(&quot;添加对端Candidate&quot;); // 添加对端Candidate pc.addIceCandidate(rtcIceCandidate);}); （2）ontrack 当监听到对方传递过来时音视频流后，动态创建一个video标签，显示接收到的音视频流数据。 继续编辑sdk.js 12345678910111213141516171819202122/** * 获取对端stream数据回调-ontrack模式 * @param {*} pc * @param {*} otherSocketId * @param {*} event */function onTrack(pc, otherSocketId, event) { console.log(&quot;onTrack from: &quot; + otherSocketId); let otherVideoDom = $(&quot;#&quot; + otherSocketId); if (otherVideoDom.length === 0) { // TODO 未知原因：会两次onTrack，就会导致建立两次dom const video = document.createElement(&quot;video&quot;); video.id = otherSocketId; video.autoplay = &quot;autoplay&quot;; video.muted = &quot;muted&quot;; video.style.width = 200; video.style.height = 200; video.style.marginRight = 5; $(&quot;#remoteDiv&quot;).append(video); } $(&quot;#&quot; + otherSocketId)[0][SRC_OBJECT] = event.streams[0];} （3）onremovestream 监听对方停止传输视频流的时候，我方进行相应处理： 继续编辑sdk.js 123456789101112131415/** * onRemoveStream回调 * @param {*} pc * @param {*} otherSocketId * @param {*} event */function onRemoveStream(pc, otherSocketId, event) { console.log(&quot;onRemoveStream from: &quot; + otherSocketId); // peer关闭 getWebRTCConnect(otherSocketId).close; // 删除peer对象 removeRtcConnect(otherSocketId); // 移除video $(&quot;#&quot; + otherSocketId).remove();} （4）添加本地音视频流 当我方开启摄像头后，全局变量localStream就不为null，我们需要往对方塞过去我们的的音视频数据，通过addTrack方法。这样，在对方同意（添加我方描述）后，就可以获取到我方的音视频数据了。 4.3.6 完善逻辑前面的内容基本把整个逻辑讲完了，但是你现在启动项目运行，是不是还是只能看到自己，后面的步骤根本没有执行？ 因为前面的我们只打开了摄像头，还没有对接后续操作。 现在编辑main.js，修改一下之前的代码： 123456789101112131415161718192021222324252627282930313233343536373839/** * dom获取 */const btnConnect = $(&quot;#connect&quot;); // 连接domconst btnLogout = $(&quot;#logout&quot;); // 挂断domconst domLocalVideo = $(&quot;#localVideo&quot;); // 本地视频domconst domRoom = $(&quot;#room&quot;); // 获取房间号输入框dom/** * 连接 */btnConnect.click(() =&gt; { const roomid = domRoom.val(); // 获取用户输入的房间号 if (!roomid) { alert(&quot;房间号不能为空&quot;); return; } //启动摄像头 if (localStream == null) { openCamera() .then((stream) =&gt; { localStream = stream; // 保存本地视频到全局变量 pushStreamToVideo(domLocalVideo[0], stream); connect(roomid); // 成功打开摄像头后，开始创建或者加入输入的房间号 }) .catch((e) =&gt; alert(`getUserMedia() error: ${e.name}`)); }});/** * 挂断 */btnLogout.click(() =&gt; { closeCamera(domLocalVideo[0]); logout(roomId); // 退出房间 //移除远程视频 $(&quot;#remoteDiv&quot;).empty();}); 编辑sdk.js，添加logout()方法，监听他人退出房间socket.on('exit')： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 挂断（退出房间） * @param {string} roomid 房间号 */const logout = (roomid) =&gt; { // 构建数据 const data = { from: socketId, // 全局变量，我方的socketId room: roomid, // 全局变量，当前房间号 }; // 向信令服务器发出退出信号，让其转发给房间里的其他用户 socket.emit(&quot;exit&quot;, data); // 数据重置 socketId = &quot;&quot;; roomId = &quot;&quot;; // 关闭每个peer连接 for (let i in rtcPeerConnects) { let pc = rtcPeerConnects[i]; pc.close(); pc = null; } // 重置RTCPeerConnection连接 rtcPeerConnects = {}; // 移除本地视频 localStream = null;};/** * 监听signal server转发过来的exit消息，和退出房间的客户端断开连接 */socket.on(&quot;exit&quot;, (data) =&gt; { // data: [from,room] console.log(&quot;exit: &quot;, data); // 获取RTCPeerConnection const pc = rtcPeerConnects[data.from]; if (typeof pc == &quot;undefined&quot;) { return; } else { // RTCPeerConnection关闭 getWebRTCConnect(data.from).close; // 删除peer对象 removeRtcConnect(data.from); console.log($(&quot;#&quot; + data.from)); // 移除video $(&quot;#&quot; + data.from).remove(); }}); 4.3.7 完整代码http://223.223.179.203:8929/product/cp6666/webrtc-demo/-/tree/master/webrtc-client 五、总结现在，我们已经基本入门 WebRTC 了。可能前 3 章的协议、服务器、API 的学习让我们感觉很枯燥，知识很杂乱。我想，大家通过第四章的实战开发，将之前的知识点串通起来，是不是有一点感觉了。其实前两章在现在看来，是可以不必着重学习的。没有这些协议和服务器的支持，不懂他们的连接原理，后面的学习应该会更加疑惑吧。 前面的实战开发，是一个很简单的 Web 端的例子，没有涉及到安卓、iOS 端如何进行 WebRTC 通信，如果需要继续深入学习，下一步可以往移动端 WebRTC 上学习，比如移动端打开摄像头都和 Web 不同。 如果暂时没有深入 WebRTC 的学习话，可以基于这个实战项目进行横向的扩展。这个实战项目虽然看起来很简单，但是你可以给它加出很多功能来，会看起来很高大尚！比如： 在线电话：咱们现在只是通过房间号进行连接，我们可以设置一个登陆页面，将用户的 id 作为房间号，每个用户登陆后直接创建一个房间。我们想要给某个用户打音视频电话的话，我们可以加入他的房间，对方也能检测到房间是否有人进来，这样对方可以做成收到来电了，对方接听后，我们就进行 WebRTC 连接，实现拨打电话的功能。 视频会议：我们开发好注册登录功能，创建会议就相当于创建一个房间，只不过这个房间号是由我们系统来自动分配，别人登录后，通过该房间号就可以加入，即可实现视频会议功能。当然还可以扩展分享屏幕、白板等功能。 本次WebRTC入门学习到此结束了，非常感谢您耐心地看完本篇长文。若有描述不对的地方，欢迎指出！ 对以下文章、项目和视频的作者们，表示非常感谢！感谢您们辛苦的成果！ 参考文章、文献、规范、项目、视频： WebRTC 协议介绍：https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Protocols WebRTC 中文社区：https://webrtc.org.cn/ RTC 开发者社区：https://rtcdeveloper.com/ 又拍云 WebRTC 实时通信服务实践：https://segmentfault.com/a/1190000010339671 P2P 通信原理：https://zhuanlan.zhihu.com/p/26796476 STUN 协议详细介绍：https://zhuanlan.zhihu.com/p/26797664 TURN 协议详细介绍：https://zhuanlan.zhihu.com/p/26797422 ICE 协议详细介绍：https://zhuanlan.zhihu.com/p/26857913 WebRTC PeerConnection 建立连接过程：https://aggresss.blog.csdn.net/article/details/106832965 STUN/TURN 服务器（C 语言）：https://github.com/coturn/coturn STUN 服务器（node）https://github.com/enobufs/stun Build Zoom Clone Video Chat Web App in Node.js Express and Socket.io Using WebRTC and PeerJS Library：https://www.youtube.com/watch?v=MX_r3Wm_BLE https://codingshiksha.com/javascript/build-zoom-clone-video-chat-web-app-in-node-js-express-and-socket-io-using-webrtc-and-peerjs-library/ Build Video Chat Web App From Scratch in 40 mins：https://www.youtube.com/watch?v=KLCcCTFivhM coturn 服务器搭建：https://www.jianshu.com/p/915eab39476d coturn 服务器搭建：https://meetrix.io/blog/webrtc/coturn/installation.html coturn 服务器搭建：https://ourcodeworld.com/articles/read/1175/how-to-create-and-configure-your-own-stun-turn-server-with-coturn-in-ubuntu-18-04 WebRtcRoomServer（信令服务器 node）：https://github.com/qdgx/WebRtcRoomServer MDN Web Docs：https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API webRTC API 之 RTCPeerConnection：https://www.cnblogs.com/suRimn/p/11314914.html RTP 与 RTCP 协议介绍：https://blog.51cto.com/zhangjunhd/25481","link":"/2021/03/11/WebRTC%E5%85%A5%E9%97%A8/"},{"title":"前端单元测试","text":"首先看一下产品研发整个流程，从图中可以看出，测试是非常重要的环节，可以分为单元测试、集成测试、系统测试、验收测试。我们作为开发，其实不应该仅仅参与开发这个过程，还包括了单元设计、单元测试。后面会详细介绍单元测试。 什么是单元测试 在计算机编程中，单元测试（英语：Unit Testing）又称为模块测试，是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。——维基百科 我觉得这个概念已经说的很详细了，就是开发过程中模块、功能、函数等最小单位的测试。每个测试应该是测试最简单的一个函数或功能。 上图中的集成测试，就是在单元测试的基础上，将所有模块按照设计要求组装成为子系统或系统，进行集成测试。 单元测试的意义成为一名优秀的程序员！ 一名优秀的程序员，一定是能够写好单元测试的。虽然开始很痛苦，但是最终我们的收货将是开发质量大大提升了，自信心增强了，bug 少了，技术提升了，头发掉的少了…… 减轻开发者负担 提前澄清需求：先写测试可以帮助我们去思考需求，并提前澄清需求细节，而不是代码写到一半才发现不明确的需求 开发流程更流畅：明确的流程，每次只关注一个点，思维负担更小 调试器中花费更少的时间 健壮的代码 代码设计更好 代码更加灵活、可扩展性更高 代码简洁、易读、逻辑性强 代码松散耦合 保护网 快速反馈，早期发现错误，快速定位错误，降低修复 bug 的成本 适应需求变更，支持新功能的可持续发展，可以安全、放心地重构 最后面会带大家在实际操作中感受。 单元测试分类 TDD—测试驱动开发，侧重点偏向开发，通过测试用例来规范约束开发者编写出质量更高、bug 更少的代码。先写测试用例，再写功能模块。 （英语：Test-driven development，缩写为TDD）是一种软件开发过程中的应用方法，由极限编程中倡导，以其倡导先写测试程序，然后编码实现其功能得名。测试驱动开发始于 20 世纪 90 年代。测试驱动开发的目的是取得快速反馈并使用“illustrate the main line”方法来构建程序。——维基百科 BDD — 行为驱动开发，由外到内的开发方式，从外部定义业务成果，再深入到能实现这些成果，每个成果会转化成为相应的包含验收标准。先写主功能模块，再写测试用例。 行为驱动开发（英语：Behavior-driven development，缩写BDD）是一种敏捷软件开发的技术，它鼓励软件项目中的开发者、QA 和非技术人员或商业参与者之间的协作。BDD 最初是由 Dan North 在 2003 年命名[1]，它包括验收测试和客户测试驱动等的极限编程的实践，作为对测试驱动开发的回应。——维基百科 TDD—测试驱动开发是不是有人第一反应会认为是测试人员驱动开发人员？实际上，TDD 是敏捷开发中的一项核心实践和技术，也是一种设计方法论。 狭义的 TDD：就是单元测试驱动开发 UTDD（Unit Test Driven Development） 广义的 TDD：是验收测试驱动开发 ATDD（Acceptance Test Driven Development），包括行为驱动开发 BDD（Behavior Driven Development）和消费者驱动契约开发 Consumer-Driven Contracts Development 等 TDD 的三层含义 Test-Driven Development，测试驱动开发 Task-Driven Development，任务驱动开发，要对问题进行分析并进行任务分解 Test-Driven Design，测试保护下的设计改善。TDD 并不能直接提高设计能力，它只是给你更多机会和保障去改善设计 TDD 的流程TDD 的基本流程 红：写一个失败的测试，它是对一个最小单位的需求描述，只关心输入输出，不考虑如何实现绿：专注在用最快的方式实现当前这个小需求，不管其他需求，也不管代码质量如何重构：既不用思考需求，也没有实现的压力，只需要找出代码中的坏味道，并用一个手法消除它，让代码变整洁 创建一个失败的测试 写出恰好能使测试通过的代码 重构刚刚实现的代码 重复前三步 下面的一张图可以清楚的明白编写单元测试的流程： 在我们现在的编码过程中是需要不断调试，不断试错，并且不能保证代码是简洁的。而“红-绿-重构”这种方式是先用脏乱代码表达出来，测试通过之后立刻重构刚写的代码，这是一个持续的循环过程，不能是写了很多实现代码后才开始重构，应该是随时重构你刚刚写出的代码，当你完成这个功能的时候，你的代码就是简洁可用的。 重构是改善代码结构的一种实践，但重构并不会改变由测试定义的行为。 重构不应该是单独拿出来花时间做的一件事情，也不应该出现在项目的计划中。重构应该是日常开发中时时刻刻都在进行的活动，它就是开发活动中不可分割的一部分。 重构应该是在不破坏任何测试的前提下对命名、类、函数和表达式进行修改。在不影响行为逻辑的情况下改善系统的结构。 通过以上，我们可以看出重构是需要完备的测试做安全网，就是这层安全网给了我们重构的信心和勇气。 简单设计原则 优先级从上至下降低 通过测试-最简单的方式让测试通过 揭示意图-表明代码意图 消除重复-去除重复代码 最少元素-使用最少的代码完成这个功能 测试条件格式在我们编写测试用例的时候通常遵循以下形式： Given-给定上下文 When-条件、行为，触发一个动作或者事件 Then-对期望结果的验证 传统编码方式 对比 TDD 编码方式传统编码方式需求分析 -&gt; 确认需求细节 -&gt; 开发 -&gt; 调试 -&gt; (加需求 -&gt; 开发 -&gt; 调试) -&gt; QA 测试 -&gt; 提出 bug -&gt; 改 bug、打补丁 -&gt; QA 测试 -&gt; 完成 最终的代码冗余、逻辑混乱，稍微动一下，就可能有未知的错误出现，改了之后还要 QA 测试，然后加班继续改… TDD 编码方式 先分解任务-分离关注点 列 Example-用实例化需求，澄清需求细节 写测试-只关注需求，程序的输入输出，不关心中间过程 写实现-不考虑别的需求，用最简单的方式满足当前这个小需求即可 重构-用手法消除代码里的坏味道 重复 3、4、5 步骤 写完功能-手动测试一下，基本没什么问题，有问题补个用例，修复 转测试-小问题，补用例，修复 代码整洁且用例齐全，信心满满地交付代码 总结从上面两个流程不难看出，测试驱动开发最大的优点就是重构了，不断迭代，不断地对现有代码进行重构，不断优化代码的内部结构，最终实现对整体代码的改进。以此不断减少一些设计冗余、代码冗余、逻辑复杂度等等。 缺点就是存在局限性，它不能发现集成错误、性能问题、或者其他系统级别的问题。还要求一定是好的测试用例，如果测试代码太复杂，那么测试代码本身就可能有 bug。 编写测试用例原则 明确自己要测什么 简单，只测试一个需求，要写刚好的实现 符合 Given-When-Then 格式 速度快 包含断言 可以重复执行 及时重构 粒度设计 大粒度— 测试功能 业务/接口不变的情况下，重构代码，不需要改测试（保证功能不被重构代码改坏） 标题可与需求、QA 测试点对应起来，容易理解 保证各个部件配合起来不出错 干扰多，需要 mock 的依赖比较多 运行时间比较长 小粒度—测试文件、类、方法、纯函数、正则表达式…… 重构时可能会被改写或删除 依赖较少 速度快 可靠性 让测试在该失败的时候失败，该通过的时候通过 遵循 TDD 流程写测试，上面有详细的介绍 还没实现功能或者还没改好 bug 前，测试必须是失败的 尝试坏功能，去检测是否失败，如果功能坏了，测试依然通过，那么测试本身是不可靠的 测试的输入输出应该是稳定的，任何时候任何环境下都一样 测试中避免依赖真实的时间、随机生成器、真实的环境（数据库、网络），换句话说，排除掉一切不确定因素的干扰 测试隔离，测试之间不能相互依赖或相互影响 测试之间应该是无序的 测试之间不能共享同一个内存状态 善于使用 afterEach，beforeEach 来重置状态 TDD 过程中，给当前测试点加 only，完成后去掉 only，结果都是一样的 可维护性 避免直接测试私有方法/属性 私有方法再重构的时候后往往会被合并、拆分、删除，如果这些操作需要更改对应的单元测试，会增加很多的工作量 减少重复代码 善于使用 describe、beforeEach、beforeAll 提取变量，创建工具方法，setup functions mock utils 测试代码的复杂度应该低于对应的功能实现 适当保留重复，测试代码本身不宜又过多的抽象和逻辑 善于使用测试框架提供的断言 API，提高可读性 单元测试适用场景 明确解决问题方案的前提 TDD 并不是任何时候都适用的，仅限于确定了问题的解决方案后，你可以使用 TDD 来实现一个更优雅的版本。如果是为了探查或者解决某种不确定的问题而要快速实现一些功能时，则会忽略测试代码而直接完成功能代码。 类和函数 一般在开发过程中，可能会自定义一些通用的工具函数或者类，这些都是需要进行单元测试的。 基础组件 一般开发基础组件的时候需要对组件的结构、事件编写单元测试。 单元测试推动过程单元测试需要足够专业技能、专业素质的人才来保证整个过程的通畅与专业，前期需要一定的投入，介于质量、效率、成本等问题，推动单元测试一定是痛苦的，而且前提还得是领导能够给出单元测试的时间，如果时间依然紧迫还要求写单元测试，那么最终的结局是写了很多无用的测试代码，为了追求测试通过率而不写断言等等问题。 会写测试用例 每个人熟悉测试框架和编写测试用例流程，且正常编写出测试用例 写对测试用例 正确的使用生命周期函数、断言库等方法，并且知道哪些该测哪些不用测，关注可测性 写好测试用例 测试用例尽可能的覆盖全面、不冗余，且是有效的 TDD 方式编写测试用例 也许很难 真正理解 TDD 的理念，认可并运用 前端测试框架简单了解下几种测试框架 Karma - 基于 Node.js 的 JavaScript 测试执行过程管理工具（Test Runner），让你的代码自动在多个浏览器（chrome，firefox，ie 等）环境下运行 Mocha - Mocha 是一个测试框架，在 vue-cli 中配合 chai 断言库实现单元测试（ Mocha+chai ） Jest - Jest 是 Facebook 开发的一款 JavaScript 测试框架。在 Facebook 内部广泛用来测试各种 JavaScript 代码 选择框架我们选择使用 Jest 框架 配置简单 学习成本低 自身包含了驱动、断言库、mock 、代码覆盖率等多种功能 断言库 断言指的是一些布尔表达式，在程序中的某个特定点该表达式值为真，判断代码的实际执行结果与预期结果是否一致，而断言库则是将常用的方法封装起来 主流的断言库 assert (TDD) 1assert('mike' == user.name); expect.js（BDD） - expect() 风格的断言 1expect(foo).to.be('aa'); should.js - BDD（行为驱动开发）风格贯穿始终 1foo.should.be('aa'); chai（BDD/TDD） - 集成了 expect()、assert()和 should 风格的断言 实际操作现在我们按照测试驱动开发中 红-绿-重构 的方式完成下述示例。 需求：实现一个检查一串字符串中()、[]、{}几种括号是否闭合 任务分解（第一种 不考虑穿插括号） 计算左括号字符在字符串中出现的个数 计算所有左括号字符在字符串中的索引和 计算右括号字符在字符串中出现的个数 计算所有右括号字符在字符串中的索引和 比较左右索引的大小 左的索引总和小于右的索引就是闭合的 否则是不闭合的 比较左右个数 相同就是闭合的 不同就是不闭合的 举例 目标字符串 期待结果 ‘’ true () true ( false [] true ] false ()] false ()[]{} true )([]{} false ({[]}) true 任务分解（第二种 考虑穿插括号） 创建括号字符左右匹配对象 遍历括号数组，遇到任何左括号就入栈 直到遇到右括号，与左括号栈顶字符匹配 能够匹配上继续，并将栈顶符号出栈 匹配失败则跳出循环 举例 目标字符串 期待结果 ‘’ true [({})] true {()[]} true )()[] false ({[}]) false [}{] false 参考文章 深度解读 - TDD（测试驱动开发）","link":"/2021/04/06/%E5%89%8D%E7%AB%AF%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"},{"title":"SonarQube安装与配置","text":"1 写在最前面在写代码过程中，难免出现代码写的不规范或存在一些静态的 bug，这时一个良好的代码审查工具就很有必要，而 SonarQube 正好满足这个要求。 2 SonarQube 介绍SonarQube 是一款自动代码审查工具，可以检测代码中的 bug 、缺陷和代码气味。它可以与现有的 CI 工具集成，以支持持续代码检查。 3 典型开发过程 开发人员在 IDE 中开发代码（可使用 SonarLint 在编写代码时检测和修复问题），然后将其代码提交到代码仓库中。 SonarLint 是一个 IDE 扩展，可以帮助你在编写代码时检测和修复质量问题。 持续集成(我们使用 GitLab CI)工具检出最新代码、构建和运行单元测试，并由集成 SonarQube 的扫描器分析结果。 扫描器程序将结果发布到 SonarQube 服务器，该服务器通过SonarQube界面，电子邮件等向开发人员提供反馈。 4 SonarQube 安装、配置 此章节普通开发人员可忽略。 4.1 准备工作4.1.1 系统设置在命令行窗口执行依次以下命令操作： 设置一个进程可能拥有的最大内存映射区域数。 不设置这个， sonarqube 启动不起来， 1echo &quot;vm.max_map_count=262144&quot; &gt;&gt; /etc/sysctl.conf 查看设置的结果： 1sysctl -p 4.1.2 Docker 及 Compose 安装本教程忽略，可参考https://www.yuque.com/docs/share/3f190b9a-321d-4155-96fd-02b66f8f6d97?# 《Docker安装（资源仓库在线安装）》 4.2 创建挂载目录 该操作用于建立容器和宿主机之间的目录映射，方便管理和维护。 依次执行以下命令： 创建 SonarQube 数据库、日志、配置等存放目录 1mkdir -p /home/sonarqube &amp;&amp; cd /home/sonarqube 创建 SonarQube 映射文件目录 12345mkdir -p /home/sonarqube/postgres &amp;&amp; \\mkdir -p /home/sonarqube/data &amp;&amp; \\mkdir -p /home/sonarqube/extensions &amp;&amp; \\mkdir -p /home/sonarqube/logs &amp;&amp; \\mkdir -p /home/sonarqube/conf 创建 postgresql 数据库挂载目录 12mkdir -p /home/sonarqube/postgresql &amp;&amp;\\mkdir -p /home/sonarqube/datasql 目录设置为 777 权限，避免权限问题 1chmod 777 ./* 4.3 根据以上创建文件目录信息创建 docker-compose.yml在 /home/sonarqube/ 目录下创建 docker-compose.yml文件，内容为以下内容： 1234567891011121314151617181920212223242526272829303132333435363738394041version: '3'services: postgres: image: postgres restart: always container_name: sonarqube_postgres ports: - 5432:5432 volumes: - /home/sonarqube/postgresql/:/var/lib/postgresql - /home/sonarqube/datasql/:/var/lib/postgresql/data environment: TZ: Asia/BeiJing POSTGRES_USER: sonar POSTGRES_PASSWORD: sxxxx POSTGRES_DB: sonar networks: - sonar-network sonar: image: sonarqube restart: always container_name: sonarqube depends_on: - postgres volumes: - /home/sonarqube/extensions:/opt/sonarqube/extensions - /home/sonarqube/logs:/opt/sonarqube/logs - /home/sonarqube/data:/opt/sonarqube/data - /home/sonarqube/conf:/opt/sonarqube/conf ports: - 9000:9000 environment: SONARQUBE_JDBC_USERNAME: sonar SONARQUBE_JDBC_PASSWORD: sxxxx SONARQUBE_JDBC_URL: jdbc:postgresql://postgres:5432/sonar networks: - sonar-networknetworks: sonar-network: driver: bridge 4.4 拉取镜像并启动容器服务在创建 docker-compose.yml 文件的目录下执行以下命令： 1docker-compose up -d 该操作首次执行会从互联网下载镜像文件，请确保系统可以联网。 4.5 首次访问访问地址为：服务器IP+端口，本例为 http://192.168.44.6:9000/ 。登录后用户名密码都为 admin admin, 登录后进行修改。 4.6 系统配置4.6.1 设置中文按照图示在应用市场安装中文语言包，安装后按照提示重启即可。 4.6.2 邮件配置 使用管理员登录系统，按照图示依次点击进入配置页面，配置-&gt;配置-&gt;通用。 按照以下截图进行邮件配置。 Email prefix：发邮件时，邮件标题会默认带上该前缀。其他配置项，根据自己邮箱SMTP配置及认证信息进行配置，这里不做详述。 4.6.3 GitLab 集成配置目前不支持，需要 GitLab https 且目前版本为开源社区版本，这里不做具体配置说明。 4.6.4 LDAP 配置 在安装阶段创建的宿主机挂载目录对应的文件 sonarqube/conf/sonar.properties 添加以下内容： 123456789101112# LDAP configuration# General Configurationsonar.security.realm=LDAPldap.url=ldap://192.168.0.xx:389ldap.bindDn=gitlab@internal.ths.com.cnldap.bindPassword=xxx# User Configurationldap.user.baseDn=OU=研发xx,OU=思路xx,DC=domain,DC=solution,DC=comldap.user.request=(&amp;(objectClass=user)(sAMAccountName={login}))ldap.user.realNameAttribute=displayNameldap.user.emailAttribute=userPrincipalName 重启 sonarqube 1docker restart sonarqube 注意这里使用网页中的重启功能是不好使的，需要重启整个容器。 以下为启动后在安装阶段创建的宿主机挂载目录下 /home/sonarqube/logs/web.log 中看到的内容。 12342021.04.15 09:42:28 INFO web[][org.sonar.INFO] Security realm: LDAP2021.04.15 09:42:28 INFO web[][o.s.a.l.LdapSettingsManager] User mapping: LdapUserMapping{baseDn=OU=研发中心,OU=思路创新,DC=domain,DC=solution,DC=com, request=(&amp;(objectClass=user)(sAMAccountName={0})), realNameAttribute=displayName, emailAttribute=userPrincipalName}2021.04.15 09:42:28 INFO web[][o.s.a.l.LdapSettingsManager] Group mapping: LdapGroupMapping{baseDn=OU=研发中心,OU=思路创新,DC=domain,DC=solution,DC=com, idAttribute=cn, requiredUserAttributes=[uid], request=(&amp;(objectClass=posixGroup)(memberUid={0}))}2021.04.15 09:42:28 INFO web[][o.s.a.l.LdapContextFactory] Test LDAP connection on ldap://192.168.0.13:389: OK 4.7 扫描器安装4.7.1 Windows 环境4.7.1.1 准备工作打开对应网站，按照截图下载Windows版本https://docs.sonarqube.org/latest/analysis/scan/sonarscanner/ 4.7.1.2 配置 将刚才下载的压缩包解压到要存放 扫描器的服务器上。 配置环境变量 将解压目录下到bin文件夹的路径配置到环境变量中。 本例环境变量配置内容为：D:\\Program Files\\sonar-scanner-4.6.0.2311-windows\\bin;具体如何操作，本例不做详细讲解。 验证 命令行输入以下命令： 1sonar-scanner -v 注意：配合跟 GitLab-Runner 一块使用时，初次配置完 sonar-scanner 环境变量，需要重启下 GitLab-Runner 服务，不然找不到 sonar-scanner 命令。 4.7.2 Linux 环境4.7.2.1 准备工作打开对应网站，按照截图下载 Linux 版本https://docs.sonarqube.org/latest/analysis/scan/sonarscanner/ 4.7.2.2 配置 通过 xshell 等 Linux 运维工具将刚才下载的压缩包上传到服务器上 解决压缩包 配置环境变量 编辑 /etc/profile 文件，添加解压后的 bin 目录路径进入该文件，本例为 /home/sonar-scanner/bin 执行命令使配置环境变量生效 1source /etc/profile 验证 命令行输入以下命令： 1sonar-scanner -v 4.8 常见问题4.8.1 执行安装命令后报以下信息：WARNING: IPv4 forwarding is disabled. Networking will not work分析：系统设置问题解决： 在宿主机上执行 echo “net.ipv4.ip_forward=1” &gt;&gt;/usr/lib/sysctl.d/00-system.conf systemctl restart network &amp;&amp; systemctl restart docker 4.8.2 代码扫描结果名称乱码通过在项目中创建 sonar-project.properties 方式进行项目扫描，当存在项目名称为中午时扫描结果出现乱码分析：汉字在 .properties 中可能需要进行 Unicode编码。解决：使用命令行扫码，没有乱码问题 1sonar-scanner.bat -D&quot;sonar.projectName=测试123哈哈哈&quot; -D&quot;sonar.projectKey=VUE3-PINXX2&quot; -D&quot;sonar.sources=src&quot; -D&quot;sonar.exclusions=src/js/i18n/**/*&quot; -D&quot;sonar.sourceEncoding=UTF-8&quot; -D&quot;sonar.login=f82121212ccccc&quot; 4.8.3 Linux 执行 sonar-scanner 报“Could not find ‘java’ executable in JAVA_HOME or PATH.”分析：根据错误是找不到 Java 的可执行程序，通过安装Jdk 发现错误依旧存在，最后发现 sonar-scanner 自带的有 jre ，那就是应该用的自带的 jre，尝试给 jre 目录下的 java 赋予权限解决。解决：进入 sonar-scanner 所在的目录，转到Java所在目录，执行以下命令 1chmod 755 java 5 SonarLint 安装 打开 VS Code 左侧的 Extensions 模块，搜索SonarLint,点击安装即可。 安装后重启 VS Code，保证插件生效。只需打开一个JS、TS、Python、Java、HTML或PHP文件，开始编码，你就会开始看到 SonarLint 报告的问题。问题会在代码中突出显示，也会在“问题”面板中列出。 6 GitLab 安装 已安装，可忽略。传送：https://www.yuque.com/heq286/dswu9s/uk2ef0 7 GitLab CI 配置按照以下说明，进行配置http://223.223.179.203:8929/common-resource/gitlab-ci/-/blob/master/README.md 8 快速上手本快速上手教程，基于 流水线模板 进行。可先查看 GitLab CI 配置章节。 8.1 获取 Sonar Token 使用公司域账号登录 http://192.168.0.134:9000/ 进入个人中心-我的账号 生成 token 输入 token 标识名称，点击生成，即可生成 token。该 token 只会显示一次，需要在当前页面复制保存。当该token不再使用时，可以在该页面点击回收进行删除。 为了规范，这里的令牌名称按照 GitLab 中的项目名称输入，可以直接在 GitLab 项目列表页面获取。举例：AN20049 深圳市生态环境局大鹏管理局-大鹏新区生态环境动态监测系统（二期） / 前端 / 微应用 / 固定源 8.2 配置 GitLab CI 在项目根目录新建 .gitlab-ci.yml 文件(注意是以“.”开头的文件) 拷贝以下示例配置信息，修改相关变量信息为自己项目相关部署信息 1include: - remote: 'http://223.223.179.203:8929/common-resource/gitlab-ci/-/raw/master/templates/web-pipeline.yml' # 定义变量variables: # 必填，部署的测试服务器地址,前提是该服务器已配置好ssh免登，格式：服务器用户名@ip，如：weihu@192.168.0.183 SIT_SERVER: &quot;weihu@192.168.0.183(根据实际需求修改)&quot; # 必填，部署的测试服务器中的物理路径（相对ssh 根路径）,需要先在服务器上对应位置创建目录，如：\\Product\\nginx-1.18.0\\html\\arcgis SIT_DIRECTORY: &quot;\\Product\\nginx-1.18.0\\html\\pindd(根据实际需求修改)&quot; # 测试环境应用的地址，部署后可以访问的HTTP地址 SIT_WEB_URL: &quot;http://192.168.0.183:8104/pindd(根据实际需求修改)&quot; # 项目类型：project、product,设置对应的项目类型，会自动匹配对应的gitlab-runner，原则上产品类型的项目设置product，项目类型的设置project PROJECT_TYPE: &quot;project&quot; 查看更多配置 配置 SONAR_TOKEN 登录 GitLab 打开对应的项目页面-点击设置-CI/CD 找到变量那一项，展开 点击添加变量 添加变量 SONAR_TOKEN key 名称不能修改，该名称跟模板文件中的 key 名称一致。Value值来自上一步在 Sonar 系统中获取。 添加后效果 可以在该页面进行编辑及删除等操作 8.3 修改 Git strategy 为 git clone在 GitLab 项目 CICD 中 General pipeline 展开，将 Git strategy 为 git clone 。该设置会使 Sonar 在分析时，获取文件作者信息。 8.4 提交代码验证配置以上配置完毕后，即可提交代码进行首次代码扫描。 提交代码后可查看流水线运行情况 待流水线跑完，即可登录 SonarQube 进行扫描结果查看。 注意这里要点击所有。 9 其他9.1 系统升级当 SonarQube 使用一段时间后，管理员登录系统后，发现有新的版本可用（如下图），这时可进行更新操作。跨多个非LTS版本的升级可直接进行升级。但如果升级版本跨了一个或多个LTS版本，则必须首先迁移到每个中间LTS，然后再迁移到目标版本。 示例1 –从7.1&gt; 8.1，升级过程为7.1&gt; 7.9.6 LTS&gt; 8.1 示例2 –从8.2&gt; 8.9 LTS，升级过程为8.2&gt;最新的8.9 LTS。 示例3 –从6.7.7 LTS&gt; 8.9 LTS，升级过程为6.7.7 LTS&gt; 7.9.6 LTS&gt;最新的8.9 LTS。 本升级教程只记录跨多个非LTS版本的升级，如果是跨多个LTS版本的升级，重复多次升级操作即可。 9.1.1 数据库备份 此操作是为了防止在升级过程中出现的异常情况或误操作导致数据丢失做备份。升级过程如果正常，此备份没有用。 9.1.1.1 安装数据库管理工具 拉取 pgadmin4 数据库管理工具镜像 启动 pgadmin4 容器 1docker run -p 5050:80 \\ -e &quot;PGADMIN_DEFAULT_EMAIL=liuyx@internal.ths.com.cn&quot; \\ -e &quot;PGADMIN_DEFAULT_PASSWORD=s*****n&quot; \\ -d dpage/pgadmin4 这里的邮箱及密码是待会要登录管理系统的密码 打开管理页面输入用户名密码（上一步设置的）登录 9.1.1.2 创建服务器连接 本示例中的数据库连接等配置，对应 SonarQube 安装章节设置值。 9.1.1.3 执行备份 9.1.2 升级 修改之前安装 SonarQube 的 docker-compose.yml 文件,添加要升级的版本 TAG ，本示例路径：/home/sonarqube/docker-compose.yml 在 docker-compose.yml 文件所在目录下执行 docker-compose up -d 1docker-compose up -d 命令执行完后，访问系统地址，出现以下界面 打开本示例系统设置地址 http://192.168.0.134:9000/setup ，点击升级 执行以上操作完成后，重新使用admin登录，确认版本是否已升级成功 点击了解这个风险 到系统界面查看版本已经升级到指定版本了 9.2 系统迁移 为防止迁移过程中数据丢失，建议迁移前进行数据库备份。 将容器和宿主机之间的映射目录，整体迁移到新的机器。例如本例中老机器的目录为/home/sonarqube/下的所有文件： 拷贝到新的机器上目录设置为 777 权限，避免权限问题 1chmod 777 ./* 根据迁移文件目录信息更新 docker-compose.yml 在 docker-compose.yml 文件的目录下执行以下命令： 1docker-compose up -d 该操作首次执行会从互联网下载镜像文件，请确保系统可以联网。 执行完成后，打开登录页验证，服务器IP+端口（docker-compose.yml 中配置端口）","link":"/2021/04/27/SonarQube%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"},{"title":"浅拷贝与深拷贝","text":"1 前言读完全文，希望你能明白： 什么是深/浅拷贝？ 深/浅拷贝的实现方式有几种？ 2 基本类型 &amp; 引用类型ECMAScript 中的数据类型可分为两种： 基本类型：undefined、null、Boolean、String、Number、Symbol 引用类型：对象类型 Object type，Object、Array、Date、Function、RegExp等 不同的复制方式： 基本类型：从一个变量向另外一个新变量复制基本类型的值，会创建这个值的一个副本，并将该副本复制给新变量 12345678let foo = 1;let bar = foo;console.log(foo === bar); // -&gt; true// 修改foo变量的值并不会影响bar变量的值let foo = 233;console.log(foo); // -&gt; 233console.log(bar); // -&gt; 1 引用类型：从一个变量向另一个新变量复制引用类型的值，其实复制的是指针（内存地址），最终两个变量最终都指向同一个对象。 1234567891011let foo = { name: 'leeper', age: 20}let bar = foo;console.log(foo === bar); // -&gt; true// 改变foo变量的值会影响bar变量的值foo.age = 19;console.log(foo); // -&gt; {name: 'leeper', age: 19}console.log(bar); // -&gt; {name: 'leeper', age: 19} 3 浅拷贝 &amp; 深拷贝注：深浅拷贝这个说法是针对引用类型 浅拷贝：仅仅是复制了引用，彼此之间的操作会互相影响 深拷贝：不同的地址，相同的值，互不影响 总的来说，深浅拷贝的主要区别就是：复制的是引用还是复制的是实例。 借助 ConardLi大佬 以下两张图片，帮我们更好的理解两者的含义： 3.1 浅拷贝3.1.1 数组 Array.prototype.slice() 12345678let a = [1, 2, 3, 4];let b = a.slice();console.log(a === b); // -&gt; falsea[0] = 5;console.log(a); // -&gt; [5, 2, 3, 4]console.log(b); // -&gt; [1, 2, 3, 4] Array.prototype.concat() 1234567let a = [1, 2, 3, 4];let b = a.concat();console.log(a === b); // -&gt; falsea[0] = 5;console.log(a); // -&gt; [5, 2, 3, 4]console.log(b); // -&gt; [1, 2, 3, 4] ES6扩展运算符 12345var arr = [1,2,3,4,5]var [ ...arr2 ] = arrarr2[2] = 5console.log(arr); // [ 1, 2, 3, 4, 5 ]console.log(arr2); // [ 1, 2, 5, 4, 5 ] 3.1.2 对象 Object.assign({}, obj); 12345var a = {'name': 'xiaoyu'};var b = Object.assign({}, a);b.name = 'xiaoyu2';console.log(a.name);//xiaoyuconsole.log(b.name);//xiaoyu2 扩展运算符 12345var a = {'name': 'xiaoyu'};var { ...b } = a;b.name = 'xiaoyu2';console.log(a.name); // xiaoyuconsole.log(b.name); // xiaoyu2 3.1.3 函数库lodash的_.clone方法 12345var _ = require('lodash');var objects = [{ 'a': 1 }, { 'b': 2 }]; var shallow = _.clone(objects);console.log(shallow[0] === objects[0]); // true 以上看起来似乎是深拷贝，再接着看就知道它们究竟是深拷贝还是浅拷贝： 1234567let a = [[1, 2], 3, 4];let b = a.slice();console.log(a === b); // -&gt; falsea[0][0] = 0;console.log(a); // -&gt; [[0, 2], 3, 4]console.log(b); // -&gt; [[0, 2], 3, 4] 12345var a = {'name': { 'zh': 'yushuang', 'en': 'shuangyu' } };var b = Object.assign({}, a);b.name.zh = 'yushuang2';console.log(a.name); // { zh: 'yushuang2', en: 'shuangyu' }console.log(b.name); // { zh: 'yushuang2', en: 'shuangyu' } 综上， 这些方法都并不是真正的深拷贝，对于第一层的元素是深拷贝，而第二层是复制引用。 3.2 深拷贝 JSON.parse()和JSON.stringify() JSON.stringify()：把一个js对象序列化为一个JSON字符串 JSON.parse()：把JSON字符串反序列化为一个js对象 123456789101112131415let obj = { name: 'leeper', age: 20, friend: { name: 'lee', age: 19 }};let copyObj = JSON.parse(JSON.stringify(obj));obj.name = 'Sandman';obj.friend.name = 'Jerry';console.log(obj);// -&gt; {name: &quot;Sandman&quot;, age: 20, friend: {age: 19,name: 'Jerry'}}console.log(copyObj);// -&gt; {name: &quot;leeper&quot;, age: 20, friend: {age: 19,name: 'lee'}} 综上，JSON.parse() 和 JSON.stringify() 是完全的深拷贝。但是，这种方法虽然可以实现数组或对象深拷贝,但不能处理函数和正则，因为这两者基于 JSON.stringify 和 JSON.parse 处理后，得到的正则就不再是正则（变为空对象），得到的函数就不再是函数（变为null）了，举个例子如下： 123456let arr = [1, 3, { username: ' kobe'},function(){}];let arr4 = JSON.parse(JSON.stringify(arr));arr4[2].username = 'duncan'; console.log(arr, arr4) 函数库lodash的_.cloneDeep方法 12345678var _ = require('lodash');var obj1 = { a: 1, b: { f: { g: 1 } }, c: [1, 2, 3]};var obj2 = _.cloneDeep(obj1);console.log(obj1.b.f === obj2.b.f); // false jQuery.extend() 1$.extend(deepCopy, target, object1, [objectN])； //第一个参数为true，就是深拷贝 12345678var $ = require('jquery');var obj1 = { a: 1, b: { f: { g: 1 } }, c: [1, 2, 3]};var obj2 = $.extend(true, {}, obj1);console.log(obj1.b.f === obj2.b.f); // false 手动实现一个深拷贝 123456789101112131415161718192021222324252627282930function clone(target, map = new WeakMap()) { if (typeof target === 'object') { let cloneTarget = Array.isArray(target) ? [] : {}; if (map.get(target)) { return target; } map.set(target, cloneTarget); for (const key in target) { cloneTarget[key] = clone(target[key], map); } return cloneTarget; } else { return target; }}const target = { field1: 1, field2: undefined, field3: { child: 'child' }, field4: [2, 4, 8], f: { f: { f: { f: { f: { f: { f: { f: { f: { f: { f: { f: {} } } } } } } } } } } },};target.target = target;const result = clone1(target);console.log(result);console.log(target);","link":"/2021/08/04/%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D%20copy/"},{"title":"Vue3入门","text":"1 为什么要用 Vue3因为它体积更小、速度更快、提供 Composition API，增加了代码的逻辑组织和代码复用能力，提供了更好的类型检查。​ 2 Composition API注：在 Vue3 中其实是可以使用 Vue2 的写法，根据我们的规范，不允许出现 Vue2 的写法。 2.1 Composition API 是什么？ 官网 https://v3.cn.vuejs.org/guide/composition-api-introduction.html#什么是组合式-api 看下边图，把每种色块当作一个功能，应该可以很直观地感受到 Composition API 在逻辑代码组织方面的优势在 Options API 中，每个选项都是分离的，处理单个逻辑关注点时，必须不断地“跳转”相关代码的选项块，这种碎片化的方式会使得理解和维护复杂组件变得困难。​ 在 Composition API 中，组件根据逻辑功能来组织的，一个功能所定义的所有 API 会放在一起（更加的高内聚，低耦合），当需要修改一个功能时，就不再需要在文件中跳来跳去。即使项目很大，功能很多，都可以更快速的定位到这个功能所用到的代码。​ 下面举个简单例子，将处理 count 属性相关的代码放在同一个函数了 12345678910111213141516function useCount() { const count = ref(10); const double = computed(() =&gt; count.value * 2); const handleConut = () =&gt; { count.value *= 2; }; console.log(count); return { count, double, handleConut, };} 使用 count 12345678910export default defineComponent({ setup() { const { count, double, handleConut } = useCount(); return { count, double, handleConut, }; },}); 2.2 setupsetup() 函数是 vue3 中，专门为 vue 组件提供的新属性。它为我们使用 vue3 的 Composition API 新特性提供了统一的入口。​ 那么下面我们将分别从函数的几个方面来解析 setup 函数：​ return 返回值 函数的参数 何时调用 this 指向 2.2.1 返回值在 setup 函数中返回一个对象，这样我们就可以在 template 模板中直接访问该对象中的属性和方法。如果只是在 setup 函数中使用某个方法，则不需要返回。 1234567891011121314...setup() { // 变量 const content = '这是 setup 中返回的数据'; // 方法 const testFun = () =&gt; { console.log('调用 testFun 方法') }; return { content, testFun, }}... 2.2.2 函数的参数使用 setup 函数时，它将接受两个参数：​ props context 2.2.2.1、propssetup 函数中的第一个参数是 props，它是响应式的，当传入新的 props 时，它会被更新。使用场景：父子组件传参。 123456789101112...setup() { props: { title: { type: String, }, }, setup(props) { console.log(props.title); }}... 开发规范：https://www.yuque.com/heq286/dswu9s/sye0sb#sGYuw 因为 props 是响应式的，所以不能使用 ES6 解构，因为它会消除 props 的响应性。​ 如果需要解构 props，可以通过使用 setup 函数中的 [toRefs](https://vue3js.cn/docs/zh/api/refs-api.html#toref) 来安全地完成此操作。 123456789...import { toRefs } from 'vue';setup(props) { const { title } = toRefs(props.data); console.log(title.value);}... 1.2.2.2、contextsetup 函数的第二个参数是 context。context 是一个普通的 JavaScript 对象，它暴露组件的三个 property： 123456789101112...setup(props, context) { // Attribute (非响应式对象) console.log(context.attrs) // 插槽 (非响应式对象) console.log(context.slots) // 触发事件 (方法) console.log(context.emit)}... context 是一个普通的 JavaScript 对象，也就是说，它不是响应式的，这意味着你可以安全地对 context 使用 ES6 解构。 12345...setup(props, { attrs, slots, emit }) { ...}... attrs 和 slots 是有状态的对象，它们总是会随组件本身的更新而更新。这意味着你应该避免对它们进行解构，并始终以 attrs.x 或 slots.x 的方式引用 属性。请注意，与 props 不同，attrs 和 slots 是非响应式的。如果你打算根据 attrs 或 slots 更改应用副作用，那么应该在 onUpdated 生命周期钩子中执行此操作。 12345678910111213141516&lt;template&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;getAttrs&quot;&gt;点击获取Attrs&lt;/el-button&lt;/template&gt;...setup(props, { attrs, slots, emit }) { console.log(attrs.title); const getAttrs = () =&gt; { console.log(attrs.title); }; return { getAttrs, }}... 1.2.3 何时调用setup 函数会在 beforeCreate 和 created 之前执行。​ setup 函数在创建组件之前被调用，所以在 setup 被执行时，组件实例并没有被创建。 1.2.4 this 指向由于在执行 setup 时，尚未创建组件实例，因此在 setup 选项中没有 this。 在**setup()**内部，**this**不会是该活跃实例的引用，因为 setup() 是在解析其它组件选项之前被调用的，所以 setup() 内部的 this 的行为与其它选项中的 this 完全不同。这在和其它选项式 API 一起使用 setup() 时可能会导致混淆。 12345678910...setup() { // 先于 created 执行，此时组件尚未创建 console.log(this); // undefined},created() { console.log(this); // proxy 对象 -&gt; 组件实例}... 1.2.4.1 问题：如何在 Vue3 中定义、获取全局变量？使用场景：需要设置名称为 name 的全局变量，并在所有组件中都能访问到此变量。 1.2 生命周期 官网：https://www.vue3js.cn/docs/zh/guide/composition-api-lifecycle-hooks.html 开发规范：https://www.yuque.com/heq286/dswu9s/sye0sb#HXy1X 通过在生命周期钩子前面加上 “on” 来访问组件的生命周期钩子 说明 Vue3 Vue2 创建组件前 setup beforeCreate 创建组件后 setup created 组件挂载前 onBeforeMount beforeMount 组件挂载后 onMounted mounted 组件更新前 onBeforeUpdate beforeUpdate 组件更新后 onUpdated updated 组件销毁前 onBeforeUnmount beforeDestroy 组件销毁后 onUnmounted destroyed 按需加载，更能减少代码体积 vue3 的生命周期会优先于 vue2 的执行。 ​ 完整示例： 12345678910111213141516171819202122232425262728293031323334353637&lt;script lang=&quot;ts&quot;&gt;import { //现在使用的方法都要按需引入 onBeforeMount, onMounted, onBeforeUpdate, onUpdated, onBeforeUnmount, onUnmounted} from 'vue'export default { name: &quot;生命周期&quot;, setup() { console.log('1---setup,组件创建之前') onBeforeMount(()=&gt;{ console.log('2---onBeforeMount,组件挂载到dom前') }) onMounted(()=&gt;{ console.log('3---onMounted,组件挂载到dom后') }) //组件更新前后--比如数据更新后，会触发组件更新 onBeforeUpdate(()=&gt;{ console.log('4---onBeforeUpdate,组件更新前') }) onUpdated(()=&gt;{ console.log('5---onUpdated,组件更新后') }) //组件销毁前后 节点删除或替换会触发 onBeforeUnmount(()=&gt;{ console.log('6---onBeforeUnmount，卸载组件前') }) onUnmounted(()=&gt;{ console.log('7---onBeforeUnmount，卸载组件后') }) }}&lt;/script&gt; 1.3 提供/注入（provide &amp; inject）provide() 和 inject() 可以实现嵌套组件之间的数据传递。父级组件中使用 provide() 函数向下传递数据；子级组件中使用 inject() 获取上层传递过来的数据。​ 通常，当我们需要从父组件向子组件传递数据时，我们会使用 props。想象一下这样的结构：有一些深度嵌套的组件，而深层的子组件只需要父组件的部分内容。在这种情况下，如果仍然将 props 沿着组件链逐级传递下去，可能会很麻烦。对于这种情况，我们可以使用一对 provide 和 inject 。无论组件层次结构有多深，父组件都可以作为其所有子组件的依赖提供者。 ​ 官 ​ 网：https://v3.cn.vuejs.org/guide/component-provide-inject.html 1.3.1 使用 Provide provide 函数允许通过两个参数定义 property： property 的 name (&lt;String&gt; 类型) property 的 value （&lt;String、Array、Object、Fun&gt; 类型） ​ 按需引入 1import { provide } from &quot;vue&quot;; 示例：​ 父组件 123456789101112131415161718192021222324252627&lt;template&gt; &lt;div&gt; &lt;h3&gt;我是父组件&lt;/h3&gt; &lt;inject-child1 /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import { defineComponent, provide } from &quot;vue&quot;;import InjectChild1 from &quot;@/components/inject-child1.vue&quot;;export default defineComponent({ components: { InjectChild1, }, setup() { // 定义数据 const themeColor = &quot;red&quot;; // 通过 provide 函数向子级组件共享数据（不限层级） // provide('要共享的数据名称', 被共享的数据) provide(&quot;globalColor&quot;, themeColor); return {}; },});&lt;/script&gt; 1.3.2 使用注入 inject 函数有两个参数： 要注入的 property 的名称 一个默认的值，当属性不存在时，读取默认的值 (可选) ​ 按需引入 1import { inject } from &quot;vue&quot;; 示例：​ 子组件 123456789101112131415161718192021222324252627&lt;template&gt; &lt;div&gt; &lt;h3&gt;我是子组件&lt;/h3&gt; &lt;p :style=&quot;{ color: themeColor }&quot;&gt;文字颜色为：{{ themeColor }}&lt;/p&gt; &lt;inject-child2 /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import { defineComponent, inject } from &quot;vue&quot;;import InjectChild2 from &quot;@/components/inject-child2.vue&quot;;export default defineComponent({ components: { InjectChild2, }, setup() { // 调用 inject 函数时，通过指定的数据名称，获取到父级共享的数据 const themeColor = inject(&quot;globalColor&quot;); // 把响应式数据 return 给 Template 使用 return { themeColor, }; },});&lt;/script&gt; 子 ​ 子子组件 12345678910111213141516171819202122232425262728293031323334&lt;template&gt; &lt;h3&gt;我是子子子组件&lt;/h3&gt; &lt;p :style=&quot;{ color: color }&quot;&gt;文字颜色为：{{ color }}&lt;/p&gt; &lt;el-button @click=&quot;setGlobalColor&quot;&gt;通过父组件修改&lt;/el-button&gt; &lt;el-button @click=&quot;forbidColor&quot;&gt;直接修改&lt;/el-button&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import { defineComponent, inject } from &quot;vue&quot;;export default defineComponent({ setup() { // 调用 inject 函数时，通过指定的数据名称，获取到父级共享的数据 const color = inject(&quot;globalColor&quot;); // 调用父组件提供的方法 const setGlobalColor = inject(&quot;setGlobalColor&quot;); /** * 修改组件中文字的颜色 */ const forbidColor = () =&gt; { // color.value = 'blue'; }; // 把响应式数据 return 给 Template 使用 return { color, setGlobalColor, forbidColor, }; },});&lt;/script&gt; 1.3.3 响应式为了增加提供值和注入值之间的响应性，我们可以在提供值时使用 ref 或 reactive。​ 示例：​ 父组件 12345678910111213141516171819202122232425262728293031323334353637&lt;template&gt; &lt;div&gt; &lt;h3&gt;我是父组件&lt;/h3&gt; &lt;el-button @click=&quot;clickTransmitData&quot;&gt;点击给子组件传值&lt;/el-button&gt; &lt;inject-child1 /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import { defineComponent, provide, ref } from &quot;vue&quot;;import InjectChild1 from &quot;@/components/inject-child1.vue&quot;;export default defineComponent({ components: { InjectChild1, }, setup() { // 定义 ref 响应式数据 const themeColor = ref(&quot;red&quot;); // 通过 provide 函数向子级组件共享数据（不限层级） // provide('要共享的数据名称', 被共享的数据) provide(&quot;globalColor&quot;, themeColor); /** * 点击传递数据 */ const clickTransmitData = () =&gt; { themeColor.value = &quot;blue&quot;; }; return { clickTransmitData, }; },});&lt;/script&gt; 1.3.4 修改响应式 property当使用响应式提供/注入值时，建议尽可能，在提供者内保持响应式 property 的任何更改。然而，有时我们需要在注入数据的组件内部更新注入的数据。在这种情况下，我们建议提供一个方法来负责改变响应式 property。​ 父组件： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;template&gt; &lt;div&gt; &lt;h3&gt;我是父组件&lt;/h3&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;clickTransmitData&quot; &gt;点击给子组件传值&lt;/el-button &gt; &lt;inject-child1 /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import { defineComponent, provide, ref } from &quot;vue&quot;;import InjectChild1 from &quot;@/components/inject-child1.vue&quot;;export default defineComponent({ components: { InjectChild1, }, setup() { // 定义 ref 响应式数据 const themeColor = ref(&quot;red&quot;); // 通过 provide 函数向子级组件共享数据（不限层级） // provide('要共享的数据名称', 被共享的数据) provide(&quot;globalColor&quot;, themeColor); /** * 点击传递数据 */ const clickTransmitData = () =&gt; { themeColor.value = &quot;blue&quot;; }; // 提供修改全局的方法 provide(&quot;setGlobalColor&quot;, clickTransmitData); return { clickTransmitData, }; },});&lt;/script&gt; 子组件 ​： 123456789101112131415161718192021222324252627282930313233&lt;template&gt; &lt;div&gt; &lt;h3&gt;我是子组件&lt;/h3&gt; &lt;p :style=&quot;{ color: themeColor }&quot;&gt;文字颜色为：{{ themeColor }}&lt;/p&gt; &lt;el-button @click=&quot;setGlobalColor&quot;&gt;通过父组件修改&lt;/el-button&gt; &lt;el-button @click=&quot;forbidColor&quot;&gt;直接修改&lt;/el-button&gt; &lt;inject-child2 /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import { defineComponent, inject } from &quot;vue&quot;;import InjectChild2 from &quot;@/components/inject-child2.vue&quot;;export default defineComponent({ components: { InjectChild2, }, setup() { // 调用 inject 函数时，通过指定的数据名称，获取到父级共享的数据 const themeColor = inject(&quot;globalColor&quot;); // 调用父组件提供的方法 const setGlobalColor = inject(&quot;setGlobalColor&quot;); // 把响应式数据 return 给 Template 使用 return { themeColor, setGlobalColor, }; },});&lt;/script&gt; 1.3.5 禁止数据的更改如果要确保通过 provide 传递的数据不会被注入的组件更改，我们建议对提供者的 property 使用 readonly。​ 父组件： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;template&gt; &lt;div&gt; &lt;h3&gt;我是父组件&lt;/h3&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;clickTransmitData&quot; &gt;点击给子组件传值&lt;/el-button &gt; &lt;inject-child1 /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import { defineComponent, provide, ref, readonly } from &quot;vue&quot;;import InjectChild1 from &quot;@/components/inject-child1.vue&quot;;export default defineComponent({ components: { InjectChild1, }, setup() { // 定义 ref 响应式数据 const themeColor = ref(&quot;red&quot;); // 通过 provide 函数向子级组件共享数据（不限层级） // provide('要共享的数据名称', 被共享的数据) provide(&quot;globalColor&quot;, readonly(themeColor)); /** * 点击传递数据 */ const clickTransmitData = () =&gt; { themeColor.value = &quot;blue&quot;; }; // 提供修改全局的方法 provide(&quot;setGlobalColor&quot;, clickTransmitData); return { clickTransmitData, }; },});&lt;/script&gt; 1.3.6 完整示例父组件 ​ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;template&gt; &lt;div&gt; &lt;p class=&quot;title&quot;&gt;测试提供/注入&lt;/p&gt; &lt;h3&gt;我是父组件&lt;/h3&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;clickTransmitData&quot; &gt;点击给子组件传值&lt;/el-button &gt; &lt;inject-child1 /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import { defineComponent, provide, ref, readonly } from &quot;vue&quot;;import InjectChild1 from &quot;@/components/inject-child1.vue&quot;;export default defineComponent({ components: { InjectChild1, }, setup() { // 定义 ref 响应式数据 const themeColor = ref(&quot;red&quot;); // 定义数据 // const themeColor = 'red'; // 通过 provide 函数向子级组件共享数据（不限层级） // provide('要共享的数据名称', 被共享的数据) provide(&quot;globalColor&quot;, themeColor); // 只读数据 // provide('globalColor', readonly(themeColor)); /** * 点击传递数据 */ const clickTransmitData = () =&gt; { themeColor.value = &quot;blue&quot;; }; // 提供修改全局的方法 provide(&quot;setGlobalColor&quot;, clickTransmitData); return { themeColor, clickTransmitData, }; },});&lt;/script&gt; 子组件 ​： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;template&gt; &lt;div&gt; &lt;h3&gt;我是子组件&lt;/h3&gt; &lt;p :style=&quot;{ color: color }&quot;&gt;文字颜色为：{{ color }}&lt;/p&gt; &lt;el-button @click=&quot;setGlobalColor&quot;&gt;通过父组件修改&lt;/el-button&gt; &lt;el-button @click=&quot;forbidColor&quot;&gt;直接修改&lt;/el-button&gt; &lt;inject-child2 /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import { defineComponent, inject } from &quot;vue&quot;;import InjectChild2 from &quot;@/components/inject-child2.vue&quot;;export default defineComponent({ components: { InjectChild2, }, setup() { // 调用 inject 函数时，通过指定的数据名称，获取到父级共享的数据 const color: any = inject(&quot;globalColor&quot;); // 调用父组件提供的方法 const setGlobalColor = inject(&quot;setGlobalColor&quot;); /** * 修改组件中文字的颜色 */ const forbidColor = () =&gt; { // color.value = 'blue'; }; // 把响应式数据 return 给 Template 使用 return { color, setGlobalColor, forbidColor, }; },});&lt;/script&gt; 子子组件 ​： 12345678910111213141516171819202122&lt;template&gt; &lt;div&gt; &lt;h3&gt;我是子子组件&lt;/h3&gt; &lt;p :style=&quot;{ color: color }&quot;&gt;文字颜色为：{{ color }}&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import { defineComponent, inject } from &quot;vue&quot;;export default defineComponent({ setup() { // 调用 inject 函数时，通过指定的数据名称，获取到父级共享的数据 const color = inject(&quot;globalColor&quot;); // 把响应式数据 return 给 Template 使用 return { color, }; },});&lt;/script&gt; 1.4 模板使用（获取模板内的元素）使用场景：比如 echarts 获取 dom 元素、element-plus 表单验证​ 为了获得对模板内元素或组件实例的引用，我们可以像往常一样声明 ref 并从 setup() 返回： 1.4.1 元素的引用12345678910111213141516171819202122232425262728&lt;template&gt; &lt;div&gt; &lt;h3 ref=&quot;h3Ref&quot;&gt;TemplateRefOne&lt;/h3&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import { defineComponent, ref, onMounted } from &quot;vue&quot;;export default defineComponent({ setup() { // 创建一个 DOM 引用 const h3Ref = ref(null); // 在 DOM 首次加载完毕之后，才能获取到元素的引用 onMounted(() =&gt; { // 为 dom 元素设置字体颜色 // h3Ref.value 是原生DOM对象 h3Ref.value.style.color = &quot;red&quot;; }); // 把创建的引用 return 出去 return { h3Ref, }; },});&lt;/script&gt; 1.4.2 组件的引用父组件中的示例代码如下： 12345678910111213141516171819202122232425262728293031323334&lt;template&gt; &lt;div&gt; &lt;test-c-child ref=&quot;comRef&quot;&gt;&lt;/test-c-child&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;showNumber&quot; &gt;点击获取子元素里的变量值&lt;/el-button &gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import { defineComponent, ref, onMounted } from &quot;vue&quot;;import testCChild from &quot;@/components/test-c-child.vue&quot;;export default defineComponent({ components: { testCChild, }, setup() { // 创建一个组件的 ref 引用 const comRef = ref(null); // 展示子组件中 count 的值 const showNumber = () =&gt; { console.log(comRef.value.count); }; // 把创建的引用 return 出去 return { comRef, showNumber, }; },});&lt;/script&gt; 子组件中的示例代码： 123456789101112131415161718192021222324&lt;template&gt; &lt;div&gt; &lt;h5&gt;我是子组件里的值哦 --- {{ count }}&lt;/h5&gt; &lt;!-- 点击按钮，让 count 值自增 +1 --&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;count += 1&quot;&gt;点击+1&lt;/el-button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import { defineComponent, ref } from &quot;vue&quot;;export default defineComponent({ name: &quot;TestCChild&quot;, setup() { // 定义响应式的数据 const count = ref(0); // 把响应式数据 return 给 Template 使用 return { count, }; },});&lt;/script&gt; 3 响应式3.1 响应式基础使用场景推荐： reactive 推荐定义复杂的数据类型 ref 推荐定义基本数据类型，ref 底层的本质还是 reactive，因为系统会根据我们给 ref 传入的值将它转换成对象 ref(xx)–&gt;reactive({value: xx}) 官网：https://vue3js.cn/vue-composition/#ref-vs-reactive &gt; https://zhuanlan.zhihu.com/p/268053724 3.1.1 reactivereactive() 函数接收一个普通对象，返回一个响应式的数据对象。​ 按需导入 reactive 函数： 1import { reactive } from 'vue'; 在 setup() 函数中调用 reactive() 函数，创建响应式数据对象： ​ 示例 123456789101112131415161718192021222324&lt;template&gt; &lt;div&gt; &lt;p&gt;reactive&lt;/p&gt; &lt;h3&gt;当前的 reactiveCount 值为：{{ reactiveCount }}&lt;/h3&gt; &lt;el-button @click=&quot;reactiveCount++&quot;&gt;点击reactiveCount+1&lt;/el-button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import { defineComponent, reactive, toRefs, ref } from &quot;vue&quot;;export default defineComponent({ name: &quot;TestE&quot;, setup() { // reactive // 创建响应式数据对象 const state = reactive({ reactiveCount: 0 }); return { ...toRefs(state), }; },});&lt;/script&gt; 3.1.2 ref3.1.2.1 基本用法ref() 函数用来根据给定的值创建一个响应式的数据对象，ref() 函数调用的返回值是一个对象，这个对象上只包含一个 .value 属性：​ 数据类型：不限，字符串、数值、布尔值、对象 12345678910111213import { ref } from &quot;vue&quot;;// 创建响应式数据对象 count，初始值为 0const refCount = ref(0);// 如果要访问 ref() 创建出来的响应式数据对象的值，必须通过 .value 属性才可以console.log(refCount.value); // 输出 0// 让 count 的值 +1refCount.value += 1;// 再次打印 count 的值console.log(refCount.value); // 输出 1 3.1.2.2 在 template 中访问 ref 创建的响应式数据当 ref 作为渲染上下文 (从 setup() 中返回的对象) 上的 property 返回并可以在模板中被访问时，它将自动展开为内部值。不需要在模板中追加 .value： 123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;div&gt; &lt;p&gt;ref&lt;/p&gt; &lt;h3&gt;当前的 refCount 值为：{{ refCount }}&lt;/h3&gt; &lt;el-button @click=&quot;refCount++&quot;&gt;点击refCount+1&lt;/el-button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import { defineComponent, reactive, toRefs, ref } from &quot;vue&quot;;export default defineComponent({ name: &quot;TestE&quot;, setup() { // ref // 创建响应式数据对象 count，初始值为 0 const refCount = ref(0); // 如果要访问 ref() 创建出来的响应式数据对象的值，必须通过 .value 属性才可以 console.log(refCount.value); // 输出 0 // 让 count 的值 +1 refCount.value += 1; // 再次打印 count 的值 console.log(refCount.value); // 输出 1 return { refCount, }; },});&lt;/script&gt; ##### 3.1.3 响应式状态解构当我们想使用大型响应式对象的一些 property 时，可能很想使用 ES6 解构来获取我们想要的 property，比如下边的代码： 1234567891011import { reactive } from &quot;vue&quot;;const book = reactive({ author: &quot;Vue Team&quot;, year: &quot;2020&quot;, title: &quot;Vue 3 Guide&quot;, description: &quot;You are reading this book right now ;)&quot;, price: &quot;free&quot;,});const { year, title } = book; 遗憾的是，使用解构的两个 property 的响应性都会丢失。对于这种情况，我们需要将我们的响应式对象转换为一组 ref。这些 ref 将保留与源对象的响应式关联： 123456789101112131415161718import { reactive } from &quot;vue&quot;;const book = reactive({ author: &quot;Vue Team&quot;, year: &quot;2020&quot;, title: &quot;Vue 3 Guide&quot;, description: &quot;You are reading this book right now ;)&quot;, price: &quot;free&quot;,});const { title, year } = toRefs(book); // 转换多个值时const titleRef = toRef(book, &quot;title&quot;); // 转单个值时title.value = &quot;我是新的值&quot;; // 我们需要使用 .value 作为标题，现在是 refconsole.log(book.title); // '我是新的值''console.log(title.value); // '我是新的值' 官网：https://v3.cn.vuejs.org/guide/reactivity-fundamentals.html#响应式状态解构ref：https://www.vue3js.cn/docs/zh/api/refs-api.html#ref 3.1.4 使用 readonly 防止更改响应式对象有时我们想跟踪响应式对象 (ref 或 reactive) 的变化，但我们也希望防止在应用程序的某个位置更改它。例如，当我们有一个被 provide 的响应式对象时，我们不想让它在注入的时候被改变。为此，我们可以基于原始对象创建一个只读的 Proxy 对象： 12345678910const original = reactive({ count: 0 });const copy = readonly(original);// 在copy上转换original 会触发侦听器依赖original.count += 1;// 转换copy 将导失败并导致警告copy.count += 1; // 警告: &quot;Set operation on key 'count' failed: target is readonly.&quot; 3.2 响应式计算使用场景：当依赖某个值的数据发生变化时，就会用到它。例如总价 = 数量 * 价格，当数量和价格发生变化时都会影响总价，这时计算属性就派上用场了。​ computed() 用来创建计算属性，computed() 函数的返回值是一个 ref 的实例。使用 computed 之前需要按需导入： 1import { computed } from &quot;vue&quot;; 3.2.1 创建只读计算属性在调用 computed() 函数期间，传入一个 function 函数，可以得到一个只读的计算属性，示例代码如下： 12345678910111213// 创建一个 ref 响应式数据const count = ref(1);// 根据 count 的值，创建一个响应式的计算属性 plusOne// 它会根据依赖的 ref 自动计算并返回一个新的 refconst plusOne = computed(() =&gt; count.value + 1);// 等同于它const plusOne = computed(() =&gt; { return count.value + 1;});plusOne.value += 1; // Write operation failed: computed value is readonly 3.2.2 创建可读可写的计算属性在调用 computed() 函数期间，传入一个包含 get 和 set 函数的对象，可以得到一个可读可写的计算属性，示例代码如下： 123456789101112// 创建一个 ref 响应式数据const count = ref(1);// 创建一个 computed 计算属性const plusOne = computed({ // 取值函数 get: () =&gt; count.value + 1, // 赋值函数 set: (val) =&gt; { count.value = val - 1; },}); 3.3 响应式监听watch() 函数用来监视某些数据项的变化，从而触发某些特定的操作，使用之前需要按需导入： 1import { watch } from &quot;vue&quot;; 3.3.1 基本用法12345678910const count = ref(0);// 定义 watch，只要 count 值变化，就会触发 watch 回调watch( () =&gt; count.value, (newVal, oldVal) =&gt; { console.log(`新值${newVal}`); console.log(`旧值${oldVal}`); }); 3.3.2 监视指定的数据源监视 reactive 类型的数据源： 123456789// 定义数据源const state = reactive({ count: 0 });// 监视 state.count 这个数据节点的变化watch( () =&gt; state.count, (count, prevCount) =&gt; { /* ... */ }); 监视 ref 类型的数据源： 12345678910const count = ref(0);// 定义 watch，只要 count 值变化，就会触发 watch 回调watch( () =&gt; count.value, (newVal, oldVal) =&gt; { console.log(`新值${newVal}`); console.log(`旧值${oldVal}`); }); 3.3.3 监视多个数据源123456789watch( [() =&gt; count.value, () =&gt; num.value], ([newCount, newNum], [prevCount, prevNum]) =&gt; { console.log(`count新值${newCount}`); console.log(`count旧值${prevCount}`); console.log(`num新值${newNum}`); console.log(`num旧值${prevNum}`); }); 官网：https://v3.cn.vuejs.org/guide/reactivity-computed-watchers.html#侦听响应式对象 ​ 3.3.4 监听对象监听对象，需要使用到 watch 的深度监听，语法如下： 1234567891011watch( () =&gt; props.data, (newVal, oldVal) =&gt; { console.log(newVal); console.log(oldVal); }, { deep: true, // 深度监听 immediate: true, // 默认执行 }); ​ 监听对象时，会遇到没有旧值的问题，可参考下方链接 官网：https://v3.cn.vuejs.org/guide/reactivity-computed-watchers.html#侦听响应式对象 网上：https://blog.csdn.net/qq_41777791/article/details/108213187 3.3.4、清除监视在 setup() 函数内创建的 watch 监视，会在当前组件被销毁的时候自动停止。如果想要明确地停止某个监视，可以调用 watch() 函数的返回值即可，语法如下： 1234567// 创建监视，并得到 停止函数const stop = watch(() =&gt; { /* ... */});// 调用停止函数，清除对应的监视stop(); 4 如何使用 vue-router1234567891011import { useRoute, useRouter } from 'vue-router';...setup () { const route = useRoute(); const router = useRouter(); // router.push({ // name: 'home' // }); },... 引入的 useRoute,useRouter 相当于 vue2 的 this.$route()，this.$router() 5 如何使用状态管理123456789101112import { useStore } from 'vuex';...setup () { const store = useStore(); // 获取变量 // store.state.XXXX // 更新值 // store.dispatch('方法名', 新值); },... 6 Vue2 和 Vue3 对比6.1 代码结构Vu​e2 把变量、声明周期、methods 等分割到独立的属性区域的 12345678910111213141516171819export default { props: { title: String }, data () { return { username: '', password: '', a: '', } }, methods: { login () { // 登陆方法 } aa () {} }} Vue3 12345678910111213141516171819export default { props: { title: String, }, setup() { const state = reactive({ username: &quot;&quot;, password: &quot;&quot;, }); const login = () =&gt; { // 登陆方法 }; return { login, state, }; },}; 6.2 生命周期Vue2 12345678910111213141516171819export default { props: { title: String, }, data() { return { username: &quot;&quot;, password: &quot;&quot;, }; }, mounted() { console.log(&quot;组件已挂载&quot;); }, methods: { login() { // login method }, },}; Vue3 12345678910111213141516import { reactive, onMounted } from &quot;vue&quot;;export default { props: { title: String, }, setup() { // .. onMounted(() =&gt; { console.log(&quot;组件已挂载&quot;); }); // ... },}; 6.3 计算属性效果：添加一个计算属性来转换username成小写字母 Vue2 12345678export default { // .. computed: { lowerCaseUsername() { return this.username.toLowerCase(); }, },}; Vue3 123456789101112131415import { reactive, onMounted, computed } from 'vue'export default { props: { title: String }, setup () { const state = reactive({ username: '', password: '', lowerCaseUsername: computed(() =&gt; state.username.toLowerCase()) }) // ... } 6.4 接收 PropsVue2 在 Vue2，this代表的是当前组件，不是某一个特定的属性。所以我们可以直接使用this访问 prop 属性值。 12345678export default { props: { title: String, }, mounted() { console.log(&quot;title: &quot; + this.title); },}; Vue3 在 Vue3 中，this无法直接拿到 props 属性，emit events（触发事件）和组件内的其他属性。不过全新的setup()方法可以接收两个参数：​ props - 传过来的参数 context - Vue3 暴露出来的属性（emit，slots，attrs） 123456789setup (props) { // ... onMounted(() =&gt; { console.log('title: ' + props.title) }) // ...} 6.5 事件效果：点击提交按钮时触发一个login的事件 Vue2 在 Vue2 中我们会调用到this.$emit然后传入事件名和参数对象。 123456789export default { // ..... login() { this.$emit(&quot;login&quot;, { username: this.username, password: this.password, }); },}; Vue3 刚刚说过this已经不是和 vue2 一样代表着这个组件了。​ 在setup()中的第二个参数content对象中就有emit，这个是和this.$emit是一样的。那么我们只要在setup()接收第二个参数中使用分解对象法取出emit就可以在 setup 方法中使用了。 123456789101112setup (props, { emit }) { // ... const login = () =&gt; { emit('login', { username: state.username, password: state.password }) } // ...} ## 7 其他7.1 全局变量7.1.1 设置全局变量12const app = createApp(App);app.config.globalProperties.name = &quot;liuyan&quot;; 官网：https://vue3js.cn/docs/zh/api/application-config.html#globalproperties ​ 7.1.2 获取全局变量1234567891011...import { getCurrentInstance } from 'vue'setup() { const internalInstance = getCurrentInstance(); const name = internalInstance.appContext.config.globalProperties.name; console.log(name); // liuyan}... 官网：https://vue3js.cn/docs/zh/api/composition-api.html#getcurrentinstance 7.2 兄弟组件传参实现方式：Vuex、通过父组件、第三方 pubsub-jsnpm：https://www.npmjs.com/package/pubsub-js 7.2.1 发布消息123import PubSub from &quot;pubsub-js&quot;; // 引入PubSub.publish(&quot;changeVal&quot;, 1); // 发布消息，第一个参数事件名、第二个数据 7.2.2 订阅和取消订阅消息12345678910import PubSub from &quot;pubsub-js&quot;; // 引入// 订阅消息const subName = PubSub.subscribe(&quot;changeVal&quot;, (name: number, val: number) =&gt; { console.log(name); console.log(val);});// 取消订阅PubSub.unsubscribe(subName);","link":"/2021/07/02/Vue3%E5%85%A5%E9%97%A8/"},{"title":"git使用","text":"1 前言读完全文，希望你能明白： 什么是git 集中式VS分布式：Git VS SVN git常用使用场景及使用方法 2 本地/远程仓库2.1 创建本地版本库 什么是版本库呢？版本库又名仓库，英文名 repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被 Git 管理起来，每个文件的修改、删除，Git 都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。 本地创建一个文件夹 把这个目录变成 Git 可以管理的仓库 12$ git initInitialized empty Git repository in /Users/yushuang/Documents/技术分享/test1/.git/ 瞬间 Git 就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的人可以发现当前目录下多了一个 .git 的目录，这个目录是Git用来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把 Git 仓库给破坏了。 如果你没有看到 .git 目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见 123git add file1.txtgit add file2.txt file3.txtgit commit -m &quot;add 3 files.&quot; 2.2 添加远程库 通过以上操作，现在的情景是，你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。 我们在Github上创建一个仓库，成功后会看到以下截图 现在，我们根据 GitHub 的提示，在本地的test1仓库下运行命令： 1git remote add origin https://github.com/geminiyu233/test1.git 添加后，远程库的名字就是 origin，这是 Git 默认的叫法，也可以改成别的，但是 origin 这个名字一看就知道是远程库。 下一步，就可以把本地库的所有内容推送到远程库上： 12345678$ git push -u origin masterEnumerating objects: 3, done.Counting objects: 100% (3/3), done.Writing objects: 100% (3/3), 217 bytes | 217.00 KiB/s, done.Total 3 (delta 0), reused 0 (delta 0), pack-reused 0To https://github.com/geminiyu233/test1.git * [new branch] master -&gt; masterBranch 'master' set up to track remote branch 'master' from 'origin' 把本地库的内容推送到远程，用 git push 命令，实际上是把当前分支 master 推送到远程。 由于远程库是空的，我们第一次推送 master 分支时，加上了-u参数，Git 不但会把本地的 master 分支内容推送的远程新的master分支，还会把本地的 master 分支和远程的 master 分支关联起来，在以后的推送或者拉取时就可以简化命令git push。 推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样： 2.3 从远程库克隆上面我们讲了先有本地库，后有远程库的时候，如何关联远程库。 现在，假设我们从远程库克隆。直接使用命令git clone克隆一个本地库： 12345$ git remote add origin https://github.com/geminiyu233/test1.gitCloning into 'test1'...remote: Counting objects: 3, done.remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 3Receiving objects: 100% (3/3), done. 2.4 设置换行符Windows 使用回车和换行两个字符来结束一行，而 Mac 和 Linux 只使用换行一个字符。Windows 系统可以在提交代码前输入命令： 1git config --global core.autocrlf false Windows 系统如果不设置换行符的话，项目代码拉取运行后可能会报下面的错误： 3 时光穿梭机我们已经成功地添加并提交了一个 README.md 文件，我们继续修改 README.md 文件 现在，运行git status命令看看结果： 12345678910$ git statusOn branch masterYour branch is up to date with 'origin/master'.Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: README.mdno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) git status命令可以让我们时刻掌握仓库当前的状态，上面的命令输出告诉我们，README.md被修改过了，但还没有准备提交的修改。 虽然Git告诉我们README.md被修改了，但如果能看看具体修改了什么内容，自然是很好的。比如你休假两周从国外回来，第一天上班时，已经记不清上次怎么修改的README.md，所以，需要用git diff这个命令看看： 3.1 工作区和暂存区在讲下面内容前，我们先了解概念工作区和暂存区 工作区（Working Directory） 就是你在电脑里能看到的目录，比如我的test1文件夹就是一个工作区： 版本库（Repository）工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 Git的版本库里存了很多东西，其中最重要的就是称为 stage（或者叫index）的暂存区，还有 Git 为我们自动创建的第一个分支 master，以及指向 master 的一个指针叫HEAD。 3.2 版本回退在我们反复不断对一个文件进行了修改，然后不断对提交修改到版本库中，现在我们来回顾下我们 README.md 文件一共有几个版本被提交到 Git 仓库中了： 版本1： 12我是女我是女生 版本2： 12我是女生我是漂亮女生 版本3： 12我是漂亮女生我是贼漂亮女生 当然了，在实际工作中，我们脑子里怎么可能记得一个几千行的文件每次都改了什么内容，不然要版本控制系统干什么。版本控制系统肯定有某个命令可以告诉我们历史记录，在 Git 中，我们用git log命令查看： 123456789101112131415161718$ git logcommit 2678160d780b6ea4ff628f63182ec379b5a00d2e (HEAD -&gt; dev)Author: yushuang &lt;yushuang@internal.ths.com.cn&gt;Date: Fri Aug 5 12:38:50 2022 +0800 feat: 我是贼漂亮女生commit 1e81612403eddf78daa8b6d132433c7334d22d2eAuthor: yushuang &lt;yushuang@internal.ths.com.cn&gt;Date: Fri Aug 5 12:38:36 2022 +0800 feat: 我是漂亮女生commit b733a33b9c0cf22d32a79a106c639a9453e39a3dAuthor: yushuang &lt;yushuang@internal.ths.com.cn&gt;Date: Fri Aug 5 12:38:16 2022 +0800 feat: 我是女生 git log命令显示从最近到最远的提交日志，我们可以看到3次提交 如果嫌输出信息太多，看得眼花缭乱的，可以试试加上--pretty=oneline参数： 1234$ git log --pretty=oneline2678160d780b6ea4ff628f63182ec379b5a00d2e (HEAD -&gt; dev) feat: 我是贼漂亮女生1e81612403eddf78daa8b6d132433c7334d22d2e feat: 我是漂亮女生b733a33b9c0cf22d32a79a106c639a9453e39a3d feat: 我是女生 好了，现在我们启动时光穿梭机，准备把README.md回退到上一个版本，也就是我们要把当前版本我是贼漂亮女生回退到上一个版本我是漂亮女生，就可以使用git reset命令： 12$ git reset --hard HEAD^HEAD is now at 1e81612 feat: 我是漂亮女生 还可以继续回退到上一个版本，不过且慢，让我们用git log再看看现在版本库的状态： 123$ git log --pretty=oneline1e81612403eddf78daa8b6d132433c7334d22d2e (HEAD -&gt; dev) feat: 我是漂亮女生b733a33b9c0cf22d32a79a106c639a9453e39a3d feat: 我是女生 最新的那个版本我是贼漂亮女生已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？ 办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个我是贼漂亮女生的commit id是2678160...，于是就可以指定回到未来的某个版本： 12$ git reset --hard 2678160HEAD is now at 2678160 feat: 我是贼漂亮女生 Git 的版本回退速度非常快，因为 Git 在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD指向我是贼漂亮女生： 然后顺便把工作区的文件更新了。所以你让HEAD指向哪个版本号，你就把当前版本定位在哪。 版本号没必要写全，前几位就可以了，Git 会自动去找。当然也不能只写前一两位，因为 Git 可能会找到多个版本号，就无法确定是哪一个了。 现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的 commit id 怎么办？ 在 Git 中，总是有后悔药可以吃的。当你用$ git reset --hard HEAD^回退到我是漂亮女生版本时，再想恢复到我是贼漂亮女生，就必须找到我是贼漂亮女生的commit id。Git提供了一个命令git reflog用来记录你的每一次命令： 1234567$ git reflog1e81612 (HEAD -&gt; dev) HEAD@{0}: reset: moving to HEAD^2678160 HEAD@{1}: reset: moving to 26781601e81612 (HEAD -&gt; dev) HEAD@{2}: reset: moving to HEAD^2678160 HEAD@{3}: commit: feat: 我是贼漂亮女生1e81612 (HEAD -&gt; dev) HEAD@{4}: commit: feat: 我是漂亮女生b733a33 HEAD@{5}: commit: feat: 我是女生 终于舒了口气，从输出可知，我是贼漂亮女生的commit id是2678160，现在，你又可以乘坐时光机回到未来了。 3.3 撤销修改 假设你正在开发一个功能，在你准备提交前，突然想起某段代码写错了，这个时候你可以删除最后一行，手动恢复到上一个版本状态。如果用git status查看一下： 12345678910$ git statusOn branch masterYour branch is up to date with 'origin/master'.Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: README.mdno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 你可以发现，Git会告诉你，git restore file可以丢弃工作区的修改： 1git restore README.md 命令git restore README.md意思就是，把 README.md 文件在工作区的修改全部撤销，这里有两种情况： 一种是 README.md 自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是 README.md 已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 总之，就是让这个文件回到最近一次git commit或git add时的状态。 假设你不但写了一些 bug，还git add到暂存区了。庆幸的是，在commit之前，你发现了这个问题。用git status查看一下，修改只是添加到了暂存区，还没有提交： 1234567$ git status On branch masterYour branch is up to date with 'origin/master'.Changes to be committed: (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage) modified: README.md Git同样告诉我们，用命令git restore --staged &lt;file&gt;可以把暂存区的修改撤销掉（unstage），重新放回工作区： 1git restore --staged README.md 再用git status查看一下，现在暂存区是干净的，工作区有修改： 12345678910$ git status On branch masterYour branch is up to date with 'origin/master'.Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: README.mdno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 4 分支管理假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。 现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。 4.1 创建与合并分支在版本回退里，你已经知道，每次提交，Git 都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在 Git 里，这个分支叫主分支，即 master 分支。HEAD严格来说不是指向提交，而是指向 master，master 才是指向提交的，所以，HEAD指向的就是当前分支。 一开始的时候，master 分支是一条线，Git 用 master 指向最新的提交，再用HEAD指向 master，就能确定当前分支，以及当前分支的提交点： 每次提交，master 分支都会向前移动一步，这样，随着你不断提交，master 分支的线也越来越长。 当我们创建新的分支，例如 dev 时，Git新建了一个指针（分支）叫 dev，指向 master 相同的提交，再把HEAD指向 dev，就表示当前分支在 dev 上： Git 创建一个分支很快，因为除了增加一个 dev 指针，改改HEAD的指向，工作区的文件都没有任何变化！ 不过，从现在开始，对工作区的修改和提交就是针对 dev 分支了，比如新提交一次后，dev 指针往前移动一步，而 master 指针不变： 假如我们在 dev 上的工作完成了，就可以把 dev 合并到 master 上。Git 怎么合并呢？最简单的方法，就是直接把 master 指向 dev 的当前提交，就完成了合并： 所以 Git 合并分支也很快！就改改指针，工作区内容也不变！ 合并完分支后，甚至可以删除 dev 分支。删除 dev 分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支： 下面开始实战。 12$ git checkout -b devSwitched to a new branch 'dev' git checkout命令加上-b参数表示创建并切换，相当于以下两条命令： 123$ git branch dev$ git checkout devSwitched to branch 'dev' 然后，用git branch命令查看当前分支： 123$ git branch* dev master git branch命令会列出所有分支，当前分支前面会标一个*号。 然后，我们就可以在 dev 分支上正常提交。现在，dev 分支的工作完成，我们就可以切换回 master 分支： 12$ git checkout masterSwitched to branch 'master' 切换回master分支后，再查看一个 README.md 文件，刚才添加的内容不见了！因为那个提交是在 dev 分支上，而 master 分支此刻的提交点并没有变： 现在，我们把 dev 分支的工作成果合并到 master 分支上： 12345$ git merge devUpdating 07220b9..4a65a7cFast-forward README.md | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-) git merge命令用于合并指定分支到当前分支。合并后，再查看 README.md 的内容，就可以看到，和 dev 分支的最新提交是完全一样的。 合并完成后，就可以放心地删除 dev 分支了： 12$ git branch -d devDeleted branch dev (was 4a65a7c). 删除后，查看 branch，就只剩下 master 分支了： 12$ git branch* master 4.2 解决冲突合并分支往往也不是一帆风顺的，现在我们模拟一个冲突的情况： 准备新的feature1分支，在该分支上修改一行代码；然后git add，git commit切换到master分支，在同一行修改代码；然后git add，git commit现在，master分支和feature1分支各自都分别有新的提交，变成了这样： 这种情况下，Git 无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看： 1234$ git merge devAuto-merging README.mdCONFLICT (content): Merge conflict in README.mdAutomatic merge failed; fix conflicts and then commit the result. 果然冲突了！Git 告诉我们，README.md 文件存在冲突，必须手动解决冲突后再提交。git status也可以告诉我们冲突的文件： 1234567891011$ git statusOn branch masterYou have unmerged paths. (fix conflicts and run &quot;git commit&quot;) (use &quot;git merge --abort&quot; to abort the merge)Unmerged paths: (use &quot;git add &lt;file&gt;...&quot; to mark resolution) both modified: README.mdno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，我们修改后保存，在你准备提交： 123$ git add readme.txt $ git commit -m &quot;conflict fixed&quot;[master cf810e4] conflict fixed 现在，master 分支和 feature1 分支变成了下图所示： 用带参数的git log也可以看到分支的合并情况： 12345678910$ git log --graph --pretty=oneline --abbrev-commit* 2abc8c6 (HEAD -&gt; dev) conflict fixed|\\ | * c7f0aef (master) feat: e* | a3d5813 feat: test|/ * a3afc7d feat: test* 461746a feat: test* 4a65a7c feat: test* 07220b9 (origin/master) init 4.2.1 避免产生冲突本地拉取： 当远端有更新，本地库没有变化，拉取操作远端会覆盖本地库（远端版本高于本地） 当同一个文件同一行远端修改，本地也有修改，拉取会产生冲突文件（远端版本和本地版本冲突） 当本地修改，而远端没有变化，拉取不会产生变化（本地版本高于远端版本） 当本地库版本低于远端版本，则无法推送，必须先拉取再操作，否则git会提示报错 4.3 多人协作多人协作时，大家都会往 master 和 dev 分支上推送各自的修改。 当你从远程库 clone 时，默认情况下，你只能看到本地的 master 分支。不信可以用git branch命令看看： 12$ git branch* master 现在，你要在 dev 分支上开发，就必须创建远程 origin 的 dev 分支到本地，于是用这个命令创建本地 dev 分支： 1git checkout -b dev origin/dev 现在，他就可以在 dev 上继续修改，然后，时不时地把 dev 分支 push 到远程： 123456789101112131415$ git add env.txt$ git commit -m &quot;add env&quot;[dev 7a5e5dd] add env 1 file changed, 1 insertion(+) create mode 100644 env.txt$ git push origin devCounting objects: 3, done.Delta compression using up to 4 threads.Compressing objects: 100% (2/2), done.Writing objects: 100% (3/3), 308 bytes | 308.00 KiB/s, done.Total 3 (delta 0), reused 0 (delta 0)To github.com:michaelliao/learngit.git f52c633..7a5e5dd dev -&gt; dev 你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送： 12345678$ git push origin devTo github.com:michaelliao/learngit.git ! [rejected] dev -&gt; dev (non-fast-forward)error: failed to push some refs to 'git@github.com:michaelliao/learngit.git'hint: Updates were rejected because the tip of your current branch is behindhint: its remote counterpart. Integrate the remote changes (e.g.hint: 'git pull ...') before pushing again.hint: See the 'Note about fast-forwards' in 'git push --help' for details. 推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git 已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送： 12345678910$ git pullThere is no tracking information for the current branch.Please specify which branch you want to merge with.See git-pull(1) for details. git pull &lt;remote&gt; &lt;branch&gt;If you wish to set tracking information for this branch you can do so with: git branch --set-upstream-to=origin/&lt;branch&gt; dev git pull也失败了，原因是没有指定本地 dev 分支与远程origin/dev分支的链接，根据提示，设置 dev 和origin/dev的链接： 12$ git branch --set-upstream-to=origin/dev devBranch 'dev' set up to track remote branch 'dev' from 'origin'. 再pull： 1234$ git pullAuto-merging env.txtCONFLICT (add/add): Merge conflict in env.txtAutomatic merge failed; fix conflicts and then commit the result. 这回git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。解决后，提交，再 push： 1234567891011$ git commit -m &quot;fix env conflict&quot;[dev 57c53ab] fix env conflict$ git push origin devCounting objects: 6, done.Delta compression using up to 4 threads.Compressing objects: 100% (4/4), done.Writing objects: 100% (6/6), 621 bytes | 621.00 KiB/s, done.Total 6 (delta 0), reused 0 (delta 0)To github.com:michaelliao/learngit.git 7a5e5dd..57c53ab dev -&gt; dev 4.4 强迫症-变基 Rebase4.4.1 原理现在两个分支master和feature，其中feature是在提交点B处从master上拉出的分支master上有一个新提交M，feature上有两个新提交C和D 现在要把master合并到feature分支上：咱们正常直接git merge master，运行结果如下，可以看到有分叉 1234567891011* 1434cad (HEAD -&gt; feature) feat: 合并master|\\ | * dcc5122 (master) feat: M* | 214697e feat: D* | a8c4e63 feat: C|/ * 9e56151 feat: B* aa2428f feat: 本地修改* 12f4d57 feat: 清理仓库* c1517e5 Initial commit 如果我们采用变基到方式呢？此时切换到feature分支上，执行如下命令，相当于是想要把master分支合并到feature分支（这一步的场景就可以类比为我们在自己的分支feature上开发了一段时间了，准备从主干master上拉一下最新改动） 12345678910111213$ git checkout feature$ git rebase master//这两条命令等价于git rebase master feature，使用`git log --graph --pretty=oneline --abbrev-commit`看下提交日志* 3807c7a (HEAD -&gt; feature) feat: D* ec30ba1 feat: C* dcc5122 (master) feat: M* 9e56151 feat: B* aa2428f feat: 本地修改* 12f4d57 feat: 清理仓库* c1517e5 Initial commit 以上是刚我举的简单例子，但是实际开发项目那日志就多了，利用变基，就可以把 变成这样，强迫症看着是不是舒服多了，并且也有利于我们利用工具一键生成项目更新日志： 下图为变基后的提交节点图，解释一下其工作原理： rebase，变基，可以直接理解为改变基底。feature分支是基于master分支的B拉出来的分支，feature的基底是B。而master在B之后有新的提交，就相当于此时要用master上新的提交来作为feature分支的新基底。实际操作为把B之后feature的提交存下来，然后删掉原来这些提交，再找到master的最新提交位置，把存下来的提交再接上去（新节点新commit id），如此feature分支的基底就相当于变成了M而不是原来的B了。（注意，如果master上在B以后没有新提交，那么就还是用原来的B作为基，rebase操作相当于无效，此时和git merge就基本没区别了，差异只在于git merge会多一条记录Merge操作的提交记录） 上面的例子可抽象为如下实际工作场景：张三从B拉了代码进行开发，目前提交了两次，开发到D了；李四也从B拉出来开发了并且开发完毕，他提交到了M，然后合到主干上了。此时张三想拉下最新代码，于是他在feature分支上执行了git rebase master，即把master分支给rebase过来，由于李四更早开发完并合了主干，如此就相当于张三是基于李四的最新提交M进行的开发了。 4.4.2 常用使用场景4.4.2.1 场景1在开发一个功能时，可能需要几天，每天都提交了更改，最后完成整个功能，但是我们的提交记录中有多个版本，如V1，V2，V3 和 V4 版本，为了提交记录简洁，可以通过变基，将多个提交记录整合成一个记录，如下图： 4.4.2.2 场景2当分支dev开发并提交了新功能V3，主分支master上也提交了新的功能，我们要把dev分支合并到master分支，正常情况下，我们的最终分支结构如下图： 这种merge结构是没问题的，也是常用的，但假如，我们想要提交记录更加简洁，即像下图这种结果，我们可以采用rebase变基方式合并。 4.4.2.2 场景3（处理rebase时的冲突）有时，在执行rebase时会产生冲突，接下来就要先解决冲突，解决完冲突后执行git add命令，在接着执行git rebase --continue命令 4.4.3 全局设置一般初学者总会感到茫然，不敢轻易下手，怕万一把时间线弄坏了，一发不可收拾。而且所有关于变基的命令都和我们已经多年习惯了的pull/add/commit/push不一样，手工输入，繁琐而且容易出错。所以我们今天不讲太多的rebase命令怎么用，而直接用两条命令设置一下，从此以后让你每次提交都可以自动变基，而不必改变之前的任何操作习惯。这两条命令就是： 12git config --global pull.rebase truegit config --global rebase.autoStash true 这两条命令在任意一台电脑上都只需要设置一次，而且一次设置，全局生效，所有的项目以后每次pull/push都会自动变基，再也不用担心在提交之前忘记变基了。 4.5 使用 git stash 解决问题 场景1：当你正在开发一个功能 A 时，刚开发到一半突然接到需要在一小时内修复一个 bug，但是功能 A 的工作预计还要一天才能开发完，当时在 dev 分支开发的一部分功能 A 功能也还没有提交，并不是你不想提交，而是工作只进行到一半，还没法提交，但是又必须在 1 小时内修复 bug 该怎么办？ 这个时候就可以用到 Git 提供的 stash 功能了：​ 先把当前工作现场“储藏”起来（相当于还原到和服务器上一样的代码，当前工作区是干净状态）。 12$ git stashSaved working directory and index state WIP on dev: f52c633 add merge 现在，用 git status 查看工作区，git 显示工作区是干净的，现在可以放心的修改 bug 了。​ 现在 bug 修复完成，然后提交。 1234$ git add readme.txt $ git commit -m &quot;fix bug 101&quot;[issue-101 4c805e2] fix bug 101 1 file changed, 1 insertion(+), 1 deletion(-) bug 修复后，提交代码后使用git status发现当前工作区是干净的，刚才的工作现场存到哪去了？用git stash list命令看看 1git stash list 是时候把存储起来的功能 A 代码恢复回来继续工作了，有两种恢复方式。 一是用git stash apply恢复，但是恢复后，stash 内容并不删除，你需要用git stash drop来删除。 用git stash pop，恢复的同时把 stash 内容也删了 12git stash popgit stash apply 再用git stash list查看，就看不到任何 stash 内容了：​ 你可以多次 stash，恢复的时候，先用 git stash list 查看，然后恢复指定的 stash，用命令： 1git stash apply &lt;stash的索引值&gt; 删除保存的 stash： 1git stash drop 场景 2：当你往远程仓库 push 代码时，本地版本 &lt; 远程版本时，并且你本地还有未 add 的代码时，Git 就会提示你 The current working tree is not clean。​ 这个时候你也可以先把本地为提交的代码使用 stash 功能给存储起来，把代码 push 到远程后再使用 git stash pop 或 git stash apply 把存储的代码给恢复。 场景 3：平常我们新开发一个功能要建个分支，修改个 bug 也要建个分支，我们经常要对不同分支进行操作，然而原本我是想在 feature 分支开发一个新功能，但是代码却写在了 test 分支上了。 在 test 分支上执行 git stash，先把代码存储起来。 1git stash 执行 git switch feature 切换到 feature 分支。 1git switch feature 执行 git stash pop 把存储的代码释放出来，并清空 stash 存储的代码。 1git stash pop","link":"/2022/08/04/git%E4%BD%BF%E7%94%A8/"},{"title":"Git常用功能总结","text":"1 基础概念 1.1 工作区 / 暂存区 / 本地仓库 / 远程仓库首先，先了解一下 Git 的构成部分可以帮助我们在后面使用 Git 指令时容易理解其实现原理。 Workspace：工作区：项目文件所在目录，可能包含一个 .git(本地仓库) 子目录 Staging Area：暂存区：也称为索引，其中所存储的是我们为下一次提交准备的内容，它以快照的形式保存了相关的文件内容 Local Repository：本地仓库：本机，通常驻留在项目的 .git 目录中 Remote Repository：远程仓库，非本机上的 Git 仓库，一般会是 GitHub 1.2 相关的 Git 命令clone 远程仓库的代码到本地： 1git clone &lt;远程仓库地址&gt; 把工作区修改的代码提交到暂存区： 1git add . 把暂存区内容提交到本地仓库： 1git commit -m &quot;feat: 提交说明&quot; 把本机仓库内容 push 到远程仓库上： 1git push origin &lt;分支名&gt; fetch 相关指令：将某个远程主机的更新，全部取回本地： 1git fetch &lt;远程主机名&gt; 取回特定分支的更新，可以指定分支名： 1git fetch &lt;远程主机名&gt; &lt;分支名&gt; pull 和 fetch 的区别：pull 相当于 fetch 和 merge 的这两步操作： 12git fetch origin master // 从远程主机的 master 分支拉取最新内容git merge FETCH_HEAD // 将拉取下来的最新内容合并到当前所在的分支中 2 基础配置Git 安装成功后做以下配置： 2.1 设置提交用户每个机器都必须自报家门：你的名字和 Email 地址。 12git config --global user.name &quot;杨静&quot;git config --global user.email &quot;yangjing@internal.ths.com.cn&quot; 2.2 设置合并方式为了能够让每一次提交都有明确的记录，统一使用 rebase 方式提交代码。在 Git Bash 中执行： 1git config --global pull.rebase true 2.3 设置换行符Windows 使用回车和换行两个字符来结束一行，而 Mac 和 Linux 只使用换行一个字符。Windows 系统可以在提交代码前输入命令： 1git config --global core.autocrlf false Windows 系统如果不设置换行符的话，项目代码拉取运行后可能会报下面的错误： 2.4 查看 Git 配置信息用户名和账号配置好后查看下最终配置信息： 1git config --list 3 撤销修改 3.1 撤销工作区内容 场景： 自从上次代码提交后，我们写了一些测试时用的代码例如 debugger、console.log() 等等。等我们测试完后我们并不想保存这些代码，想把他们从工作区删除掉，这个时候我们就可以使用 Git 的撤销功能。 3.1.1 使用 git checkout 撤销工作区修改​ 撤销指定文件在工作区的修改： 1git checkout -- &lt;file&gt; 撤销所有文件在工作区的修改： 1git checkout -- . 注意：git checkout -- file 命令中的 – 很重要，没有 -- 就变成了 切换到另一个分支 的命令，我们在后面的分支管理中会再次遇到 git checkout 命令。 3.1.2 使用 git restore 撤销工作区修改可能是因为 Git 版本不一样，我的电脑执行 git status 后是提示我使用 git restore 命令进行撤销的。 1git restore &lt;file&gt;... 所以也就是说你在执行 git status 命令后，你可以使用 Git 提示的那个命令进行撤销操作。 3.1.3 使用小乌龟撤销工作区修改使用小乌龟撤销工作区修改内容：第一步： 选择 Revert 功能 第二步：选中你要撤销修改的文件点确定。 3.2 撤销暂存区内容 场景：假使自从上次提交代码后你写了一些测试代码，由于加班到凌晨三点脑子已经不好使了，习惯之下进行了 git add . 操作，庆幸的是在 commit 之前发现了这个问题，执行 git status 看一下，修改只是存到了暂存区，并没有提交。 3.2.1 使用 git reset 撤销暂存区内容撤销指定文件暂存区的修改，重新放回工作区： 1git reset HEAD &lt;file&gt; // HEAD 也可以用 commitid 代替 撤销所有文件暂存区的修改，重新放回工作区： 1git reset HEAD . 撤销所有文件暂存区的修改，直接撤销掉，不会重新放回工作区： 1git reset --hard HEAD // --hard 在这有一步到位的意思 已经执行 git add . 提交了暂存区，但是没有 commit：可以使用 git reset HEAD 把暂存区的修改撤销掉（unstage），重新放回工作区。如果工作区也想清掉的话再执行一下刚才的 git checkout – 指令。git reset 命令既可以进行版本回退，也可以把暂存区的修改回退到工作区。当我们用 HEAD 时，表示最新的版本。 3.2.2 使用 git restore 撤销暂存区内容可能是因为 Git 版本的问题，同样，我的电脑执行 git status 命令后，Git 提示我使用 git restore 进行回退。 3.3 撤销本地仓库内容（版本回退） 场景：git reset –hard 适合我们提交了错误的内容后进行回退的命令，因为执行这个命令后 Git 并不会将代码重新放回工作区。 Git 实现版本回退的原理是通过让 HEAD 这个指针指向其它版本来完成版本回退。 3.3.1 使用 git reset 实现版本回退如果我们已经把内容 commit 到了本地仓库里，那么如果想撤销的话可以按照以下步骤：第一步：查看历史提交记录，找到你想回退到那个版本的 commitid，copy 下来备用。 1git log 第二步：执行 git reset 实现版本回退 1git reset --hard commitid 注意：执行 git reset –hard 进行版本回退后，并不会重新把你提交为 commitid 的内容重新放回工作区。拓展 1：在第二个步骤中如果你想回退至上一个版本，也可以用命令 git reset --hard HEAD^ 来实现，因为在 Git 中，使用 HEAD 表示当前版本，那上一个版本就是 HEAD^，上上个版本就是 HEAD^^，当然往上 100 个版本写 100个 ^ 比较容易数不过来，所以写成 HEAD~100。​ 拓展 2：现在，你已经成功回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commitid怎么办？在 Git 中，总是有后悔药可以吃的： 使用 git reflog 查看每次的提交命令。 执行 git reset –hard commitid 好了，就这样我们又乘坐时光机回到了未来。 4 分支管理下图中的 HEAD 可以理解为指向 commit 对象的可变指针。 4.1 分支说明为了避免代码合并经常会出现的冲突，保证随时拥有可发布的版本，使得持续集成和持续部署成为可能，我们采用基于主干的开发方式。分支可包含以下类型： master：主干分支，唯一一个长期存在的分支。所有的开发人员基于此分支进行开发，无特殊情况，提交直接 push 到这个分支上。 release：发布分支，紧急情况下需要进行版本发布的时候，从 master 创建发布分支，进行测试完善，最终修改代码要合并回 master 分支。非特殊情况均通过 master 分支进行发布。 如无特殊情况，原则上禁止以下分支的创建。如想使用可以在本地按如下规范创建： feature/*：特性（功能）分支，用于开发新的功能，不同的功能创建不同的功能分支，功能分支开发完成并自测通过之后，需要合并到 master 分支，之后删除该分支。 bugfix/*：bug 修复分支，用于修复不紧急的 bug，开发完成自测没问题合并进 master 分支后，删除该分支。 hotfix/*：紧急 bug 修复分支，该分支只有在紧急情况下使用，从 release 分支创建，修复完成后，需要合并该分支到 release 分支，同时需要再合并回 master 分支。 4.2 创建与合并分支 说明：使用 Git 命令在本地新建的分支都属于本地分支，push 到远程之后远程仓库上才有此分支。 4.2.1 原理 我们在切换分支，和新建分支的时候，有没有想过，这些操作背后的工作原理是怎样的呢？最大的功臣就是 .git 目录下的 HEAD 引用，它从一个分支跳到另一个分支，虽无声无息，却精准无比。 ​ 下面一块来看一下 Git 是如何通过改变 HEAD 指向来实现创建、合并分支的。​ 一开始的时候，master 分支是一条线，Git 用 master 指向最新的提交，再用 HEAD 指向 master，就能确定当前分支，以及当前分支的提交点： 当我们创建新的分支，例如 dev 时，Git 新建了一个指针叫 dev，指向 master 相同的提交，再把 HEAD 指向 dev，就表示当前分支在 dev 上： 你看，Git创建一个分支很快，因为除了增加一个 dev 指针，改改 HEAD 的指向，工作区的文件都没有任何变化！​ 从现在开始，对工作区的修改和提交就是针对 dev 分支了，比如新提交一次后，dev 指针往前移动一步，而 master 指针不变： 当我们在 dev 上的工作完成了之后，就可以进行分支合并了，把 dev 分支合并到 master 分支上，其实 Git 的做法就是改变一下指针指向，把 master 分支指向 dev 的当前提交，就完成了合并。 完成了分支合并后，就可以把本地的 dev 分支给删除掉了，删除后就又剩下一个 master 分支。 **总结**： 一条时间线就是一个分支，HEAD 指向的那个分支也就是当前分支。 Git 合并分支（Fast-forward 模式）其实很快！就改改指针，工作区内容也不变。 4.2.2 实战 ​首先，我们创建 dev 分支，然后切换到 dev 分支： 12$ git checkout -b devSwitched to a new branch 'dev' git checkout 命令加上 -b 参数表示创建并切换，相当于以下两条命令： 123$ git branch dev$ git checkout devSwitched to branch 'dev' 然后，用 git branch 命令查看当前分支： 123$ git branch* dev master git branch 命令会列出所有分支，当前分支前面会标一个 * 号。然后，我们就可以在 dev 分支上正常提交，比如对 readme.txt 做个修改，加上一行： 1## 这是 dev 分支的内容 把上方内容提交之后，执行 git checkout master 切换回 master 分支，这时候发现刚才提交的内容不见了，这是因为 master 分支此刻的提交点并没有改变： 现在，我们把 dev 分支的工作成果合并到 master 分支上： 12345$ git merge devUpdating d46f35e..b17d20eFast-forward readme.txt | 1 + 1 file changed, 1 insertion(+) git merge 命令用于合并指定分支到当前分支。合并后，再查看 readme.txt 的内容，就可以看到，和 dev 分支的最新提交是完全一样的。​ 拓展：注意到上面的 Fast-forward 信息，Git 告诉我们，这次合并是“快进模式”，也就是直接把 master 指向 dev 的当前提交，所以合并速度非常快。当然，也不是每次合并都能 Fast-forward，我们后面会讲其他方式的合并。合并完成后，就可以放心地删除 dev 分支了： 12$ git branch -d devDeleted branch dev (was b17d20e). 删除后，查看 branch，就只剩下 master 分支了： 12$ git branch* master 因为创建、合并和删除分支非常快，所以 Git 鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在 master 分支上工作效果是一样的，但过程更安全。但是分支合并时很可能要解决冲突，很可能要花时间解决冲突，所以虽然 Git 鼓励你使用分支来完成某个任务，但是要不要新建分支还是需要你视情况而定。​ 4.2.3 拓展内容 4.2.3.1 使用 switch 命令切换分支 刚才我们知道使用 git checkout &lt;branch&gt; 命令可以切换分支，前面讲撤销工作区内容的时候是使用 git checkout -- &lt;file&gt; 。这两种方式很容易让人弄混 git checkout 的用法。所以 Git 新版本就使用 git switch 分支来切换分支，更语义化。 ​ 创建并切换到新的 dev 分支： 1git switch -c 分支名 直接切换到已有分支： 1git switch 分支名 4.2.3.2 git merge 和 git merge –no-ff 的区别 Fast-forward 方式就是当条件允许的时候，Git 直接把 HEAD 指针指向合并分支的头，完成合并。属于“快进方式”，不过这种情况如果删除分支，则会丢失分支信息。因为在这个过程中没有创建 commit。如果要强制禁用 Fast forward模式，Git 就会在 merge 时生成一个新的 commit，这样，从分支历史上就可以看出分支信息。 ​ 下面我们一起看一下使用–no-ff 禁用掉 Fast-forward 模式的 git merge 合并方式：​ 首先，仍然创建并切换 dev 分支： 12$ git switch -c devSwitched to a new branch 'dev' 修改 readme.txt 文件，并提交一个新的 commit： 1234$ git add readme.txt $ git commit -m &quot;add merge&quot;[dev f52c633] add merge 1 file changed, 1 insertion(+) 现在，我们切换回 master： 12$ git switch masterSwitched to branch 'master' 准备合并 dev 分支，请注意 –no-ff 参数，表示禁用 Fast forward： 1234$ git merge --no-ff -m &quot;merge with no-ff&quot; devMerge made by the 'recursive' strategy. readme.txt | 1 + 1 file changed, 1 insertion(+) 因为本次合并要创建一个新的 commit，所以加上 -m 参数，把 commit 描述写进去。合并后，我们用 git log 看看分支历史： 1234567$ git log --graph --pretty=oneline --abbrev-commit* e1e9c68 (HEAD -&gt; master) merge with no-ff|\\ | * f52c633 (dev) add merge|/ * cf810e4 conflict fixed... 可以看到，不使用 Fast forward 模式，merge 后就像这样： 之前使用 Fast forward 模式合并， merge 后是这样子的： 4.2.4 总结 查看分支：git branch 创建分支：git branch 切换分支：git checkout 或者 git switch 创建+切换分支：git checkout -b 或者 git switch -c 合并某分支到当前分支：git merge 或者 git merge –no-ff -m “提交说明” &lt;分支名&gt; 删除已被合并过的分支：git branch -d 删除还未被合并的分支：git branch -D 分支合并时 –no-ff 的作用: 合并分支时，加上–no-ff 参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而 Fast forward 合并就看不出来曾经做过合并。 4.3 解决冲突 前面我们合并分支时 Git 输出的信息有一个 Fast-forward Git 告诉我们，这次合并是“快进模式”，也就是直接把 master 指向 dev 的当前提交。但是合并操作并不总是简单的改变指针指向的这种 “快进模式”的。当 Git 无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。 ​ 先来制造一个冲突的场景新建 feature1 本地分支： 12$ git switch -c feature1Switched to a new branch 'feature1' 修改 readme.txt 最后一行，改为下方文字后执行 git add . 和 git commit 提交。 1Creating a new branch is quick AND simple. 切换到 master 分支并修改 readme.txt 文件最后一样为下方文字并进行提交： 1Creating a new branch is quick &amp; simple. 现在，master 分支和 feature1 分支各自都分别有新的提交，变成了这样： 这种情况下，Git 无法执行“快速合并”，因为 HEAD 指针简单的指向谁都不能完成最终的合并，只能试图把各自的修改合并起来，但这种合并就可能会有冲突。我们切换到 master 分支后把 feature1 分支合并到 master 分支： 1234$ git merge feature1Auto-merging readme.txtCONFLICT (content): Merge conflict in readme.txtAutomatic merge failed; fix conflicts and then commit the result. 这个时候我们就需要手动解决冲突，冲突解决后再进行提交。​ 解决冲突时你要清楚的知道 Current Change 和 Incoming Change 的代码都来自哪里。 最后就是删除掉 feature1 本地临时分支： 12$ git branch -d feature1Deleted branch feature1 (was 14096d0). 拓展：使用 git log --graph --pretty=oneline --abbrev-commit 指令也可以看到分支的合并情况：​ 总结： 当 Git 无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。 解决冲突就是把 Git 合并失败的文件手动编辑为我们希望的内容，再提交。 用 git log –graph 命令可以看到分支合并图。 4.4 分支使用时常遇问题 4.4.1 使用 git stash 解决问题 场景1：当你正在开发一个功能 A 时，刚开发到一半突然接到需要在一小时内修复一个 bug，但是功能 A 的工作预计还要一天才能开发完，当时在 dev 分支开发的一一部分功能 A 功能也还没有提交，并不是你不想提交，而是工作只进行到一半，还没法提交，但是又必须在 1 小时内修复 bug 该怎么办？ 这个时候就可以用到 Git 提供的 stash 功能了：​ 先把当前工作现场“储藏”起来（相当于还原到和服务器上一样的代码，当前工作区是干净状态）。 12$ git stashSaved working directory and index state WIP on dev: f52c633 add merge 现在，用 git status 查看工作区，git 显示工作区是干净的，现在可以放心的修改 bug 了。​ 现在修复 bug，需要把“现在存在一个 bug”改为“bug 修复完成”，然后提交。 1234$ git add readme.txt $ git commit -m &quot;fix bug 101&quot;[issue-101 4c805e2] fix bug 101 1 file changed, 1 insertion(+), 1 deletion(-) bug 修复后，提交代码后使用 git status 发现当前工作区是干净的，刚才的工作现场存到哪去了？用 git stash list命令看看 1git stash list 是时候把存储起来的功能 A 代码恢复回来继续工作了，有两种恢复方式。 一是用 git stash apply 恢复，但是恢复后，stash 内容并不删除，你需要用 git stash drop 来删除。 用 git stash pop，恢复的同时把 stash 内容也删了 12git stash popgit stash apply 再用 git stash list 查看，就看不到任何 stash 内容了：​ 你可以多次 stash，恢复的时候，先用 git stash list 查看，然后恢复指定的 stash，用命令： 1git stash apply &lt;stash的索引值&gt; 删除保存的 stash： 1git stash drop 场景 2：当你往远程仓库 push 代码时，本地版本 &lt; 远程版本时，并且你本地还有未 add 的代码时，Git 就会提示你 The current working tree is not clean。 如果使用的是小乌龟的话它会这样提示： ​ 这个时候你也可以先把本地为提交的代码使用 stash 功能给存储起来，把代码 push 到远程后再使用 git stash pop 或 git stash apply 把存储的代码给恢复。​ 场景 3：平常我们新开发一个功能要建个分支，修改个 bug 也要建个分支，我们经常要对不同分支进行操作，然而原本我是想在 feature 分支开发一个新功能，但是代码却写在了 test 分支上了。 ​ 在 test 分支上执行 git stash，先把代码存储起来。 1git stash 执行 git switch feature 切换到 feature 分支。 1git switch feature 执行 git stash pop 把存储的代码释放出来，并清空 stash 存储的代码。 1git stash pop 4.4.2 使用 cherry-pick 解决问题 场景1：假如我们要在 master 分支上修复 bug，bug 修复好后，我们一想 dev 是开发分支，如果 master 分支上存在 bug，那 dev 分支上肯定也有这样的一个 bug，那么我们要怎么做呢，难道要把修复 bug 的代码一行一行复制过去吗？ ​ 我们有更简单的方法： 我们找到并修复 bug A 提交的 commitid 然后切换到 dev 分支 使用 git cherry-pick commitid 命令去复制提交为 commitid 的那次代码到 dev 分支 ​ 用 git cherry-pick，我们就不需要在 dev 分支上手动再把修改 bug 的过程重复一遍。​ 场景 2：release 分支是项目的预发布环境，平时我们只能把 main 分支上的代码整个全部给合并到 release 分支上，这时候需求问现在需要给客户演示刚才小明同事新增的地图功能，但是现在 main 分支上的代码还没经过测试，不能完全合并过去，呃…… ​ 这个时候也可以使用 git cherry-pick 来实现上诉需求。具体做法可以参考下面步骤：​ 在 main 分支上通过 git log 查看日志，将自己提交的该功能对应的 commitid 值整理出来。 如果本地没有 release 分支，需要先将 release 分支从远程仓库拉到本地仓库(如果本地有 release 分支，并且已与远程对应的 release 分支已关联，无需这一步，直接到下一步) 1git checkout --track origin/release 切换到 release 分支 1git checkout release 在 release 分支上操作：通过 git cherry-pick &lt;commit 对应的 hash 值&gt;将当前 hash 对应提交的代码合并到 release 分支上去。 1git cherry-pick &lt;commitid&gt; 最后将本地合并好的 release 分支 push 到远程的 release 分支上去。 1git push origin release ​ 场景 3：在 main 分支上开发了 A、B、C、D 等功能，现在只需把 main 分支上的 A 功能合并到 release 分支，B、C、D 功能不做合并。 ​ 比如说我这个时候功能 A 的代码提交次数有多次 commitid3~commitid10 都是功能 A 的开发提交，或则是提交次数有多次但是 commitid 不是连续的，中间也有其它人提交。那么这两种情况下如果和功能 A 相关的开发有 10 次提交，那么我们需要执行 10 次 git cherry-pick commitid 吗？​ 答案肯定是没有必要的，下面再来介绍一下有关 git cherry-pick 的拓展知识：拓展：​ 单个 commit 合并 1git cherry-pick commitid 多个分开的 commit 一起合并 1git cherry-pick commit-id1 commit-id3 commit-id6 多个连续的 commit 合并， 将 commitid1到 commitid8 之间的所有提交合并到 release 分支上（不包含第一个 commitid） 1git cherry-pick commitid1..commitid8 每一次合并都可能会产生冲突，如果产生冲突，先解决冲突，然后将代码 commit 到本地仓库即可。​ 注意：测试无误之后，再将合并后的代码push到远程仓库。切记！ 4.4.3 如何丢弃没有被合并过的分支 场景：我们正在开发一个庞大的功能 B，为了不影响主分支上的功能，就新建了一个 feature-vulcan 分支来开发功能 B，功能开发完了，准备合并，接到领导通知说客户改变想法了，不想要此功能了，此功能又涉及到保密工作，所以客户要求要立即销毁。 ​ 所以我们执行 git branch -d feature-vulcan， 123$ git branch -d feature-vulcanerror: The branch 'feature-vulcan' is not fully merged.If you are sure you want to delete it, run 'git branch -D feature-vulcan'. 销毁失败。Git友情提醒，feature-vulcan 分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用大写的 -D 参数。。现在我们强行删除： 12$ git branch -D feature-vulcanDeleted branch feature-vulcan (was 287773e). 终于删除成功！ 4.4.4 本地分支是否到 push 到远程仓库本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？ master 分支是主分支，因此要时刻与远程同步 dev 分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步 bug 分支只用于在本地修复 bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个 bug feature 分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发 总之，就是在 Git 中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定。 4.4.5 总结 修复 bug 时，我们会通过创建新的 bug 分支进行修复，然后合并，最后删除 当手头工作没有完成时，先把工作现场 git stash 一下，然后去修复 bug，修复后，再 git stash pop，回到工作现场 在 master 分支上修复的 bug，想要合并到当前 dev 分支，可以用 git cherry-pick 命令，把 bug提交的修改“复制”到当前分支，避免重复劳动 如果要丢弃一个没有被合并过的分支，可以通过 git branch -D 强行删除 5 git 常用操作 5.1 如何把本地项目推送到远程仓库 场景：想把本地的一个项目文件存到 github 远程仓库。 操作步骤： 123456781. 在本地建一个文件夹，例如 git-study-demo 作为本机工作区。2. 使用 git init 命令来初始化一个 Git 仓库。3. 把项目文件复制到 git-study-demo 目录下。4. 执行 git add . 把所有文件存到暂存区。5. 执行 git status 查看文件状态。6. 执行 git commit -m &quot;初始化项目模板&quot;。把暂存区文件提交到本地库。7. git remote add origin https://github.com/beyond-yang/study-git-demo.git 添加远程版本库8. git push -u origin main 提交到远程仓库 说明：​git push -u origin main 命令中的 -u 参数其实就相当于记录了 push 到远端分支的默认值，这样当下次我们还想要继续 push 的这个远端分支的时候推送命令就可以简写成 git push 即可。 5.2 git log 退出方法使用 git log 命令之后，无法回到主页面，然后只能用暴力的方法解决，直接关闭命令窗口。 其实很简单，输入字母 Q 即可退出。 5.3 删除分支 删除已经合并过的分支： 1git branch -b feature-1 强行删除没有合并过的分支： 1git branch -D feature-1 5.4 在本地创建和远程分支对应的分支1git checkout -b branch-name origin/branch-name 5.5 建立本地分支和远程分支的关联1git branch --set-upstream-to=origin/&lt;branch&gt; dev 5.6 撤销合并操作 场景1：需求说要把综合查询合并到 release 分支，目的是发布到预发布环境，代码合并后发现有 bug，说是要撤销这次的代码合并。 release 分支是远程分支，肯定不能直接对远程分支进行撤销操作，可以在本地进行撤销后再 push 到远程上去： 1git reset HEAD^ 6 个人使用习惯 6.1 查看提交日志查看提交日志喜欢使用界面化工具——例如小乌龟 因为界面化工具不仅可以很方便的看出提交记录，还可以看出每次提交记录都修改了哪些文件，以及文件的修改内容。 6.2 撤销工作区的修改撤销工作区修改喜欢用界面化工具——例如小乌龟 6.3 提交代码提交代码喜欢用界面化工具——例如小乌龟为了防止提交错误的代码或无用的代码，所以每次提交代码时都习惯看一下修改的内容都有哪些，如果发现有一些测试代码如 console.log 或 debugger 之类的。就删除掉后再提交。 7 记录工作中遇到的问题 7.1 git 源换了之后应该怎么处理场景说明：​公司代码库迁移到另外的服务器，个人需要重新更新本地代码库，重新拉代码显然效率低，这时候只需要更换git源就可以轻松搞定前提：本地代码已经更新到最新的 commit，更换源之后拉代码才不会出现冲突。方法一：​ 进入本地仓库路径，进入 .git 目录 修改 config 文件，将 url 换成现在的 git 仓库地址 方法二：第一步查看源地址： 1git remote -v 第二步删除源地址： 1git remote rm origin 第三步添加源地址： 1git remote add origin git@git..gitxxx.com:fei/stic.git 这就行了,然后git pull 拉取代码看有没有问题。最后可以关联起来本地的分支(可忽略)： 1git branch --set-upstream master origin/master 7.2 git 绿色、红色图标不显示问题的解决方案问题：在使用git的过程当中发现，项目文件上没有绿色图标，即便修改文件也没有红色图标显示git绿色图标是指提交成功的，红色图标是指修改后还未提交的。没有图标显示，可是能够正常上传下载，在文件比较多的时候，不知道本身修改了哪些，容易出现错误。解决步骤： win+r,regedit.exe，打开注册表 按照文件的层次关系依次找到blog HKEY_LOCAL_MACHINE\\Software\\Microsoft\\windows\\CurrentVersion\\Explorer;排序修改键名 Max Cached Icons (最大缓存图标) 的值为 2000 （没有这个键，能够新建）资源重启电脑 打开后找到“HKEY_LOCAL_MACHINE–&gt;SOFTWARE–&gt;Microsoft–&gt;Windows–&gt;CurrentVersion–&gt;Explorer–&gt;ShellIconOverlayIdentifiers”这一项。将 Tortoise 相关的项都提到靠前的位置（重命名，在名称以前加几个空格） 重启电脑或重启资源管理器后，绿色和红色图标就显示出来了。","link":"/2022/03/07/Git%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD%E6%80%BB%E7%BB%93/"},{"title":"canvas绘制流光效果","text":"前言最近可能也不是最近（因为22年底时候说过），问这个流光效果能不能不用动图，用代码写出来： （原图找不到了，找了个类似的）当时一看这不就是个位移动画嘛，那不分分钟就搞出来了为啥要问下呢，仔细一打听说，这不一定是直线我让它怎么走就怎么走，比如这样： 我一看心想：坏了这是啥啊，怎么还带拐弯的？？？但是咱已经答应了那就必须给它整出来对吧，还是动画，这不就对味了。话不多说咱就开整。 1.需求分析看上面的 图片我们可以发现要实现这段动画需要的元素有：预备好的路线、一条在路线上移动的线段。路线：既然是不规则的线那普通的盒子边框啊，啥啥的平常的手段肯定是不好或者实现不了了，只能是另辟蹊径了；那都什么好实现这种不规则的路线呢？经过度娘的回答，原来svg和canvas都比较好实现这种线，因为它们都可以根据path路径来绘制出想要的线段。但是根据做好组件后要给平台服务，用svg的话里面可能嵌套的元素可能会太多，平台实现的话可能会很耗时间；用canvas来画的画就最合适不过了，就一个标签，对于谁都省事😀。路线上移动的线段：说是线段，但实现起来其实是用n个小球来拼成的线段，至于为什么，在下文会为你解惑。OK，需求分析结束，准备动手开干~ 2.实现过程2.1绘制运动路线在上面已经提到了canvas可以根据path参数来绘制自定义的线，那么这时就会有两个问题：path参数从哪来呢？用什么办法绘制呢？其实一开始我也不知道，那咋整，抄呗，没啥不好意思的看看人家腾讯，莆田哪个不是呢。通过毅哥给的EasyV的链接，看到人家写好的功能，打开控制台扒它的元素构成，发现原来是svg+canvas组合成的： （这个截图是LeGo的哈，但是都是这么点元素）当时就好奇了，这俩任何一个都能实现功能，为啥要组合到一起呢，完全不明白，别着急，继续看下去你会发现貌似确实不得不这么做。继续上面的问题：看到path元素，啊~原来是用svg这种路径参数来绘制的。第一个问题解决了；第二个问题，用什么办法绘制呢，那既然都是path参数了，那直接搜关键词吧，canvas path；经mdn一查，马上就有结果了， 用大白话说就是用Path2D对象可以创建出canvas所认识的路径，在用stroke给它绘制出来。现在问题都解决了，我们要怎么给它放到一起使用呢？ 我们先获取svg中path元素的d属性中的值，保存到本地。 然后可以把这个参数放到Path2D对象当作参数来创建一个实例出来 用strokeAPI将创建出来的实例绘制到画布上 12345678const canvas = document.getElementById(&quot;canvas&quot;);const ctx = canvas.getContext(&quot;2d&quot;);const pathElement = document.querySelector('path');const path = pathElement.getAttribute('d');const strokePath = new Path2D(path);ctx.stroke(strokePath); 这时我们的路线就出来啦。当然截图里的是给了先的宽度和颜色，这里就不展开说了。 2.2绘制小球这里就来解释下为什么是绘制小球不是线段，其实答案已经在上一句了，线段只能是直线，没有弯曲的形态，canvas也只有lineTo这个api去绘制直的线段。这个思路不同了我们就只能换个想法了，能不能用某个形状去拼成一条线呢？感觉这个可以有噢。那我们就来试一下：绘制小球简单，调用现成api就ok了。 1234567ctx.arc(x, y, r, startAngle, endAngle, anticlockwise?)// x:画布中的横坐标// y：纵坐标// r：圆的半径// startAngle： 圆弧的起始点，x 轴方向开始计算，单位以弧度表示。// endAngle：圆弧的终点，单位以弧度表示。ctx.stroke(strokePath); 调用完之后我们在给它填充个颜色，就可以在画布中看到这个圆了； 2.3让小球在路线上动起来现在我们的路线和小球都已经准备好了，那么接下来最关键的就要给它们组合到一起让小球在上面动起来啦。那首先第一步，怎么才能让小球放到路线里呢，哪怕是随便一个地方都可以。如果我们把路线看成是由若干个点组成的话，那么这里每个点都应该会有自己的坐标。经度娘解惑，我们可以利用svg的getTotalLength和getPointAtLength方法，这应该就是为什么试svg和canvas组合用的原因， getTotalLength的返回值简单来说就是整个路径的总长度； getPointAtLength就是往里面要传一个0-总长度之间的一个浮点数，返回出这个点的x、y坐标； 利用这两个方法就可以把小球放到路线上了，具体方法： 1234// 1.获取路线总长度const pathLength = pathElement.getTotalLength();// 2. 获取路线起点的坐标const {x, y} = pathElement.getPointAtLength(0); x，y坐标也有了，直接调用上面绘制小球的方法，把坐标放上去，小球就出现在路线的起点了。 那么现在最重要的，如何让小球动起来呢？ 我们知道让画动起来的根本原因其实就是静态图片的更新，只不过是更新的太快给我们的感觉就是动起来了而已。canvas动画其实就是利用这一原理进行的。 我们可以一直更新小球的x，y坐标，再不断的擦画布，画画来达到动画的效果。 上面已经说过，用getPointAtLength可以知道每个路线上的点的横纵坐标，那我们可以持续的调用这个方法，只让里面的参数变动，是不是就可以让小球位移了呀；真不错； 那么用什么方法让他一直调用getPointAtLength方法呢，很多同学下意识的会想：这还用问？肯定是定时器啊！没错，定时器确实可以，但是定时器是以固定的时间间隔来执行代码，但是动画一般都是一帧一帧的动，用定时器固然不好算出每一帧的时间，结果就是用setInterval会导致动画卡顿。那我们只能换一种方式了，又经度娘解惑，我发现一直非常契合目前这种需求的api，它就是requestAnimationFramerequestAnimationFrame是一种浏览器提供的API，它允许我们在浏览器的下一次重绘之前执行JavaScript代码。这样可以避免浏览器反复重绘，并提供更流畅的动画效果。当我们使用requestAnimationFrame时，浏览器会在下一次重绘之前调用我们提供的回调函数。回调函数中通常会更新动画的状态，并再次调用requestAnimationFrame以便在下一次重绘时更新动画。requestAnimationFrame的调用频率通常为每秒60次。这意味着我们可以在每次重绘之前更新动画的状态，并确保动画流畅运行，而不会对浏览器的性能造成影响。以下是各个浏览器的兼容问题： 简单来说就是requestAnimationFrame性能好，运行出来的动画流畅，那必须是它了。那问题来了 怎么用它呢？别慌，马上就来答案； 12345678910111213141516let position = 0;function move() { // 首先先要把画布擦干净 ctx.clearRect(0, 0, width, height); // 获取xy坐标 const {x, y} = pathElement.getPointAtLength(position); // 绘制小球 ctx.arc(x, y, r, startAngle, endAngle, anticlockwise?) // 更新位移的长度 position++; // 在这里调用requestAnimationFrame方法，将move函数传进去，就可以实现循环调用了。 requestAnimationFrame(move);} 2.4绘制若干个小球一起运动让若干个小球动起来也很简单，只需要让所有小球在画布外面排列生成好之后，再进入轨道行驶就好了； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/*设置小球起始位置*/ function setCircles() { for (let i = 0; i &lt; 50; i++) { circles.push({ x: -1000, y: -1000, position: -(i + 1), t: 0, }); } }function changePosition() { for (let i of circles) { i.position++; // 获取xy坐标 const { x, y } = pathElement.getPointAtLength(i.position); i.x = x; i.y = y; } }setCircles();function move() { // 首先先要把画布擦干净 ctx.clearRect(0, 0, 1000, 250); changePosition(); ctx.beginPath(); ctx.strokeStyle = &quot;#000&quot;; ctx.stroke(strokePath); ctx.save(); for (let i of circles) { if (i.position &lt; pathLength) { ctx.beginPath(); // ctx.rotate(0.01); // ctx.rect(i.x, i.y, 20, 20); ctx.arc(i.x, i.y, 2, 0, Math.PI * 2); ctx.fillStyle = &quot;red&quot;; ctx.fill(); } } // 在这里调用requestAnimationFrame方法，将move函数传进去，就可以实现循环调用了。 timer = requestAnimationFrame(move); if (position &gt; pathLength) { ctx.rect(x + 1000, y + 250, 20, 20); // ctx.arc(x + 1000, y + 250, 10, 0, Math.PI * 2); ctx.fillStyle = &quot;red&quot;; ctx.fill(); cancelAnimationFrame(timer); } } move(); 先调用setCircles函数,让小球按照顺序生成在画布外面； 在move函数中先调用changePosition函数改变每个小球在轨道上的位置，从而生成坐标； 再遍历存储小球的数组，重新在画布上画出来； 最后调用move函数； 2.5控制小球的运动速度上面虽然我们已经让小球们都动起来了，但是貌似还少了点什么。观察了一会儿可能会发现，我们目前好像还控制不了小球的移动速度，因为现在的move函数是根据屏幕刷新率自动调用的，也就是说这个函数我们不能随意控制调用频率，所以只能想办法换一种方式实现了。那么怎么去控制它们的移动速度呢？ 首先我们要去想这个小球动起来的根本原因是啥，是因为一直在根据它位置的改变-获取坐标-重新画画这三步得来的动画，那不妨想想这三步中，哪一步我们能改造改造，好像也只能是第一步了。 123456789function changePosition() { for (let i of circles) { i.position++; // 获取xy坐标 const { x, y } = pathElement.getPointAtLength(i.position); i.x = x; i.y = y; } } 从上面函数中，可以试着改一下第3行的i.position试试呢，改成+=5会发生什么？没改之前： 改了之后： 好像真的可以改速度了啊那现在匀速的完事了，变速是不是也好说了,在此之前我们要先把初中物理学的匀变速运动公式临时搬出来用一下V=V0+at;看到这个公式，有没有什么想法；V0=初速度， at是在时间间隔t内速度的变化量。所以，我们可以在每次画画的时候让t自增，来达到变速的效果，试一下； 12345678910111213141516171819// 设置初速度let speed = 2;// 设置加速度let jia = 5;// 设置时间间隔let t = 0; function changePosition() { const realSpeed = speed + jia*t; for (let i of circles) { i.position+=realSpeed; // 获取xy坐标 const { x, y } = pathElement.getPointAtLength(i.position); i.x = x; i.y = y; } t+=0.05; } 看下效果： 结束语如果你看到了这里我相信你一定也是一个对动画很感兴趣的同学，上面已经介绍了匀速和匀加速运动的实现思路和简要过程，那么匀减速甚至其他的运动曲线是不是也可以举一反三呢？加油！","link":"/2023/05/22/canvas%E7%BB%98%E5%88%B6%E6%B5%81%E5%85%89%E6%95%88%E6%9E%9C/"},{"title":"bat学习与简单实践","text":"1.概念.bat在 Windows 系统下是一种可执行文件。我们可以在这种文件中输入一系列的 DOS 命令，来自动地执行某些指令。带 .bat、.cmd 后缀的文件是批处理文件。bat 全称：batch 。 批处理，也称批处理脚本，就是对某对象进行批量的处理，通常被认为是一种简化的脚本语言，它应用于 DOS 和 Windows 系统中。批处理文件的扩展名为 bat 或 cmd。比较常见的批处理包含两类：DOS 批处理和 PS 批处理。一些有关于批处理学习的文档地址：http://www.bathome.net/index.php 2.特殊符号2.1.@ 隐藏命令隐藏 @ 后的命令，不让命令在终端输出。 不加“@”： 12echo lalapause&gt;nul 执行结果： 加“@”： 12@echo lalapause&gt;nul 2.2.&amp;&amp;和||判断这两个符号拼接的命令属于组合命令。&amp;拼接的也属于组合命令。&amp;&amp;表示前面的命令成功就执行后面的命令，||反之。 123@echo off@echo;&gt;&gt;D:\\code\\study\\bat\\test.txt&amp;&amp;echo success||echo failedpause&gt;nul 目录：执行结果： 2.3.管道2.3.1 |它能够将它右边命令的输入后果放到它左边的命令里作为输出参数。 123@echo hello1 | find &quot;ll&quot;@echo hello2 | find &quot;aa&quot;@pause&gt;nul 执行结果： 2.3.2 &gt;、&gt;&gt;、&lt; 重定向符DOS 的标准输入输出通常是在标准设备键盘和显示器上进行的，利用重定向可以方便将输入输出改向磁盘文件或者其它设备。 2.3.2.1 &gt;&gt;：将命令发送到文件或者设备（有些命令输出重定向，比如错误信息）原来： 123@echo offtype aa.txt&gt;bb.txtpause&gt;nul 执行结果： 2.3.2.2 &gt;&gt;&gt;&gt;：将命令输出添加到文件结尾，而不删除文件中已有的内容原来： 123@echo offtype aa.txt&gt;&gt;bb.txtpause&gt;nul 执行结果： 2.3.2.3 &lt;&lt;：从文件而不是键盘上获取命令所需的输入 1234@echo offset /p var=&quot;&quot; &lt; aa.txtecho %var%pause&gt;nul 执行结果： 2.4.&amp; 分行符可以把几个命令写在同一行。属于组合命令。 12@echo 123&amp;@echo 456@pause&gt;nul 执行结果： 2.5.^ 分行与转义符2.5.1.分行可以把一个命令写成多行。 12345@echo 1^2^3^4@pause&gt;nul 执行结果： 2.5.1.转义将特殊符号转变为普通字符串。譬如“&amp;”是特殊符号，可以对“&amp;”转义输出： 12@echo ^&amp;@pause&gt;nul 执行结果： 2.6.通配符*: 匹配任意字符，个数不限。?: 只匹配一个任意字符。下文中的“ for 语法介绍”这一章节有例子。 2.7.括号括号，在批处理编程中有特殊的作用，左右括号必须成对使用，括号中可以包括多行命令，这些命令将被看作一个整体，视为一条命令。括号在 for 语句或者 if 语句中常见，用来嵌套使用循环或者条件语句，其实括号也可以单独使用。以下两段代码等价： 1echo 1 &amp; echo 2 &amp; echo 3 等价于： 12345(echo 1echo 2echo 3) 3.变量3.1.类型批处理中的变量基本是万能的，可以储存各种各样的数据。不过用来计算时，会发现变量类型转为了int（整数），数值的极端范围为[-2147483648，2147483647]，如果不拿来计算的话，似乎数万位也是可以的。 3.2.命名变量名可以为数字、字母、甚至汉字的组合。平时尽量不要用命令、汉字取名。不能直接用数字作为变量名。建议直接用非关键字的单词来命名变量。 3.3.扩展先看以下代码： 1234@echo offset var1=1echo var1pause &gt; nul 执行结果： 第3行语句执行时，直接打印了变量名。如果想要引用变量的值，就需要做一些扩展。比如我定义了一个变量等于一个计算结果，我想打印出来这个变量，那么我就需要对这个变量进行扩展。扩展的方式有两种：%变量% 或 !变量!!变量! 这种变量与延迟环境变量扩展有关。如果没开启延迟环境，那么!var!就是一个普通的包含5个字母的字符串。如果开启了延迟环境变量扩展，那么它就是变量的实际值。开启延迟环境变量扩展，语句为“SetLocal EnableDelayedExpansion”。 对比下两种扩展： 12345@echo offset num=10echo %num%set num=100&amp;echo %num%pause&gt;nul 执行结果： 你或许会奇怪，为啥第 4 行语句中 变量 num 已经赋值为 100 了，打印出来还是 10 呢？这跟批处理脚本执行机制有关。批处理脚本是按行执行，执行前会先预处理。第4行语句的 num 在预处理的时候，%num% 被替换成 10 了，实际执行到的语句是：“set num=100&amp;echo 10”，所以打印成了 10。针对这种情况，我们需要开启延迟环境变量扩展，使用 !变量!+SetLocal EnableDelayedExpansion 的一套语法： 123456@echo offSetLocal EnableDelayedExpansionset num=10echo !num!set num=100&amp;echo !num!pause&gt;nul 执行结果： 在 for 循环中要格外注意，因为 for 循环语句的循环体括号中，所有的操作被看成是同一行。所以经常会用到延迟环境变量扩展。 其他说明 可以直接用 %time% 获取到当前系统时间。 123@echo offecho %time%pause&gt;nul 执行结果： 3.4.字符串的处理假设变量 str 值为“1234567890”： 3.4.1.截取字符串 格式 含义 结果 %str% 获取整个字符串的值 1234567890 %str:~0,5% 从索引值0开始，截取5个字符 12345 %str:~1,5% 从索引值1开始，截取5个字符 12345 %str:~-5% 从字符串末尾开始，截取5个字符 67890 %str:~5,-2% 从索引值5开始，截取到倒数下标为2个字符 678 3.4.2.替换字符串语法：%变量:子字符串=被替换的字符串% 1234@echo offset str=1234567890echo %str:7890=54321%pause&gt;nul 执行结果： 3.4.3.合并字符串语法：%变量1%%变量2% 123456@echo offset str1=aset str2=bset str3=str3=%str1%%str2%echo %str3%pause&gt;nul 执行结果： 3.4.4.字符串修饰符设变量为i： 修饰符 含义 ~i 删除所有引号（”） %~fi 将 %Ii扩充到一个完全合格的路径名 %~di 仅将 %i 扩充到一个驱动器号 %~pi 仅将 %i 扩充到一个路径 %~ni 仅将 %i 扩充到一个文件名 %~xi 仅将 %i 扩充到一个文件扩展名 %~si 扩充的路径只含有短名 %~ai 将 %i 扩充到文件的文件属性 %~ti 将 %i 扩充到文件的日期/时间 %~zi 将 %i 扩充到文件的大小 %~$PATH:i 查找列在路径环境变量的目录，并将 %i 扩充到找到的第一个完全合格的名称。如果环境变量名未被定义，或者没有找到文件，此组合键会扩到空字符串 也可以组合地使用多个修饰符，比如想要将 %i 扩充到一个驱动器号和路径，可以写成 %~dpi 。 4.命令以下命令大写小写都行。命令执行优先级：管道命令 &gt; 重定向命令 &gt; 组合命令 echo用途：在命令行编辑器中打印一些文字。语法：echo [on | off]echo [message]echo [%变量名%]执行 echo on 后，后来执行的指令不会把命令回显出来，直接打印文字。反之 echo off 会把命令显示出来，并打印文字。echo xxx 就会直接打印 xxx。执行代码感受下： 1234567echo offecho aaaecho bbbecho onecho aaaecho bbbpause 执行结果： echo [%变量名%]在介绍 set 命令的时候会有示例。 其他用法 换行 1echo; 输出空行 echo.输出一个空行，这里的.和 echo 之间不要有空格，其实除了echo.有这个效果，echo+、echo-、echo*、echo，都可以。3. 输出 off、on 关键字 1234@echo offecho;offecho;onpause &gt; nul pause用途：暂停让用户按下任意键继续。语法： pause pause &gt; nul不展示“请按任意键继续…”的文本，用户按下任意键结束。 cls清屏。 rem用途：在批处理文件或 CONFIG.SYS 里加上注解或说明。注解和说明不会被打印出来。 语法：rem [comment]给下一行代码添加注释的示例： 1234echo offrem 打印文字echo lala~pause set用途：1、给变量赋值；2、等待用户输入数据(开关/P)； 1、给变量赋值语法：set 变量名 =xxx变量名相同时，后边声明的会覆盖前边声明的。示例： 1234@echo offset str= lalala~ 打断点echo %str%pause 里注意了，变量赋值的时候，变量与等号之间不能有空格，不然会赋值失败。等号后边的所有内容都会赋给变量。赋值时输入中文会乱码。遇到回车相当于语句结束。以上代码的执行结果为： 运算在第3小节介绍。给变量赋值还能撤销（目前还不知道什么情况下要撤销）给变量赋值直接让等号后边不跟任何内容就行了： 123456@echo offset str=yydsecho %str%set str=echo %str%pause 2、等待用户输入数据语法：set /p 变量名=xxx 12345@echo offset /p name=input your name:set /p age=input your age:echo %name% is %age% years old.pause 3、计算语法：set /a 变量名=表达式 注意：批处理能处理的数字必须是整数，不能是小数。可处理的数据范围：[-2147483648，2147483647]。 1234@echo offset /a num=(12*2)+(13*4)echo (12x2)+(13x4)=%num%pause 我们来看一个获取平方数的例子： 1234567@echo offecho ===Get Square===set /p num=input number:echo you inputed number is %num%.set /a num*=numecho result is %num%.pause set /a支持多行表达式并列，比如： 1set /a num1=1+1,num2=1+2,num3=1+3 若是想计算小数，我们需要将小数扩大到10的 n 倍，让其成为整数计算，在使用时可以用字符串截取、字符串拼接的语法转成小数。若是计算的数值想保留到几位小数，我们以除法为例，举了一个四舍五入的例子： 12345678910111213141516171819202122232425262728293031323334chcp 65001@echo offtitle 被除数的数字位和精确位数和不能大于10位setlocal enabledelayedexpansionset 零常数=100000000000000000000000000000000:整数clsset /p 被除数=被除数:set /p 除数=除数:set /p 精确位数=精确到多少小数点(遇用于小数时):set /a 解=!被除数!/!除数!set /a x=!解!*!除数!clsif !x!==!被除数! (echo !被除数!/!除数!=!解!pause&gt;nulgoto 整数):小数set/a 精确位数加一 =%精确位数%+1set 数点=!零常数:~-%精确位数加一%!set x=!被除数!!数点!set /a 小解=!x!/!除数!set 最后一位=!小解:~-1!echo !最后一位!rem 四舍五入if !最后一位! gtr 5 (set /a 小解=!x!/!除数!+1)set 小数=!小解:~-%精确位数%!set 解=!解!.!小数!echo !被除数!/!除数!=!解!pause&gt;nulgoto 整数 4.显示当前已定义变量以下示例可直接输出当前所有的系统变量： 12@set@pause&gt;nul 在@set 后边还可加上过滤条件（不区分大小写）： 12@set al@pause&gt;nul 上例执行结果： if语法：if 表达式 (执行语句 ) else if 表达式 ( 执行语句) else (执行语句) 1.比较字符串语法：if %变量名% == 字符串 (执行语句)if “%变量名%” == “字符串” (执行语句) 12345678910@echo offset /p name=please input string:if %name% == aa (echo aaa) else if %name% == bb (echo bb) else (echo emmm...)pause&gt;nul 如果想判断是否输入了回车，需要加上双引号来判断（if “%name%” == “aa”），否则直接输入回车就会关闭命令行。 2.比较数字语法：if %变量名% 比较运算符 %变量名% (执行语句)需要了解下比较运算符： 比较运算符EQU | equ - 等于NEQ | neq - 不等于LSS | lss - 小于LEQ | leq - 小于或等于GTR | gtr - 大于GEQ | geq - 大于或等于 比较数字: 123456789101112131415161718192021@echo offset /p num1=please input num1:set /p num2=please input num2:rem 若num1 &gt; num2if %num1% gtr %num2% (echo num1 bigger than num2rem 若num1 &lt; num2) else if %num1% lss %num2% (echo num1 less than num2rem 若num1 &lt; num2) else (echo num1 equal num2)rem 若num1 !== num2 not 为可选值，表示非if not %num1% equ %num2% (echo 666)pause&gt;nul 3.检测文件(夹)是否存在该命令可用来判断文件是否存在，并执行相关的命令。语法见示例：语法1：if exist 文件名 文件存在执行的命令if not exist 文件不存在执行的命令示例： 1234@echo offif exist a.txt type a.txtif not exist a.txt echo a.txt isn't exist.pause &gt; nul type 是 DOS 命令。type 文件名，表示将一个文件的内容输出到命令行中。详细介绍：https://baike.baidu.com/item/type/61894579?fr=ge_ala 语法2：if exist 命令传参 文件存在执行的命令if not exist 文件不存在执行的命令DOS 允许传递 9 个批参数信息给批处理文件，分别为 %1~%9（%0表示命令本身）。%1表示的是第一个传参，%2 表示的是第二个传参，以此类推。 下例中，我们在当前目录中新建了c.txt，c.txt的内容：。然后在当前目录创建 if-exist.bat，添加以下代码块的内容: 1234@echo offif exist %1 type %1if not exist %1 echo %1 isn't exist.pause &gt; nul 然后在当前目录打开命令行，输入if-exist c.txt，“c.txt”就是 if-exist.bat 实参 %1 的值了。运行结果： 4.检测变量是否被定义语法：if defined 变量名 (执行语句)检测变量是否被定义: 12345678@echo offset aa=aif defined aa (echo aa has defined.) else (echo aa haven't defined.)pause&gt;nul 5.判断返回值(errorlevel)语法：批处理命令if errorlevel 返回值 (执行语句)用来测试它的上一个 DOS命令 的返回值。注意只是上一个命令的返回值，而且返回值必须依照从大到小次序顺序判断。注：这里的执行语句最好使用 goto 语句，不然的话会执行剩下的 if errorlevel语句。这里可以看一个示例： 1234567@echo offcopy D:\\code\\study\\bat\\c.txt D:\\code\\study\\bat\\bif errorlevel 1 echo failedif errorlevel 0 echo successif errorlevel -1 echo 1111if errorlevel -2 echo 222pause &gt; nul 若 c.txt 不存在，执行结果： 若 c.txt 存在，执行结果： 执行到第4条语句后，语句4、5、6因为上一条语句返回值是1，所以也都挨个触发了。 我们来看正确的示例： 12345678910111213@echo offcopy D:\\code\\study\\bat\\c.txt D:\\code\\study\\bat\\bif errorlevel 1 echo goto errorif errorlevel 0 echo goto success:errorecho errorpause &gt; nulexit:successecho successpause &gt; nulexit 若 c.txt 存在，执行结果： 若 c.txt 不存在，执行结果： 如果不想展示命令执行输出的结果（如上图的），可以在 copy 语句后加上 &gt;nul 2&gt;nul： 1copy D:\\code\\study\\bat\\c.txt D:\\code\\study\\bat &gt;nul 2&gt;nul copy 是 DOS命令，作用是拷贝文件。格式：copy [源目录或文件] [目的目录或文件] 注意：在该示例中，if errorlevel 1 表示命令执行结果失败的判断，if errorlevel 0 表示命令执行结果成功的判断。这两行命令不能调换位置。 一些常用 DOS 命令的返回值： 命令名 返回值 含义 xcopy 0 成功拷贝文件 xcopy 1 未找到拷贝文件 xcopy 2 用户通过ctrl-c中止拷贝操作 xcopy 4 预置错误阻止文件拷贝操作 xcopy 5 拷贝过程中写盘错误 format 0 格式化成功 format 3 用户通过ctrl-c中止格式化处理 format 4 因致命的处理错误使格式化中止 format 5 在提示“proceed with format（y/n）?”下用户键入n结束 backup 0 备份成功 backup 1 未找到备份文件 backup 2 文件共享冲突阻止备份完成 backup 3 用户用ctrl-c中止备份 backup 4 由于致命的错误使备份操作中止 %errorlevel%能获取到上一条语句的返回值。 1234@echo offcopy D:\\code\\study\\bat\\test.txt D:\\code\\study\\bat\\becho %errorLevel%pause&gt;nul 执行结果： goto语法：goto labellabel为标签名。标签必须独占一行，并以冒号打头。例：:label1未定义的:eof会退出脚本文件。 1234567891011121314@echo offset /p pw=please input string:if &quot;%pw%&quot;==&quot;lala&quot; goto yesif &quot;%pw%&quot;==&quot;a&quot; goto errorgoto :eofrem 未定义的:eof会退出脚本文件:errorecho errorpause&gt;nul:yesecho turepause&gt;nul 输入“lala”，会打印：输入a，会打印：输入ccc，会关闭窗口。 注意：多个标签的情况下，注意是否需要在标签间添加退出语句来终止脚本继续向下执行，若不往下进行则要在最后加上 exit 命令退出当前标签。 加上exit: 12345678910111213141516@echo offset /p pw=please input string:if &quot;%pw%&quot;==&quot;lala&quot; goto yesif &quot;%pw%&quot;==&quot;a&quot; goto errorgoto :eofrem 未定义的:eof会退出脚本文件:errorecho errorpause&gt;nulexit:yesecho turepause&gt;nulexit 输入a，会打印： for说明：下文语法中的 set 表示一个集合，每个元素以空格分隔，如(a b)。do 后面的语句会被执行。语法1：for %variable in (set) do command [command-parameters]%variable 指定一个单一字母可替换的参数。(set) 指定一个或一组文件。可以使用通配符。command 指定对每个文件执行的命令。command-parameters为特定命令指定参数或命令行开关。 注: %%i为for输出专用变量格式，其中i可以是a-z、A-Z、0-9和一些符号什么的(如! # 不过不建议使用)，在cmd中只能用一个%。 123@echo offfor %%i in (a b c) do echo %%ipause&gt;nul 打印结果：展示当前目录下所有带.txt后缀的文件名： 123@echo offfor %%i in (*.txt) do echo %%ipause&gt;nul 打印结果： 语法2：for /l %variable in (start,step,end) do command [command-parameters] 该集表示以增量形式从开始到结束的一个数字序列。 123@echo offfor /l %%i in (1,2,10) do echo %%ipause&gt;nul 打印结果： 语法3：for /r [[drive:]path] %variable in (set) do command [command-parameters]检查以 [drive:]path 为根的目录树，指向每个目录中的 for 语句。如果在 /r 后没有指定目录，则使用当前目录。如果集仅为一个单点 (.) 字符，则枚举该目录树。 123@echo offfor /r D:\\code\\study\\bat %%i in (*) do echo %%ipause&gt;nul 打印结果： 语法4：for /d [[drive:]path] %variable in (set) do command [command-parameters]如果集中包含通配符，则指定与目录名匹配，而不与文件名匹配。 123@echo offfor /d %%i in (*) do echo %%ipause&gt;nul 执行结果： 语法5：for /f [“options”] %variable in (文件名|”字符串”|’命令名’) do command [command-parame]按行输出。test.txt 写入了两行内容，但是只能遍历出空格之前的内容。 123456@echo offecho aa bb cc&gt;&gt;test.txtecho dd ee&gt;&gt;test.txtrem 以上代码在当前文件夹下生成了一个test.txt,打开看看?for /f %%i in (test.txt) do echo %%ipause&gt;null test.txt：打印结果： “options”可以有以下参数： 参数 含义 “token=1” 取当前行的第1个元素（默认情况下，一行字符串按空格分隔成集合） “token=*” 取当前行的所有元素 “delims=*” 设置元素的分隔符为任意字符，即会获取到整行字符串 “skip=1” 忽略文本的前1行，若文本中一行内容都没有则什么也不输出 “eol=a” 忽略以a开头的行 在下例中， aa bb cc 可以看做一个集合，元素为aa、bb、cc，以空格分隔。可以理解为：遍历某个文件中的每一行，一次遍历一行，取到集合中的第几个元素%%i，进行操作。 123456789@echo offecho aa bb cc&gt;&gt;test.txtecho dd ee&gt;&gt;test.txtfor /f &quot;tokens=1&quot; %%i in (test.txt) do echo %%ipause&gt;nulfor /f &quot;tokens=2&quot; %%i in (test.txt) do echo %%ipause&gt;nulfor /f &quot;tokens=3&quot; %%i in (test.txt) do echo %%ipause&gt;nul test.txt：打印结果：第一次循环结束打印：，回车第二次循环结束打印：，回车第三次循环结束打印： 还有很多可扩展变量的修饰符。比如对循环遍历一组目录路径，想在每一次遍历时取到路径中的驱动器号，假设循环中定义的变量为 %i，则可以写成 %~di 。 123@echo offfor /f %%i in (a.txt) do echo %%~dipause&gt;nul a.txt 内容：执行结果：关于字符串修饰符可见这一章节：3.4.4 字符串修饰符 startstart 命令可以在命令行下运行一个程序，可以打开盘符，文件，文件夹，网址，程序。该外部程序在新的窗口中运行，批处理程序继续往下执行，不理会外部程序执行的情况），如果直接运行外部程序则必须等待外部程序完成后才可以继续执行剩余的指令。 打开网址: 123@echo offstart www.baidu.compause&gt;nul 打开文件: 123@echo offstart &quot;&quot; &quot;D:\\software\\Robo 3T 1.4.1\\robo3t.exe&quot;pause&gt;nul 注: 路径中有空格时，不仅路径要加双引号，路径之前也要加（路径之前的空双引号表示空标题) 打开文件夹： 123@echo offstart &quot;&quot; &quot;D:\\software\\Robo 3T 1.4.1&quot;pause&gt;nul 打开盘符： 123@echo offstart d:pause&gt;nul start cmd.exe启动参数说明用的比较多的：1、start cmd /k “命令”表示启动一个CMD且不关闭cmd2、start cmd /c “命令”表示启动一个CMD且关闭cmd更多启动参数详见：https://blog.csdn.net/chenghui2006/article/details/108363769 5.一些简单实践5.1 开机自启动项目创建一个start.bat，内容如下： 12345:: 运行mapgo5.0项目d:cd &quot;D:\\code\\company-silu\\infrastructure\\map-go\\map-go2.0&quot;npm run serve win+r 打开运行，输入 shell:startup，打开开机自执行脚本的目录，将 start.bat 放到目录下。这样，你每天一开机，去打个水上个厕所的功夫，你的前端项目就自己启动起来啦~是不是很实用？ 5.2 快速启动所有主应用微应用启动一堆主应用微应用太费事？写一个批处理命令文件，只需双击两下，就能搞定一切~ 123@echo offstart cmd /k &quot;d: &amp;&amp; cd D:\\code\\company-silu\\pwxkz-manage-servie-production\\baseapp &amp;&amp; npm run serve&quot;start cmd /k &quot;d: &amp;&amp; cd D:\\code\\company-silu\\pwxkz-manage-servie-production\\microapp &amp;&amp; npm run serve&quot; 6.其他6.1.自动运行批处理文件 AUTOEXEC.BAT 6.2.让批处理脚本支持汉字默认情况下，cmd.exe 的编码是 GBK 编码：。要想显示中文汉字不乱吗，需要将编码改成 UTF-8编码的（65001）。我们可以在.bat文件首行加上“chcp 65001”，就能正常使用汉字啦。 123chcp 65001echo test中文pause&gt;nul 执行结果：","link":"/2023/08/05/bat%E5%AD%A6%E4%B9%A0%E4%B8%8E%E7%AE%80%E5%8D%95%E5%AE%9E%E8%B7%B5/"}],"tags":[{"name":"Blog","slug":"Blog","link":"/tags/Blog/"},{"name":"HTTP","slug":"HTTP","link":"/tags/HTTP/"},{"name":"TypeScript","slug":"TypeScript","link":"/tags/TypeScript/"},{"name":"Module","slug":"Module","link":"/tags/Module/"},{"name":"Rap2","slug":"Rap2","link":"/tags/Rap2/"},{"name":"Mock","slug":"Mock","link":"/tags/Mock/"},{"name":"PWA","slug":"PWA","link":"/tags/PWA/"},{"name":"Vue.js2","slug":"Vue-js2","link":"/tags/Vue-js2/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"cordova","slug":"cordova","link":"/tags/cordova/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"Vue.js3","slug":"Vue-js3","link":"/tags/Vue-js3/"},{"name":"if-else","slug":"if-else","link":"/tags/if-else/"},{"name":"优化","slug":"优化","link":"/tags/%E4%BC%98%E5%8C%96/"},{"name":"原型链","slug":"原型链","link":"/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"},{"name":"HTTP&#x2F;HTTPS","slug":"HTTP-HTTPS","link":"/tags/HTTP-HTTPS/"},{"name":"Nest.js","slug":"Nest-js","link":"/tags/Nest-js/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"},{"name":"ESLint","slug":"ESLint","link":"/tags/ESLint/"},{"name":"Babel","slug":"Babel","link":"/tags/Babel/"},{"name":"Browserslist","slug":"Browserslist","link":"/tags/Browserslist/"},{"name":"概念","slug":"概念","link":"/tags/%E6%A6%82%E5%BF%B5/"},{"name":"CORS","slug":"CORS","link":"/tags/CORS/"},{"name":"Storybook","slug":"Storybook","link":"/tags/Storybook/"},{"name":"中间件","slug":"中间件","link":"/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"Promise, async&#x2F;await, event-loop","slug":"Promise-async-await-event-loop","link":"/tags/Promise-async-await-event-loop/"},{"name":"HTTPS","slug":"HTTPS","link":"/tags/HTTPS/"},{"name":"性能优化","slug":"性能优化","link":"/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"正则表达式","slug":"正则表达式","link":"/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"微前端","slug":"微前端","link":"/tags/%E5%BE%AE%E5%89%8D%E7%AB%AF/"},{"name":"OpenSSH","slug":"OpenSSH","link":"/tags/OpenSSH/"},{"name":"Gitlab CI","slug":"Gitlab-CI","link":"/tags/Gitlab-CI/"},{"name":"其他","slug":"其他","link":"/tags/%E5%85%B6%E4%BB%96/"},{"name":"单元测试","slug":"单元测试","link":"/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"},{"name":"WebRTC","slug":"WebRTC","link":"/tags/WebRTC/"},{"name":"质量控制","slug":"质量控制","link":"/tags/%E8%B4%A8%E9%87%8F%E6%8E%A7%E5%88%B6/"},{"name":"SonarQube","slug":"SonarQube","link":"/tags/SonarQube/"},{"name":"Vue3","slug":"Vue3","link":"/tags/Vue3/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"常用功能","slug":"常用功能","link":"/tags/%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/"},{"name":"canvas","slug":"canvas","link":"/tags/canvas/"},{"name":"标签","slug":"标签","link":"/tags/%E6%A0%87%E7%AD%BE/"}],"categories":[{"name":"周边","slug":"周边","link":"/categories/%E5%91%A8%E8%BE%B9/"},{"name":"协议","slug":"协议","link":"/categories/%E5%8D%8F%E8%AE%AE/"},{"name":"TypeScript","slug":"TypeScript","link":"/categories/TypeScript/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"博客","slug":"周边/博客","link":"/categories/%E5%91%A8%E8%BE%B9/%E5%8D%9A%E5%AE%A2/"},{"name":"开发周边","slug":"开发周边","link":"/categories/%E5%BC%80%E5%8F%91%E5%91%A8%E8%BE%B9/"},{"name":"跨平台","slug":"跨平台","link":"/categories/%E8%B7%A8%E5%B9%B3%E5%8F%B0/"},{"name":"HTTP","slug":"协议/HTTP","link":"/categories/%E5%8D%8F%E8%AE%AE/HTTP/"},{"name":"JS框架","slug":"JS框架","link":"/categories/JS%E6%A1%86%E6%9E%B6/"},{"name":"CSS","slug":"CSS","link":"/categories/CSS/"},{"name":"编码规范","slug":"TypeScript/编码规范","link":"/categories/TypeScript/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"},{"name":"HTML","slug":"HTML","link":"/categories/HTML/"},{"name":"安卓","slug":"安卓","link":"/categories/%E5%AE%89%E5%8D%93/"},{"name":"模块化","slug":"JavaScript/模块化","link":"/categories/JavaScript/%E6%A8%A1%E5%9D%97%E5%8C%96/"},{"name":"Rap2","slug":"开发周边/Rap2","link":"/categories/%E5%BC%80%E5%8F%91%E5%91%A8%E8%BE%B9/Rap2/"},{"name":"PWA","slug":"跨平台/PWA","link":"/categories/%E8%B7%A8%E5%B9%B3%E5%8F%B0/PWA/"},{"name":"Vue.js2","slug":"JS框架/Vue-js2","link":"/categories/JS%E6%A1%86%E6%9E%B6/Vue-js2/"},{"name":"编码规范","slug":"CSS/编码规范","link":"/categories/CSS/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"},{"name":"编码规范","slug":"HTML/编码规范","link":"/categories/HTML/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"},{"name":"cordova","slug":"安卓/cordova","link":"/categories/%E5%AE%89%E5%8D%93/cordova/"},{"name":"新特性","slug":"JavaScript/新特性","link":"/categories/JavaScript/%E6%96%B0%E7%89%B9%E6%80%A7/"},{"name":"Vue.js3","slug":"JS框架/Vue-js3","link":"/categories/JS%E6%A1%86%E6%9E%B6/Vue-js3/"},{"name":"优化if-else","slug":"JavaScript/优化if-else","link":"/categories/JavaScript/%E4%BC%98%E5%8C%96if-else/"},{"name":"编程范式","slug":"JavaScript/编程范式","link":"/categories/JavaScript/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/"},{"name":"原型链","slug":"JavaScript/原型链","link":"/categories/JavaScript/%E5%8E%9F%E5%9E%8B%E9%93%BE/"},{"name":"Nest.js","slug":"Nest-js","link":"/categories/Nest-js/"},{"name":"Node.js","slug":"Node-js","link":"/categories/Node-js/"},{"name":"基础建设","slug":"基础建设","link":"/categories/%E5%9F%BA%E7%A1%80%E5%BB%BA%E8%AE%BE/"},{"name":"概念","slug":"概念","link":"/categories/%E6%A6%82%E5%BF%B5/"},{"name":"安全","slug":"安全","link":"/categories/%E5%AE%89%E5%85%A8/"},{"name":"项目搭建","slug":"基础建设/项目搭建","link":"/categories/%E5%9F%BA%E7%A1%80%E5%BB%BA%E8%AE%BE/%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"},{"name":"基础","slug":"概念/基础","link":"/categories/%E6%A6%82%E5%BF%B5/%E5%9F%BA%E7%A1%80/"},{"name":"跨域","slug":"安全/跨域","link":"/categories/%E5%AE%89%E5%85%A8/%E8%B7%A8%E5%9F%9F/"},{"name":"组件库","slug":"基础建设/组件库","link":"/categories/%E5%9F%BA%E7%A1%80%E5%BB%BA%E8%AE%BE/%E7%BB%84%E4%BB%B6%E5%BA%93/"},{"name":"变量的基本用法","slug":"CSS/变量的基本用法","link":"/categories/CSS/%E5%8F%98%E9%87%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"},{"name":"Promise","slug":"Promise","link":"/categories/Promise/"},{"name":"async&#x2F;await","slug":"Promise/async-await","link":"/categories/Promise/async-await/"},{"name":"event-loop","slug":"Promise/async-await/event-loop","link":"/categories/Promise/async-await/event-loop/"},{"name":"性能","slug":"性能","link":"/categories/%E6%80%A7%E8%83%BD/"},{"name":"正则表达式","slug":"JavaScript/正则表达式","link":"/categories/JavaScript/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"微前端","slug":"微前端","link":"/categories/%E5%BE%AE%E5%89%8D%E7%AB%AF/"},{"name":"性能优化","slug":"性能/性能优化","link":"/categories/%E6%80%A7%E8%83%BD/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"工具","slug":"开发周边/工具","link":"/categories/%E5%BC%80%E5%8F%91%E5%91%A8%E8%BE%B9/%E5%B7%A5%E5%85%B7/"},{"name":"持续集成&amp;交付&amp;部署","slug":"持续集成-交付-部署","link":"/categories/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90-%E4%BA%A4%E4%BB%98-%E9%83%A8%E7%BD%B2/"},{"name":"其他","slug":"其他","link":"/categories/%E5%85%B6%E4%BB%96/"},{"name":"qiankun","slug":"微前端/qiankun","link":"/categories/%E5%BE%AE%E5%89%8D%E7%AB%AF/qiankun/"},{"name":"WebRTC","slug":"JavaScript/WebRTC","link":"/categories/JavaScript/WebRTC/"},{"name":"Vue3","slug":"Vue3","link":"/categories/Vue3/"},{"name":"模块化","slug":"模块化","link":"/categories/%E6%A8%A1%E5%9D%97%E5%8C%96/"},{"name":"Gitlab","slug":"持续集成-交付-部署/Gitlab","link":"/categories/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90-%E4%BA%A4%E4%BB%98-%E9%83%A8%E7%BD%B2/Gitlab/"},{"name":"Git","slug":"开发周边/Git","link":"/categories/%E5%BC%80%E5%8F%91%E5%91%A8%E8%BE%B9/Git/"},{"name":"工具使用","slug":"工具使用","link":"/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"},{"name":"有意思的动画","slug":"有意思的动画","link":"/categories/%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E5%8A%A8%E7%94%BB/"},{"name":"单元测试","slug":"其他/单元测试","link":"/categories/%E5%85%B6%E4%BB%96/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"},{"name":"质量控制","slug":"持续集成-交付-部署/质量控制","link":"/categories/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90-%E4%BA%A4%E4%BB%98-%E9%83%A8%E7%BD%B2/%E8%B4%A8%E9%87%8F%E6%8E%A7%E5%88%B6/"},{"name":"Vue3入门","slug":"Vue3/Vue3入门","link":"/categories/Vue3/Vue3%E5%85%A5%E9%97%A8/"},{"name":"canvas","slug":"有意思的动画/canvas","link":"/categories/%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E5%8A%A8%E7%94%BB/canvas/"},{"name":"bat","slug":"开发周边/bat","link":"/categories/%E5%BC%80%E5%8F%91%E5%91%A8%E8%BE%B9/bat/"}]}