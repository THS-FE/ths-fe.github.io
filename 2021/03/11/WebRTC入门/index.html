<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>WebRTC入门 - 思路大前端团队</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#f7f7f7"><meta name="application-name" content="思路大前端"><meta name="msapplication-TileImage" content="/img/favicon.ico"><meta name="msapplication-TileColor" content="#f7f7f7"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="思路大前端"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description="本文介绍了WebRTC涉及的协议、相关服务器搭建、部分WebRTC核心API，最后包含一个WenRTC音视频通话的小实例开发过程。"><meta property="og:type" content="blog"><meta property="og:title" content="WebRTC入门"><meta property="og:url" content="https://ths-fe.github.io/2021/03/11/WebRTC%E5%85%A5%E9%97%A8/"><meta property="og:site_name" content="思路大前端团队"><meta property="og:description" content="本文介绍了WebRTC涉及的协议、相关服务器搭建、部分WebRTC核心API，最后包含一个WenRTC音视频通话的小实例开发过程。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://ths-fe.github.io/2021/03/11/WebRTC%E5%85%A5%E9%97%A8/cover.jpg"><meta property="article:published_time" content="2021-03-11T14:38:58.000Z"><meta property="article:modified_time" content="2021-03-13T09:30:58.000Z"><meta property="article:author" content="吴俊"><meta property="article:tag" content="JavaScript"><meta property="article:tag" content="WebRTC"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/2021/03/11/WebRTC%E5%85%A5%E9%97%A8/cover.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://ths-fe.github.io/2021/03/11/WebRTC%E5%85%A5%E9%97%A8/"},"headline":"思路大前端团队","image":["https://ths-fe.github.io/2021/03/11/WebRTC%E5%85%A5%E9%97%A8/cover.jpg"],"datePublished":"2021-03-11T14:38:58.000Z","dateModified":"2021-03-13T09:30:58.000Z","author":{"@type":"Person","name":"吴俊"},"description":"本文介绍了WebRTC涉及的协议、相关服务器搭建、部分WebRTC核心API，最后包含一个WenRTC音视频通话的小实例开发过程。"}</script><link rel="canonical" href="https://ths-fe.github.io/2021/03/11/WebRTC%E5%85%A5%E9%97%A8/"><link rel="icon" href="/img/favicon.ico"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.13.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/monokai.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?fd8cc3421abec7b8f4e6bc337e25c7d1";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=UA-72716512-3" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'UA-72716512-3');</script><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><script data-ad-client="ca-pub-6826040978803389" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script><meta name="generator" content="Hexo 5.2.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/ths.png" alt="思路大前端团队" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">博客</a><a class="navbar-item" href="/fe">大前端技术体系</a><a class="navbar-item" href="/gis">GIS技术体系</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/about">关于我们</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/2021/03/11/WebRTC%E5%85%A5%E9%97%A8/cover.jpg" alt="WebRTC入门"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-03-11T14:38:58.000Z" title="2021-03-11T14:38:58.000Z">2021-03-11</time>发表</span><span class="level-item"><time dateTime="2021-03-13T09:30:58.000Z" title="2021-03-13T09:30:58.000Z">2021-03-13</time>更新</span><span class="level-item"> 吴俊 </span><span class="level-item"><a class="link-muted" href="/categories/JavaScript/">JavaScript</a><span> / </span><a class="link-muted" href="/categories/JavaScript/WebRTC/">WebRTC</a></span><span class="level-item">2 小时读完 (大约15230个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">WebRTC入门</h1><div class="content"><h1 id="一、协议"><a href="#一、协议" class="headerlink" title="一、协议"></a>一、协议</h1><h2 id="1-1-P2P-通信原理与实现"><a href="#1-1-P2P-通信原理与实现" class="headerlink" title="1.1 P2P 通信原理与实现"></a>1.1 P2P 通信原理与实现</h2><h3 id="1-1-1-基本术语"><a href="#1-1-1-基本术语" class="headerlink" title="1.1.1 基本术语"></a>1.1.1 基本术语</h3><p><strong>防火墙（Firewall）</strong>： 防火墙主要限制内网和公网的通讯，通常丢弃未经许可的数据包。防火墙会检测(但是不修改)试图进入内网数据包的 IP 地址和 TCP/UDP 端口信息。</p>
<p><strong>网络地址转换协议</strong><a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/NAT">（NAT）</a>： 用来给你的（私网）设备映射一个公网的 IP 地址的协议。一般情况下，路由器的 WAN 口有一个公网 IP，所有连接这个路由器 LAN 口的设备会分配一个私有网段的 IP 地址（例如 192.168.1.3）。私网设备的 IP 被映射成路由器的公网 IP 和唯一的端口，通过这种方式不需要为每一个私网设备分配不同的公网 IP，但是依然能被外网设备发现。NAT 不止检查进入数据包的头部，而且对其进行修改，从而实现同一内网中不同主机共用更少的公网 IP（通常是一个）。</p>
<p><strong>基本 NAT（Basic NAT）</strong>： 基本 NAT 会将内网主机的 IP 地址映射为一个公网 IP，不改变其 TCP/UDP 端口号。基本 NAT 通常只有在当 NAT 有公网 IP 池的时候才有用。</p>
<p><strong>网络地址-端口转换器（NAPT）</strong>： 到目前为止最常见的即为 NAPT，其检测并修改出入数据包的 IP 地址和端口号，从而允许多个内网主机同时共享一个公网 IP 地址。</p>
<p><strong>锥形 NAT（Cone NAT）</strong>： 在建立了一对（公网 IP，公网端口）和（内网 IP，内网端口）二元组的绑定之后，Cone NAT 会重用这组绑定用于接下来该应用程序的所有会话（同一内网 IP 和端口），只要还有一个会话还是激活的。 例如，假设客户端 A 建立了两个连续的对外会话，从相同的内部端点（10.0.0.1:1234）到两个不同的外部服务端 S1 和 S2。Cone NAT 只为两个会话映射了一个公网端点（155.99.25.11:62000）， 确保客户端端口的“身份”在地址转换的时候保持不变。由于基本 NAT 和防火墙都不改变数据包的端口号，因此这些类型的中间件也可以看作是退化的 Cone NAT。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    Server S1                                     Server S2</span><br><span class="line">18.181.0.31:1235                              138.76.29.7:1235</span><br><span class="line">       |                                             |</span><br><span class="line">       |                                             |</span><br><span class="line">       +----------------------+----------------------+</span><br><span class="line">                              |</span><br><span class="line">  ^  Session 1 (A-S1)  ^      |      ^  Session 2 (A-S2)  ^</span><br><span class="line">  |  18.181.0.31:1235  |      |      |  138.76.29.7:1235  |</span><br><span class="line">  v 155.99.25.11:62000 v      |      v 155.99.25.11:62000 v</span><br><span class="line">                              |</span><br><span class="line">                           Cone NAT</span><br><span class="line">                         155.99.25.11</span><br><span class="line">                              |</span><br><span class="line">  ^  Session 1 (A-S1)  ^      |      ^  Session 2 (A-S2)  ^</span><br><span class="line">  |  18.181.0.31:1235  |      |      |  138.76.29.7:1235  |</span><br><span class="line">  v   10.0.0.1:1234    v      |      v   10.0.0.1:1234    v</span><br><span class="line">                              |</span><br><span class="line">                           Client A</span><br><span class="line">                        10.0.0.1:1234</span><br></pre></td></tr></table></figure>

<h3 id="1-1-2-UDP-打洞-UDP-hole-punching"><a href="#1-1-2-UDP-打洞-UDP-hole-punching" class="headerlink" title="1.1.2 UDP 打洞(UDP hole punching)"></a>1.1.2 UDP 打洞(UDP hole punching)</h3><p>P2P 通信技术中被广泛采用的技术“UDP 打洞”。UDP 打洞技术依赖于通常防火墙和 cone NAT 允许正当的 P2P 应用程序在中间件中打洞且与对方建立直接链接的特性。</p>
<p>在学习 UDP 打洞之前，我们先了解一下另外两种 P2P 通信技术。</p>
<p>（1）中继（Relaying）</p>
<p>中继是最可靠但效率最低的一种 P2P 通信技术，它的原理是通过一台服务器来中继转发不同客户端的数据。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">                       Server S</span><br><span class="line">                          |</span><br><span class="line">                          |</span><br><span class="line">   +----------------------+----------------------+</span><br><span class="line">   |                                             |</span><br><span class="line"> NAT A                                         NAT B</span><br><span class="line">   |                                             |</span><br><span class="line">   |                                             |</span><br><span class="line">Client A                                      Client B</span><br></pre></td></tr></table></figure>

<p>什么意思呢？就是我和你开视频，我和你的视频数据会直接被我们共同连接上的一台服务器接收，这台服务器会将你我的视频数据分别转发响应给我和你的客户端。这样服务器压力就很大，带宽需求也非常大，当仅仅只有两个客户端连接服务器开视频的话，服务器的带宽就至少是客户端带宽的两倍，CPU 消耗同样也是。那么当同时视频通话的人很多了，那么服务器的压力难以想象。</p>
<p>所以中继是一种效率很低的 P2P 通信技术。</p>
<p>（2）逆向连接（Connection reversal）</p>
<p>这种连接只有在两个通信端点中有一个不存在中间件的时候有效。</p>
<p>例如，客户端 A 在 NAT 之后而客户端 B 拥有全局 IP 地址，如下图：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">                            Server S</span><br><span class="line">                        18.181.0.31:1235</span><br><span class="line">                               |</span><br><span class="line">                               |</span><br><span class="line">        +----------------------+----------------------+</span><br><span class="line">        |                                             |</span><br><span class="line">      NAT A                                           |</span><br><span class="line">155.99.25.11:62000                                    |</span><br><span class="line">        |                                             |</span><br><span class="line">        |                                             |</span><br><span class="line">     Client A                                      Client B</span><br><span class="line">  10.0.0.1:1234                               138.76.29.7:1234　</span><br></pre></td></tr></table></figure>

<p>客户端 A 内网地址为 10.0.0.1，且应用程序正在使用 TCP 端口 1234。A 和服务器 S 建立了一个连接，服务器的 IP 地址为 18.181.0.31，监听 1235 端口。NAT A 给客户端 A 分配了 TCP 端口 62000，地址为 NAT 的公网 IP 地址 155.99.25.11， 作为客户端 A 对外当前会话的临时 IP 和端口。因此 S 认为客户端 A 就是 155.99.25.11:62000。而 B 由于有公网地址，所以对 S 来说 B 就是 138.76.29.7:1234。</p>
<p>当客户端 B 想要发起一个对客户端 A 的 P2P 链接时，要么链接 A 的外网地址 155.99.25.11:62000，要么链接 A 的内网地址 10.0.0.1:1234，然而两种方式链接都会失败。 链接 10.0.0.1:1234 失败自不用说，为什么链接 155.99.25.11:62000 也会失败呢？来自 B 的 TCP SYN 握手请求到达 NAT A 的时候会被拒绝，因为对 NAT A 来说只有外出的链接才是允许的。</p>
<p>在直接链接 A 失败之后，B 可以通过 S 向 A 中继一个链接请求，从而从 A 方向“逆向“地建立起 A-B 之间的点对点链接。</p>
<p>现在很多 P2P 系统都实现了这种技术，但是这种技术有局限性，只有当其中一放客户端有公网 IP 的时候才能建立起连接。为什么现在很多 P2P 系统都实现了逆向连接技术，因为我们接下来要讲的 UDP 打洞技术，主要是依赖这种技术。</p>
<p><strong>UDP 打洞正文开始</strong>：</p>
<p>现在最多的网路连接情况是双方都是在内网下，都需要通过 NAT 进行地址转换，所以上面的逆向连接不适用，但是可以利用逆向连接技术进行改造。</p>
<p>假设客户端 A 和客户端 B 的地址都是内网地址，且在不同的 NAT 后面。A、B 上运行的 P2P 应用程序和服务器 S 都使用了 UDP 端口 1234，A 和 B 分别初始化了 与 Server 的 UDP 通信，地址映射如图所示:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">                            Server S</span><br><span class="line">                        18.181.0.31:1234</span><br><span class="line">                               |</span><br><span class="line">                               |</span><br><span class="line">        +----------------------+----------------------+</span><br><span class="line">        |                                             |</span><br><span class="line">      NAT A                                         NAT B</span><br><span class="line">155.99.25.11:62000                            138.76.29.7:31000</span><br><span class="line">        |                                             |</span><br><span class="line">        |                                             |</span><br><span class="line">     Client A                                      Client B</span><br><span class="line">  10.0.0.1:1234                                 10.1.1.3:1234</span><br></pre></td></tr></table></figure>

<p>现在假设客户端 A 打算与客户端 B 直接建立一个 UDP 通信会话。如果 A 直接给 B 的公网地址 138.76.29.7:31000 发送 UDP 数据，NAT B 将很可能会无视进入的 数据（除非是 Full Cone NAT），因为源地址和端口与 S 不匹配，而最初只与 S 建立过会话。B 往 A 直接发信息也类似。</p>
<p>假设 A 开始给 B 的公网地址发送 UDP 数据的同时，给服务器 S 发送一个中继请求，要求 B 开始给 A 的公网地址发送 UDP 信息。</p>
<p>A 往 B 的输出信息会导致 NAT A 打开 一个 A 的内网地址与与 B 的外网地址之间的新通讯会话，B 往 A 亦然。一旦新的 UDP 会话在两个方向都打开之后，客户端 A 和客户端 B 就能直接通讯， 而无须再通过引导服务器 S 了。</p>
<p>UDP 打洞技术有许多有用的性质。一旦一个的 P2P 链接建立，链接的双方都能反过来作为“引导服务器”来帮助其他中间件后的客户端进行打洞， 极大减少了服务器的负载。应用程序不需要知道中间件具体是什么（如果有的话），因为以上的过程在没有中间件或者有多个中间件的情况下 也一样能建立通信链路。</p>
<p><strong>还有一些特殊情况</strong>：当通信双方都在同一局域网，也就是两个客户端都在一个内网下呢？是不是可以降低 NAT 转换，直接在内网上连接呢？此外还有，当一些大型企业，内网中有多级 NAT 转换呢？这里已不再本文的讨论中了，详细可以看以下参考文章详细了解：</p>
<blockquote>
<p>参考文章：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/26796476">https://zhuanlan.zhihu.com/p/26796476</a></p>
</blockquote>
<p>学到这里，根据上面的原理是可以实现自己的一套程序和通信规则，但很多时候是需要对接第三方的协议，往往这个适配是比较麻烦的。因此就产生了标准化的通用规则（STUN、TURN、ICE），下面的几个章节将逐个介绍这些协议。</p>
<h2 id="1-2-STUN-协议"><a href="#1-2-STUN-协议" class="headerlink" title="1.2 STUN 协议"></a>1.2 STUN 协议</h2><p>STUN（<a target="_blank" rel="noopener" href="http://www.rfc-editor.org/info/rfc3489">STUN/RFC3489(废弃)</a>，<a target="_blank" rel="noopener" href="http://www.rfc-editor.org/info/rfc5389">STUN/RFC5389</a>）是 P2P 标准化通信规则（协议）之一。</p>
<h3 id="1-2-1-简介"><a href="#1-2-1-简介" class="headerlink" title="1.2.1 简介"></a>1.2.1 简介</h3><p>NAT 的会话穿越功能<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/STUN">Session Traversal Utilities for NAT (STUN)</a> (缩略语的最后一个字母是 NAT 的首字母)是一个允许位于 NAT 后的客户端找出自己的公网地址，判断出路由器阻止直连的限制方法的协议。</p>
<p>STUN 是一个 C/S 架构的协议，支持两种传输类型。一种是请求/响应（request/respond）类型，由客户端给服务器发送请求，并等待服务器返回响应；另一种是指示类型（indication transaction），由服务器或者客户端 发送指示，另一方不产生响应。对于请求/响应类型，允许客户端将响应和产生响应的请求连接起来； 对于指示类型，通常在 debug 时使用。我们主要了解请求/响应类型。</p>
<h3 id="1-2-2-通信过程"><a href="#1-2-2-通信过程" class="headerlink" title="1.2.2 通信过程"></a>1.2.2 通信过程</h3><p>客户端通过给公网的 STUN 服务器发送请求获得自己的公网地址信息，以及是否能够被（穿过路由器）访问。</p>
<ol>
<li>客户端 A 向服务器产生一个 Request（STUN 叔叔，你能告诉我我的 ip 是多少吗）</li>
<li>服务器接收 Request，检查报文是否合法，并生成 Success 响应或 Error 响应（A 小朋友，你的 ip 是 208.141.55.130:3255）</li>
</ol>
<p><img src="https://mdn.mozillademos.org/files/6115/webrtc-stun.png" alt="客户端A和STUN服务器之间的通信"></p>
<h2 id="1-3-TURN-协议"><a href="#1-3-TURN-协议" class="headerlink" title="1.3 TURN 协议"></a>1.3 TURN 协议</h2><p>TURN（<a target="_blank" rel="noopener" href="http://www.rfc-editor.org/info/rfc5766">TURN/RFC5766</a>）是 P2P 标准化通信规则（协议）之一，是对 STUN 的补充。</p>
<h3 id="1-3-1-简介"><a href="#1-3-1-简介" class="headerlink" title="1.3.1 简介"></a>1.3.1 简介</h3><p>TURN 的全称为<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/TURN">Traversal Using Relays around NAT (TURN)</a> ，是 STUN/RFC5389 的一个拓展，主要添加了 Relay 功能。前面介绍的 STUN 协议处理的是市面上大多数的 Cone NAT，但还有少量的设备使用的 Symmetric NAT。因此传统的打洞方法不适用，为了保证这一部分设备能够建立通信，我们不得不通过中继（Relaying）的方法进行连接，这时就需要公网的服务器作为一个中继， 对来往的数据进行转发。这个转发的协议就被定义为 TURN。这种情况会增加服务器负担，所以这是最坏的情况的通信解决方案。</p>
<p>TURN 服务器与客户端之间的连接都是基于 UDP 的，但是服务器和客户端之间可以通过其他各种连接来传输 STUN 报文, 比如 TCP/UDP/TLS-over-TCP。客户端之间通过中继传输数据时候，如果用了 TCP，也会在服务端转换为 UDP，因此建议客户端使用 UDP 来进行传输。至于为什么要支持 TCP，那是因为一部分防火墙会完全阻挡 UDP 数据，而对于三次握手的 TCP 数据则不做隔离。</p>
<h3 id="1-3-2-通信过程"><a href="#1-3-2-通信过程" class="headerlink" title="1.3.2 通信过程"></a>1.3.2 通信过程</h3><p>客户端 A 向 STUN 服务器发送请求获取自己的公网地址，STUN 服务器可以获取到客户端 A 的地址，但发现客户端 A 的使用的 Symmetric NAT，因此 STUN 服务器告诉客户端 A，我不能帮助你和客户端 B 建立连接，你们之间可以通过 TURN 进行连接。因此客户端 A 和客户端 B 同时去连接 TURN 服务器，通过 TURN 服务器进行中继连接。</p>
<ol>
<li>客户端 A 向 STUN 服务器产生一个 Request（STUN 叔叔，你能告诉我我的 ip 是多少吗）</li>
<li>STUN 服务器响应（A 小朋友，你的 ip 是 208.141.55.130:3255，可是你的 ip 别人不能和你连接哦，你需要去找你 TURN 大伯，他是专门负责帮你连接）</li>
<li>客户端 A 向 TURN 服务器发起请求（TURN 大伯，STUN 叔叔叫我来找你）</li>
<li>TURN 服务器响应（A 小侄儿，我知道了，但是现在还没有其他小朋友找你哦，你可以在这附近逛一逛，每 10 分钟要给我报告一下你还在这附近哦，一有其他小朋友来找你我就通知你。）</li>
</ol>
<p><img src="https://mdn.mozillademos.org/files/6117/webrtc-turn.png" alt="客户端A、B与STUN服务器，TURN之间的通信"></p>
<h2 id="1-4-ICE-协议"><a href="#1-4-ICE-协议" class="headerlink" title="1.4 ICE 协议"></a>1.4 ICE 协议</h2><p>TURN（<a target="_blank" rel="noopener" href="http://www.rfc-editor.org/info/rfc5245">ICE/RFC5245</a>）是 P2P 标准化通信规则（协议）之一，提供了完整的 NAT 传输解决方案。</p>
<blockquote>
<p>STUN、TURN 都是工具类协议，只提供穿透 NAT 的功能。且 TURN 本身就是被设计为 ICE/RFC5245 的一部分</p>
</blockquote>
<h3 id="1-4-1-简介"><a href="#1-4-1-简介" class="headerlink" title="1.4.1 简介"></a>1.4.1 简介</h3><p>ICE 的全称为<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Interactive_Connectivity_Establishment">Interactive Connectivity Establishment (ICE)</a>，即交互式连接建立。在实际的网络当中，有很多原因能导致简单的从 A 端到 B 端直连不能如愿完成。这需要绕过阻止建立连接的防火墙，给你的设备分配一个唯一可见的地址（通常情况下我们的大部分设备没有一个固定的公网地址），如果路由器不允许主机直连，还得通过一台服务器转发数据。ICE 通过使用 STUN、TURN、NAT、SDP 技术完成上述工作。(引用自：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Protocols">https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Protocols</a>)</p>
<p>ICE 是一个用于在<a target="_blank" rel="noopener" href="http://www.rfc-editor.org/info/rfc3264">Offer/Answer</a>模式下的 NAT 传输协议，主要用于 UDP 下多媒体会话的建立，其使用了 STUN 协议以及 TURN 协议，同时也能被其他实现了 Offer/Answer 模型的的其他程序所使用，比如<a target="_blank" rel="noopener" href="http://www.rfc-editor.org/info/rfc3261">SIP</a>(Session Initiation Protocol)。</p>
<blockquote>
<p>网络编程的 ICE（Internate Communications Engine）：是一种用于分布式程序设计的网络通信中间件，本文指并非此 ICE</p>
</blockquote>
<blockquote>
<p>交互式连接 ICE（Interactive Connectivity Establishment）：是一个允许你的浏览器和对端浏览器建立连接的协议框架。</p>
</blockquote>
<h3 id="1-4-2-SDP-会话描述"><a href="#1-4-2-SDP-会话描述" class="headerlink" title="1.4.2 SDP 会话描述"></a>1.4.2 SDP 会话描述</h3><p>ICE 信息的描述格式通常采用标准的<a target="_blank" rel="noopener" href="http://www.rfc-editor.org/info/rfc4566">SDP</a>，其全称为<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Session_Description_Protocol">Session Description Protocol (SDP)</a> ，即会话描述协议。SDP 不是一个真正的协议，而是一种数据格式，用于描述在设备之间共享媒体的连接。可以被其他传输协议用来交换必要的信息，如 SIP 和 RTSP 等。</p>
<p><strong>SDP 格式</strong>：</p>
<p>SDP 由一行或多行 UTF-8 文本组成，每行以一个字符的类型开头，后跟等号（“ =”），然后是包含值或描述的结构化文本，其格式取决于类型。</p>
<p>SDP 会话描述包含了多行如下类型的文本:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt;=&lt;value&gt;</span><br></pre></td></tr></table></figure>

<p>以给定字母开头的文本行通常称为“字母行”。例如，提供媒体描述的行的类型为“ m”，因此这些行称为“ m 行”。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m=audio 49170 RTP/AVP 0</span><br></pre></td></tr></table></figure>

<p>&lt;type&gt;是大小写敏感的，其中一些行是必须要有的，有些是可选的，所有元素都必须以固定顺序给出。如下所示，其中可选的元素标记为* ：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">会话描述:</span><br><span class="line">     v=  (protocol version)</span><br><span class="line">     o=  (originator and session identifier)</span><br><span class="line">     s=  (session name)</span><br><span class="line">     i=* (session information)</span><br><span class="line">     u=* (URI of description)</span><br><span class="line">     e=* (email address)</span><br><span class="line">     p=* (phone number)</span><br><span class="line">     c=* (connection information -- not required if included in</span><br><span class="line">          all media)</span><br><span class="line">     b=* (zero or more bandwidth information lines)</span><br><span class="line">     One or more time descriptions (&quot;t=&quot; and &quot;r=&quot; lines; see below)</span><br><span class="line">     z=* (time zone adjustments)</span><br><span class="line">     k=* (encryption key)</span><br><span class="line">     a=* (zero or more session attribute lines)</span><br><span class="line">     Zero or more media descriptions</span><br><span class="line"></span><br><span class="line">时间信息描述:</span><br><span class="line">     t=  (time the session is active)</span><br><span class="line">     r=* (zero or more repeat times)</span><br><span class="line"></span><br><span class="line">多媒体信息描述(如果有的话):</span><br><span class="line">     m=  (media name and transport address)</span><br><span class="line">     i=* (media title)</span><br><span class="line">     c=* (connection information -- optional if included at</span><br><span class="line">          session level)</span><br><span class="line">     b=* (zero or more bandwidth information lines)</span><br><span class="line">     k=* (encryption key)</span><br><span class="line">     a=* (zero or more media attribute lines)</span><br></pre></td></tr></table></figure>

<p>所有元素的 type 都为小写，并且不提供拓展.但是我们可以用 a(attribute)字段来提供额外的信息。一个 SDP 描述的例子如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">v=0</span><br><span class="line">o=jdoe 2890844526 2890842807 IN IP4 10.47.16.5</span><br><span class="line">s=SDP Seminar</span><br><span class="line">i=A Seminar on the session description protocol</span><br><span class="line">u=http://www.example.com/seminars/sdp.pdf</span><br><span class="line">e=j.doe@example.com (Jane Doe)</span><br><span class="line">c=IN IP4 224.2.17.12/127</span><br><span class="line">t=2873397496 2873404696</span><br><span class="line">a=recvonly</span><br><span class="line">m=audio 49170 RTP/AVP 0</span><br><span class="line">m=video 51372 RTP/AVP 99</span><br><span class="line">a=rtpmap:99 h263-1998/90000</span><br></pre></td></tr></table></figure>

<p>具体字段的 type/value 描述和格式可以参考<a target="_blank" rel="noopener" href="http://www.rfc-editor.org/info/rfc4566">RFC4566</a>。</p>
<h3 id="1-4-3-Offer-Answer-模型"><a href="#1-4-3-Offer-Answer-模型" class="headerlink" title="1.4.3 Offer/Answer 模型"></a>1.4.3 Offer/Answer 模型</h3><p>SDP 用来描述多播主干网络的会话信息，但是并没有具体的交互操作细节是如何实现的，因此<a href="https://link.zhihu.com/?target=http://www.rfc-editor.org/info/rfc3264">RFC3264</a> 定义了一种基于 SDP 的 Offer/Answer 模型。</p>
<p>在该模型中，会话参与者的其中一方生成一个 SDP 报文构成 offer， 其中包含了一组 offer 希望使用的多媒体流和编解码方法，以及 offer 用来接收改数据的 IP 地址和端口信息。</p>
<p>offer 传输到会话的另一端(称为 answer)，由这一端生成一个 answer，即用来响应对应 offer 的 SDP 报文。</p>
<p>answer 中包含不同 offer 对应的多媒体流，并指明该流是否可以接受。</p>
<img src="/2021/03/11/WebRTC%E5%85%A5%E9%97%A8/2017-signaling-state-diagram.png" class="">

<h3 id="1-4-4-ICE-工作流程"><a href="#1-4-4-ICE-工作流程" class="headerlink" title="1.4.4 ICE 工作流程"></a>1.4.4 ICE 工作流程</h3><p>一个典型的 ICE 工作环境如下，有两个端点 A 和 B，都运行在各自的 NAT 之后(他们自己也许并不知道)，NAT 的类型和性质也是未知的。L 和 R 通过交换 SDP 信息在彼此之间建立多媒体会话，通常交换通过一个 SIP 服务器完成：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">                 +-----------+</span><br><span class="line">                 |    SIP    |</span><br><span class="line">+-------+        |    Srvr   |         +-------+</span><br><span class="line">| STUN  |        |           |         | STUN  |</span><br><span class="line">| Srvr  |        +-----------+         | Srvr  |</span><br><span class="line">|       |        /           \         |       |</span><br><span class="line">+-------+       /             \        +-------+</span><br><span class="line">               /&lt;- Signaling -&gt;\</span><br><span class="line">              /                 \</span><br><span class="line">         +--------+          +--------+</span><br><span class="line">         |  NAT   |          |  NAT   |</span><br><span class="line">         +--------+          +--------+</span><br><span class="line">           /                       \</span><br><span class="line">          /                         \</span><br><span class="line">         /                           \</span><br><span class="line">     +-------+                    +-------+</span><br><span class="line">     | Agent |                    | Agent |</span><br><span class="line">     |   A   |                    |   B   |</span><br><span class="line">     |       |                    |       |</span><br><span class="line">     +-------+                    +-------+</span><br></pre></td></tr></table></figure>

<p>ICE 的基本思路是，每个终端都有一系列传输地址(包括传输协议，IP 地址和端口)的候选，可以用来和其他端点进行通信。其中可能包括：</p>
<ul>
<li>直接和网络接口联系的传输地址(host address)</li>
<li>经过 NAT 转换的传输地址,即反射地址(server reflective address)</li>
<li>TURN 服务器分配的中继地址(relay address)</li>
</ul>
<blockquote>
<p>通过之前的学习，我们可以了解到每个终端的情况是比较复杂的（有的终端可能同时连着 wifi 和网线，有多个内网地址），所有每个终端有多种可以连接的方案。</p>
</blockquote>
<p>获取到这一系列传输地址后，会以一定优先级将地址排序。按照优先级和其他终端的传输地址进行组合检测连接可用性（连接性检查：Connectivity Checks）。</p>
<p>两端连接性检查，是一个 4 次握手过程:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A                        B</span><br><span class="line">-                        -</span><br><span class="line">STUN request -&gt;                  \  A&#x27;s</span><br><span class="line">          &lt;- STUN response       /  check</span><br><span class="line"></span><br><span class="line">           &lt;- STUN request       \  B&#x27;s</span><br><span class="line">STUN response -&gt;                 /  check</span><br></pre></td></tr></table></figure>

<p><strong>连接性检查详细过程</strong>：</p>
<ol>
<li><p>为中继候选地址生成许可(Permissions)；</p>
</li>
<li><p>从本地候选往远端候选发送 Binding Request：</p>
<p>在 Binding 请求中通常需要包含一些特殊的属性，以在 ICE 进行连接性检查的时候提供必要信息：</p>
<ul>
<li>PRIORITY 和 USE-CANDIDATE：优先级和候选</li>
<li>ICE-CONTROLLED 和 ICE-CONTROLLING：标识本端是受控方还是主控方（offer 生成方）。</li>
<li>生成 Credential：STUN 短期身份验证</li>
</ul>
</li>
<li><p>处理 Response：</p>
<p>当收到 Binding Response 时，终端会将其与 Binding Request 相联系，通常生成事务 ID。随后将会将此事务 ID 与候选地址对进行绑定。</p>
<ul>
<li>成功响应：要同时满足三个条件（STUN 传输产生一个 Success Response；response 的源 IP 和端口等于 Binding Request 的目的 IP 和端口；response 的目的 IP 和端口等于 Binding Request 的源 IP 和端口）</li>
<li>失败响应：487 错误，并将检测地址状态设置为 Waiting</li>
</ul>
</li>
</ol>
<p>以上仅对协议作了简单的介绍，具体服务器程序实现可参考：<a target="_blank" rel="noopener" href="https://github.com/evilpan/TurnServer">https://github.com/evilpan/TurnServer</a></p>
<h2 id="1-5-经典-WebRTC-连接建立流程"><a href="#1-5-经典-WebRTC-连接建立流程" class="headerlink" title="1.5 经典 WebRTC 连接建立流程"></a>1.5 经典 WebRTC 连接建立流程</h2><p>通过前面的协议了解学习，相信大家已经对 WebRTC 的底层连接流程有了一个模糊的意思，这里有张图展现了具体的连接流程。</p>
<img src="/2021/03/11/WebRTC%E5%85%A5%E9%97%A8/20200618134458727.png" class="">

<blockquote>
<p>引用自：<a target="_blank" rel="noopener" href="https://aggresss.blog.csdn.net/article/details/106832965">https://aggresss.blog.csdn.net/article/details/106832965</a></p>
</blockquote>
<h1 id="二、服务器搭建"><a href="#二、服务器搭建" class="headerlink" title="二、服务器搭建"></a>二、服务器搭建</h1><h2 id="2-1-STUN-TURN-服务器"><a href="#2-1-STUN-TURN-服务器" class="headerlink" title="2.1 STUN/TURN 服务器"></a>2.1 STUN/TURN 服务器</h2><p>STUN 服务器已有现成项目：<a target="_blank" rel="noopener" href="https://github.com/coturn/coturn">https://github.com/coturn/coturn</a></p>
<p>以下是在 ubuntu 上的安装和配置：</p>
<h3 id="2-1-1-安装-coturn"><a href="#2-1-1-安装-coturn" class="headerlink" title="2.1.1 安装 coturn"></a>2.1.1 安装 coturn</h3><p>可以克隆 github 上的源码编译安装，在 ubuntu 里有直接的安装包</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get -y update</span><br><span class="line">apt-get -y install coturn</span><br></pre></td></tr></table></figure>

<p>安装完毕后，先关闭 coturn 服务：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop coturn</span><br></pre></td></tr></table></figure>

<h3 id="2-1-2-配置-coturn"><a href="#2-1-2-配置-coturn" class="headerlink" title="2.1.2 配置 coturn"></a>2.1.2 配置 coturn</h3><p><strong>(1) 允许 turnserver</strong></p>
<p>首先需要允许 turnserver，打开<code>/etc/default/coturn</code>文件，将注释去掉：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/default/coturn</span><br></pre></td></tr></table></figure>

<p>取消注释后如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TURNSERVER_ENABLED=1</span><br></pre></td></tr></table></figure>

<p><strong>(2) 获取 ip 和 SSL</strong></p>
<p>首选需要获取一下自己的内网 ip 以及网卡:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure>

<p>生成 SSL 证书:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install openssl</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -x509 -newkey rsa:2048 -keyout /etc/turn_server_pkey.pem -out /etc/turn_server_cert.pem -days 99999 -nodes</span><br></pre></td></tr></table></figure>

<p><strong>(3) 配置</strong></p>
<p>接下来正式改配置文件<code>/etc/turnserver.conf</code>，改之前先将原文件备份一个：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv /etc/turnserver.conf /etc/turnserver.conf.bat</span><br></pre></td></tr></table></figure>

<p>然后新建配置文件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/turnserver.conf</span><br></pre></td></tr></table></figure>

<p>然后复制以下配置：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">server-name=turn.webrtc.zzboy.cn</span><br><span class="line">realm=turn.webrtc.zzboy.cn</span><br><span class="line"></span><br><span class="line">fingerprint</span><br><span class="line"></span><br><span class="line">relay-device=eth0   <span class="comment">#与前ifconfig查到的网卡名称一致</span></span><br><span class="line"></span><br><span class="line">listening-ip=192.168.0.186    <span class="comment">#内网IP</span></span><br><span class="line">listening-port=3478</span><br><span class="line">tls-listening-port=5349</span><br><span class="line">relay-ip=192.168.0.186</span><br><span class="line">external-ip=121.36.105.109    <span class="comment">#公网IP</span></span><br><span class="line"></span><br><span class="line">relay-threads=50</span><br><span class="line">lt-cred-mech</span><br><span class="line">no-cli</span><br><span class="line">verbose</span><br><span class="line"></span><br><span class="line">cert=/etc/turn_server_cert.pem</span><br><span class="line">pkey=/etc/turn_server_pkey.pem</span><br><span class="line"><span class="comment">#pidfile=/var/run/turnserver.pid</span></span><br><span class="line">min-port=49152</span><br><span class="line">max-port=65535</span><br><span class="line">user=jun:123456    <span class="comment">#用户名密码，创建IceServer时用</span></span><br></pre></td></tr></table></figure>

<h3 id="2-1-3-测试"><a href="#2-1-3-测试" class="headerlink" title="2.1.3 测试"></a>2.1.3 测试</h3><p>工具：<a target="_blank" rel="noopener" href="https://webrtc.github.io/samples/src/content/peerconnection/trickle-ice/">Trickle ICE</a></p>
<p>点击打开上面的工具</p>
<h2 id="2-2-Nodejs-构建信令服务器-Signal-Server"><a href="#2-2-Nodejs-构建信令服务器-Signal-Server" class="headerlink" title="2.2 Nodejs 构建信令服务器(Signal Server)"></a>2.2 Nodejs 构建信令服务器(Signal Server)</h2><p>信令服务器我直接使用的一个开源项目：<a target="_blank" rel="noopener" href="https://github.com/qdgx/WebRtcRoomServer">https://github.com/qdgx/WebRtcRoomServer</a></p>
<p>其实信令服务器已经涉及到实战了，这里就不讲具体实现，这里只先部署。</p>
<p>单纯地看，信令服务器其实可以算作是一个后端项目，我们这里部署也只是对该项目进行服务器部署。这里我使用的这个开源项目是使用 node.js 开发的，因此部署步骤和 node.js 部署步骤相差无异。</p>
<p>以下是我在 ubuntu 上的安装和配置：</p>
<h3 id="2-2-1-安装-node-环境"><a href="#2-2-1-安装-node-环境" class="headerlink" title="2.2.1 安装 node 环境"></a>2.2.1 安装 node 环境</h3><p><strong>(1) 更新环境，安装 curl、git</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install -y curl git</span><br></pre></td></tr></table></figure>

<p><strong>(2) 安装 node.js</strong></p>
<p>先去官网<a target="_blank" rel="noopener" href="https://nodejs.org/%EF%BC%8C%E6%9F%A5%E7%9C%8B%E6%9C%80%E6%96%B0%E7%A8%B3%E5%AE%9A%E9%95%BF%E6%9C%9F%E6%94%AF%E6%8C%81%E7%89%88%EF%BC%8C%E5%8F%91%E7%8E%B0%E6%9C%80%E6%96%B0%E7%A8%B3%E5%AE%9A%E7%89%88%E6%98%AF14.15.3">https://nodejs.org/，查看最新稳定长期支持版，发现最新稳定版是14.15.3</a> LTS，node.js 的每个大版本号都有相对应的源，比如这里的 14.15.3 版本的源是 <a target="_blank" rel="noopener" href="https://deb.nodesource.com/setup_14.x">https://deb.nodesource.com/setup_14.x</a></p>
<p>所以在终端执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sL https://deb.nodesource.com/setup_10.x | sudo -E bash -</span><br></pre></td></tr></table></figure>

<p>然后安装 node.js</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install nodejs</span><br></pre></td></tr></table></figure>

<p><code>node -v</code> 和 <code>npm -v</code> 查看 node 和 npm 是否安装成功</p>
<h3 id="2-2-2-克隆项目，安装依赖"><a href="#2-2-2-克隆项目，安装依赖" class="headerlink" title="2.2.2 克隆项目，安装依赖"></a>2.2.2 克隆项目，安装依赖</h3><p>进入用户目录，克隆项目：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/ &amp;&amp; git clone https://github.com/qdgx/WebRtcRoomServer.git</span><br></pre></td></tr></table></figure>

<p>安装依赖：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/WebRtcRoomServer</span><br><span class="line">npm i</span><br></pre></td></tr></table></figure>

<p>启动服务：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node app.js</span><br></pre></td></tr></table></figure>

<p>在浏览器打开以下地址，测试一下是否访问：</p>
<p><strong><a target="_blank" rel="noopener" href="https://你服务器外网地址:8443/">https://你服务器外网地址:8443</a></strong></p>
<p>只要浏览器提示该页面存在风险，即表示项目已生效，点击高级，选择接受风险继续访问即可。（为什么提示风险：因为这个项目的证书是自签名证书）</p>
<img src="/2021/03/11/WebRTC%E5%85%A5%E9%97%A8/signal-server-success.png" class="">

<p>如果无法访问，请检查服务器安全组是否打开了 TCP 和 UDP 协议的 8443 端口，有些服务器开端口需要在服务器上那配置安全组，比如阿里云 ECS 和华为云。</p>
<h3 id="2-2-3-pm2-管理-node-服务"><a href="#2-2-3-pm2-管理-node-服务" class="headerlink" title="2.2.3 pm2 管理 node 服务"></a>2.2.3 pm2 管理 node 服务</h3><p>直接用<code>node app.js</code>运行项目，在关闭终端后，node 项目也会随之被关闭，因此需要使用额外的工具来保持 node 服务一直开启。</p>
<p>安装 pm2：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install pm2@latest -g</span><br></pre></td></tr></table></figure>

<p>启动服务：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 start app.js --name signal-server --watch</span><br></pre></td></tr></table></figure>

<ul>
<li>name：给应用命名，可以不管</li>
<li>watch：相当于热更新，应用文件更新后会重启应用</li>
</ul>
<p>有关 pm2 的使用，可以百度查询一下，也可以参考本人之前写的一篇文章：<a target="_blank" rel="noopener" href="https://www.zzboy.cn/Learning/f360ef90efef">https://www.zzboy.cn/Learning/f360ef90efef</a></p>
<h1 id="三、API-学习"><a href="#三、API-学习" class="headerlink" title="三、API 学习"></a>三、API 学习</h1><p>以下主要介绍下一章节实战开中需要到的常用接口，完整的接口学习可查看对应官方文档。</p>
<h2 id="3-1-socket-io"><a href="#3-1-socket-io" class="headerlink" title="3.1 socket.io"></a>3.1 socket.io</h2><blockquote>
<p>官方文档：<a target="_blank" rel="noopener" href="https://socket.io/docs/v3/">https://socket.io/docs/v3/</a></p>
</blockquote>
<blockquote>
<p>中文 w3chool：<a target="_blank" rel="noopener" href="https://www.w3cschool.cn/socket/">https://www.w3cschool.cn/socket/</a></p>
</blockquote>
<p><code>Socket</code>是一种<strong>全双工通信</strong>,当客户端和服务端建立起连接后，如果不主动断开，双方可以一直互相发送消息，适合于双方频繁通信的场景，也是支持服务端主动推送的一种通信方式。<code>WebSocket</code>是<code>Html5</code>推出的前端可以直接使用的 API，不过目前项目中用的还是 socket.io 比较多。socket.io 在浏览器环境下封装了 WebSocket, 可以给开发者带来更好的体验，在功能上也更完善。</p>
<p>socket.io 主要使用两个方法：</p>
<ul>
<li><p><code>emit(description: string, data: any</code>：监听事件；<code>description</code>是标识；<code>data</code>是需要发送的数据。</p>
</li>
<li><p><code>on(description: string, callback: function</code>：监听事件；<code>description</code>表示监听的标识；<code>callback</code>是监到事件后处理方法，参数是<code>emit</code>发送的数据。</p>
</li>
</ul>
<p>通俗说，一个就是发送，一个是接收。发送方法需要指定谁(<code>description</code>)来接收；接收方法找到对应<code>description</code>接收。</p>
<h3 id="3-1-1-服务器端"><a href="#3-1-1-服务器端" class="headerlink" title="3.1.1 服务器端"></a>3.1.1 服务器端</h3><p><strong>(1) 安装</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install socket.io</span><br></pre></td></tr></table></figure>

<p><strong>(2) 初始化</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> httpServer = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>).createServer(); <span class="comment">// 创建http服务</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用socket.io监听http服务</span></span><br><span class="line"><span class="keyword">const</span> socketIO = <span class="built_in">require</span>(<span class="string">&quot;socket.io&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> io = socketIO.listen(httpServer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以使用如下方式</span></span><br><span class="line"><span class="keyword">const</span> io = <span class="built_in">require</span>(<span class="string">&quot;socket.io&quot;</span>)(httpServer, &#123;</span><br><span class="line">  <span class="comment">// options配置项</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>配置项：是初始配置 socket.io 的一些参数，我们使用默认的接口，如需要配置，可以看文档了解具体配置项：<a target="_blank" rel="noopener" href="https://socket.io/docs/v3/server-api/#new-Server-httpServer-options">https://socket.io/docs/v3/server-api/#new-Server-httpServer-options</a></p>
<p>根据 WebRTC 安全策略，我们需要使用 https，因此，比较<strong>完整的初始化代码</strong>为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> server = <span class="built_in">require</span>(<span class="string">&quot;https&quot;</span>).createServer(&#123;</span><br><span class="line">  key: fs.readFileSync(<span class="string">&quot;/tmp/key.pem&quot;</span>),</span><br><span class="line">  cert: fs.readFileSync(<span class="string">&quot;/tmp/cert.pem&quot;</span>),</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> io = <span class="built_in">require</span>(<span class="string">&quot;socket.io&quot;</span>)(server, options);</span><br><span class="line"></span><br><span class="line">io.on(<span class="string">&quot;connection&quot;</span>, <span class="function">(<span class="params">socket</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<p><strong>(3) 方法</strong></p>
<p><strong>io.on(‘connection’, fn)</strong> ：监听客户端连接</p>
<p>从上面初始化代码不难看出，socket.io 第一个方法应该<code>io.on(&#39;connection&#39;, fn)</code>。</p>
<p>connection 是保留<code>description</code>，当有客户端连接上当前服务器时，就会触发。</p>
<p>我们需要在其回调中处理相关业务：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">io.on(<span class="string">&quot;connection&quot;</span>, <span class="function">(<span class="params">socket</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 监听断开连接</span></span><br><span class="line">  socket.on(<span class="string">&quot;disconnect&quot;</span>, <span class="function">(<span class="params">reason</span>) =&gt;</span> <span class="built_in">console</span>.log(reason)); <span class="comment">// socket断开监听，disconnect也是保留字段</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 其他业务监听</span></span><br><span class="line">  socket.on(<span class="string">&quot;join&quot;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`欢迎<span class="subst">$&#123;data.name&#125;</span>进入直播间`</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>socket.on(‘disconnect’, fn)</strong> ：监听客户端断开连接</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">socket.on(<span class="string">&quot;disconnect&quot;</span>, <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(reason); <span class="comment">// 断开原因有很多，可能是用户主动断开，也可能是浏览器直接关闭等</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>socket.emit() : 发送信息</p>
<h3 id="3-1-2-客户端"><a href="#3-1-2-客户端" class="headerlink" title="3.1.2 客户端"></a>3.1.2 客户端</h3><h2 id="3-2-音视频相关-API"><a href="#3-2-音视频相关-API" class="headerlink" title="3.2 音视频相关 API"></a>3.2 音视频相关 API</h2><h3 id="3-2-1-navigator-mediaDevices"><a href="#3-2-1-navigator-mediaDevices" class="headerlink" title="3.2.1 navigator.mediaDevices"></a>3.2.1 navigator.mediaDevices</h3><p>浏览器 API，可以通过该浏览器 API 获取用户媒体设备，通常只会用到一个方法：<code>getUserMedia(options)</code>，调用该方法时，浏览器会弹出请求音频或视频的权限，用户同意授权过后，即可获取到音视频流。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">navigator.mediaDevices</span><br><span class="line">  .getUserMedia(options)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">stream</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/* use the stream */</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/* handle the error */</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>需要注意：<code>navigator</code>的<code>mediaDevices</code>属性需要在 https 环境下才会有，这是浏览器的限制。</p>
<p><strong>options: 配置项</strong></p>
<p>一般可直接设置为：<code>&#123; audio: true, video: true &#125;</code>，表示为获取音频和视频。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">navigator.mediaDevices</span><br><span class="line">  .getUserMedia(&#123;</span><br><span class="line">    audio: <span class="literal">true</span>,</span><br><span class="line">    video: <span class="literal">true</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">stream</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/* use the stream */</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/* handle the error */</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>视频方面，也可以准确定义视频画面的宽高：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">navigator.mediaDevices</span><br><span class="line">  .getUserMedia(&#123;</span><br><span class="line">    audio: <span class="literal">true</span>,</span><br><span class="line">    video: &#123; <span class="attr">width</span>: <span class="number">1280</span>, <span class="attr">height</span>: <span class="number">720</span> &#125;, <span class="comment">// 当定义宽高是，视频算是true，请求视频权限</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">stream</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/* use the stream */</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/* handle the error */</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>其他更多配置可参考：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia">https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia</a></p>
<h3 id="3-2-2-video"><a href="#3-2-2-video" class="headerlink" title="3.2.2 video"></a>3.2.2 video</h3><p><strong>(1) video 标签</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">&quot;path/to/movie.mp4&quot;</span> <span class="attr">controls</span>=<span class="string">&quot;controls&quot;</span>&gt;</span></span><br><span class="line">  您的浏览器不支持 video 标签。</span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>属性：</p>
<ul>
<li>autoplay: 如果出现该属性，则视频在就绪后马上播放</li>
<li>controls：如果出现该属性，则向用户显示控件，比如播放按钮</li>
<li>loop：如果出现该属性，则当媒介文件完成播放后再次开始播放</li>
<li>muted：规定视频的音频输出应该被静音</li>
<li>poster：规定视频下载时显示的图像，或者在用户点击播放按钮前显示的图像</li>
<li>preload：如果出现该属性，则视频在页面加载时进行加载，并预备播放。如果使用 “autoplay”，则忽略该属性</li>
<li>src：要播放的视频的 URL</li>
<li>width：设置视频播放器的宽度，单位 px</li>
<li>height：设置视频播放器的高度，单位 px</li>
</ul>
<p>我们在进行音视频通话时，通常</p>
<p><strong>本地视频（我方视频）</strong>应如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">id</span>=<span class="string">&quot;local&quot;</span> <span class="attr">muted</span> <span class="attr">autoplay</span>&gt;</span>您的浏览器不支持 video 标签。<span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>本地视频静音播放，因为我们无需我们自己发出的声音，因为我们到时候视频资源是从设备直接实时获取视频流，因此无需设置 src，并且设置<code>autoplay</code>，可以让我们获取到视频流直接播放。</p>
<p><strong>远程视频（对方视频）</strong>应如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">id</span>=<span class="string">&quot;remote&quot;</span> <span class="attr">poster</span>=<span class="string">&quot;xxx&quot;</span> <span class="attr">autoplay</span>&gt;</span>您的浏览器不支持 video 标签。<span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>远程视频同样设置<code>autoplay</code>属性，让接收到的视频流直接播放。另外可设置一个<code>poster</code>属性，可以在呼叫过程中或者被呼叫时，让页面显示呼叫中或者是显示对方头像肖像等，不然页面全黑会显得很尴尬。</p>
<p><strong>(2) video 对象</strong></p>
<p>使用音视频通话，我们控制音视频的播放基本通过<code>js</code>实现的，就连前面介绍的<code>video标签</code>一般都是通过<code>js</code>创建。<code>video</code>对象有很多属性，我这里只简单介绍部分属性，能基本满足 WebRTC 音视频通话。</p>
<p>我们要实现音视频实时通讯，传递的数据是音视频流，音视频流怎么让<code>video</code>播放出来呢？看看下面代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 视频流绑定到video节点展示</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;dom&#125;</span> </span>video video节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;obj&#125;</span> </span>stream 视频流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> pushStreamToVideo = <span class="function">(<span class="params">video, stream</span>) =&gt;</span> &#123;</span><br><span class="line">  video.srcObject = stream;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取video节点</span></span><br><span class="line"><span class="keyword">const</span> domLocalVideo = $(<span class="string">&quot;#local&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用摄像头</span></span><br><span class="line">navigator.mediaDevices</span><br><span class="line">  .getUserMedia(&#123;</span><br><span class="line">    audio: <span class="literal">true</span>,</span><br><span class="line">    video: <span class="literal">true</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">stream</span>) =&gt;</span> &#123;</span><br><span class="line">    pushStreamToVideo(domLocalVideo[<span class="number">0</span>], stream); <span class="comment">// 实时显示</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    alert(<span class="string">`getUserMedia() error: <span class="subst">$&#123;err.name&#125;</span>`</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>不难看出，<code>video</code>对象有个<code>srcObject</code>的属性，初始时该属性值是<code>null</code>，将我们获取到音视频流直接赋值给该属性，我们的<code>video</code>标签就可以实时播放了。上面这个例子是调用本地摄像头并展示到一个 id=local 的<code>video</code>标签上，需要在 https 上就可以正常运行了。</p>
<p><strong>我们如何关闭视频呢？</strong></p>
<p>方法一：简单粗暴，关闭页面或者关闭浏览器。（你会让用户这么干么？）</p>
<p>方法二：使用<code>MediaStream.getTracks()</code>，获取到所有媒体流轨道，每条轨道调用一个方法<code>stop()</code>，就可以关闭当前流，摄像头也会停止录制。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 关闭摄像头</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;dom&#125;</span> </span>video video节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> closeCamera = <span class="function">(<span class="params">video</span>) =&gt;</span> &#123;</span><br><span class="line">  video.srcObject.getTracks()[<span class="number">0</span>].stop(); <span class="comment">// audio</span></span><br><span class="line">  video.srcObject.getTracks()[<span class="number">1</span>].stop(); <span class="comment">// video</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>音频是第一条轨道，视频是第二条轨道，两个同时关闭即可。</p>
<h2 id="3-3-WebRTC"><a href="#3-3-WebRTC" class="headerlink" title="3.3 WebRTC"></a>3.3 WebRTC</h2><blockquote>
<p>官方文档（不推荐）：<a target="_blank" rel="noopener" href="https://www.w3.org/TR/webrtc/#peer-to-peer-connections">https://www.w3.org/TR/webrtc/#peer-to-peer-connections</a></p>
</blockquote>
<blockquote>
<p>官方文档中文翻译（不推荐）：<a target="_blank" rel="noopener" href="https://github.com/RTC-Developer/WebRTC-Documentation-in-Chinese/tree/master/resource">https://github.com/RTC-Developer/WebRTC-Documentation-in-Chinese/tree/master/resource</a></p>
</blockquote>
<blockquote>
<p>MDN Web Docs（推荐）：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API">https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API</a></p>
</blockquote>
<h3 id="3-3-1-RTCPeerConnection"><a href="#3-3-1-RTCPeerConnection" class="headerlink" title="3.3.1 RTCPeerConnection"></a>3.3.1 RTCPeerConnection</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/">https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/</a></p>
</blockquote>
<p><code>RTCPeerConnection</code>是浏览器之间点对点连接的核心 API，用于处理对等体之间流数据的稳定和有效通信，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pc = <span class="keyword">new</span> RTCPeerConnection(serverConfig);</span><br></pre></td></tr></table></figure>

<p>serverConfig 包含 iceServers 参数，它包含有关 STUN 和 TURN 服务器相关信息数组，在查找 ICE 的时候候选使用。可以在网上找一些公共的 STUN 服务器，也可以使用前面章节我们自己通过 coturn 搭建的 STUN 服务器。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> serverConfig = &#123;</span><br><span class="line">  iceServers: [</span><br><span class="line">    &#123;</span><br><span class="line">      urls: <span class="string">&quot;stun:stun.xten.com&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      urls: <span class="string">&quot;stun:你的服务器ip:3478&quot;</span>, <span class="comment">// 见2.1服务器搭建</span></span><br><span class="line">      username: <span class="string">&quot;用户名&quot;</span>,</span><br><span class="line">      credential: <span class="string">&quot;密码&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>(1) onicecandidate = eventHandler</strong></p>
<p>作用：监听 RTCPeerConnection 实例上发生 icecandidate 事件，该函数会返回 ICE 协商结果，我们需要将结果发送给信令服务器，交由信令服务器转发给对方。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pc.onicecandidate = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (event.candidate) &#123;</span><br><span class="line">    sendCandidateToRemotePeer(event.candidate);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* there are no more candidates coming during this negotiation */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>(2) ontrack = eventHandler</strong></p>
<p>作用：监听 RTCPeerConnection 实例上接收到远程的数据流，该函数可获取到对端的媒体流。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pc.ontrack = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&quot;received_video&quot;</span>).srcObject = event.streams[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>(3) addTrack(track, stream…)</strong></p>
<p>作用：设置轨道，该轨道将会在连同后传输到对端。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">openCall</span>(<span class="params">pc</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> gumStream = <span class="keyword">await</span> navigator.mediaDevices.getUserMedia(&#123;<span class="attr">video</span>: <span class="literal">true</span>, <span class="attr">audio</span>: <span class="literal">true</span>&#125;);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> track <span class="keyword">of</span> gumStream.getTracks()) &#123;</span><br><span class="line">    pc.addTrack(track);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MDN 不建议使用 addStream()</p>
<p><strong>(3) removeTrack(sender)</strong></p>
<p>作用：删除轨道，删除已添加的轨道，用于挂断的时候</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pc, sender;</span><br><span class="line">navigator.getUserMedia(&#123; <span class="attr">video</span>: <span class="literal">true</span> &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">stream</span>) </span>&#123;</span><br><span class="line">  pc = <span class="keyword">new</span> RTCPeerConnection();</span><br><span class="line">  <span class="keyword">var</span> track = stream.getVideoTracks()[<span class="number">0</span>];</span><br><span class="line">  sender = pc.addTrack(track, stream);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;closeButton&quot;</span>).addEventListener(</span><br><span class="line">  <span class="string">&quot;click&quot;</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    pc.removeTrack(sender);</span><br><span class="line">    pc.close();</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>不建议的：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/onremovestream">onremovestream</a></p>
<p><strong>(5) setLocalDescription()/setRemoteDescription()</strong></p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/setLocalDescription">setLocalDescription(sessionDescription)</a>：</p>
<p>设置本地 offer，将自己的描述信息加入到<code>PeerConnection</code>中，参数类型：<code>RTCSessionDescription</code>（见下一小节 3.2.2 RTCSessionDescription）</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/setRemoteDescription">setRemoteDescription(sessionDescription)</a>：</p>
<p>设置远端的<code>answer</code>，将对方的描述信息加入到<code>PeerConnection</code>中，参数类型：<code>RTCSessionDescription</code>（见下一小节 3.2.2 RTCSessionDescription）</p>
<img src="/2021/03/11/WebRTC%E5%85%A5%E9%97%A8/2017-signaling-state-diagram.png" class="">

<p>通俗说：<code>Alice</code>为了和<code>Bob</code>建立合作关系(连接)，<code>Alice</code>我把拟好了一份合同，并签字了，我这里先保留扫描版，纸质合同通过快递(SDP)给你了，你通过快递(SDP)拿到合同后，先签字确认，这时候纸质合同上都有我们双方的签名了，但我这边还没有你的签名。你保存一下扫描版，然后通过快递把纸质再给我发回来，我拿到快递后，我也保存一下扫描版。这样，你我双放都有双方签名的扫描版合同。合同开始生效！</p>
<p><strong>(6) createOffer()/createAnswer()</strong></p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/createOffer">createOffer([options])</a>：</p>
<p>创建一个<code>offer</code>，表示我方的请求。通常在 WebRTC 通信中，我们会请求对方接收我们的<code>音频</code>和<code>视频</code>数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> offerOptions = &#123;</span><br><span class="line">  offerToReceiveAudio: <span class="literal">true</span>, <span class="comment">// 请求接收音频</span></span><br><span class="line">  offerToReceiveVideo: <span class="literal">true</span>, <span class="comment">// 请求接收视频</span></span><br><span class="line">&#125;,</span><br><span class="line">pc.createOffer(offerOptions)</span><br><span class="line">        .then(<span class="function"><span class="params">offer</span> =&gt;</span> onCreateOfferSuccess(offer.sdp))</span><br><span class="line">        .catch(<span class="function"><span class="params">error</span> =&gt;</span> onCreateOfferError());</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/createAnswer">createAnswer([options])</a>：</p>
<p>创建一个<code>answer</code>，回应对方<code>offer</code>。<code>answer</code>也是有<code>offer</code>作用的，在回应的时候，表示<code>答应</code>你，并向你<code>请求</code>。</p>
<p>打个比方：A 向 B 表白，请求 B 做 A 的女朋友。如果 B 接受了，表示 B 成了 A 女朋友。同时，这也有另外一层含义，表示 B 有请求：请 A 做我的男朋友。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> answerOptions = &#123;</span><br><span class="line">  offerToReceiveAudio: <span class="literal">true</span>, <span class="comment">// 请求接收音频</span></span><br><span class="line">  offerToReceiveVideo: <span class="literal">true</span>, <span class="comment">// 请求接收视频</span></span><br><span class="line">&#125;,</span><br><span class="line">pc.createAnswer(answerOptions)</span><br><span class="line">        .then(<span class="function"><span class="params">answer</span> =&gt;</span> onCreateAnswerSuccess(answer.sdp))</span><br><span class="line">        .catch(<span class="function"><span class="params">error</span> =&gt;</span> onCreateAnswerError());</span><br></pre></td></tr></table></figure>

<h3 id="3-3-2-RTCSessionDescription"><a href="#3-3-2-RTCSessionDescription" class="headerlink" title="3.3.2 RTCSessionDescription"></a>3.3.2 RTCSessionDescription</h3><p>用于生成 Offer/Answer 协商过程中 SDP 协议的相关描述。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> RTCSessionDescription(rtcDescription);</span><br></pre></td></tr></table></figure>

<p>rtcDescription 只有两个属性：<code>type</code>，<code>sdp</code></p>
<ul>
<li><code>type</code>只能设置：’answer’，’offer’，’pranswer’，’rollback’；</li>
<li><code>sdp</code>是标准的 SDP 会话描述（可由 createOffer/createAnswer 生成）</li>
</ul>
<h3 id="3-3-3-RTCIceCandidate"><a href="#3-3-3-RTCIceCandidate" class="headerlink" title="3.3.3 RTCIceCandidate"></a>3.3.3 RTCIceCandidate</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/RTCIceCandidate">https://developer.mozilla.org/en-US/docs/Web/API/RTCIceCandidate</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.51cto.com/zhangjunhd/25481">https://blog.51cto.com/zhangjunhd/25481</a></p>
</blockquote>
<p>用于建立 ICE 连接。通常我们不会手动去实例化一个<code>RTCIceCandidate</code>对象，在前面<code>3.3.1 RTCPeerConnection</code>中的<code>onicecandidate</code>事件回调就是一个<code>RTCIceCandidate</code>对象，我们只需要了解其中几个属性即可。</p>
<ul>
<li><strong>candidate</strong>: 用于连接性检测的对象</li>
<li><strong>sdpMid</strong>: candidate 的媒体流的识别标签</li>
<li><strong>sdpMLineIndex</strong>: candidate 的媒体流的相关联的 SDP 描述索引号</li>
<li>address: 本机 IP 地址</li>
<li>relatedAddress: 中继 IP</li>
<li>port: 本机端口</li>
<li>relatedPort: 中继端口</li>
<li>component: 候选协议，只有两种情况：<code>RTP</code>(Real-Time Transport Protocol)， <code>RTCP</code>(Real-Time Transport Control Protocol)</li>
<li>foundation: 来自于 STUN 服务器的唯一标识符</li>
<li>priority: 优先级</li>
<li>tcpType: 如果使用的 TCP 协议，这个属性及表示 TCP 的状态</li>
<li>type: <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/RTCIceCandidateType">RTCIceCandidateType 类型</a></li>
<li>usernameFragment: <code>ice-ufrag</code>片段，用于生成<code>ice-pwd</code>，同一 ICE 进程的连接都将使用的是同一个片段。</li>
</ul>
<h1 id="四、实战开发"><a href="#四、实战开发" class="headerlink" title="四、实战开发"></a>四、实战开发</h1><p>前面基本上已经列举了大部分基础知识，现在开始运用起来。</p>
<p>本章实战开发，是开发一个 <strong>web 实时音视频聊天室</strong> ：输入相同房间号，即可加入聊天室，进行视频聊天。</p>
<p>主要有两个项目，前端界面(页面+WebRTC+socket.io)，后端信令服务器控制转发(Express+socket.io)。</p>
<p>整个项目完整代码：<a target="_blank" rel="noopener" href="http://223.223.179.203:8929/product/cp6666/webrtc-demo">http://223.223.179.203:8929/product/cp6666/webrtc-demo</a></p>
<h2 id="4-1-环境准备"><a href="#4-1-环境准备" class="headerlink" title="4.1 环境准备"></a>4.1 环境准备</h2><ul>
<li>anywhere: <code>npm i -g anywhere</code></li>
</ul>
<h2 id="4-2-信令服务器"><a href="#4-2-信令服务器" class="headerlink" title="4.2 信令服务器"></a>4.2 信令服务器</h2><p>因为信令服务器代码结构比较简单，咱们先开发信令服务器。观察<code>1.5 经典WebRTC连接建立流程</code>，不难发现，信令服务器主要需要实现：转发<code>offer</code>、转发<code>answer</code>、转发<code>candidate</code>的三大核心功能。此外，我们开发聊天室，还需要：创建聊天室、退出聊天室的功能。</p>
<img src="/2021/03/11/WebRTC%E5%85%A5%E9%97%A8/20200618134458727.png" class="">

<h3 id="4-2-1-搭建项目"><a href="#4-2-1-搭建项目" class="headerlink" title="4.2.1 搭建项目"></a>4.2.1 搭建项目</h3><p>（1）创建一个文件夹<code>signal-server</code>，在目录下创建两个文件：</p>
<p>package.json</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;signal-server&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;author&quot;</span>: <span class="string">&quot;Patrick Jun&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;A webRTC signal server&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;node app.js&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;express&quot;</span>: <span class="string">&quot;^4.17.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;express-session&quot;</span>: <span class="string">&quot;^1.17.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;socket.io&quot;</span>: <span class="string">&quot;^2.3.0&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>app.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> https = <span class="built_in">require</span>(<span class="string">&quot;https&quot;</span>); <span class="comment">// https服务</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>); <span class="comment">// fs</span></span><br><span class="line"><span class="keyword">const</span> socketIO = <span class="built_in">require</span>(<span class="string">&quot;socket.io&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取密钥和签名证书</span></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  key: fs.readFileSync(<span class="string">&quot;keys/server_key.pem&quot;</span>),</span><br><span class="line">  cert: fs.readFileSync(<span class="string">&quot;keys/server_crt.pem&quot;</span>),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建https服务器</span></span><br><span class="line"><span class="keyword">const</span> apps = https.createServer(options);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SSL_PORT = <span class="number">8443</span>;</span><br><span class="line"></span><br><span class="line">apps.listen(SSL_PORT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建signal server</span></span><br><span class="line"><span class="keyword">const</span> io = socketIO.listen(apps);</span><br><span class="line"></span><br><span class="line"><span class="comment">// socket监听连接</span></span><br><span class="line">io.sockets.on(<span class="string">&quot;connection&quot;</span>, <span class="function">(<span class="params">socket</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;连接建立&quot;</span>);</span><br><span class="line">  <span class="comment">// 之后所有业务处理，写在这里面</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>（2）创建证书</p>
<p>在项目文件夹下，创建一个文件夹<code>keys</code>，然后开始生成自签名证书：</p>
<p>linux 环境下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -x509 -newkey rsa:2048 -keyout ./keys/server_key.pem -out ./keys/server_crt.pem -days 99999 -nodes</span><br></pre></td></tr></table></figure>

<p>windows 下：参考 <a target="_blank" rel="noopener" href="https://letsencrypt.org/zh-cn/docs/certificates-for-localhost/">https://letsencrypt.org/zh-cn/docs/certificates-for-localhost/</a></p>
<p>修改<code>app.js</code>，将秘钥和签名证书的路径改为你电脑中的绝对路径，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取密钥和签名证书</span></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  key: fs.readFileSync(<span class="string">&quot;D://signal-server/keys/server_key.pem&quot;</span>),</span><br><span class="line">  cert: fs.readFileSync(<span class="string">&quot;D://signal-server/keys/server_crt.pem&quot;</span>),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>（3）运行</p>
<p>在项目根目录下，安装依赖：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i</span><br></pre></td></tr></table></figure>

<p>然后，启动：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node app.js</span><br></pre></td></tr></table></figure>

<p>打开浏览器，访问：<code>https://localhost:8443</code></p>
<p>访问时，浏览器会提示不安全的访问，这个时候，直接敲键盘：<code>thisisunsafe</code> 即可继续访问。当看到浏览器地址栏继续一直在请求中，那么就表示项目成功运行。</p>
<h3 id="4-2-2-房间功能"><a href="#4-2-2-房间功能" class="headerlink" title="4.2.2 房间功能"></a>4.2.2 房间功能</h3><p>房间功能主要包括：创建/加入房间、退出房间。</p>
<p>业务处理，都放在连接成功后的回调函数里。</p>
<p>（1）创建房间</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// socket监听连接</span></span><br><span class="line">io.sockets.on(<span class="string">&quot;connection&quot;</span>, <span class="function">(<span class="params">socket</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;连接建立&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建/加入房间</span></span><br><span class="line">  socket.on(<span class="string">&quot;createAndJoinRoom&quot;</span>, <span class="function">(<span class="params">message</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; room &#125; = message;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Received createAndJoinRoom：&quot;</span> + room);</span><br><span class="line">    <span class="comment">// 判断room是否存在</span></span><br><span class="line">    <span class="keyword">const</span> clientsInRoom = io.sockets.adapter.rooms[room];</span><br><span class="line">    <span class="keyword">const</span> numClients = clientsInRoom</span><br><span class="line">      ? <span class="built_in">Object</span>.keys(clientsInRoom.sockets).length</span><br><span class="line">      : <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Room &quot;</span> + room + <span class="string">&quot; now has &quot;</span> + numClients + <span class="string">&quot; client(s)&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (numClients === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// room 不存在 不存在则创建（socket.join）</span></span><br><span class="line">      <span class="comment">// 加入并创建房间</span></span><br><span class="line">      socket.join(room);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;Client ID &quot;</span> + socket.id + <span class="string">&quot; created room &quot;</span> + room);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 发送消息至客户端 [id,room,peers]</span></span><br><span class="line">      <span class="keyword">const</span> data = &#123;</span><br><span class="line">        id: socket.id, <span class="comment">//socket id</span></span><br><span class="line">        room: room, <span class="comment">// 房间号</span></span><br><span class="line">        peers: [], <span class="comment">// 其他连接</span></span><br><span class="line">      &#125;;</span><br><span class="line">      socket.emit(<span class="string">&quot;created&quot;</span>, data);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// room 存在</span></span><br><span class="line">      <span class="comment">// 加入房间中</span></span><br><span class="line">      socket.join(room);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;Client ID &quot;</span> + socket.id + <span class="string">&quot; joined room &quot;</span> + room);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// joined告知房间里的其他客户端 [id,room]</span></span><br><span class="line">      io.sockets.in(room).emit(<span class="string">&quot;joined&quot;</span>, &#123;</span><br><span class="line">        id: socket.id, <span class="comment">//socket id</span></span><br><span class="line">        room: room, <span class="comment">// 房间号</span></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 发送消息至客户端 [id,room,peers]</span></span><br><span class="line">      <span class="keyword">const</span> data = &#123;</span><br><span class="line">        id: socket.id, <span class="comment">//socket id</span></span><br><span class="line">        room: room, <span class="comment">// 房间号</span></span><br><span class="line">        peers: [], <span class="comment">// 其他连接</span></span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="comment">// 查询其他连接</span></span><br><span class="line">      <span class="keyword">const</span> otherSocketIds = <span class="built_in">Object</span>.keys(clientsInRoom.sockets);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; otherSocketIds.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (otherSocketIds[i] !== socket.id) &#123;</span><br><span class="line">          data.peers.push(&#123;</span><br><span class="line">            id: otherSocketIds[i],</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      socket.emit(<span class="string">&quot;created&quot;</span>, data);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>（2）退出房间</p>
<p>在加入房间监听后面，继续添加：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 退出房间，转发exit消息至room其他客户端 [from,room]</span></span><br><span class="line">socket.on(<span class="string">&quot;exit&quot;</span>, <span class="function">(<span class="params">message</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(</span><br><span class="line">    <span class="string">&quot;Received exit: &quot;</span> + message.from + <span class="string">&quot; message: &quot;</span> + <span class="built_in">JSON</span>.stringify(message)</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">const</span> &#123; room &#125; = message;</span><br><span class="line">  <span class="comment">// 关闭该连接</span></span><br><span class="line">  socket.leave(room);</span><br><span class="line">  <span class="comment">// 转发exit消息至room其他客户端</span></span><br><span class="line">  <span class="keyword">const</span> clientsInRoom = io.sockets.adapter.rooms[room];</span><br><span class="line">  <span class="keyword">if</span> (clientsInRoom) &#123;</span><br><span class="line">    <span class="keyword">const</span> otherSocketIds = <span class="built_in">Object</span>.keys(clientsInRoom.sockets);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; otherSocketIds.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> otherSocket = io.sockets.connected[otherSocketIds[i]];</span><br><span class="line">      otherSocket.emit(<span class="string">&quot;exit&quot;</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>还有一种情况，当 socket 连接异常断开时，也需要退出房间：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// socket关闭</span></span><br><span class="line">socket.on(<span class="string">&quot;disconnect&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> socketId = socket.id;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;disconnect: &quot;</span> + socketId + <span class="string">&quot; reason:&quot;</span> + reason);</span><br><span class="line">  <span class="keyword">const</span> message = &#123;</span><br><span class="line">    <span class="keyword">from</span>: socketId,</span><br><span class="line">    room: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  socket.broadcast.emit(<span class="string">&quot;exit&quot;</span>, message);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="4-2-3-转发功能"><a href="#4-2-3-转发功能" class="headerlink" title="4.2.3 转发功能"></a>4.2.3 转发功能</h3><p>转发功能有：转发<code>offer</code>、转发<code>answer</code>、转发<code>candidate</code></p>
<p>（1）转发 offer</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转发offer消息至room其他客户端 [from,to,room,sdp]</span></span><br><span class="line">socket.on(<span class="string">&quot;offer&quot;</span>, <span class="function">(<span class="params">message</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// const room = Object.keys(socket.rooms)[1];</span></span><br><span class="line">  <span class="built_in">console</span>.log(</span><br><span class="line">    <span class="string">&quot;收到offer: from &quot;</span> +</span><br><span class="line">      message.from +</span><br><span class="line">      <span class="string">&quot; room:&quot;</span> +</span><br><span class="line">      message.room +</span><br><span class="line">      <span class="string">&quot; to &quot;</span> +</span><br><span class="line">      message.to</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// 根据id找到对应连接</span></span><br><span class="line">  <span class="keyword">const</span> otherClient = io.sockets.connected[message.to];</span><br><span class="line">  <span class="keyword">if</span> (!otherClient) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 转发offer消息至其他客户端</span></span><br><span class="line">  otherClient.emit(<span class="string">&quot;offer&quot;</span>, message);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>（2）转发 answer</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转发answer消息至room其他客户端 [from,to,room,sdp]</span></span><br><span class="line">socket.on(<span class="string">&quot;answer&quot;</span>, <span class="function">(<span class="params">message</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// const room = Object.keys(socket.rooms)[1];</span></span><br><span class="line">  <span class="built_in">console</span>.log(</span><br><span class="line">    <span class="string">&quot;收到answer: from &quot;</span> +</span><br><span class="line">      message.from +</span><br><span class="line">      <span class="string">&quot; room:&quot;</span> +</span><br><span class="line">      message.room +</span><br><span class="line">      <span class="string">&quot; to &quot;</span> +</span><br><span class="line">      message.to</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// 根据id找到对应连接</span></span><br><span class="line">  <span class="keyword">const</span> otherClient = io.sockets.connected[message.to];</span><br><span class="line">  <span class="keyword">if</span> (!otherClient) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 转发answer消息至其他客户端</span></span><br><span class="line">  otherClient.emit(<span class="string">&quot;answer&quot;</span>, message);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>（3）转发 candidate</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转发candidate消息至room其他客户端 [from,to,room,candidate[sdpMid,sdpMLineIndex,sdp]]</span></span><br><span class="line">socket.on(<span class="string">&quot;candidate&quot;</span>, <span class="function">(<span class="params">message</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(</span><br><span class="line">    <span class="string">&quot;收到candidate: from &quot;</span> +</span><br><span class="line">      message.from +</span><br><span class="line">      <span class="string">&quot; room:&quot;</span> +</span><br><span class="line">      room +</span><br><span class="line">      <span class="string">&quot; to &quot;</span> +</span><br><span class="line">      message.to</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// 根据id找到对应连接</span></span><br><span class="line">  <span class="keyword">const</span> otherClient = io.sockets.connected[message.to];</span><br><span class="line">  <span class="keyword">if</span> (!otherClient) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 转发candidate消息至其他客户端</span></span><br><span class="line">  otherClient.emit(<span class="string">&quot;candidate&quot;</span>, message);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="4-2-4-完整代码"><a href="#4-2-4-完整代码" class="headerlink" title="4.2.4 完整代码"></a>4.2.4 完整代码</h3><p><a target="_blank" rel="noopener" href="http://223.223.179.203:8929/product/cp6666/webrtc-demo/-/tree/master/signal-server">http://223.223.179.203:8929/product/cp6666/webrtc-demo/-/tree/master/signal-server</a></p>
<h2 id="4-3-前端"><a href="#4-3-前端" class="headerlink" title="4.3 前端"></a>4.3 前端</h2><p>前端可以分为三大功能：音视频设备控制和音视频显示控制、Offer/Answer 沟通、ICE 连接。</p>
<img src="/2021/03/11/WebRTC%E5%85%A5%E9%97%A8/20200618134458727.png" class="">

<h3 id="4-3-1-搭建项目"><a href="#4-3-1-搭建项目" class="headerlink" title="4.3.1 搭建项目"></a>4.3.1 搭建项目</h3><p>（1）创建一个文件夹<code>webrtc-client</code>，在目录下创建一个<code>index.html</code>文件，创建一个目录`js</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|- webrtc-client/</span><br><span class="line">   |- js/</span><br><span class="line">   |- index.html</span><br></pre></td></tr></table></figure>

<p>（2）在<code>js</code>目录下创建几个文件，并在从网上下载<code>socket.io.js</code>和<code>jquery.min.js</code>文件</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">|- webrtc-client/</span><br><span class="line">   |- js/</span><br><span class="line">      |- config.js</span><br><span class="line">      |- sdk.js</span><br><span class="line">      |- main.js</span><br><span class="line">      |- socket.io.js  // 自行从网上下载</span><br><span class="line">      |- jquery.min.js // 自行从网上下载</span><br><span class="line">   |- index.html</span><br></pre></td></tr></table></figure>

<p>（3）代码</p>
<p>index.html</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span></span></span><br><span class="line"><span class="tag">      <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no&quot;</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>WebRtc视频通话demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">      video &#123;</span><br><span class="line">        background-color: bisque;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/socket.io.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/config.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/sdk.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;room&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;输入房间号&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;connect&quot;</span>&gt;</span>连接<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;logout&quot;</span>&gt;</span>挂断<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>本地视频<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">video</span></span></span><br><span class="line"><span class="tag">      <span class="attr">id</span>=<span class="string">&quot;localVideo&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">style</span>=<span class="string">&quot;width:200px;height:200px;&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">autoplay</span></span></span><br><span class="line"><span class="tag">      <span class="attr">muted</span></span></span><br><span class="line"><span class="tag">    &gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>远程视频<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;remoteDiv&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>config.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WebRTC配置文件</span></span><br><span class="line"><span class="keyword">const</span> THSConfig = &#123;</span><br><span class="line">  <span class="comment">// 信令服务器</span></span><br><span class="line">  signalServer: <span class="string">&quot;wss://localhost:8443&quot;</span>,</span><br><span class="line">  <span class="comment">// Offer/Answer模型请求配置</span></span><br><span class="line">  offerOptions: &#123;</span><br><span class="line">    offerToReceiveAudio: <span class="literal">true</span>, <span class="comment">// 请求接收音频</span></span><br><span class="line">    offerToReceiveVideo: <span class="literal">true</span>, <span class="comment">// 请求接收视频</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ICE服务器</span></span><br><span class="line">  iceServers: &#123;</span><br><span class="line">    iceServers: [</span><br><span class="line">      &#123; <span class="attr">urls</span>: <span class="string">&quot;stun:stun.xten.com&quot;</span> &#125;, <span class="comment">// Safri兼容：url -&gt; urls</span></span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-2-兼容预处理"><a href="#4-3-2-兼容预处理" class="headerlink" title="4.3.2 兼容预处理"></a>4.3.2 兼容预处理</h3><p>因为部分<code>web API</code>在不同浏览器有不同的名称或者属性，因此需要处理兼容，以下是兼容代码，预先定义一下。</p>
<p>编辑<code>sdk.js</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 兼容处理</span></span><br><span class="line"><span class="keyword">const</span> PeerConnection =</span><br><span class="line">  <span class="built_in">window</span>.RTCPeerConnection ||</span><br><span class="line">  <span class="built_in">window</span>.mozRTCPeerConnection ||</span><br><span class="line">  <span class="built_in">window</span>.webkitRTCPeerConnection;</span><br><span class="line"><span class="keyword">const</span> SessionDescription =</span><br><span class="line">  <span class="built_in">window</span>.RTCSessionDescription ||</span><br><span class="line">  <span class="built_in">window</span>.mozRTCSessionDescription ||</span><br><span class="line">  <span class="built_in">window</span>.webkitRTCSessionDescription;</span><br><span class="line"><span class="keyword">const</span> GET_USER_MEDIA = navigator.getUserMedia</span><br><span class="line">  ? <span class="string">&quot;getUserMedia&quot;</span></span><br><span class="line">  : navigator.mozGetUserMedia</span><br><span class="line">  ? <span class="string">&quot;mozGetUserMedia&quot;</span></span><br><span class="line">  : navigator.webkitGetUserMedia</span><br><span class="line">  ? <span class="string">&quot;webkitGetUserMedia&quot;</span></span><br><span class="line">  : <span class="string">&quot;getUserMedia&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> v = <span class="built_in">document</span>.createElement(<span class="string">&quot;video&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> SRC_OBJECT =</span><br><span class="line">  <span class="string">&quot;srcObject&quot;</span> <span class="keyword">in</span> v</span><br><span class="line">    ? <span class="string">&quot;srcObject&quot;</span></span><br><span class="line">    : <span class="string">&quot;mozSrcObject&quot;</span> <span class="keyword">in</span> v</span><br><span class="line">    ? <span class="string">&quot;mozSrcObject&quot;</span></span><br><span class="line">    : <span class="string">&quot;webkitSrcObject&quot;</span> <span class="keyword">in</span> v</span><br><span class="line">    ? <span class="string">&quot;webkitSrcObject&quot;</span></span><br><span class="line">    : <span class="string">&quot;srcObject&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-3-音视频控制"><a href="#4-3-3-音视频控制" class="headerlink" title="4.3.3 音视频控制"></a>4.3.3 音视频控制</h3><p>音视频控制主要分打开关闭摄像头，视频流绑定到<code>video</code>标签，其实这一节前面<code>3.2 音视频相关API</code>已经学习过了，这里直接给出代码。</p>
<p>接着编辑<code>sdk.js</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动摄像头</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> openCamera = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> navigator.mediaDevices[GET_USER_MEDIA](&#123;</span><br><span class="line">    audio: <span class="literal">true</span>,</span><br><span class="line">    video: <span class="literal">true</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 关闭摄像头</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;dom&#125;</span> </span>video video节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> closeCamera = <span class="function">(<span class="params">video</span>) =&gt;</span> &#123;</span><br><span class="line">  video[SRC_OBJECT].getTracks()[<span class="number">0</span>].stop(); <span class="comment">// audio</span></span><br><span class="line">  video[SRC_OBJECT].getTracks()[<span class="number">1</span>].stop(); <span class="comment">// video</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 视频流绑定到video节点展示</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;dom&#125;</span> </span>video video节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;obj&#125;</span> </span>stream 视频流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> pushStreamToVideo = <span class="function">(<span class="params">video, stream</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;视频流绑定到video节点展示&quot;</span>, video, stream);</span><br><span class="line">  video[SRC_OBJECT] = stream;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>编辑<code>main.js</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * dom获取</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> btnConnect = $(<span class="string">&quot;#connect&quot;</span>); <span class="comment">// 连接dom</span></span><br><span class="line"><span class="keyword">const</span> btnLogout = $(<span class="string">&quot;#logout&quot;</span>); <span class="comment">// 挂断dom</span></span><br><span class="line"><span class="keyword">const</span> domLocalVideo = $(<span class="string">&quot;#localVideo&quot;</span>); <span class="comment">// 本地视频dom</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 连接</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">btnConnect.click(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//启动摄像头</span></span><br><span class="line">  <span class="keyword">if</span> (localStream == <span class="literal">null</span>) &#123;</span><br><span class="line">    openCamera()</span><br><span class="line">      .then(<span class="function">(<span class="params">stream</span>) =&gt;</span> &#123;</span><br><span class="line">        pushStreamToVideo(domLocalVideo[<span class="number">0</span>], stream);</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function">(<span class="params">e</span>) =&gt;</span> alert(<span class="string">`getUserMedia() error: <span class="subst">$&#123;e.name&#125;</span>`</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 挂断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">btnLogout.click(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  closeCamera(domLocalVideo[<span class="number">0</span>]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>测试一下摄像头功能，因为开启摄像头需要使用 https 服务，因此在前端项目根目录打开控制台命令，运行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">anywhere 5000</span><br></pre></td></tr></table></figure>

<p>然后浏览器打开命令行提示里的端口号为<code>5001</code>的那个 https 协议的地址，例如：<code>https://192.168.1.4:5001/</code></p>
<p>这时候，可能也会提示您的连接不是私密连接，点击<code>高级</code>，最下面<code>继续前往</code>。</p>
<p>点击<code>连接</code>按钮，允许访问摄像头，看摄像头是否正常打开，页面视频是否出现，然后点击<code>断开</code>，看摄像头是否关闭、画面是否消失。</p>
<h3 id="4-3-4-Offer-Answer-模型"><a href="#4-3-4-Offer-Answer-模型" class="headerlink" title="4.3.4 Offer/Answer 模型"></a>4.3.4 Offer/Answer 模型</h3><p>从这节开始，就正式涉及到<code>WebRTC</code>相关 API 了，下面先写几个全局变量，用于保存一些公用数据：</p>
<p>编辑<code>sdk.js</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// socket连接</span></span><br><span class="line"><span class="keyword">const</span> socket = io(THSConfig.signalServer);</span><br><span class="line"><span class="comment">// 本地socket id</span></span><br><span class="line"><span class="keyword">let</span> socketId;</span><br><span class="line"><span class="comment">// 房间 id</span></span><br><span class="line"><span class="keyword">let</span> roomId;</span><br><span class="line"><span class="comment">// 对RTCPeerConnection连接进行缓存</span></span><br><span class="line"><span class="keyword">let</span> rtcPeerConnects = &#123;&#125;;</span><br><span class="line"><span class="comment">// 本地stream</span></span><br><span class="line"><span class="keyword">let</span> localStream = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>（1）加入房间</p>
<p>在开始 Offer/Answer 模型前，我们必须得至少有两个客户端才行。因此，我们先写一下，怎么控制房间。</p>
<p>咱们先整理一下思路，我们先让<code>甲</code>创建一个房间，然后，这个房间里只有<code>甲</code>一个人，无法进行 Offer/Answer。这时候<code>乙</code>在进入房间时，可以获取一下房间的人数，如果房间有人，那么<code>乙</code>就给房间里的每一个人发送<code>Offer</code>请求。房间里的<code>甲</code>监听到了刚进来<code>乙</code>的 Offer 后，给<code>乙</code>回复 Answer。这样就建立起了<code>Offer/Answer</code>模型。</p>
<p>编辑<code>sdk.js</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 连接（给signal server 发送创建或者加入房间的消息）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>roomid 房间号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> connect = <span class="function">(<span class="params">roomid</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;创建或者加入房间&quot;</span>, roomid);</span><br><span class="line">  socket.emit(<span class="string">&quot;createAndJoinRoom&quot;</span>, &#123;</span><br><span class="line">    room: roomid,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 监听signal server创建房间或者加入房间成功的消息，signal server会判断房间里是否有人</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">socket.on(<span class="string">&quot;created&quot;</span>, <span class="keyword">async</span> (data) =&gt; &#123;</span><br><span class="line">  <span class="comment">// data: [id,room,peers]</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;created: &quot;</span>, data);</span><br><span class="line">  <span class="comment">// 保存signal server给我分配的socketId</span></span><br><span class="line">  socketId = data.id;</span><br><span class="line">  <span class="comment">// 保存创建房间或者加入房间的room id</span></span><br><span class="line">  roomId = data.room;</span><br><span class="line">  <span class="comment">// 如果data.peers = []，说明房间里没有人，是创建房间，以下步骤则不会执行</span></span><br><span class="line">  <span class="comment">// 如果data.peers != []，说明房间里有人，是加入房间，给返回的每一个peers，创建WebRtcPeerConnection并发送offer消息</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; data.peers.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> otherSocketId = data.peers[i].id;</span><br><span class="line">    <span class="comment">// 创建WebRtcPeerConnection // 注意：这个函数是下一个步骤写的。</span></span><br><span class="line">    <span class="keyword">let</span> pc = getWebRTCConnect(otherSocketId);</span><br><span class="line">    <span class="comment">// 创建offer</span></span><br><span class="line">    <span class="keyword">const</span> offer = <span class="keyword">await</span> pc.createOffer(THSConfig.offerOptions);</span><br><span class="line">    <span class="comment">// 发送offer</span></span><br><span class="line">    onCreateOfferSuccess(pc, otherSocketId, offer);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * offer创建成功回调</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">pc</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">otherSocketId</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">offer</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onCreateOfferSuccess</span>(<span class="params">pc, otherSocketId, offer</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(</span><br><span class="line">    <span class="string">&quot;createOffer: success &quot;</span> + <span class="string">&quot; id:&quot;</span> + otherSocketId + <span class="string">&quot; offer: &quot;</span>,</span><br><span class="line">    offer</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// 设置本地setLocalDescription 将自己的描述信息加入到PeerConnection中</span></span><br><span class="line">  pc.setLocalDescription(offer);</span><br><span class="line">  <span class="comment">// 构建offer</span></span><br><span class="line">  <span class="keyword">const</span> message = &#123;</span><br><span class="line">    <span class="keyword">from</span>: socketId,</span><br><span class="line">    to: otherSocketId,</span><br><span class="line">    room: roomId,</span><br><span class="line">    sdp: offer.sdp,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;发送offer消息&quot;</span>, message);</span><br><span class="line">  <span class="comment">// 发送offer消息</span></span><br><span class="line">  socket.emit(<span class="string">&quot;offer&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面，可以算是把<code>Offer</code>发出去了，可以回顾<code>4.2.3 转发功能</code>，信令服务器收到<code>Offer</code>后，会将其转发给房间里的每一个用户，然后，我们就需要写一个监听，当信令服务器转发过来<code>Offer</code>后，我们应该进行<code>Answer</code>：</p>
<p>继续编辑<code>sdk.js</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 监听signal server转发过来的offer消息，将对方的描述信息加入到PeerConnection中，然后构建answer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">socket.on(<span class="string">&quot;offer&quot;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// data:  [from,to,room,sdp]</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;收到offer: &quot;</span>, data);</span><br><span class="line">  <span class="comment">// 获取RTCPeerConnection</span></span><br><span class="line">  <span class="keyword">const</span> pc = getWebRTCConnect(data.from);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;getWebRTCConnect: &quot;</span>, pc);</span><br><span class="line">  <span class="comment">// 构建RTCSessionDescription参数</span></span><br><span class="line">  <span class="keyword">const</span> rtcDescription = &#123;</span><br><span class="line">    type: <span class="string">&quot;offer&quot;</span>,</span><br><span class="line">    sdp: data.sdp,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;offer设置远端setRemoteDescription&quot;</span>);</span><br><span class="line">  <span class="comment">// 设置远端setRemoteDescription</span></span><br><span class="line">  pc.setRemoteDescription(<span class="keyword">new</span> SessionDescription(rtcDescription));</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;setRemoteDescription: &quot;</span>, rtcDescription);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// createAnswer</span></span><br><span class="line">  pc.createAnswer(THSConfig.offerOptions)</span><br><span class="line">    .then(<span class="function">(<span class="params">offer</span>) =&gt;</span> onCreateAnswerSuccess(pc, data.from, offer))</span><br><span class="line">    .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> onCreateAnswerError(error));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * answer创建成功回调</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">pc</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">otherSocketId</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">offer</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onCreateAnswerSuccess</span>(<span class="params">pc, otherSocketId, offer</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(</span><br><span class="line">    <span class="string">&quot;createAnswer: success &quot;</span> + <span class="string">&quot; id:&quot;</span> + otherSocketId + <span class="string">&quot; offer: &quot;</span>,</span><br><span class="line">    offer</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// 设置本地setLocalDescription，将对方的描述信息加入到PeerConnection中</span></span><br><span class="line">  pc.setLocalDescription(offer);</span><br><span class="line">  <span class="comment">// 构建answer信息</span></span><br><span class="line">  <span class="keyword">const</span> message = &#123;</span><br><span class="line">    <span class="keyword">from</span>: socketId,</span><br><span class="line">    to: otherSocketId,</span><br><span class="line">    room: roomId,</span><br><span class="line">    sdp: offer.sdp,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;发送answer消息&quot;</span>, message);</span><br><span class="line">  <span class="comment">// 发送answer消息</span></span><br><span class="line">  socket.emit(<span class="string">&quot;answer&quot;</span>, message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * answer创建失败回调</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">error</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onCreateAnswerError</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;createAnswer: fail error &quot;</span> + error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们把<code>Answer</code>信息回复出去了，通过信令服务器会转发指定的用户（刚刚发来 offer 的用户），然后我们还要添加一个监听<code>Answer</code>的信息：</p>
<p>继续编辑<code>sdk.js</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 监听signal server转发过来的answer消息，将对方的描述信息加入到PeerConnection中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">socket.on(<span class="string">&quot;answer&quot;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// data:  [from,to,room,sdp]</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;收到answer: &quot;</span>, data);</span><br><span class="line">  <span class="comment">// 获取RTCPeerConnection</span></span><br><span class="line">  <span class="keyword">const</span> pc = getWebRTCConnect(data.from);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构建RTCSessionDescription参数</span></span><br><span class="line">  <span class="keyword">const</span> rtcDescription = &#123;</span><br><span class="line">    type: <span class="string">&quot;answer&quot;</span>,</span><br><span class="line">    sdp: data.sdp,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;answer设置远端setRemoteDescription&quot;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;setRemoteDescription: &quot;</span>, rtcDescription);</span><br><span class="line">  <span class="comment">//设置远端setRemoteDescription</span></span><br><span class="line">  pc.setRemoteDescription(<span class="keyword">new</span> SessionDescription(rtcDescription));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>（2）获取 RTCPeerConnection、移除 RTCPeerConnection</p>
<p>接上一步骤，其中涉及到一个<code>getWebRTCConnect</code>的方法，这节就写如何实现它，以及本地如何管理与他人的连接。</p>
<p>继续编辑<code>sdk.js</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对RTCPeerConnection连接进行缓存</span></span><br><span class="line"><span class="keyword">let</span> rtcPeerConnects = &#123;&#125;; <span class="comment">// 这是开始前设置的全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取RTCPeerConnection</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>otherSocketId 对方socketId</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getWebRTCConnect</span>(<span class="params">otherSocketId</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!otherSocketId) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 查询全局中是否已经保存了连接</span></span><br><span class="line">  <span class="keyword">let</span> pc = rtcPeerConnects[otherSocketId];</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;建立连接：&quot;</span>, otherSocketId, pc);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> pc === <span class="string">&quot;undefined&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果没有保存，就创建RTCPeerConnection</span></span><br><span class="line">    <span class="comment">// 构建RTCPeerConnection</span></span><br><span class="line">    pc = <span class="keyword">new</span> PeerConnection(THSConfig.iceServers); <span class="comment">// PeerConnection是4.3.2定义的兼容处理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置获取icecandidate信息回调 此处可暂时忽略，将在4.3.5讲解</span></span><br><span class="line">    pc.onicecandidate = <span class="function">(<span class="params">e</span>) =&gt;</span> onIceCandidate(pc, otherSocketId, e);</span><br><span class="line">    <span class="comment">// 设置获取对端stream数据回调-track方式 此处可暂时忽略，将在4.3.5讲解</span></span><br><span class="line">    pc.ontrack = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;我接到数据流了！！&quot;</span>, pc, otherSocketId, e);</span><br><span class="line">      onTrack(pc, otherSocketId, e);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 设置获取对端stream数据回调 此处可暂时忽略，将在4.3.5讲解</span></span><br><span class="line">    pc.onremovestream = <span class="function">(<span class="params">e</span>) =&gt;</span> onRemoveStream(pc, otherSocketId, e);</span><br><span class="line">    <span class="comment">// peer设置本地流 此处可暂时忽略，将在4.3.5讲解</span></span><br><span class="line">    <span class="keyword">if</span> (localStream != <span class="literal">null</span>) &#123;</span><br><span class="line">      localStream.getTracks().forEach(<span class="function">(<span class="params">track</span>) =&gt;</span> &#123;</span><br><span class="line">        pc.addTrack(track, localStream);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓存peer连接</span></span><br><span class="line">    rtcPeerConnects[otherSocketId] = pc;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除RTCPeerConnection连接缓存</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>otherSocketId 对方socketId</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeRtcConnect</span>(<span class="params">otherSocketId</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">delete</span> rtcPeerConnects[otherSocketId];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-5-ICE-连接-接收音视频流"><a href="#4-3-5-ICE-连接-接收音视频流" class="headerlink" title="4.3.5 ICE 连接/接收音视频流"></a>4.3.5 ICE 连接/接收音视频流</h3><p>Offer/Answer 模型让两个客户端互相建立了签订了合同，建立了信任的合作伙伴关系，接下来可以开始进行交易了（传输音视频数据）。在交易前，我们要互相知道对方真实的交易地址和银行账号（允许主机直连的地址，详细可回顾 1.4ICE 协议），我给你发货，你给我打钱。</p>
<p>通常，在第一步<code>乙</code>的<code>Offer</code>发出后，<code>乙客户端</code>就开始通过 ICE 获取自己的地址（通过 ICE 协议可以了解，这个地址可能是自己的 IP 地址），只要等<code>甲方</code>同意（设置远程描述完成，这时候可能还未回复 Answer），<code>甲方</code>就可以接收到<code>乙客户端</code>的音视频流了。同理，<code>甲方</code>回复的<code>Answer</code>之后，只要<code>乙客户端</code>同意，<code>乙客户端</code>也就能收到<code>甲方</code>的音视频流了。至此，双方都收到对方的视频流了，视频通话建立。</p>
<p>回顾上一小节 <code>4.3.4 (2) 获取RTCPeerConnection</code>中的一段代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建RTCPeerConnection</span></span><br><span class="line">pc = <span class="keyword">new</span> PeerConnection(THSConfig.iceServers); <span class="comment">// PeerConnection是4.3.2定义的兼容处理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 设置获取icecandidate信息回调</span></span><br><span class="line">pc.onicecandidate = <span class="function">(<span class="params">e</span>) =&gt;</span> onIceCandidate(pc, otherSocketId, e);</span><br><span class="line"><span class="comment">// 2. 设置获取对端stream数据回调-track方式  还有种方式是onaddstream，但这种方式已经不推荐使用了。</span></span><br><span class="line">pc.ontrack = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;我接到数据流了！！&quot;</span>, pc, otherSocketId, e);</span><br><span class="line">  onTrack(pc, otherSocketId, e);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 3. 设置获取对端stream数据回调</span></span><br><span class="line">pc.onremovestream = <span class="function">(<span class="params">e</span>) =&gt;</span> onRemoveStream(pc, otherSocketId, e);</span><br><span class="line"><span class="comment">// 4. peer设置本地流</span></span><br><span class="line"><span class="keyword">if</span> (localStream != <span class="literal">null</span>) &#123;</span><br><span class="line">  localStream.getTracks().forEach(<span class="function">(<span class="params">track</span>) =&gt;</span> &#123;</span><br><span class="line">    pc.addTrack(track, localStream);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例<code>pc</code>实际就是<code>window.RTCPeerConnection</code>对象，这个对象有几个回调方法在<code>3.3.1</code>节已经讲过了。</p>
<p>（1）onicecandidate</p>
<p>当 ICE 协商完成后，我们将协商结果发送至信令服务器，让其转发给指定的客户端。</p>
<p>继续编辑<code>sdk.js</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RTCPeerConnection 事件回调，获取icecandidate信息回调</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">pc</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">otherSocketId</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">event</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onIceCandidate</span>(<span class="params">pc, otherSocketId, event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;onIceCandidate to &quot;</span> + otherSocketId + <span class="string">&quot; candidate: &quot;</span>, event);</span><br><span class="line">  <span class="keyword">if</span> (event.candidate !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 构建信息 [from,to,room,candidate[sdpMid,sdpMLineIndex,sdp]]</span></span><br><span class="line">    <span class="keyword">const</span> message = &#123;</span><br><span class="line">      <span class="keyword">from</span>: socketId,</span><br><span class="line">      to: otherSocketId,</span><br><span class="line">      room: roomId,</span><br><span class="line">      candidate: &#123;</span><br><span class="line">        sdpMid: event.candidate.sdpMid,</span><br><span class="line">        sdpMLineIndex: event.candidate.sdpMLineIndex,</span><br><span class="line">        sdp: event.candidate.candidate,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;向信令服务器发送candidate&quot;</span>, message);</span><br><span class="line">    <span class="comment">// 向信令服务器发送candidate</span></span><br><span class="line">    socket.emit(<span class="string">&quot;candidate&quot;</span>, message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>远程客户端收到 candidate 后，添加 candidate 后即可接收到本机的音视频流：</p>
<p>继续编辑<code>sdk.js</code>，添加监听事件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 监听signal server转发过来的candidate消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">socket.on(<span class="string">&quot;candidate&quot;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// data:  [from,to,room,candidate[sdpMid,sdpMLineIndex,sdp]]</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;candidate: &quot;</span>, data);</span><br><span class="line">  <span class="keyword">const</span> iceData = data.candidate;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取RTCPeerConnection</span></span><br><span class="line">  <span class="keyword">const</span> pc = getWebRTCConnect(data.from);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> rtcIceCandidate = <span class="keyword">new</span> RTCIceCandidate(&#123;</span><br><span class="line">    candidate: iceData.sdp,</span><br><span class="line">    sdpMid: iceData.sdpMid,</span><br><span class="line">    sdpMLineIndex: iceData.sdpMLineIndex,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;添加对端Candidate&quot;</span>);</span><br><span class="line">  <span class="comment">// 添加对端Candidate</span></span><br><span class="line">  pc.addIceCandidate(rtcIceCandidate);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>（2）ontrack</p>
<p>当监听到对方传递过来时音视频流后，动态创建一个<code>video</code>标签，显示接收到的音视频流数据。</p>
<p>继续编辑<code>sdk.js</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取对端stream数据回调-ontrack模式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">pc</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">otherSocketId</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">event</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onTrack</span>(<span class="params">pc, otherSocketId, event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;onTrack from: &quot;</span> + otherSocketId);</span><br><span class="line">  <span class="keyword">let</span> otherVideoDom = $(<span class="string">&quot;#&quot;</span> + otherSocketId);</span><br><span class="line">  <span class="keyword">if</span> (otherVideoDom.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// TODO 未知原因：会两次onTrack，就会导致建立两次dom</span></span><br><span class="line">    <span class="keyword">const</span> video = <span class="built_in">document</span>.createElement(<span class="string">&quot;video&quot;</span>);</span><br><span class="line">    video.id = otherSocketId;</span><br><span class="line">    video.autoplay = <span class="string">&quot;autoplay&quot;</span>;</span><br><span class="line">    video.muted = <span class="string">&quot;muted&quot;</span>;</span><br><span class="line">    video.style.width = <span class="number">200</span>;</span><br><span class="line">    video.style.height = <span class="number">200</span>;</span><br><span class="line">    video.style.marginRight = <span class="number">5</span>;</span><br><span class="line">    $(<span class="string">&quot;#remoteDiv&quot;</span>).append(video);</span><br><span class="line">  &#125;</span><br><span class="line">  $(<span class="string">&quot;#&quot;</span> + otherSocketId)[<span class="number">0</span>][SRC_OBJECT] = event.streams[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）onremovestream</p>
<p>监听对方停止传输视频流的时候，我方进行相应处理：</p>
<p>继续编辑<code>sdk.js</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * onRemoveStream回调</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">pc</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">otherSocketId</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">event</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onRemoveStream</span>(<span class="params">pc, otherSocketId, event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;onRemoveStream from: &quot;</span> + otherSocketId);</span><br><span class="line">  <span class="comment">// peer关闭</span></span><br><span class="line">  getWebRTCConnect(otherSocketId).close;</span><br><span class="line">  <span class="comment">// 删除peer对象</span></span><br><span class="line">  removeRtcConnect(otherSocketId);</span><br><span class="line">  <span class="comment">// 移除video</span></span><br><span class="line">  $(<span class="string">&quot;#&quot;</span> + otherSocketId).remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）添加本地音视频流</p>
<p>当我方开启摄像头后，全局变量<code>localStream</code>就不为<code>null</code>，我们需要往对方塞过去我们的的音视频数据，通过<code>addTrack</code>方法。这样，在对方同意（添加我方描述）后，就可以获取到我方的音视频数据了。</p>
<h3 id="4-3-6-完善逻辑"><a href="#4-3-6-完善逻辑" class="headerlink" title="4.3.6 完善逻辑"></a>4.3.6 完善逻辑</h3><p>前面的内容基本把整个逻辑讲完了，但是你现在启动项目运行，是不是还是只能看到自己，后面的步骤根本没有执行？</p>
<p>因为前面的我们只打开了摄像头，还没有对接后续操作。</p>
<p>现在编辑<code>main.js</code>，修改一下之前的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * dom获取</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> btnConnect = $(<span class="string">&quot;#connect&quot;</span>); <span class="comment">// 连接dom</span></span><br><span class="line"><span class="keyword">const</span> btnLogout = $(<span class="string">&quot;#logout&quot;</span>); <span class="comment">// 挂断dom</span></span><br><span class="line"><span class="keyword">const</span> domLocalVideo = $(<span class="string">&quot;#localVideo&quot;</span>); <span class="comment">// 本地视频dom</span></span><br><span class="line"><span class="keyword">const</span> domRoom = $(<span class="string">&quot;#room&quot;</span>); <span class="comment">// 获取房间号输入框dom</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 连接</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">btnConnect.click(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> roomid = domRoom.val(); <span class="comment">// 获取用户输入的房间号</span></span><br><span class="line">  <span class="keyword">if</span> (!roomid) &#123;</span><br><span class="line">    alert(<span class="string">&quot;房间号不能为空&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//启动摄像头</span></span><br><span class="line">  <span class="keyword">if</span> (localStream == <span class="literal">null</span>) &#123;</span><br><span class="line">    openCamera()</span><br><span class="line">      .then(<span class="function">(<span class="params">stream</span>) =&gt;</span> &#123;</span><br><span class="line">        localStream = stream; <span class="comment">// 保存本地视频到全局变量</span></span><br><span class="line">        pushStreamToVideo(domLocalVideo[<span class="number">0</span>], stream);</span><br><span class="line">        connect(roomid); <span class="comment">// 成功打开摄像头后，开始创建或者加入输入的房间号</span></span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function">(<span class="params">e</span>) =&gt;</span> alert(<span class="string">`getUserMedia() error: <span class="subst">$&#123;e.name&#125;</span>`</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 挂断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">btnLogout.click(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  closeCamera(domLocalVideo[<span class="number">0</span>]);</span><br><span class="line">  logout(roomId); <span class="comment">// 退出房间</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//移除远程视频</span></span><br><span class="line">  $(<span class="string">&quot;#remoteDiv&quot;</span>).empty();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>编辑<code>sdk.js</code>，添加<code>logout()</code>方法，监听他人退出房间<code>socket.on(&#39;exit&#39;)</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 挂断（退出房间）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>roomid 房间号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> logout = <span class="function">(<span class="params">roomid</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 构建数据</span></span><br><span class="line">  <span class="keyword">const</span> data = &#123;</span><br><span class="line">    <span class="keyword">from</span>: socketId, <span class="comment">// 全局变量，我方的socketId</span></span><br><span class="line">    room: roomid, <span class="comment">// 全局变量，当前房间号</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 向信令服务器发出退出信号，让其转发给房间里的其他用户</span></span><br><span class="line">  socket.emit(<span class="string">&quot;exit&quot;</span>, data);</span><br><span class="line">  <span class="comment">// 数据重置</span></span><br><span class="line">  socketId = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  roomId = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="comment">// 关闭每个peer连接</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> rtcPeerConnects) &#123;</span><br><span class="line">    <span class="keyword">let</span> pc = rtcPeerConnects[i];</span><br><span class="line">    pc.close();</span><br><span class="line">    pc = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 重置RTCPeerConnection连接</span></span><br><span class="line">  rtcPeerConnects = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 移除本地视频</span></span><br><span class="line">  localStream = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 监听signal server转发过来的exit消息，和退出房间的客户端断开连接</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">socket.on(<span class="string">&quot;exit&quot;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// data: [from,room]</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;exit: &quot;</span>, data);</span><br><span class="line">  <span class="comment">// 获取RTCPeerConnection</span></span><br><span class="line">  <span class="keyword">const</span> pc = rtcPeerConnects[data.from];</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> pc == <span class="string">&quot;undefined&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// RTCPeerConnection关闭</span></span><br><span class="line">    getWebRTCConnect(data.from).close;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除peer对象</span></span><br><span class="line">    removeRtcConnect(data.from);</span><br><span class="line">    <span class="built_in">console</span>.log($(<span class="string">&quot;#&quot;</span> + data.from));</span><br><span class="line">    <span class="comment">// 移除video</span></span><br><span class="line">    $(<span class="string">&quot;#&quot;</span> + data.from).remove();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="4-3-7-完整代码"><a href="#4-3-7-完整代码" class="headerlink" title="4.3.7 完整代码"></a>4.3.7 完整代码</h3><p><a target="_blank" rel="noopener" href="http://223.223.179.203:8929/product/cp6666/webrtc-demo/-/tree/master/webrtc-client">http://223.223.179.203:8929/product/cp6666/webrtc-demo/-/tree/master/webrtc-client</a></p>
<h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>现在，我们已经基本入门 WebRTC 了。可能前 3 章的协议、服务器、API 的学习让我们感觉很枯燥，知识很杂乱。我想，大家通过第四章的实战开发，将之前的知识点串通起来，是不是有一点感觉了。其实前两章在现在看来，是可以不必着重学习的。没有这些协议和服务器的支持，不懂他们的连接原理，后面的学习应该会更加疑惑吧。</p>
<p>前面的实战开发，是一个很简单的 Web 端的例子，没有涉及到安卓、iOS 端如何进行 WebRTC 通信，如果需要继续深入学习，下一步可以往移动端 WebRTC 上学习，比如移动端打开摄像头都和 Web 不同。</p>
<p>如果暂时没有深入 WebRTC 的学习话，可以基于这个实战项目进行横向的扩展。这个实战项目虽然看起来很简单，但是你可以给它加出很多功能来，会看起来很高大尚！比如：</p>
<ul>
<li>在线电话：咱们现在只是通过房间号进行连接，我们可以设置一个登陆页面，将用户的 id 作为房间号，每个用户登陆后直接创建一个房间。我们想要给某个用户打音视频电话的话，我们可以加入他的房间，对方也能检测到房间是否有人进来，这样对方可以做成收到来电了，对方接听后，我们就进行 WebRTC 连接，实现拨打电话的功能。</li>
<li>视频会议：我们开发好注册登录功能，创建会议就相当于创建一个房间，只不过这个房间号是由我们系统来自动分配，别人登录后，通过该房间号就可以加入，即可实现视频会议功能。当然还可以扩展分享屏幕、白板等功能。</li>
</ul>
<p>本次<code>WebRTC入门</code>学习到此结束了，非常感谢您耐心地看完本篇长文。若有描述不对的地方，欢迎指出！</p>
<p>对以下文章、项目和视频的作者们，表示非常感谢！感谢您们辛苦的成果！</p>
<p>参考文章、文献、规范、项目、视频：</p>
<blockquote>
<p>WebRTC 协议介绍：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Protocols">https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Protocols</a></p>
<p>WebRTC 中文社区：<a target="_blank" rel="noopener" href="https://webrtc.org.cn/">https://webrtc.org.cn/</a></p>
<p>RTC 开发者社区：<a target="_blank" rel="noopener" href="https://rtcdeveloper.com/">https://rtcdeveloper.com/</a></p>
<p>又拍云 WebRTC 实时通信服务实践：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000010339671">https://segmentfault.com/a/1190000010339671</a></p>
<p>P2P 通信原理：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/26796476">https://zhuanlan.zhihu.com/p/26796476</a></p>
<p>STUN 协议详细介绍：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/26797664">https://zhuanlan.zhihu.com/p/26797664</a></p>
<p>TURN 协议详细介绍：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/26797422">https://zhuanlan.zhihu.com/p/26797422</a></p>
<p>ICE 协议详细介绍：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/26857913">https://zhuanlan.zhihu.com/p/26857913</a></p>
<p>WebRTC PeerConnection 建立连接过程：<a target="_blank" rel="noopener" href="https://aggresss.blog.csdn.net/article/details/106832965">https://aggresss.blog.csdn.net/article/details/106832965</a></p>
<p>STUN/TURN 服务器（C 语言）：<a target="_blank" rel="noopener" href="https://github.com/coturn/coturn">https://github.com/coturn/coturn</a></p>
<p>STUN 服务器（node）<a target="_blank" rel="noopener" href="https://github.com/enobufs/stun">https://github.com/enobufs/stun</a></p>
<p>Build Zoom Clone Video Chat Web App in Node.js Express and Socket.io Using WebRTC and PeerJS Library：<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=MX_r3Wm_BLE">https://www.youtube.com/watch?v=MX_r3Wm_BLE</a></p>
<p><a target="_blank" rel="noopener" href="https://codingshiksha.com/javascript/build-zoom-clone-video-chat-web-app-in-node-js-express-and-socket-io-using-webrtc-and-peerjs-library/">https://codingshiksha.com/javascript/build-zoom-clone-video-chat-web-app-in-node-js-express-and-socket-io-using-webrtc-and-peerjs-library/</a></p>
<p>Build Video Chat Web App From Scratch in 40 mins：<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=KLCcCTFivhM">https://www.youtube.com/watch?v=KLCcCTFivhM</a></p>
<p>coturn 服务器搭建：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/915eab39476d">https://www.jianshu.com/p/915eab39476d</a></p>
<p>coturn 服务器搭建：<a target="_blank" rel="noopener" href="https://meetrix.io/blog/webrtc/coturn/installation.html">https://meetrix.io/blog/webrtc/coturn/installation.html</a></p>
<p>coturn 服务器搭建：<a target="_blank" rel="noopener" href="https://ourcodeworld.com/articles/read/1175/how-to-create-and-configure-your-own-stun-turn-server-with-coturn-in-ubuntu-18-04">https://ourcodeworld.com/articles/read/1175/how-to-create-and-configure-your-own-stun-turn-server-with-coturn-in-ubuntu-18-04</a></p>
<p>WebRtcRoomServer（信令服务器 node）：<a target="_blank" rel="noopener" href="https://github.com/qdgx/WebRtcRoomServer">https://github.com/qdgx/WebRtcRoomServer</a></p>
<p>MDN Web Docs：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API">https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API</a></p>
<p>webRTC API 之 RTCPeerConnection：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/suRimn/p/11314914.html">https://www.cnblogs.com/suRimn/p/11314914.html</a></p>
<p>RTP 与 RTCP 协议介绍：<a target="_blank" rel="noopener" href="https://blog.51cto.com/zhangjunhd/25481">https://blog.51cto.com/zhangjunhd/25481</a></p>
</blockquote>
</div><div class="article-licensing box"><div class="licensing-title"><p>WebRTC入门</p><p><a href="https://ths-fe.github.io/2021/03/11/WebRTC%E5%85%A5%E9%97%A8/">https://ths-fe.github.io/2021/03/11/WebRTC%E5%85%A5%E9%97%A8/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>吴俊</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-03-11</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-03-13</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="" rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/JavaScript/">JavaScript</a><a class="link-muted mr-2" rel="tag" href="/tags/WebRTC/">WebRTC</a></div><div class="sharethis-inline-share-buttons"></div><script src="https://platform-api.sharethis.com/js/sharethis.js#property=5ea1492221690600121bcf3a&amp;product=inline-share-buttons&amp;cms=sop" defer></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/alipayqr.jpg" alt="支付宝"></span></a><a class="button donate" href="https://www.buymeacoffee.com/zapzqc?new=1" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>送我杯咖啡</span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/wechatqr.jpg" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/03/30/%E5%9F%BA%E4%BA%8E-qiankun-%E7%9A%84%E5%BE%AE%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">基于 qiankun 的微前端应用实践</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/02/04/Windows-OpenSSH%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"><span class="level-item">Windows OpenSSH 安装与配置</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="content" id="valine-thread"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script><script>new Valine({
            el: '#valine-thread' ,
            appId: "4o5OfjCIGaSyqIwg7jop80Ge-gzGzoHsz",
            appKey: "Rj9jcPLhW8WgWd6bDmXGmKaA",
            placeholder: "欢迎评论交流",
            avatar: "mm",
            
            meta: ["nick","mail","link"],
            pageSize: 10,
            lang: "zh-CN",
            
            highlight: true,
            
            
            
            
            
            requiredFields: [],
        });</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#一、协议"><span class="level-left"><span class="level-item">一、协议</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-1-P2P-通信原理与实现"><span class="level-left"><span class="level-item">1.1 P2P 通信原理与实现</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-1-1-基本术语"><span class="level-left"><span class="level-item">1.1.1 基本术语</span></span></a></li><li><a class="level is-mobile" href="#1-1-2-UDP-打洞-UDP-hole-punching"><span class="level-left"><span class="level-item">1.1.2 UDP 打洞(UDP hole punching)</span></span></a></li></ul></li><li><a class="level is-mobile" href="#1-2-STUN-协议"><span class="level-left"><span class="level-item">1.2 STUN 协议</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-2-1-简介"><span class="level-left"><span class="level-item">1.2.1 简介</span></span></a></li><li><a class="level is-mobile" href="#1-2-2-通信过程"><span class="level-left"><span class="level-item">1.2.2 通信过程</span></span></a></li></ul></li><li><a class="level is-mobile" href="#1-3-TURN-协议"><span class="level-left"><span class="level-item">1.3 TURN 协议</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-3-1-简介"><span class="level-left"><span class="level-item">1.3.1 简介</span></span></a></li><li><a class="level is-mobile" href="#1-3-2-通信过程"><span class="level-left"><span class="level-item">1.3.2 通信过程</span></span></a></li></ul></li><li><a class="level is-mobile" href="#1-4-ICE-协议"><span class="level-left"><span class="level-item">1.4 ICE 协议</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-4-1-简介"><span class="level-left"><span class="level-item">1.4.1 简介</span></span></a></li><li><a class="level is-mobile" href="#1-4-2-SDP-会话描述"><span class="level-left"><span class="level-item">1.4.2 SDP 会话描述</span></span></a></li><li><a class="level is-mobile" href="#1-4-3-Offer-Answer-模型"><span class="level-left"><span class="level-item">1.4.3 Offer/Answer 模型</span></span></a></li><li><a class="level is-mobile" href="#1-4-4-ICE-工作流程"><span class="level-left"><span class="level-item">1.4.4 ICE 工作流程</span></span></a></li></ul></li><li><a class="level is-mobile" href="#1-5-经典-WebRTC-连接建立流程"><span class="level-left"><span class="level-item">1.5 经典 WebRTC 连接建立流程</span></span></a></li></ul></li><li><a class="level is-mobile" href="#二、服务器搭建"><span class="level-left"><span class="level-item">二、服务器搭建</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-1-STUN-TURN-服务器"><span class="level-left"><span class="level-item">2.1 STUN/TURN 服务器</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-1-1-安装-coturn"><span class="level-left"><span class="level-item">2.1.1 安装 coturn</span></span></a></li><li><a class="level is-mobile" href="#2-1-2-配置-coturn"><span class="level-left"><span class="level-item">2.1.2 配置 coturn</span></span></a></li><li><a class="level is-mobile" href="#2-1-3-测试"><span class="level-left"><span class="level-item">2.1.3 测试</span></span></a></li></ul></li><li><a class="level is-mobile" href="#2-2-Nodejs-构建信令服务器-Signal-Server"><span class="level-left"><span class="level-item">2.2 Nodejs 构建信令服务器(Signal Server)</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-2-1-安装-node-环境"><span class="level-left"><span class="level-item">2.2.1 安装 node 环境</span></span></a></li><li><a class="level is-mobile" href="#2-2-2-克隆项目，安装依赖"><span class="level-left"><span class="level-item">2.2.2 克隆项目，安装依赖</span></span></a></li><li><a class="level is-mobile" href="#2-2-3-pm2-管理-node-服务"><span class="level-left"><span class="level-item">2.2.3 pm2 管理 node 服务</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#三、API-学习"><span class="level-left"><span class="level-item">三、API 学习</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-1-socket-io"><span class="level-left"><span class="level-item">3.1 socket.io</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-1-1-服务器端"><span class="level-left"><span class="level-item">3.1.1 服务器端</span></span></a></li><li><a class="level is-mobile" href="#3-1-2-客户端"><span class="level-left"><span class="level-item">3.1.2 客户端</span></span></a></li></ul></li><li><a class="level is-mobile" href="#3-2-音视频相关-API"><span class="level-left"><span class="level-item">3.2 音视频相关 API</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-2-1-navigator-mediaDevices"><span class="level-left"><span class="level-item">3.2.1 navigator.mediaDevices</span></span></a></li><li><a class="level is-mobile" href="#3-2-2-video"><span class="level-left"><span class="level-item">3.2.2 video</span></span></a></li></ul></li><li><a class="level is-mobile" href="#3-3-WebRTC"><span class="level-left"><span class="level-item">3.3 WebRTC</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-3-1-RTCPeerConnection"><span class="level-left"><span class="level-item">3.3.1 RTCPeerConnection</span></span></a></li><li><a class="level is-mobile" href="#3-3-2-RTCSessionDescription"><span class="level-left"><span class="level-item">3.3.2 RTCSessionDescription</span></span></a></li><li><a class="level is-mobile" href="#3-3-3-RTCIceCandidate"><span class="level-left"><span class="level-item">3.3.3 RTCIceCandidate</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#四、实战开发"><span class="level-left"><span class="level-item">四、实战开发</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#4-1-环境准备"><span class="level-left"><span class="level-item">4.1 环境准备</span></span></a></li><li><a class="level is-mobile" href="#4-2-信令服务器"><span class="level-left"><span class="level-item">4.2 信令服务器</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#4-2-1-搭建项目"><span class="level-left"><span class="level-item">4.2.1 搭建项目</span></span></a></li><li><a class="level is-mobile" href="#4-2-2-房间功能"><span class="level-left"><span class="level-item">4.2.2 房间功能</span></span></a></li><li><a class="level is-mobile" href="#4-2-3-转发功能"><span class="level-left"><span class="level-item">4.2.3 转发功能</span></span></a></li><li><a class="level is-mobile" href="#4-2-4-完整代码"><span class="level-left"><span class="level-item">4.2.4 完整代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#4-3-前端"><span class="level-left"><span class="level-item">4.3 前端</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#4-3-1-搭建项目"><span class="level-left"><span class="level-item">4.3.1 搭建项目</span></span></a></li><li><a class="level is-mobile" href="#4-3-2-兼容预处理"><span class="level-left"><span class="level-item">4.3.2 兼容预处理</span></span></a></li><li><a class="level is-mobile" href="#4-3-3-音视频控制"><span class="level-left"><span class="level-item">4.3.3 音视频控制</span></span></a></li><li><a class="level is-mobile" href="#4-3-4-Offer-Answer-模型"><span class="level-left"><span class="level-item">4.3.4 Offer/Answer 模型</span></span></a></li><li><a class="level is-mobile" href="#4-3-5-ICE-连接-接收音视频流"><span class="level-left"><span class="level-item">4.3.5 ICE 连接/接收音视频流</span></span></a></li><li><a class="level is-mobile" href="#4-3-6-完善逻辑"><span class="level-left"><span class="level-item">4.3.6 完善逻辑</span></span></a></li><li><a class="level is-mobile" href="#4-3-7-完整代码"><span class="level-left"><span class="level-item">4.3.7 完整代码</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#五、总结"><span class="level-left"><span class="level-item">五、总结</span></span></a></li></ul></div></div><style>.menu-list > li > a.is-active + .menu-list { display: block; }.menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="adsense"><div class="card-content"><div class="menu"><h3 class="menu-label"> </h3><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-6826040978803389" data-ad-slot="1033672070" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/ths.png" alt="思路大前端团队" height="28"></a><p class="is-size-7"><span>&copy; 2023 吴俊</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>